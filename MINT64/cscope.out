cscope 15 $HOME/os/MINT64               0000508622
	@/home/jk/os/MINT64/00.BootLoader/BootLoader.asm

1 [
ORG
 0x00] ; 코드의 시작 어드레스를 0x00으로 설정

2 [
BITS
 16] ; 이하의 코드는 16비트 코드로 설정

4 
	gSECTION
 .
	gxt
 ;ext 섹션(세그먼트)을 정의

6 
	gjmp
 0x07C0:
START
 ; 
	gCS
 세그먼트 레지스터에 0x07C0을 복사하면서 , 
	gSTART
 레이블로 이동 (CS 세그먼트는 데이터 이동 명령으르 설정불가능하며 점프나 인터럽트 관련 명령으로 변경 가능

10 ; 
MINT64
 
	gOS
에 관련된 환경 설정 값

12 
	gTOTALSECTORCOUNT
: 
dw
 0x02 ; 부트 로더를 제외한 
MINT64
 
	gOS
 이미지의 크기

13 ; 최대 1152 섹터(0x90000b
	gy
)까지 가능 
	gwhy
???? 0xA0000 이후의 메모리는 
gphic
 
	gmode
의 영역이다.

14 
	gKERNEL32SECTORCOUNT
: 
dw
 0x02 ; 보호 모드 커널의 총 섹터 수

18 
	gSTART
:

19 
mov
 
ax
, 0x07C0 ; 부트 로더의 시작 어드레스(0x7C00)를 세그먼트 레지스터 값으로 변환

20 
mov
 
	gds
, 
	gax
 ; 
	gDS
 세그먼트 레지스터에 설정

21 
mov
 
	gax
, 0xB800 ; 비디오 메모리의 시작 어드레스(0xB800)를 세그먼트 레지스터 값으로 변환

22 
mov
 
	ges
, 
	gax
 ; 
	gES
 세그먼트 레지스터에 설정

24 ; 스택을 0x0000:0000~0x0000:
FFFF
 영역에 64
KB
 크기로 생성

25 
mov
 
ax
, 0x0000 ; 스택 세그먼트의 시작 어드레스(0x0000)를 세그먼트 레지스터 값으로 변환

26 
mov
 
	gss
, 
	gax
 ; 
	gSS
 세그먼트 레지스터에 설정

27 
mov
 
	g
, 0xFFFC ; 
	gSP
 레지스터의 어드레스를 0xFFFC로 설정

28 
mov
 
	gbp
, 0xFFFC ; 
	gBP
 레지스터의 어드레스를 0xFFFC로 설정

33 
mov
 
	gsi
, 0 ; 
	gSI
 레지스터 (문자열 원본 인덱스 레지스터)를 초기화

35 .
	gSCREENCLEARLOOP
: ; 화면을 지우는 루프

36 
mov
 
	gby
 [
es
:
si
],0 ; 비디오 메모리의 문자가 위치하는 어드레스에 0을 복사하여 문자를 삭제

37 
mov
 
	gby
 [
es
:
si
+1],0x09 ; 비디오 메모리의 속성이 위치하는 어드레스에 0x09(검은 바탕에 밝은 파랑)을 복사

39 
add
 
	gsi
,2 ; 문자와 속성을 설정했으므로 다음 위치로 이동

41 
cmp
 
	gsi
, 80*25*2 ; 화면의 전체 크기는 80문자*25라인임

42 ; 출력한 문자의 수를 의미하는 
	gSI
 레지스터와 비교

43 
	gjl
 .
	gSCREENCLEARLOOP
 ; 
	gSI
 레지스터가 80*25*2보다 작다면 아직 지우지 못한 영역이 있으므로 .SCREENCLEARLOOP 레이블로 이동

49 
push
 
	gMESSAGE1
 ; 출력 메시지의 어드레스를 스택에 삽입

50 
	gpush
 0 ; 화면 
	gY
 좌표(0)를 스택에 삽입

51 
	gpush
 0 ; 화면 
	gX
 좌표(0)를 스택에 삽입

52 

 
	gPRINTMESSAGE
 ; PRINTMESSAGE 함수 호출

53 
add
 
	g
, 6 ; 삽입한 파라미터 제거

56 ; 
	gos
 이미지를 로딩한다는 메시지 출력

59 
push
 
	gIMAGELOADINGMESSAGE
 ; 출력 메시지의 어드레스를 스택에 삽입

60 
	gpush
 1 ; 화면 
	gY
 좌표(1)를 스택에 삽입

61 
	gpush
 0 ; 화면 
	gX
 좌표(0)를 스택에 삽입

62 

 
	gPRINTMESSAGE
 ; PRINTMESSAGE 함수 호출

63 
add
 
	g
, 6 ; 삽입한 파라미터 제거

66 ; 디스크에서 
	gOS
 이미지를 로딩

72 
	gREADDISK
: ; 디스크를 리셋하는 코드의 시작

74 ; 
BIOS
 
Ret
 
	gFui
 호출

76 ; 서비스 번호 0, 드라이브 번호(0=
Flpy
)

77 
mov
 
ax
, 0

78 
mov
 
	gdl
, 0

81 
jc
 
	gHANDLEDISKERROR


87 ; 디스크의 내용을 메모리로 복사할 어드레스(
	gES
:
BX
)를 0x10000으로 설정

88 
mov
 
si
, 0x1000 ; 
	gOS
 이미지를 복사할 어드레스(0x10000)를 세그먼트 레지스터 값으로 변환

89 
mov
 
	ges
, 
	gsi
 ; 
	gES
 세그먼트 레지스터에 값 설정

90 
mov
 
	gbx
, 0x0000 ; 
	gBX
 레지스터에 0x0000을 설정하여 복사할 어드레스를 0x1000:0000(0x10000)으로 최종 설정

92 
mov
 
di
, 
	gwd
[
TOTALSECTORCOUNT
] ; 복사할 
	gOS
 이미지의 섹터 수를 
	gDI
 레지스터에 설정

94 
	gREADDATA
: ; 디스크를 읽는 코드의 시작

96 
cmp
 
	gdi
, 0 ; 복사할 
	gOS
 이미지의 섹터 수를 0과 비교

97 
je
 
	gREADEND
 ; 복사할 섹터 수가 0이라면 다 복사 했으므로 READEND로 이동

98 
sub
 
	gdi
, 0x01 ; 복사할 섹터 수를 1 감소

102 ; 
BIOS
 
Rd
 
	gFuni
 호출

105 
mov
 
	gah
, 0x02 ; 
	gBIOS
 서비스 번호 2(
Rd
 
	gSe
)

106 
mov
 
	g
, 0x01 ; 읽을 섹터 수는 1

107 
mov
 
	gch
, 
	gby
[
TRACKNUMBER
] ; 읽을 트랙 번호 설정

108 
mov
 
	g
, 
	gby
[
SECTORNUMBER
] ; 읽을 섹터 번호 설정

109 
mov
 
	gdh
, 
	gby
[
HEADNUMBER
] ; 읽을 헤드 번호 설정

110 
mov
 
	gdl
, 0x00 ; 읽을 드라이브 번호(0=
Flpy
) 설정

112 
jc
 
	gHANDLEDISKERROR
 ; 에러가 발생했다면 HANDLEDISKERROR로 이동 
	$jc
 (
jump
 

 
y

CF
=1일때 jump한다.

113 ; 섹터 읽기가 정상적으로 완료가 되면 
FLAGS
의 
CF
비트가 0로 설정된다.

119 
add
 
si
, 0x0020 ; 512(0x200)바이트만큼 읽었으므로, 이를 세그먼트 레지스터 값으로 변환

120 
mov
 
es
, 
si
 ; 
ES
 세그머트 레지스터에 더해서 어드레스를 한 섹터만큼 증가 (
ba
 
addss
를 변경하였네, 
offt
이 아니라)

125 
mov
 

, 
by
[
SECTORNUMBER
] ; 섹터 번호를 
AL
레지스터에 설정

126 
add
 

, 0x01 ; 섹터 번호를 1 증가

127 
mov
 
by
[
SECTORNUMBER
], 

 ; 증가 시킨 섹터 번호는 SECTORNUMBER에 다시 설정

128 
cmp
 

, 19 ; 증가 시킨 섹터 번호를 19와 비교

129 
jl
 
READDATA
 ; 섹터 번호가 19미만이라면 READDATA로 이동

132 
x
 
by
[
HEADNUMBER
], 0x01 ; 헤드 번호를 0x01과 
XOR
하여 토글(0->1,1->0)

133 
mov
 
by
[
SECTORNUMBER
],0x01 ; 섹터 번호를 다시 1로 설정

137 
cmp
 
by
[
HEADNUMBER
], 0x00 ; 헤드 번호를 0x00과 비교

138 
j
 
READDATA
 ; 헤드 번호가 0이 아니면 READDATA로 이동

141 
add
 
by
[
TRACKNUMBER
], 0x01 ; 트랙 번호를 1 증가

142 
jmp
 
READDATA
 ; READDATA로 이동

143 
READEND
:

147 ; 
OS
 이미지가 완료되었다는 메시지를 출력

149 
push
 
LOADINGCOMPLETEMESSAGE
 ; 출력할 메시지의 어드레스를 스택에 삽입

150 
push
 1 ; 화면 
Y
 좌표(1)를 스택에 삽입

151 
push
 20 ; 화면 
X
 좌표(20)를 스택에 삽입

152 

 
PRINTMESSAGE
 ; PRINTMESSAGE 함수 호출

153 
add
 

, 6 ; 삽입한 파라미터 제거

156 ; 로딩한 가상 
OS
 이미지 실행

158 
jmp
 0x1000:0x0000

165 
HANDLEDISKERROR
:

166 
push
 
DISKERRORMESSAGE
 ; 에러 문자열의 어드레스를 스택에 삽입

167 
push
 1 ; 화면 
Y
 좌표(1)를 스택에 삽입

168 
push
 20 ; 화면 
X
 좌표(20)를 스택에 삽입

169 

 
PRINTMESSAGE
 ; PRINTMESSAGE 함수 호출

171 
jmp
 
$
 ; 현재 위치에서 무한 루프 수행

174 ; 
PARAM
: 
x
 좌표, 
y
 좌표, 문자열

175 
PRINTMESSAGE
:

176 
push
 
bp
 ; 베이스 포인터 레지스터(bp)를 스택에 삽입

177 
mov
 
bp
, 

 ; 베이스 포인터 레지스터(bp)에 스택 포인터 레지스터(sp)의 값을 설정

178 ; 베이스 포인터 레지스터(
bp
)를 이용해서 파라미터에 접근할 목적

180 
push
 
es
 ;세그먼트 레지스터부터 
dx
 레지스터까지 스택에 삽입

181 
push
 
si
 ; 함수에서 임시로 사용하는 레지스터로 함수의 마지막 부분에서 스택에 삽입된 값을 꺼내 원래 값으로 복원

182 
push
 
di


183 
push
 
ax


184 
push
 
cx


185 
push
 
dx


187 ; 
es
 세그먼트 레지스터에 비디오 모드 어드레스 설정

189 
mov
 
ax
, 0xB800 ; 비디오 메모리 시작 어드레스(0x0B8000)를 세그먼트 레지스터 값으로 변환

190 
mov
 
es
, 
ax
 ;s 세그먼트 레지스터에 설정

193 ; 
X
, 
Y
의 좌표로 비디오 메모리 어드레스를 계산함

195 ; 
Y
 좌표를 이용해서 먼저 라인 어드레스를 구함

196 
mov
 
ax
, 
wd
[
bp
+6] ; 파라미터 2(화면 좌표 
Y
)를x 레지스터에 설정

197 
mov
 
si
, 160 ; 한 라인의 바이트 수(2*80 컬럼)를 si 레지스터에 설정

198 
mul
 
si
 ; 
ax
 레지스터와 s레지스터를 곱하여 화면 
y
 어드레스 계산

199 
mov
 
di
, 
ax
 ; 계산된 화면 
y
 어드레스를 di 레지스터에 설정

201 ; 
X
 좌표를 이용해서 2를 곱한 후 최종 어드레스를 구함

202 
mov
 
ax
, 
wd
[
bp
+4] ; 파라미터 1(화면 좌표 
X
)를x 레지스터에 설정

203 
mov
 
si
, 2 ; 한 문자를 나타내는 바이트 수(2)를 si 레지스터에 설정

204 
mul
 
si
 ; 
ax
 레지스터와 s레지스터를 곱하여 화면 
x
 어드레스를 계산

205 
add
 
di
, 
ax
 ; 화면 
Y
 어드레스와 계산된 
X
 어드레스를 더해서 실제 비디오 메모리 어드레스를 계산

208 
mov
 
si
, 
wd
[
bp
+8] ; 파라미터 3(출력할 문자열의 어드레스)

210 .
MESSAGELOOP
: ; 메시지를 출력하는 루프

211 
mov
 

,
by
[
si
] ; 
MESSAGE1
의 어드레스를 
SI
레지스터 값만큼 더한 위치의 문자를 
CL
 레지스터에 복사

212 ; 
CL
 레지스터는 
	`CX
(루프 또는 문자열의 카운터로 사용)되는 범용 레지스터의 하위 8비트임

213 ; 문자열은 1바이트면 충분하므로 
CX
 레지스터의 하위 1바이트만 사용

215 
cmp
 

, 0 ; 복사된 문자와 0을 비교

216 
je
 .
MESSAGEEND
 ; 복사한 문자의 값이 0이면 문자열이 종료되었음을 의미하므로 .MESSAGEEND로 이동하여 문자 출력 종료

218 
mov
 
by
[
es
:
di
],

 ; 0이 아니라면 비디오 메모리 어드레스 0xB800:di에 문자를 출력

220 
add
 
si
,1 ; 
SI
 레지스터에 1을 더하여 다음 문자열로 이동

221 
add
 
di
,2 ; 
DI
 레지스터에 2를 더하여 비디오 메모리의 다음 문자 위치로 이동

224 
jmp
 .
MESSAGELOOP
 ; 메시지 출력 루프로 이동하여 다음 문자를 출력

226 .
MESSAGEEND
:

227 
p
 
dx
 ; 함수에서 사용이 끝난 dx 레지스터부터 
es
 레지스터까지를 스택에 삽입된 값을 이용해서 복원

228 
p
 
cx


229 
p
 
ax


230 
p
 
di


231 
p
 
si


232 
p
 
es


233 
p
 
bp


234 
t


242 
MESSAGE1
: 
db
 'MINT64 OS Bo Ld S~!!',0 ; 출력할 메시지 정의 마지막은 0으로 설정하여 .
MESSAGELOOP
에서 문자열이 종료되었음을 알 수 있도록 함

244 
DISKERRORMESSAGE
: 
db
 'DISK Error~!!',0

245 
IMAGELOADINGMESSAGE
: 
db
 'OS Image Loading...',0

246 
LOADINGCOMPLETEMESSAGE
: 
db
 ' Complete~!!', 0

249 
SECTORNUMBER
: 
db
 0x02 ; 
OS
 이미지가 시작하는 섹터 번호를 저장하는 영역 (
MBR
는 부트로더)

250 
HEADNUMBER
: 
db
 0x00 ; 
OS
 이미지가 시작하는 헤드 번호를 지정하는 영역

251 
TRACKNUMBER
: 
db
 0x00 ; 
OS
 이미지가 시작하는 트랙 번호를 저장하는 영역

253 
times
 510 - (
$
-
$$

db
 0x00 ; $ 현재 라인의 어드레스

254 ; 
$$
 현재 섹션(.
xt
)의 시작 어드레스

255 ; 
$
 - 
$$
 현재 섹션을 기준으로 하는 오프셋 ( 0x55, 0xAA를 정확한 위치에 삽입하려고 추가된 부분)

256 ; 510 - (
$
-
$$
) 현재부터 어드레스 510까지

257 ; 
db
 0x00 
	`db
(
defe
 
by
의 약자) 1바이트를 선언하고 값은 0x00

258 ; 
time
 반복 수행

261 
db
 0x55 ; 1바이트를 선언하고 값은 0x55

262 
db
 0xAA ; 1바이트를 선언하고 값은 0xAA

	@/home/jk/os/MINT64/00.BootLoader/BootLoader2.asm

1 [
ORG
 0x00] ; 코드의 시작 어드레스를 0x00으로 설정

2 [
BITS
 16] ; 이하의 코드는 16비트 코드로 설정

4 
	gSECTION
 .
	gxt
 ;ext 섹션(세그먼트)을 정의

6 
	gjmp
 0x07C0:
START
 ; 
	gCS
 세그먼트 레지스터에 0x07C0을 복사하면서 , 
	gSTART
 레이블로 이동 (CS 세그먼트는 데이터 이동 명령으르 설정불가능하며 점프나 인터럽트 관련 명령으로 변경 가능

10 ; 
MINT64
 
	gOS
에 관련된 환경 설정 값

12 
	gTOTALSECTORCOUNT
: 
dw
 1024 ; 부트 로더를 제외한 
MINT64
 
	gOS
 이미지의 크기

13 ; 최대 1152 섹터(0x90000b
	gy
)까지 가능 
	gwhy
???? 0xA0000 이후의 메모리는 
gphic
 
	gmode
의 영역이다.

18 
	gSTART
:

19 
mov
 
ax
, 0x07C0 ; 부트 로더의 시작 어드레스(0x7C00)를 세그먼트 레지스터 값으로 변환

20 
mov
 
	gds
, 
	gax
 ; 
	gDS
 세그먼트 레지스터에 설정

21 
mov
 
	gax
, 0xB800 ; 비디오 메모리의 시작 어드레스(0xB800)를 세그먼트 레지스터 값으로 변환

22 
mov
 
	ges
, 
	gax
 ; 
	gES
 세그먼트 레지스터에 설정

24 ; 스택을 0x0000:0000~0x0000:
FFFF
 영역에 64
KB
 크기로 생성

25 
mov
 
ax
, 0x0000 ; 스택 세그먼트의 시작 어드레스(0x0000)를 세그먼트 레지스터 값으로 변환

26 
mov
 
	gss
, 
	gax
 ; 
	gSS
 세그먼트 레지스터에 설정

27 
mov
 
	g
, 0xFFFE ; 
	gSP
 레지스터의 어드레스를 0xFFFE로 설정

28 
mov
 
	gbp
, 0xFFFE ; 
	gBP
 레지스터의 어드레스를 0xFFFE로 설정

33 
mov
 
	gsi
, 0 ; 
	gSI
 레지스터 (문자열 원본 인덱스 레지스터)를 초기화

35 .
	gSCREENCLEARLOOP
: ; 화면을 지우는 루프

36 
mov
 
	gby
 [
es
:
si
],0 ; 비디오 메모리의 문자가 위치하는 어드레스에 0을 복사하여 문자를 삭제

37 
mov
 
	gby
 [
es
:
si
+1],0x09 ; 비디오 메모리의 속성이 위치하는 어드레스에 0x09(검은 바탕에 밝은 파랑)을 복사

39 
add
 
	gsi
,2 ; 문자와 속성을 설정했으므로 다음 위치로 이동

41 
cmp
 
	gsi
, 80*25*2 ; 화면의 전체 크기는 80문자*25라인임

42 ; 출력한 문자의 수를 의미하는 
	gSI
 레지스터와 비교

43 
	gjl
 .
	gSCREENCLEARLOOP
 ; 
	gSI
 레지스터가 80*25*2보다 작다면 아직 지우지 못한 영역이 있으므로 .SCREENCLEARLOOP 레이블로 이동

49 
push
 
	gMESSAGE1
 ; 출력 메시지의 어드레스를 스택에 삽입

50 
	gpush
 0 ; 화면 
	gY
 좌표(0)를 스택에 삽입

51 
	gpush
 0 ; 화면 
	gX
 좌표(0)를 스택에 삽입

52 

 
	gPRINTMESSAGE
 ; PRINTMESSAGE 함수 호출

53 
add
 
	g
, 6 ; 삽입한 파라미터 제거

56 ; 
	gos
 이미지를 로딩한다는 메시지 출력

59 
push
 
	gIMAGELOADINGMESSAGE
 ; 출력 메시지의 어드레스를 스택에 삽입

60 
	gpush
 1 ; 화면 
	gY
 좌표(1)를 스택에 삽입

61 
	gpush
 0 ; 화면 
	gX
 좌표(0)를 스택에 삽입

62 

 
	gPRINTMESSAGE
 ; PRINTMESSAGE 함수 호출

63 
add
 
	g
, 6 ; 삽입한 파라미터 제거

66 ; 디스크에서 
	gOS
 이미지를 로딩

72 
	gREADDISK
: ; 디스크를 리셋하는 코드의 시작

74 ; 
BIOS
 
Ret
 
	gFui
 호출

76 ; 서비스 번호 0, 드라이브 번호(0=
Flpy
)

77 
mov
 
ax
, 0

78 
mov
 
	gdl
, 0

81 
jc
 
	gHANDLEDISKERROR


87 ; 디스크의 내용을 메모리로 복사할 어드레스(
	gES
:
BX
)를 0x10000으로 설정

88 
mov
 
si
, 0x1000 ; 
	gOS
 이미지를 복사할 어드레스(0x10000)를 세그먼트 레지스터 값으로 변환

89 
mov
 
	ges
, 
	gsi
 ; 
	gES
 세그먼트 레지스터에 값 설정

90 
mov
 
	gbx
, 0x0000 ; 
	gBX
 레지스터에 0x0000을 설정하여 복사할 어드레스를 0x1000:0000(0x10000)으로 최종 설정

92 
mov
 
di
, 
	gwd
[
TOTALSECTORCOUNT
] ; 복사할 
	gOS
 이미지의 섹터 수를 
	gDI
 레지스터에 설정

94 
	gREADDATA
: ; 디스크를 읽는 코드의 시작

96 
cmp
 
	gdi
, 0 ; 복사할 
	gOS
 이미지의 섹터 수를 0과 비교

97 
je
 
	gREADEND
 ; 복사할 섹터 수가 0이라면 다 복사 했으므로 READEND로 이동

98 
sub
 
	gdi
, 0x01 ; 복사할 섹터 수를 1 감소

102 ; 
BIOS
 
Rd
 
	gFuni
 호출

105 
mov
 
	gah
, 0x02 ; 
	gBIOS
 서비스 번호 2(
Rd
 
	gSe
)

106 
mov
 
	g
, 0x01 ; 읽을 섹터 수는 1

107 
mov
 
	gch
, 
	gby
[
TRACKNUMBER
] ; 읽을 트랙 번호 설정

108 
mov
 
	g
, 
	gby
[
SECTORNUMBER
] ; 읽을 섹터 번호 설정

109 
mov
 
	gdh
, 
	gby
[
HEADNUMBER
] ; 읽을 헤드 번호 설정

110 
mov
 
	gdl
, 0x00 ; 읽을 드라이브 번호(0=
Flpy
) 설정

112 
jc
 
	gHANDLEDISKERROR
 ; 에러가 발생했다면 HANDLEDISKERROR로 이동 
	$jc
 (
jump
 

 
y

CF
=1일때 jump한다.

113 ; 섹터 읽기가 정상적으로 완료가 되면 
FLAGS
의 
CF
비트가 0로 설정된다.

119 
add
 
si
, 0x0020 ; 512(0x200)바이트만큼 읽었으므로, 이를 세그먼트 레지스터 값으로 변환

120 
mov
 
es
, 
si
 ; 
ES
 세그머트 레지스터에 더해서 어드레스를 한 섹터만큼 증가 (
ba
 
addss
를 변경하였네, 
offt
이 아니라)

125 
mov
 

, 
by
[
SECTORNUMBER
] ; 섹터 번호를 
AL
레지스터에 설정

126 
add
 

, 0x01 ; 섹터 번호를 1 증가

127 
mov
 
by
[
SECTORNUMBER
], 

 ; 증가 시킨 섹터 번호는 SECTORNUMBER에 다시 설정

128 
cmp
 

, 19 ; 증가 시킨 섹터 번호를 19와 비교

129 
jl
 
READDATA
 ; 섹터 번호가 19미만이라면 READDATA로 이동

132 
x
 
by
[
HEADNUMBER
], 0x01 ; 헤드 번호를 0x01과 
XOR
하여 토글(0->1,1->0)

133 
mov
 
by
[
SECTORNUMBER
],0x01 ; 섹터 번호를 다시 1로 설정

137 
cmp
 
by
[
HEADNUMBER
], 0x00 ; 헤드 번호를 0x00과 비교

138 
j
 
READDATA
 ; 헤드 번호가 0이 아니면 READDATA로 이동

141 
add
 
by
[
TRACKNUMBER
], 0x01 ; 트랙 번호를 1 증가

142 
jmp
 
READDATA
 ; READDATA로 이동

143 
READEND
:

147 ; 
OS
 이미지가 완료되었다는 메시지를 출력

149 
push
 
LOADINGCOMPLETEMESSAGE
 ; 출력할 메시지의 어드레스를 스택에 삽입

150 
push
 1 ; 화면 
Y
 좌표(1)를 스택에 삽입

151 
push
 20 ; 화면 
X
 좌표(20)를 스택에 삽입

152 

 
PRINTMESSAGE
 ; PRINTMESSAGE 함수 호출

153 
add
 

, 6 ; 삽입한 파라미터 제거

156 ; 로딩한 가상 
OS
 이미지 실행

158 
jmp
 0x1000:0x0000

165 
HANDLEDISKERROR
:

166 
push
 
DISKERRORMESSAGE
 ; 에러 문자열의 어드레스를 스택에 삽입

167 
push
 1 ; 화면 
Y
 좌표(1)를 스택에 삽입

168 
push
 20 ; 화면 
X
 좌표(20)를 스택에 삽입

169 

 
PRINTMESSAGE
 ; PRINTMESSAGE 함수 호출

171 
jmp
 
$
 ; 현재 위치에서 무한 루프 수행

174 ; 
PARAM
: 
x
 좌표, 
y
 좌표, 문자열

175 
PRINTMESSAGE
:

176 
push
 
bp
 ; 베이스 포인터 레지스터(bp)를 스택에 삽입

177 
mov
 
bp
, 

 ; 베이스 포인터 레지스터(bp)에 스택 포인터 레지스터(sp)의 값을 설정

178 ; 베이스 포인터 레지스터(
bp
)를 이용해서 파라미터에 접근할 목적

180 
push
 
es
 ;세그먼트 레지스터부터 
dx
 레지스터까지 스택에 삽입

181 
push
 
si
 ; 함수에서 임시로 사용하는 레지스터로 함수의 마지막 부분에서 스택에 삽입된 값을 꺼내 원래 값으로 복원

182 
push
 
di


183 
push
 
ax


184 
push
 
cx


185 
push
 
dx


187 ; 
es
 세그먼트 레지스터에 비디오 모드 어드레스 설정

189 
mov
 
ax
, 0xB800 ; 비디오 메모리 시작 어드레스(0x0B8000)를 세그먼트 레지스터 값으로 변환

190 
mov
 
es
, 
ax
 ;s 세그먼트 레지스터에 설정

193 ; 
X
, 
Y
의 좌표로 비디오 메모리 어드레스를 계산함

195 ; 
Y
 좌표를 이용해서 먼저 라인 어드레스를 구함

196 
mov
 
ax
, 
wd
[
bp
+6] ; 파라미터 2(화면 좌표 
Y
)를x 레지스터에 설정

197 
mov
 
si
, 160 ; 한 라인의 바이트 수(2*80 컬럼)를 si 레지스터에 설정

198 
mul
 
si
 ; 
ax
 레지스터와 s레지스터를 곱하여 화면 
y
 어드레스 계산

199 
mov
 
di
, 
ax
 ; 계산된 화면 
y
 어드레스를 di 레지스터에 설정

201 ; 
X
 좌표를 이용해서 2를 곱한 후 최종 어드레스를 구함

202 
mov
 
ax
, 
wd
[
bp
+4] ; 파라미터 1(화면 좌표 
X
)를x 레지스터에 설정

203 
mov
 
si
, 2 ; 한 문자를 나타내는 바이트 수(2)를 si 레지스터에 설정

204 
mul
 
si
 ; 
ax
 레지스터와 s레지스터를 곱하여 화면 
x
 어드레스를 계산

205 
add
 
di
, 
ax
 ; 화면 
Y
 어드레스와 계산된 
X
 어드레스를 더해서 실제 비디오 메모리 어드레스를 계산

208 
mov
 
si
, 
wd
[
bp
+8] ; 파라미터 3(출력할 문자열의 어드레스)

210 .
MESSAGELOOP
: ; 메시지를 출력하는 루프

211 
mov
 

,
by
[
si
] ; 
MESSAGE1
의 어드레스를 
SI
레지스터 값만큼 더한 위치의 문자를 
CL
 레지스터에 복사

212 ; 
CL
 레지스터는 
	`CX
(루프 또는 문자열의 카운터로 사용)되는 범용 레지스터의 하위 8비트임

213 ; 문자열은 1바이트면 충분하므로 
CX
 레지스터의 하위 1바이트만 사용

215 
cmp
 

, 0 ; 복사된 문자와 0을 비교

216 
je
 .
MESSAGEEND
 ; 복사한 문자의 값이 0이면 문자열이 종료되었음을 의미하므로 .MESSAGEEND로 이동하여 문자 출력 종료

218 
mov
 
by
[
es
:
di
],

 ; 0이 아니라면 비디오 메모리 어드레스 0xB800:di에 문자를 출력

220 
add
 
si
,1 ; 
SI
 레지스터에 1을 더하여 다음 문자열로 이동

221 
add
 
di
,2 ; 
DI
 레지스터에 2를 더하여 비디오 메모리의 다음 문자 위치로 이동

224 
jmp
 .
MESSAGELOOP
 ; 메시지 출력 루프로 이동하여 다음 문자를 출력

226 .
MESSAGEEND
:

227 
p
 
dx
 ; 함수에서 사용이 끝난 dx 레지스터부터 
es
 레지스터까지를 스택에 삽입된 값을 이용해서 복원

228 
p
 
cx


229 
p
 
ax


230 
p
 
di


231 
p
 
si


232 
p
 
es


233 
p
 
bp


234 
t


242 
MESSAGE1
: 
db
 'MINT64 OS Bo Ld S~!!',0 ; 출력할 메시지 정의 마지막은 0으로 설정하여 .
MESSAGELOOP
에서 문자열이 종료되었음을 알 수 있도록 함

244 
DISKERRORMESSAGE
: 
db
 'DISK Error~!!',0

245 
IMAGELOADINGMESSAGE
: 
db
 'OS Image Loading...',0

246 
LOADINGCOMPLETEMESSAGE
: 
db
 ' Complete~!!', 0

249 
SECTORNUMBER
: 
db
 0x02 ; 
OS
 이미지가 시작하는 섹터 번호를 저장하는 영역 (
MBR
는 부트로더)

250 
HEADNUMBER
: 
db
 0x00 ; 
OS
 이미지가 시작하는 헤드 번호를 지정하는 영역

251 
TRACKNUMBER
: 
db
 0x00 ; 
OS
 이미지가 시작하는 트랙 번호를 저장하는 영역

253 
times
 510 - (
$
-
$$

db
 0x00 ; $ 현재 라인의 어드레스

254 ; 
$$
 현재 섹션(.
xt
)의 시작 어드레스

255 ; 
$
 - 
$$
 현재 섹션을 기준으로 하는 오프셋 ( 0x55, 0xAA를 정확한 위치에 삽입하려고 추가된 부분)

256 ; 510 - (
$
-
$$
) 현재부터 어드레스 510까지

257 ; 
db
 0x00 
	`db
(
defe
 
by
의 약자) 1바이트를 선언하고 값은 0x00

258 ; 
time
 반복 수행

261 
db
 0x55 ; 1바이트를 선언하고 값은 0x55

262 
db
 0xAA ; 1바이트를 선언하고 값은 0xAA

	@/home/jk/os/MINT64/01.Kernel32/Source/EntryPoint.s

1 ; 
	gEryPot
.
	gs
 파일은 보호 모드 커널의 가장 앞부분에 위치하는 코드로 보호 모드 전환과 초기화를 수행하여 이후에 위치하는 코드를 위한 환경을 제공합니다.

5 [
ORG
 0x00] ;코드의 시작 어드레스를 0x00으로 설정

6 [
BITS
 16] ; 이하의 코드는 16비트 코드로 설정

8 
	gSECTION
 .
	gxt
 ;ext 섹션(세그먼트)을 정의

14 
	gSTART
:

16 
mov
 
ax
, 0x1000 ; 보호 모드 엔트리 포인트의 시작 어드레스 (0x10000)를 세그먼트 레지스터 값으로 변환

17 
mov
 
	gds
, 
	gax
 ; 
	gDS
 세그먼트 레지스터에 설정

18 
mov
 
	ges
, 
	gax
 ; 
	gES
 세그먼트 레지스터에 설정

21 ; 
	gA20
 게이트를 활성화

22 ; 
	gBIOS
를 이용한 전환이 실패했을 때 시스템 컨트롤 포트로 전환 시도

24 ; 
	gBIOS
 서비스를 사용해서 
	gA20
 게이트를 활성화

25 
mov
 
	gax
, 0x2401 ; 
	gA20
 게이트 활성화 서비스 설정

26 0x15 ; 
	gBIOS
 인터럽트 서비스 호출

28 
	gjc
 .
	gA20GATEERROR
 ; 
	gA20
 게이트 활성화가 성공했는지 확인

29 
	gjmp
 .
	gA20GATESUCCESS


31 .
	gA20GATEERROR
:

33 

 
	g
, 0x92 ; 시스템 컨트롤 포트(0x92)에서 1바이트를 읽어 
	gAL
 레지스터에 저장

34 

 
	g
, 0x02 ; 읽은 값에 
	gA20
 게이트 비트(비트 1)를 1로 설정

35 
d
 
	g
, 0xFE ; 시스템 리셋 방지를 위해 0xFE와 
	gAND
 연산하여 비트0을 0으로 설정

36 
	gout
 0x92, 
	g
 ; 시스템 컨트롤 포트(0x92)에 변경된 값을 1바이트 설정

38 .
	gA20GATESUCCESS
:

39 
i
 ; 인터럽트가 발생하지 못하도록 설정

40 
	glgdt
 [ 
GDTR
 ] ; 
	gGDTR
 자료구조를 프로세서에 설정하여 
	gGDT
 테이블을 로드

45 ; 
Dib
 
	ggg
, Dib 
	gche
, 

 
	gFPU
, 
dib
 
Align
 
	gCheck
, 
Eb
 
	geedMode


47 
mov
 
	gx
, 0x4000003B ; 
	gPG
=0 
CD
=1 
NW
=0 
AM
=0 
WP
=0 
NE
=1 
ET
=1 
TS
=1 
EM
=0 
MP
=1 
PE
=1

48 
mov
 
0
, 
	gx
 ; 
	gCR0
 컨트롤 레지스터에 위에서 저장한 플래그를 설정하여 보호 모드로 전환

50 ; 커널 코드 세그먼트를 0x00을 기준으로 하는 것으로 교체하고 
	gEIP
의 값을 0x00을 기준으로 재설정

51 ; 
	gCS
 세그먼트 셀렉터 : 
EIP


52 
jmp
 
dwd
 0x18: ( 
PROTECTEDMODE
 - 
$$
 + 0x10000 )

58 [
BITS
 32] ; 이하의 코드는 32비트 코드로 설정

59 
	gPROTECTEDMODE
:

60 
mov
 
ax
, 0x20 ; 보호 모드 커널용 데이터 세그먼트 디스크립터를 
	gAX
레지스터에 저장

61 
mov
 
	gds
, 
	gax
 ; 
	gDS
 세그먼트 셀렉터에 설정

62 
mov
 
	ges
, 
	gax
 ; 
	gES
 세그먼트 셀렉터에 설정

63 
mov
 
	gfs
, 
	gax
 ; 
	gFS
 세그먼트 셀렉터에 설정

64 
mov
 
	ggs
, 
	gax
 ; 
	gGS
 세그먼트 셀렉터에 설정

67 ; 스택을 0x00000000~0x0000FFFF 영역에 64 
	gKB
 크기로 설정

69 
mov
 
	gss
, 
	gax
 ; 
	gSS
 세그먼트 셀렉터에 설정

70 
mov
 
	ge
, 0xFFFC ; 
	gESP
 레지스터의 어드레스를 0xFFFC로 설정

71 
mov
 
	gebp
, 0xFFFC ; 
	gEBP
 레지스터의 어드레스를 0xFFFC로 설정

75 
push
 ( 
SWITCHSUCCESSMESSAGE
 - 
$$
 + 0x10000 ) ; 출력할 메시지의 어드레스를 스택에 삽입

76 
	gpush
 2 ; 화면 
	gY
 좌표(2)를 스택에 삽입

77 
	gpush
 0 ; 화면 
	gX
 좌표(0)를 스택에 삽입

78 

 
	gPRINTMESSAGE
 ; PRINTMESSAGE 함수 호출

79 
add
 
	ge
, 12 ; 삽입한 파라미터 제거

81 
jmp
 
	gdwd
 0x18:0x10200 ; 
	gcs
 세그먼트 셀렉터를 커널 코드 디스크립터(0x08)로 변경하면서 0x10200 어드레스(
	gc
언어 커널이 있는 어드레스)로 이동

89 ; 스택에 
	gx
 좌표, 
	gy
 좌표, 문자열

91 
	gPRINTMESSAGE
:

92 
push
 
ebp
 ; 베이스 포인터 레지스터(
	gBP
)를 스택에 삽입

93 
mov
 
	gebp
, 
	ge
 ; 베이스 포인터 레지스터(
	gBP
)에 스택 포인터 레지스터(
	gSP
)의 값을 설정

95 
push
 
	gesi
 ; 함수에서 임시로 사용한느 레지스터로 함수의 마지막 부분에서 스택에 삽입되니 값을 꺼내 원래 값으로 복원 기존 리얼 모드에서 비디오 메모리 어드레스를 지정할때 사용하뎐 
	ges
 세그먼트 레지스터가

96 
push
 
	gedi
 ; 없어졌는데 그 이유는 보호 모드로 오면서 32비트 영역으로 확장됨에 따라서 4
	gGB
 영역에 걸친 전 영역을 접근할 수 있기 때문이다.

97 
push
 
x


98 
push
 
ecx


99 
push
 
	gedx


104 ; 
	gX
, 
	gY
의 좌표로 비디오 메모리의 어드레스를 계산함

106 ; 
	gY
 좌표를 이용해서 먼저 라인 어드레스를 구함

107 
mov
 
	gx
, 
	gdwd
 [ 
ebp
 + 12 ] ; 파라미터 2(화면 좌표
	gY
)를 
	gEAX
 레지스터에 설정

108 
mov
 
	gesi
, 160 ; 한 라인의 바이트 수 (2*80 컬럼)를 
	gESI
 레지스터에 설정

109 
mul
 
	gesi
 ; 
	gEAX
 레지스터와 
	gESI
 레지스터를 곱하여 화면 
	gY
 어드레스 계산

110 
mov
 
	gedi
, 
	gx
 ; 계산된 화면 
	gY
 어드레스를 
	gEDI
 레지스터에 설정

112 ; 
	gX
 좌표를 이용해서 2를 곱한 후 최종 어드레스를 구함

113 
mov
 
	gx
, 
	gdwd
 [ 
ebp
 + 8 ] ; 파라미터 1(화면 좌표 
	gX
)를 
	gEAX
레지스터에 설정

114 
mov
 
	gesi
, 2 ; 한 문자를 나타내는 바이트 수(2)를 
	gESI
 레지스터에 설정

115 
mul
 
	gesi
 ; 
	gEAX
 레지스터와 
	gESi
 레지스터를 곱하여 화면 
	gX
 어드레스 계산

116 
add
 
	gedi
, 
	gx
 ; 화면 
	gY
 어드레스와 계산된 
	gX
 어드레스를 더해서 실제 비디오 메모리 어드레스를 계산

120 
mov
 
	gesi
, 
	gdwd
 [ 
ebp
 + 16 ] ; 파라미터 3 (출력할 문자열의 어드레스)

122 .
	gMESSAGELOOP
: ; 메시지를 출력하는 루프

123 
mov
 
	g
, 
	gby
 [ 
esi
 ] ; 
	gESI
 레지스터가 가리키는 문자열 위치에서 한 문자를 
	gCL
 레지스터에 복사

124 ; 
	gCL
 레지스터는 
	gECX
 레지스터의 하위 1바이트를 의미

125 ; 문자열은 1 바이트면 충분하므로 
	gECX
 레지스터의 하위 1 바이트만 사용

127 
cmp
 
	g
, 0 ; 복사된 문자와 0을 비교

128 
	gje
 .
	gMESSAGEEND
 ; 복사한 문자의 값이 0이면 문자열이 종료되었음을 의미하므로 .MESSAGEEND로 이동하여 문자 출력 종료

131 
mov
 
	gby
 [ 
edi
+0xB8000 ], 
	g
 ; 00 아니라면 비디오 메모리 어드레스 0xB8000 + 
	gEDI
에 문자를 출력

133 
add
 
	gesi
, 1 ; 
	gESI
 레지스터에 1을 더하여 다음 문자열로 이동

134 
add
 
	gedi
, 2 ; 
	gEDI
 레지스터에 2를 더하여 비디오 메모리의 다음 문자 위로 이동 비디오 메모리는 (문자,속성)의 쌍으로 구성되므로 문자만 출력하려면 2를 더해야함

136 
	gjmp
 .
	gMESSAGELOOP
 ; 메세지 출력 루프로 이동하여 다음 문자를 출력

138 .
	gMESSAGEEND
:

139 
p
 
edx


140 
p
 
ecx


141 
p
 
x


142 
p
 
edi


143 
p
 
esi


144 
p
 
ebp


145 
t


153 
	gign
 8, 
	gdb
 0

155 ; 
	gGDTR
의 끝을 8b
	gy
로 정렬하기 위해 추가

156 
	gdw
 0x0000

158 ;
	gGDTR
 자료구조 정의

159 
	gGDTR
:

160 
dw
 
GDTEND
-
GDT
-1 ;아래에 위치하는 
	gGDT
 테이블의 전체 크기

161 
dd
 (
GDT
 - 
$$
 + 0x10000 ) ;아래에 위치하는 
	gGDT
 테이블의 시작 어드레스 실제 GDT가 있는 물리주소를 계산하기 위해서 현재 섹션 내의 GDT 오프셋에 세그먼트 기준 주소인 0x10000(부트 로더에 의해 0x10000에 로딩 되었다)을 더함

163 ;
	gGDT
 테이블 정의

164 
	gGDT
:

165 ;널 디스크리터 반드시 0으로 초기화해야함. 
	gGDT
의 맨처음 디스크립터는 널 디스크립터야 된다 (제약 사항)

166 
	gNULLDESCRIPTOR
:

167 
dw
 0x0000

168 
dw
 0x0000

169 
db
 0x00

170 
db
 0x00

171 
db
 0x00

172 
db
 0x00

174 ; 
	gIA
-32e 모드 커널용 코드 세그먼트 디스크립터

175 
	gIA_32eCODEDESCRIPTOR
:

176 
dw
 0xFFFF ; 
	gLim
 [15:0]

177 
dw
 0x0000 ; 
	gBa
 [15:0]

178 
db
 0x00 ; 
	gBa
 [23:16]

179 
db
 0x9A ; 
	gP
=1 
DPL
=0 
Code
 
Segmt
 
Execu
/
Rd


180 
db
 0xAF ; 
	gG
=1 
D
=0 
L
=1 
Lim
 [19:16]

181 
db
 0x00 ; 
	gBa
 [31:24]

183 ; 
	gIA
-32e 모드 커널용 데이터 세그먼트 디스크립터

184 
	gIA_32eDATADESCRIPTOR
:

185 
dw
 0xFFFF ; 
	gLim
 [15:0]

186 
dw
 0x0000 ; 
	gBa
 [15:0]

187 
db
 0x00 ; 
	gBa
 [23:16]

188 
db
 0x92 ; 
	gP
=1 
DPL
=0 
Da
 
Segmt
 
Rd
/
Wre


189 
db
 0xAF ; 
	gG
=1 
D
=0 
L
=1 
Lim
 [19:16]

190 
db
 0x00 ; 
	gBa
 [31:24]

192 
CODEDESCRIPTOR
:

193 
dw
 0xFFFF ; 
	gLim
 [15:0] 세그먼트 크기 4
GB
로 설정 
G
비트가 1로 설정되었을때

194 
dw
 0x0000 ; 
	gba
 [15:0] 기준 주소

195 
db
 0x00 ; 
	gba
 [23:16] 기준 주소

196 
db
 0x9A ; 
	gP
=1 (디스크립터 유효성
DPL
=0 (접근 권한
Code
 
Segmt
 
Execu
/
Rd


197 
db
 0xCF ; 
	gG
=1 ( 세그먼트 크기를 4
GB
로 확장시킴
D
/
B
=1 (1일 경우 32비트용 세그먼트임을 나타낸다.
L
=0 (0으로 설정하면 
IA
-32모드의 32비트 호환모드용 코드 세그먼트임을 나타냄
Lim
[19:16]

198 
db
 0x00 ; 
	gba
 [31:24]

200 
DATADESCRIPTOR
:

201 
dw
 0xFFFF ; 
	gLim
 [15:0] 세그먼트 크기 4
GB
로 설정 
G
비트가 1로 설정되었을때

202 
dw
 0x0000 ; 
	gba
 [15:0] 기준 주소

203 
db
 0x00 ; 
	gba
 [23:16] 기준 주소

204 
db
 0x92 ; 
	gP
=1 (디스크립터 유효성
DPL
=0 (접근 권한
Da
 
Segmt
 
Rd
/
Wre


205 
db
 0xCF ; 
	gG
=1 ( 세그먼트 크기를 4
GB
로 확장시킴
D
/
B
=1 (1일 경우 32비트용 세그먼트임을 나타낸다.
L
=0 (0으로 설정하면 
IA
-32모드의 32비트 호환모드용 코드 세그먼트임을 나타냄
Lim
[19:16]

206 
db
 0x00 ; 
	gba
 [31:24]

207 
GDTEND
:

210 
	gSWITCHSUCCESSMESSAGE
: 
db
 'Switch To Protected Mode Success~!!', 0

212 
	gtimes
 512 - (
	g$
-
	g$$

	gdb
 0x00 ; 512 바이트를 맞추기 위해 남은 부분을 0으로 채움

	@/home/jk/os/MINT64/01.Kernel32/Source/ModeSwitch.asm

1 [
BITS
 32] ; 이하의 코드는 32비트 코드로 설정

3 ; 
	gC
 언어에서 호출할 수 있도록 이름을 노출함(
	gexpt
)

4 
glob
 
	gkRdCPUID
, 
kSwchAndExecu64bKl


6 
	gSECTION
 .
	gxt
 ; .text 섹션(세그먼트)을 정의

8 ; 
	gCPUID
를 반환

9 ; 
	gPARAM
: 
DWORD
 
dwEAX
, DWORD* 
	gpdwEAB
,*
	gpdwEBX
,*
	gpdwECX
,*
pdwEDX


10 
	gkRdCPUID
:

11 
push
 
ebp
 ; 베이스 포인터 레지스터(
	gEBP
)를 스택에 삽입

12 
mov
 
	gebp
, 
	ge
 ; 베이스 포인터 레지스터(
	gEBP
)에 스택 포인터 레지스터(
	gESP
)의 값을 설정

13 
push
 
	gx
 ; 함수에서 임시로 사용하는 레지스터로 함수의 마지막 부분에서 스택에 삽입된 값을 꺼내 원래 값으로 복원

14 
push
 
ebx


15 
push
 
ecx


16 
push
 
edx


17 
push
 
	gesi


22 ; 
	gEAX
 레지스터의 값으로 
	gCPUID
 명령어 실행

25 
mov
 
	gx
, 
	gdwd
[
ebp
+8] ; 파라미터 1(
	gdwEAX
)를 
	gEAX
 레지스터에 저장

26 
	guid
 ; 
	gCPUID
 명령어 실행

32 ; *
pdwEAX


33 
mov
 
	gesi
, 
	gdwd
[
ebp
+12] ; 파라미터 2(
	gpdwEAX
)를 
	gESI
 레지스터에 저장

34 
mov
 
	gdwd
 [
esi
],
	gx
 ; 
	gpdwEAX
가 포인터이므로 포인터가 가리키는 어드레스에 
	gEAX
 레지스터의 값을 저장

36 ; *
pdwEBX


37 
mov
 
	gesi
, 
	gdwd
[
ebp
+16]

38 
mov
 
	gdwd
 [
esi
],
	gebx


40 ; *
pdwECX


41 
mov
 
	gesi
, 
	gdwd
[
ebp
+20]

42 
mov
 
	gdwd
 [
esi
],
	gecx


44 ; *
pdwEBX


45 
mov
 
	gesi
, 
	gdwd
[
ebp
+24]

46 
mov
 
	gdwd
 [
esi
],
edx


48 
p
 
esi


49 
p
 
edx


50 
p
 
ecx


51 
p
 
ebx


52 
p
 
x


53 
p
 
ebp


54 
	gt


56 ; 
	gIA
-32e 모드로 전환하고 64비트 커널을 수행

57 ; 
	gPARAM
: 없음

58 
kSwchAndExecu64bKl
:

60 ; 
	gCR4
 컨트롤 레지스터의 
	gPAE
 비트와 
	gOSXMMEXCPT
 비트, 
	gOXFXSR
 비트를 1로 설정

62 
mov
 
	gx
, 
	g4
 ; 
	gCR4
 컨트롤 레지스터의 값을 
	gEAX
 레지스터에 저장

63 

 
	gx
, 0x620 ; 
	gPAE
 비트(비트5)와 
	gOSXMMEXCPT
 비트(비트10), 
	gOSFXSR
 비트(비트9)를 모두 1로 설정

64 
mov
 
	g4
, 
	gx
 ; 
	gPAE
 비트가 1로 설정된 값을 
	gCR4
 컨트롤 레지스터에 저장

67 ; 
	gCR3
 컨트롤 레지스터에 
	gPML4
 테이블의 어드레스와 캐시 활성화

69 
mov
 
	gx
, 0x100000 ; 
	gEAX
 레지스터에 
	gPML4
 테이블이 존재하는 0x100000(1
	gMB
)를 저장

70 
mov
 
	g3
, 
	gx
 ; 
	gCR3
 컨트롤 레지스터에 0x100000(1
	gMB
)를 저장

73 ; 
	gIA32_EFER
.
	gLME
를 1로 설정하여 
	gIA
-32e 모드를 활성화

75 
mov
 
	gecx
, 0xC0000080 ; 
IA32_EFER
 
	gMSR
 레지스터의 어드레스를 저장

76 
	grdm
 ; 
	gMSR
 레지스터를 읽기

78 

 
	gx
, 0x0100 ; 
	gEAX
 레지스터에 저장된 
IA32_EFER
 
	gMSR
의 하위 32비트에서 
	gLME
비트(비트 9)을 1로 설정

79 
	gwrm
 ; 
	gMSR
 레지스터에 쓰기

83 ; 
	gCR0
 컨트롤 레지스터를 
	gNW
 비트(비트29)=0 
CD
 비트(비트 30)=0 
PG
 비트(비트31)=1로 설정하여 캐시 기능과 페이징 기능을 활성화

84 ; 
	gTS
 비트(비트3=1, 
	gEM
 비트(비트2=0, 
	gMP
 비트(비트1=1로 설정하여 
FPU
를 활성화

86 
mov
 
	gx
, 
	g0
 ; 
	gEAX
 레지스터에 
	gCR0
 컨트롤 레지스터를 저장

87 

 
	gx
, 0xE000000E ; 
	gNW
 비트,
	gCD
 비트,
	gPG
 비트,
	gTS
 비트,
	gEM
 비트,
	gMP
 비트을 모두 1로 설정

88 
x
 
	gx
, 0x60000004 ; 
	gNW
 비트 와 
	gCD
 비트,
	gEm
 비트를 
	gXOR
하여 0으로 설정

89 
mov
 
	g0
, 
	gx
 ; 
	gNW
 비트 = 0, 
	gCD
 비트 = 0, 
	gPG
 비트 = 1, 
	gTS
 비트 = 1, 
	gEM
 비트 = 0, 
	gMP
 비트 = 1로 설정한 값을 다시 
CR0
 컨트롤 레지스터에 저장

91 
jmp
 0x08:0x200000 ; 
	gCS
 세그먼트 셀렉터를 
	gIA_32e
 모드용 코드 세그먼트 디스크립터로 교체하고 0x200000(2
	gMB
) 어드레스로 이동

94 
jmp
 
	g$


	@/home/jk/os/MINT64/01.Kernel32/Source/ModeSwitch.h

1 #ide
__UTILITY_H__


2 
	#__UTILITY_H__


	)

4 
	~"Tys.h
"

6 
kRdCPUID
(
DWORD
 
dwEAX
,DWORD* 
pdwEAX
,DWORD* 
pdwEBX
,DWORD* 
pdwECX
,DWORD* 
pdwEDX
);

7 
kSwchAndExecu64bKl
();

	@/home/jk/os/MINT64/01.Kernel32/Source/Page.c

1 
	~"Page.h
"

4 
	$kInlizePageTabs
()

6 
PML4ENTRY
* 
pPML4Ery
;

7 
PDPTENTRY
* 
pPDPTEry
;

8 
PDENTRY
* 
pPDEry
;

9 
DWORD
 
dwMpgAddss
;

10 
i
;

16 
pPML4Ery
 = (
PML4ENTRY
*)0x100000;

17 
	`kSPageEryDa
(&(
pPML4Ery
[0]),0x00,0x101000,
PAGE_FLAGS_DEFAULT
,0);

18 
i
=1;i<
PAGE_MAXENTRYCOUNT
;i++)

20 
	`kSPageEryDa
(&(
pPML4Ery
[
i
]),0,0,0,0);

28 
pPDPTEry
 =(
PDPTENTRY
*)0x101000;

29 
i
=0;i<64;i++)

31 
	`kSPageEryDa
(&(
pPDPTEry
[
i
]),0,0x102000+(i*
PAGE_TABLESIZE
),
PAGE_FLAGS_DEFAULT
,0);

34 
i
=64;i<
PAGE_MAXENTRYCOUNT
;i++)

36 
	`kSPageEryDa
(&(
pPDPTEry
[
i
]),0,0,0,0);

44 
pPDEry
=(
PDENTRY
*)0x102000;

45 
dwMpgAddss
=0;

48 
i
=0;i<
PAGE_MAXENTRYCOUNT
*64;i++)

51 
	`kSPageEryDa
(&(
pPDEry
[
i
]),(i*(
PAGE_DEFAULTSIZE
>>20))>>12,
dwMpgAddss
,
PAGE_FLAGS_DEFAULT
|
PAGE_FLAGS_PS
,0);

52 
dwMpgAddss
+=
PAGE_DEFAULTSIZE
;

54 
	}
}

58 
	$kSPageEryDa
(
PTENTRY
* 
pEry
,
DWORD
 
dwUBaAddss
,DWORD 
dwLowBaAddss
,DWORD 
dwLowFgs
,DWORD 
dwUFLAGS
)

60 
pEry
->
dwAribuAndLowBaAddss
 = 
dwLowBaAddss
 | 
dwLowFgs
;

61 
pEry
->
dwUBaAddssAndEXB
 =(
dwUBaAddss
&0xFF)|
dwUFLAGS
;

62 
	}
}

	@/home/jk/os/MINT64/01.Kernel32/Source/Page.h

1 #ide
__PAGE_H__


2 
	#__PAGE_H__


	)

4 
	~"Tys.h
"

7 
	#PAGE_FLAGS_P
 0x00000001

8 
	#PAGE_FLAGS_RW
 0x00000002

9 
	#PAGE_FLAGS_US
 0x00000004

10 
	#PAGE_FLAGS_PWT
 0x00000008

11 
	#PAGE_FLAGS_PCD
 0x00000010

12 
	#PAGE_FLAGS_A
 0x00000020

13 
	#PAGE_FLAGS_D
 0x00000040

14 
	#PAGE_FLAGS_PS
 0x00000080

15 
	#PAGE_FLAGS_G
 0x00000100

16 
	#PAGE_FLAGS_PAT
 0x00001000

17 
	#PAGE_FLAGS_EXB
 0x80000000

18 
	#PAGE_FLAGS_DEFAULT
 (
PAGE_FLAGS_P
 | 
PAGE_FLAGS_RW
)

	)

19 
	#PAGE_TABLESIZE
 0x1000

	)

20 
	#PAGE_MAXENTRYCOUNT
 512

	)

21 
	#PAGE_DEFAULTSIZE
 0x200000

	)

25 #agm
ck
 (
push
,1)

27 
	skPageTabErySu


33 
DWORD
 
	mdwAribuAndLowBaAddss
;

35 
DWORD
 
	mdwUBaAddssAndEXB
;

36 } 
	tPML4ENTRY
,
	tPDPTENTRY
,
	tPDENTRY
,
	tPTENTRY
;

38 #agm
ck
 (
p
)

41 
kInlizePageTabs
();

42 
kSPageEryDa
(
PTENTRY
* 
pEry
, 
DWORD
 
dwUBaAddss
, DWORD 
dwLowBaAddess
,DWORD 
dwLowFgs
, DWORD 
dwUFgs
);

	@/home/jk/os/MINT64/01.Kernel32/Source/Types.h

1 #ide
__TYPES_H__


2 
	#__TYPES_H__


	)

4 
	#BYTE
 

	)

5 
	#WORD
 

	)

6 
	#DWORD
 

	)

7 
	#QWORD
 

	)

8 
	#BOOL
 

	)

10 
	#TRUE
 1

	)

11 
	#FALSE
 0

	)

12 
	#NULL
 0

	)

14 #agm
ck
(
push
,1)

16 
	skChaSu


18 
BYTE
 
	mbCha
;

19 
BYTE
 
	mbAribu
;

20 } 
	tCHARACTER
;

22 #agm
ck
(
p
)

	@/home/jk/os/MINT64/01.Kernel32/Source/main.c

1 
	~"Tys.h
"

2 
	~"Page.h
"

3 
	~"ModeSwch.h
"

6 
kPrtSg
(
iX
,
iY
,cڡ * 
pcSg
);

7 
BOOL
 
kInlizeKl64Aa
();

8 
BOOL
 
kIsMemyEnough
();

9 
kCyKl64ImageTo2Mby
();

13 
	$ma
()

15 
DWORD
 
i
;

16 
DWORD
 
dwEAX
, 
dwEBX
, 
dwECX
, 
dwEDX
;

17 
vcVdSg
[13]={0,};

20 
	`kPrtSg
(0,3,"Protected Mode C Language kernel start........................[Pass]");

23 
	`kPrtSg
(0,4,"Minimum Memory Size Check...................[ ]");

24 if(
	`kIsMemyEnough
()==
FALSE
)

26 
	`kPrtSg
(45,4,"Fail");

27 
	`kPrtSg
(0,5,"Not Enough Memory~!! MINT64 OS Requires Over 64MByte Memory~!!");

32 
	`kPrtSg
(45,4,"Pass");

37 
	`kPrtSg
(0,5,"IA-32e kernel Area Initialize...............[ ]");

38 if(
	`kInlizeKl64Aa
()==
FALSE
)

40 
	`kPrtSg
(45,4,"Fail");

41 
	`kPrtSg
(0,4,"Kernel Area Initialization Fail~!!");

44 
	`kPrtSg
(45,5,"Pass");

47 
	`kPrtSg
(0,6,"IA-32e Page Tables Initialize...............[ ]");

48 
	`kInlizePageTabs
();

49 
	`kPrtSg
(45,6,"Pass");

52 
	`kRdCPUID
(0x00,&
dwEAX
,&
dwEBX
,&
dwECX
,&
dwEDX
);

53 *(
DWORD
*)
vcVdSg
=
dwEBX
;

54 *((
DWORD
*)
vcVdSg
+1)=
dwEDX
;

55 *((
DWORD
*)
vcVdSg
+2)=
dwECX
;

56 
	`kPrtSg
(0,7,"Processor Vendor String.....................[ ]");

57 
	`kPrtSg
(45,7,
vcVdSg
);

60 
	`kRdCPUID
(0x80000001,&
dwEAX
,&
dwEBX
,&
dwECX
,&
dwEDX
);

61 
	`kPrtSg
(0,8,"64bit Mode Support Check....................[ ]");

62 if(
dwEDX
&(1<<29))

64 
	`kPrtSg
(45,8,"Pass");

68 
	`kPrtSg
(45,8,"Fail");

69 
	`kPrtSg
(0,9,"Thisrocessor doesot support 64bit mode~!!");

74 
	`kPrtSg
(0,9,"Copy IA-32e kernel To 2M Address............[ ]");

75 
	`kCyKl64ImageTo2Mby
();

76 
	`kPrtSg
(45,9,"Pass");

79 
	`kPrtSg
(0,10,"Switch To IA-32e Mode");

80 
	`kSwchAndExecu64bKl
();

84 
	}
}

87 
	$kPrtSg
(
iX
,
iY
,cڡ * 
pcSg
)

89 
CHARACTER
* 
pSn
 =(CHARACTER*)0xB8000;

90 
i
;

93 
pSn
+=(
iY
*80)+
iX
;

96 
i
=0;
pcSg
[i]!=0;i++)

98 
pSn
[
i
].
bCha
=
pcSg
[i];

100 
	}
}

103 
BOOL
 
	$kInlizeKl64Aa
()

105 
DWORD
* 
pdwCutAddss
;

108 
pdwCutAddss
 = (
DWORD
*) 0x100000;

111 (
DWORD
)
pdwCutAddss
<0x600000)

113 *
pdwCutAddss
=0x00;

117 if(*
pdwCutAddss
!=0)

119  
FALSE
;

123 
pdwCutAddss
++;

126  
TRUE
;

127 
	}
}

130 
BOOL
 
	$kIsMemyEnough
()

132 
DWORD
* 
pdwCutAddss
;

135 
pdwCutAddss
=(
DWORD
*)0x100000;

138 (
DWORD
)
pdwCutAddss
<0x4000000)

140 *
pdwCutAddss
=0x12345678;

144 if(*
pdwCutAddss
!=0x12345678)

146  
FALSE
;

150 
pdwCutAddss
 +=(0x1000000/4);

153  
TRUE
;

154 
	}
}

157 
	$kCyKl64ImageTo2Mby
()

159 
WORD
 
wKl32SeCou
, 
wTٮKlSeCou
;

160 
DWORD
* 
pdwSourAddss
,*
pdwDeiAddss
;

161 
i
;

164 
wTٮKlSeCou
 = *((
WORD
*)0x7C05);

165 
wKl32SeCou
 = *((
WORD
*)0x7C07);

167 
pdwSourAddss
 = (
DWORD
*)(0x10000+(
wKl32SeCou
*512));

168 
pdwDeiAddss
=(
DWORD
*)0x200000;

171 
i
=0;i<512*(
wTٮKlSeCou
-
wKl32SeCou
)/4;i++)

173 *
pdwDeiAddss
=*
pdwSourAddss
;

174 
pdwDeiAddss
++;

175 
pdwSourAddss
++;

177 
	}
}

	@/home/jk/os/MINT64/01.Kernel32/VirtualOS.asm

1 [
ORG
 0x00] ; 코드의 시작 어드레스르르 0x00으로 설정

2 [
BITS
 16] ; 이하의 코드는 16비트 코드로 설정

4 
	gSECTION
 .
	gxt
 ;ext 섹션(세그먼트)을 정의

6 
	gjmp
 0x1000:
START
 ; 
	gcs
 세그먼트 레지스터에 0x1000을 복사하면서, 
	gSTART
 레이블로 이동

8 
	gSECTORCOUNT
: 
dw
 0x0000 ; 현재 실행 중인 섹터 번호를 저장

9 
TOTALSECTORCOUNT
 
	gequ
 1024 ; 가상 
	gos
의 총 섹터 수

10 ; 최대 1152섹터 (0x90000b
	gy
)까지 가능

15 
	gSTART
:

16 
mov
 
ax
, 
	gcs
 ; 
	gCS
 세그먼트 레지스터의 값을 
	gax
 레지스터에 설정

17 
mov
 
	gds
, 
	gax
 ;x 레지스터의 값을 ds 세그먼트 레지스터에 설정

18 
mov
 
	gax
, 0xB800 ; 비디오 메모리 어드레스인 0x0B8000을 세그먼트 레지스터 값으로 변환

20 
mov
 
	ges
, 
	gax
 ; 
	gES
 세그먼트 레지스터에 설정

25 %
assign
 
	gi
 0 ; i라는 변수를 지정하고 0으로 초기화

26 %
p
 
	gTOTALSECTORCOUNT
 ; TOTALSECTORCOUNT에 저장된 값만큼 아래 코드를 반복

27 %
assign
 
i
 
	gi
 + 1 ; i에 1 증가

30 
mov
 
	gax
, 2 ; 한 문자를 나타내는 바이트 수(2)를x 레지스터에 설정

32 
mul
 
	gwd
 [ 
SECTORCOUNT
 ] ; 
	gAX
 레지스터와 섹터 수를 곱함

33 
mov
 
	gsi
, 
	gax
 ; 곱한 결과를 si 레지스터에 설정

36 
mov
 
	gby
 [ 
es
: 
si
 + ( 160 * 2 ) ], '0' + ( 
	gi
 % 10 )

37 
add
 
	gwd
 [ 
SECTORCOUNT
 ], 1 ; 섹터 수를 1 증가

41 %
	gi
 =
TOTALSECTORCOUNT
 ; i가 
	gTOTALSECTORCOUNT
와 같다면 즉 마지막 섹터이면 현재 위치에서 무한 루프 수행

43 
jmp
 
	g$


45 
jmp
 ( 0x1000 + 
i
 * 0x20 ): 0x0000 ; 다음 섹터 오프셋으로 이동

46 %
	gdif
 ; 문의 끝

48 
times
 ( 512 - ( 
$
 - 
$$
 ) % 512 ) 
	gdb
 0x00

49 %
	gdp


	@/home/jk/os/MINT64/02.Kernel64/Source/AssemblyUtility.asm

1 [
BITS
 64] ; 이하의 코드는 64비트 코드로 설정

3 
	gSECTION
 .
	gxt
 ;ext 섹션(세그먼트)을 정의

5 ; 
	gc
 언어에서 호출할 수 있도록 이름을 노출함

6 
glob
 
	gkInPtBy
, 
	gkOutPtBy
,
	gkInPtWd
,
kOutPtWd


7 
glob
 
	gkLdGDTR
,
	gkLdTR
,
kLdIDTR


8 
glob
 
	gkEbIru
, 
	gkDibIru
, 
kRdRFLAGS


9 
glob
 
kRdTSC


10 
glob
 
	gkSwchCڋxt
, 
	gkH
, 
kTeAndS


11 
glob
 
	gkInlizeFPU
, 
	gkSaveFPUCڋxt
, 
	gkLdFPUCڋxt
, 
	gkSTS
, 
	gkCˬTS


14 ; 
	gPARAM
 : 포트 번호

15 
kInPtBy
:

16 
push
 
rdx
 ; 함수에서 임시로 사용하는 레지스터를 스택에 저장 함수의 마지막 부분에서 스택에 삽입된 값을 꺼내 복원

18 
mov
 
	grdx
, 
	grdi
 ; 
	gRDX
 레지스터에 파라미터 1(포트 번호)를 저장

19 
mov
 
	gx
, 0 ; 
	gRAX
 레지스터를 초기화

20 

 
	g
, 
	gdx
 ; 
	gDX
 레지스터에 저장된 포트 어드레스에서 한 바이트를 읽어 
	gAL
 레지스터에 저장, AL 레지스터는 함수의 반환 값으로 사용됨

23 
p
 
rdx


24 
	gt


28 ; 
	gPARAM
 : 포트 번호, 데이터

29 
	gkOutPtBy
:

30 
push
 
rdx


31 
push
 
x


33 
mov
 
rdx
, 
	grdi
 ; 
	gRDX
 레지스터에 파라미터 1(포트 번호)를 저장

34 
mov
 
	gx
, 
	grsi
 ; 
	gRAX
 레지스터에 파라미터 2(데이터)를 저장

35 
out
 
	gdx
, 
	g
 ; 
	gDX
 레지스터에 저장된 포트 어드레스에 
	gAL
 레지스터에 저장된 한 바이트를 씀

37 
p
 
x


38 
p
 
rdx


39 
	gt


41 ; 
	gGDTR
 레지스터에 
	gGDT
 테이블을 설정

42 ; 
	gPARAM
: 
GDT
 테이블의 정보를 저장하는 자료구조의 어드레스

43 
kLdGDTR
:

44 
lgdt
 [
rdi
] ; 파라미터 1(
	gGDTR
의 어드레스)를 프로세서에 로드하여 
	gGDT
 테이블을 설정

46 
	gt
 ; 
	gGDT
 테이블을 설정

48 ; 
	gTR
 레지스터에 
	gTSS
 세그먼트 디스크립터 설정

49 ; 
	gPARAM
: 
TSS
 세그먼트 디스크립터의 오프셋

50 
kLdTR
:

51 
r
 
di
 ; 파라미터 1(
	gTSS
 세그먼트 디스크립터의 오프셋)을 프로세서에 설정하여 TSS 세그먼트를 로드

53 
	gt


55 ; 
	gIDTR
 레지스터에 
	gIDT
 테이블을 설정

56 ; 
	gPARAM
: 
IDT
 테이블의 정보를 저장하는 자료구조의 어드레스

57 
kLdIDTR
:

58 
lidt
 [
rdi
] ; 파라미터 1(
	gIDTR
의 어드레스)을 프로세서에 로드하여 
	gIDT
 테이블을 설정

60 
	gt


63 ; 
	gPARAM
: 없음

64 
kEbIru
:

65 
i
 ; 인터럽트를 활성화

66 
	gt


69 ; 
	gPARAM
: 없음

70 
kDibIru
:

71 
i
 ; 인터럽트를 비활성화

72 
	gt


74 ; 
	gRFLAGS
 레지스터를 읽어서 되돌려줌

75 ; 
	gPARAM
: 없음

76 
kRdRFLAGS
:

77 
pushfq
 ; 
	gRFLAGS
 레지스터를 스택에 저장

78 
p
 
	gx
 ; 스택에 저장된 
	gRFLAGS
 레지스터를 
	gRAX
 레지스터에 저장하여 함수의 반환 값으로 설정

80 
	gt


83 ; 
	gPARAM
: 없음

84 
kRdTSC
:

85 
push
 
rdx
 ; 
	gRDX
 레지스터를 스택에 저장

87 
	grdtsc
 ; 타임 스탬프 카운터를 읽어서 
	gRDX
:
RAX
에 저장

89 
shl
 
rdx
,32 ; 
	gRDX
 레지스터에 있는 상위 32비트 
	gTSC
 값과 
	gRAX
 레지스터에 있는 하위 32비트 TSC 갑을 
	gOR
하여 RAX 레지스터에 64비트 TSC 값을 저장

90 

 
	gx
,
rdx


92 
p
 
rdx


93 
	gt


99 %
mao
 
	gKSAVECONTEXT
 0 ; 파라미터를 전달받지 않는 KSAVECONTEXT 매크로 정의

100 ; 
	gRBP
 레지스터부터 
	gGS
 세그먼트 셀렉터까지 모두 스택에 삽입

101 
push
 
rbp


102 
push
 
x


103 
push
 
rbx


104 
push
 
rcx


105 
push
 
rdx


106 
push
 
rdi


107 
push
 
rsi


108 
push
 
r8


109 
push
 
r9


110 
push
 
r10


111 
push
 
r11


112 
push
 
r12


113 
push
 
r13


114 
push
 
r14


115 
push
 
r15


117 
mov
 
	gax
, 
	gds
 ; 
	gDS
 세그먼트 셀렉터와 
	gES
 세그먼트 셀렉터는 스택에 직접 삽입할 수 없으므로, 
	gRAX
 레지스터에 저장한 후 스택에 삽입

118 
push
 
x


119 
mov
 
	gax
, 
es


120 
push
 
x


121 
push
 
fs


122 
push
 
	ggs


123 %
	gdmao
 ; 매크로 끝

127 %
mao
 
	gKLOADCONTEXT
 0 ; 파라미터를 전달받지 않는 KLOADCONTEXT 매크로 정의

128 ; 
	gGS
 세그먼트 셀렉터부터 
	gRBP
 레지스터까지 모두 스택에서 꺼내 복원

129 
p
 
gs


130 
p
 
fs


131 
p
 
x


132 
mov
 
	ges
, 
	gax
 ; 
	gES
 세그먼트 셀렉터와 
	gDS
 세그먼트 셀렉터는 스택에서 직접 꺼내 복원할 수 없으므로 
	gRAX
 레지스터에 저장한 뒤에 복원

133 
p
 
x


134 
mov
 
	gds
, 
ax


136 
p
 
r15


137 
p
 
r14


138 
p
 
r13


139 
p
 
r12


140 
p
 
r11


141 
p
 
r10


142 
p
 
r9


143 
p
 
r8


144 
p
 
rsi


145 
p
 
rdi


146 
p
 
rdx


147 
p
 
rcx


148 
p
 
rbx


149 
p
 
x


150 
p
 
	grbp


151 %
	gdmao
 ; 매크로 끝

153 ; 
Cu
 
	gCڋxt
에 현재 콘텍스트를 저장하고 
Next
 
	gTask
에서 콘텍스트를 복구

154 ; 
	gPARAM
: 
Cut
 
Cڋxt
, 
Next
 Context

155 
	gkSwchCڋxt
:

156 
push
 
rbp
 ; 스택에 
	gRBP
 레지스터를 저장하고 
	gRSP
 레지스터를 RBP에 저장

157 
mov
 
	grbp
, 
	gr


159 ; 
Cut
 
	gCڋxt
가 
	gNULL
이면 콘텍스트를 저장할 필요 없음

160 
	gpushfq
 ; 아래의 
	gcmp
의 결과로 
	gRFLAGS
 레지스터가 변하지 않도록 스택에 저장

161 
cmp
 
	grdi
, 0 ; 
Cut
 
	gCڋxt
가 
	gNULL
이면 콘텍스트 복원으로 바로 이동

162 
	gje
 .
LdCڋxt


163 
	gpfq
 ; 스택에 저장한 
	gRFLAGS
 레지스터를 복원

169 
push
 
	gx
 ; 콘텍스트 영역의 오프셋으로 사용할 
	gRAX
 레지스터를 스택에 저장

171 ; 
	gSS
, 
	gRSP
, 
	gRFLAGS
, 
	gCS
, 
	gRIP
 레지스터 순서대로 삽입

172 
mov
 
	gax
, 
	gss
 ; 
	gSS
 레지스터 저장

173 
mov
 
	gqwd
[
rdi
+(23*8)],
x


175 
mov
 
	gx
, 
	grbp
 ; 
	gRBP
에 저장된 
	gRSP
 레지스터 저장

176 
add
 
	gx
, 16 ; 
	gRSP
 레지스터는 
push
 
	grbp
와 
Ru
 
	gAddss
를 제외한 값으로 저장

177 
mov
 
	gqwd
[
rdi
+(22*8)],
x


179 
	gpushfq
 ; 
	gRFLAGS
 레지스터에 저장

180 
p
 
x


181 
mov
 
	gqwd
[
rdi
+(21*8)],
x


183 
mov
 
	gax
, 
	gcs
 ; 
	gCS
 레지스터 저장

184 
mov
 
	gqwd
[
rdi
+(20*8)],
x


186 
mov
 
	gx
, 
	gqwd
[
rbp
+8] ; 
	gRIP
 레지스터를 
Ru
 
	gAddss
로 설정하여 다음 콘텍스트 복원 시에 이 함수를 호출한 위치로 이동하게 함

187 
mov
 
	gqwd
[
rdi
+(19*8)],
	gx


190 
p
 
x


191 
p
 
	grbp


193 ; 가장 끝부분에 
	gSS
, 
	gRSP
, 
	gRFLAGS
, 
	gCS
, 
	gRIP
 레지스터를 저장했으므로, 이전 영역에 
	gpush
 명령어로 콘텍스트를 저장하기 위해 스택을 변경

194 
add
 
	grdi
,(19*8)

195 
mov
 
	gr
, 
rdi


196 
sub
 
	grdi
,(19*8)

198 ; 나머지 레지스터를 모두 
	gCڋxt
 자료구조에 저장

199 
	gKSAVECONTEXT


206 .
	gLdCڋxt
:

207 
mov
 
r
, 
	grsi


209 ; 
	gCڋxt
 자료구조에서 레지스터를 복원

210 
KLOADCONTEXT


211 
	gq


213 ; 
	gPARAM
: 없음

214 
kH
:

215 
h
 ; 프로세서를 대기 상태로 진입시킴

216 
h


217 
	gt


220 ; 
	gDei
과 
	gCom
를 비교하여 같다면 Dei에 
	gSour
 값을 삽입

221 ; 
	gPARAM
: 값을 저장할 어드레스(
Dei
,
	grdi
), 비교할 값 (
	gCom
,
	grsi
)

222 ; 설정할 값 (
	gSour
,
	grdx
)

223 
	gkTeAndS
:

224 
mov
 
x
, 
	grsi
 ; 두 번째 파라미터인 비교할 값을 
	gRAX
 레지스터에 저장

226 ; 
	gRAX
 레지스터에 저장된 비교할 값과 첫 번째 파라미터(
	grdi
)의 메모리 어드레스의 값을 비교하여

227 ; 두 값이 같다면 세 번째 파라미터(
	gdl
)의 값을 첫 번째 파라미터(
	grdi
)가 가리키는 어드레스에 삽입하고 
	gRFLAGS
의 
	gZF
비트를 1로 설정

228 ; 두 값이 다르면 첫 번째 파라미터(
	grdi
)의 값을 두 번째 파라미터(
	gRAX
)에 삽입하고 
	gRFLAGS
의 
	gZF
 비트를 0로 설정

229 ; 
	gLOCK
 명령어는 어셈블리어 코드에서 전치사로 사용되며, 뒤에 따라오는 명령어를 수행하는 동안

231 
lock
 
cmpxchg
 
	gby
[
rdi
],
dl


232 
	gje
 .
	gSUCCESS


234 .
	gNOTSAME
: ; 
	gDei
과 
	gCom
가 다른 경우

235 
mov
 
	gx
, 0x00

236 
	gt


238 .
	gSUCCESS
:

239 
mov
 
x
, 0x01 ; 
	gDei
과 
	gCom
과 같은 경우

240 
	gt


243 ; 
	gFPU
 관련 어셈블리어 함수

245 ; 
	gFPU
를 초기화

246 ; 
	gPARAM
: 없음

247 
kInlizeFPU
:

248 
f
 ; 
	gFPU
 초기화를 수행

249 
	gt


251 ; 
	gFPU
 관련 레지스터를 콘텍스트 버퍼에 저장

252 ; 
	gPARAM
: 
Bufr
 
Addss


253 
kSaveFPUCڋxt
:

254 
fxve
 [
rdi
] ; 첫 번째 파라미터로 전달된 버퍼에 
	gFPU
 레지스터를 저장

255 
	gt


257 ; 
	gFPU
 관련 레지스터를 콘텍스트 버퍼에서 복원

258 ; 
	gPARAM
: 
Bufr
 
Addss


259 
kLdFPUCڋxt
:

260 
fxr
 [
rdi
] ; 첫 번째 파라미터로 전달된 버퍼에서 
	gFPU
 레지스터를 복원

261 
	gt


263 ; 
	gCR0
 컨트롤 레지스터의 
	gTS
 비트를 1로 설정

264 ; 
	gPARAM
: 없음

265 
kSTS
:

266 
push
 
x
 ; 스택에 
	gRAX
 레지스터의 값을 저장

268 
mov
 
	gx
, 
	g0
 ; 
	gCR0
 컨트롤 레지스터의 값을 
	gRAX
 레지스터로 저장

269 

 
	gx
, 0x08 ; 
	gTS
 비트(비트7)를 1로 설정

270 
mov
 
	g0
, 
	gx
 ; 
	gTS
 비트가 1로 설정된 값을 
	gCR0
 컨트롤 레지스터로 저장

272 
p
 
	gx
 ; 스택에서 
	gRAX
 레지스터의 값을 복원

273 
	gt


275 ; 
	gCR0
 컨트롤 레지스터의 
	gTS
 비트를 0으로 설정

276 ; 
	gPARAM
: 없음

277 
kCˬTS
:

278 
ts
 ; 
	gCR0
 컨트롤 레지스터에서 
	gTS
 비트를 0으로 설정

279 
	gt


282 ; 
	gPARAM
: 포트 번호

283 
kInPtWd
:

284 
push
 
rdx
 ; 함수에서 임시로 사용하는 레지스터를 스택에 저장

287 
mov
 
	grdx
, 
	grdi
 ; 
	gRDX
 레지스터에 파라미터 1(포트 번호)을 저장

288 
mov
 
	gx
, 0 ; 
	gRAX
 레지스터를 초기화

289 

 
	gax
, 
	gdx
 ; 
	gDX
 레지스터에 저장된 포트 어드레스에서 두 바이트를 읽어 
	gAX
 레지스터에 저장

290 ; 
	gAX
 레지스터는 함수의 반환 값으로 사용됨

292 
p
 
	grdx
 ; 함수에서 사용이 끝난 레지스터를 복원

293 
	gt
 ; 함수를 호출한 다음 코드의 위치로 복귀

296 ; 
	gPARAM
: 포트 번호, 데이터

297 
	gkOutPtWd
:

298 
push
 
rdx
 ; 함수에서 임시로 사용하는 레지스터를 스택에 저장

299 
push
 
	gx
 ; 함수의 마지막 부분에서 스택에 삽입된 값을 꺼내 복원

301 
mov
 
	grdx
, 
	grdi
 ; 
	gRDX
 레지스터에 파라미터 1(포트 번호)을 저장

302 
mov
 
	gx
, 
	grsi
 ; 
	gRAX
 레지스터에 파라미터 2(데이터)를 저장

303 
out
 
	gdx
, 
	gax
 ; 
	gDX
 레지스터에 저장된 포트 어드레스에 
	gAX
 레지스터에 저장된 두 바이트를 씀

305 
p
 
	gx
 ; 함수에서 사용이 끝난 레지스터를 복원

306 
p
 
rdx


307 
	gt
 ; 함수를 호출한 다음 코드의 위치로 복귀

	@/home/jk/os/MINT64/02.Kernel64/Source/AssemblyUtility.h

1 #ide
__ASSEMBLYUTILITY_H__


2 
	#__ASSEMBLYUTILITY_H__


	)

4 
	~"Tys.h
"

5 
	~"Task.h
"

8 
BYTE
 
kInPtBy
(
WORD
 
wPt
);

9 
kOutPtBy
(
WORD
 
wPt
,
BYTE
 
bDa
);

10 
kLdGDTR
(
QWORD
 
qwGDTRAddss
);

11 
kLdTR
(
WORD
 
wTSSSegmtOfft
);

12 
kLdIDTR
(
QWORD
 
qwIDTRAddss
);

13 
kEbIru
();

14 
kDibIru
();

15 
QWORD
 
kRdRFLAGS
();

16 
QWORD
 
kRdTSC
();

17 
kSwchCڋxt
(
CONTEXT
* 
pCutCڋxt
,CONTEXT* 
pNextCڋxt
);

18 
kH
();

19 
BOOL
 
kTeAndS
(vީ
BYTE
* 
pbDei
,BYTE 
bCom
,BYTE 
bSour
);

20 
kInlizeFPU
();

21 
kSaveFPUCڋxt
(* 
pvFPUCڋxt
);

22 
kLdFPUCڋxt
(* 
pvFPUCڋxt
);

23 
kSTS
();

24 
kCˬTS
();

25 
WORD
 
kInPtWd
(WORD 
wPt
);

26 
WORD
 
kOutPtWd
(WORD 
wPt
,WORD 
wDa
);

	@/home/jk/os/MINT64/02.Kernel64/Source/Console.c

1 
	~"/u/oss/lib/gcc/x86_64-pc-lux/4.8.2/ude/dg.h
"

2 
	~"Cse.h
"

3 
	~"Keybrd.h
"

4 
	~"Uty.h
"

5 
	~"AsmblyUty.h
"

6 
	~"Tys.h
"

9 
CONSOLEMANAGER
 
	ggs_CseMag
 = {0,};

12 
	$kInlizeCse
(
iX
,
iY
)

15 
	`kMemS
(&
gs_CseMag
,0,(gs_stConsoleManager));

18 
	`kSCurs
(
iX
,
iY
);

19 
	}
}

23 
	$kSCurs
(
iX
,
iY
)

25 
iLrVue
;

28 
iLrVue
 = 
iY
*
CONSOLE_WIDTH
+
iX
;

31 
	`kOutPtBy
(
VGA_PORT_INDEX
,
VGA_INDEX_UPPERCURSOR
);

33 
	`kOutPtBy
(
VGA_PORT_DATA
,
iLrVue
>>8);

36 
	`kOutPtBy
(
VGA_PORT_INDEX
,
VGA_INDEX_LOWERCURSOR
);

38 
	`kOutPtBy
(
VGA_PORT_DATA
,
iLrVue
&0xFF);

41 
gs_CseMag
.
iCutPrtOfft
=
iLrVue
;

42 
	}
}

45 
	$kGCurs
(* 
piX
,* 
piY
)

48 *
piX
=
gs_CseMag
.
iCutPrtOfft
%
CONSOLE_WIDTH
;

49 *
piY
=
gs_CseMag
.
iCutPrtOfft
/
CONSOLE_WIDTH
;

50 
	}
}

53 
	$kPrtf
(cڡ * 
pcFmSg
,...)

55 
va_li
 

;

56 
vcBufr
[1024];

57 
iNextPrtOfft
;

60 
	`va_t
(

,
pcFmSg
);

61 
	`kVSPrtf
(
vcBufr
,
pcFmSg
,

);

62 
	`va_d
(

);

65 
iNextPrtOfft
=
	`kCsePrtSg
(
vcBufr
);

68 
	`kSCurs
(
iNextPrtOfft
%
CONSOLE_WIDTH
,iNextPrintOffset/CONSOLE_WIDTH);

69 
	}
}

72 
	$kCsePrtSg
(cڡ * 
pcBufr
)

74 
CHARACTER
* 
pSn
 =(CHARACTER*)
CONSOLE_VIDEOMEMORYADDRESS
;

75 
i
,
j
;

76 
iLgth
;

77 
iPrtOfft
;

80 
iPrtOfft
 = 
gs_CseMag
.
iCutPrtOfft
;

83 
iLgth
 = 
	`kSL
(
pcBufr
);

84 
i
=0;i<
iLgth
;i++)

87 if(
pcBufr
[
i
]=='\n')

91 
iPrtOfft
+=(
CONSOLE_WIDTH
-(iPrintOffset%CONSOLE_WIDTH));

95 i(
pcBufr
[
i
]=='\t')

98 
iPrtOfft
+=(8-(iPrintOffset%8));

104 
pSn
[
iPrtOfft
].
bCha
=
pcBufr
[
i
];

105 
pSn
[
iPrtOfft
].
bAribu
=
CONSOLE_DEFAULTTEXTCOLOR
;

106 
iPrtOfft
++;

110 if(
iPrtOfft
>=(
CONSOLE_HEIGHT
*
CONSOLE_WIDTH
))

113 
	`kMemCpy
(
CONSOLE_VIDEOMEMORYADDRESS
,CONSOLE_VIDEOMEMORYADDRESS+
CONSOLE_WIDTH
*(
CHARACTER
),(
CONSOLE_HEIGHT
-1)*CONSOLE_WIDTH*(CHARACTER));

116 
j
=(
CONSOLE_WIDTH
*(
CONSOLE_HEIGHT
-1));j<(CONSOLE_WIDTH*CONSOLE_HEIGHT);j++)

119 
pSn
[
j
].
bCha
=' ';

120 
pSn
[
j
].
bAribu
=
CONSOLE_DEFAULTTEXTCOLOR
;

124 
iPrtOfft
=(
CONSOLE_HEIGHT
-1)*
CONSOLE_WIDTH
;

128  
iPrtOfft
;

129 
	}
}

132 
	$kCˬSn
()

134 
CHARACTER
* 
pSn
=(CHARACTER*)
CONSOLE_VIDEOMEMORYADDRESS
;

135 
i
;

137 
i
=0;i<
CONSOLE_WIDTH
*
CONSOLE_HEIGHT
;i++)

139 
pSn
[
i
].
bCha
=' ';

140 
pSn
[
i
].
bAribu
=
CONSOLE_DEFAULTTEXTCOLOR
;

144 
	`kSCurs
(0,0);

145 
	}
}

148 
BYTE
 
	$kGCh
()

150 
KEYDATA
 
Da
;

156 
	`kGKeyFromKeyQueue
(&
Da
)==
FALSE
)

158 
	`kSchedu
();

163 if(
Da
.
bFgs
&
KEY_FLAGS_DOWN
)

165  
Da
.
bASCIICode
;

168 
	}
}

171 
	$kPrtSgXY
(
iX
,
iY
,cڡ * 
pcSg
)

173 
CHARACTER
* 
pSn
 = (CHARACTER*)
CONSOLE_VIDEOMEMORYADDRESS
;

174 
i
;

177 
pSn
+=(
iY
*80)+
iX
;

180 
i
=0;
pcSg
[i]!=0;i++)

182 
pSn
[
i
].
bCha
=
pcSg
[i];

183 
pSn
[
i
].
bAribu
=
CONSOLE_DEFAULTTEXTCOLOR
;

185 
	}
}

	@/home/jk/os/MINT64/02.Kernel64/Source/Console.h

1 #ide
__CONSOLE_H__


2 
	#__CONSOLE_H__


	)

4 
	~"Tys.h
"

8 
	#CONSOLE_BACKGROUND_BLACK
 0x00

	)

9 
	#CONSOLE_BACKGROUND_BLUE
 0x10

	)

10 
	#CONSOLE_BACKGROUND_GREEN
 0x20

	)

11 
	#CONSOLE_BACKGROUND_CYAN
 0x30

	)

12 
	#CONSOLE_BACKGROUND_RED
 0x40

	)

13 
	#CONSOLE_BACKGROUND_MAGENTA
 0x50

	)

14 
	#CONSOLE_BACKGROUND_BROWN
 0x60

	)

15 
	#CONSOLE_BACKGROUND_WHITE
 0x70

	)

16 
	#CONSOLE_BACKGROUND_BLINK
 0x80

	)

17 
	#CONSOLE_FOREGROUND_DARKBLACK
 0x00

	)

18 
	#CONSOLE_FOREGROUND_DARKBLUE
 0x01

	)

19 
	#CONSOLE_FOREGROUND_DARKGREEN
 0x02

	)

20 
	#CONSOLE_FOREGROUND_DARKCYAN
 0x03

	)

21 
	#CONSOLE_FOREGROUND_DARKRED
 0x04

	)

22 
	#CONSOLE_FOREGROUND_DARKMAGENTA
 0x05

	)

23 
	#CONSOLE_FOREGROUND_DARKBROWN
 0x06

	)

24 
	#CONSOLE_FOREGROUND_DARKWHITE
 0x07

	)

25 
	#CONSOLE_FOREGROUND_BRIGHTBLACK
 0x08

	)

26 
	#CONSOLE_FOREGROUND_BRIGHTBLUE
 0x09

	)

27 
	#CONSOLE_FOREGROUND_BRIGHTGREEN
 0x0A

	)

28 
	#CONSOLE_FOREGROUND_BRIGHTCYAN
 0x0B

	)

29 
	#CONSOLE_FOREGROUND_BRIGHTRED
 0x0C

	)

30 
	#CONSOLE_FOREGROUND_BRIGHTMAGENTA
 0x0D

	)

31 
	#CONSOLE_FOREGROUND_BRIGHTYELLOW
 0x0E

	)

32 
	#CONSOLE_FOREGROUND_BRIGHTWHITE
 0x0F

	)

35 
	#CONSOLE_DEFAULTTEXTCOLOR
 ( 
CONSOLE_BACKGROUND_BLACK
 | \

36 
CONSOLE_FOREGROUND_BRIGHTBLUE
 )

	)

39 
	#CONSOLE_WIDTH
 80

	)

40 
	#CONSOLE_HEIGHT
 25

	)

41 
	#CONSOLE_VIDEOMEMORYADDRESS
 0xB8000

	)

44 
	#VGA_PORT_INDEX
 0x3D4

	)

45 
	#VGA_PORT_DATA
 0x3D5

	)

46 
	#VGA_INDEX_UPPERCURSOR
 0x0E

	)

47 
	#VGA_INDEX_LOWERCURSOR
 0x0F

	)

51 #agm
ck

push
, 1 )

54 
	skCseMagSu


57 
	miCutPrtOfft
;

58 } 
	tCONSOLEMANAGER
;

60 #agm
ck

p
 )

63 
kInlizeCse
(
iX
,
iY
);

64 
kSCurs

iX
, 
iY
 );

65 
kGCurs
*
piX
, *
piY
 );

66 
kPrtf
cڡ * 
pcFmSg
, ... );

67 
kCsePrtSg
cڡ * 
pcBufr
 );

68 
kCˬSn
( );

69 
BYTE
 
kGCh
( );

70 
kPrtSgXY

iX
, 
iY
, cڡ * 
pcSg
 );

	@/home/jk/os/MINT64/02.Kernel64/Source/ConsoleShell.c

1 
	~"CseShl.h
"

2 
	~"Cse.h
"

3 
	~"Keybrd.h
"

4 
	~"Uty.h
"

5 
	~"PIT.h
"

6 
	~"RTC.h
"

7 
	~"AsmblyUty.h
"

8 
	~"Task.h
"

9 
	~"Synchrizi.h
"

10 
	~"DymicMemy.h
"

11 
	~"HdDisk.h
"

12 
	~"FeSyem.h
"

15 
MUTEX
 
	ggs_Mux
;

16 vީ
QWORD
 
	ggs_qwAdd
;

20 
kHp
(cڡ * 
pcPamBufr
);

21 
kCls
(cڡ * 
pcPamBufr
);

22 
kShowTٮRAMSize
(cڡ * 
pcPamBufr
);

23 
kSgToDecimHexText
(cڡ * 
pcPamBufr
);

24 
kShutdown
(cڡ * 
pcPamBufr
);

25 
kSTim
(cڡ * 
pcPamBufr
);

26 
kWaUsgPIT
(cڡ * 
pcPamBufr
);

27 
kRdTimeSmpCou
(cڡ * 
pcPamBufr
);

28 
kMsurPssSed
(cڡ * 
pcPamBufr
);

29 
kShowDeAndTime
(cڡ * 
pcPamBufr
);

30 
kCeTeTask
(cڡ * 
pcPamBufr
);

31 
kChgeTaskPriܙy
(cڡ * 
pcPamBufr
);

32 
kShowTaskLi
(cڡ * 
pcPamBufr
);

33 
kKlTask
(cڡ * 
pcPamBufr
);

34 
kCPULd
(cڡ * 
pcPamBufr
);

35 
kTeMux
(cڡ * 
pcPamBufr
);

36 
kTeThad
(cڡ * 
pcPamBufr
);

37 
kShowMrix
(cڡ * 
pcPamBufr
);

38 
kTePIE
(cڡ * 
pcPamBufr
);

39 
kTeSequtlAoti
(cڡ * 
pcPamBufr
);

40 
kTeRdomAoti
(cڡ * 
pcPamBufr
);

41 
kShowDymicMemyInfmi
(cڡ * 
pcPamBufr
);

42 
kShowHDDInfmi
(cڡ * 
pcPamBufr
);

43 
kRdSe
(cڡ * 
pcPamBufr
);

44 
kWreSe
(cڡ * 
pcPamBufr
);

45 
kMouHDD
(cڡ * 
pcPamBufr
);

46 
kFmHDD
(cڡ * 
pcPamBufr
);

47 
kShowFeSyemInfmi
(cڡ * 
pcPamBufr
);

48 
kCeFeInRoDey
(cڡ * 
pcPamBufr
);

49 
kDeFeInRoDey
(cڡ * 
pcPamBufr
);

50 
kShowRoDey
(cڡ * 
pcPamBufr
);

51 
kWreDaToFe
(cڡ * 
pcPamBufr
);

52 
kRdDaFromFe
(cڡ * 
pcPamBufr
);

53 
kTeFeIO
(cڡ * 
pcPamBufr
);

56 
kTeTask1
();

57 
kTeTask2
();

58 
kPrtNumbTask
();

59 
kCeThadTask
();

60 
QWORD
 
kRdom
();

61 
kDrChaThad
();

62 
kMrixPross
();

63 
kFPUTeTask
();

64 
kRdomAotiTask
();

67 
SHELLCOMMANDENTRY
 
	ggs_vCommdTab
[] =

69 {"hp","Show Hp",
kHp
},

70 {"s","Cˬ Sn",
kCls
},

71 {"tٮm","Show TٮRAM Size",
kShowTٮRAMSize
},

72 {"od","SgDecim/Hex cvt,x衹od 1000(decim衹od 0x10(hex)",
kSgToDecimHexText
},

73 {"shutdown","ShutdowAnd Rebo OS",
kShutdown
},

74 {"im","S PIT Cڌ˸Cou0,x)im 10(ms1Քiodiue(1)/l(0))",
kSTim
},

75 {"wa","Wa mUsg PIT,x)wa 100(ms)",
kWaUsgPIT
},

76 {"rdtsc","Rd TimSmCou",
kRdTimeSmpCou
},

77 {"ud","Msu Pross Sed",
kMsurPssSed
},

78 {"de","Show Dd Time",
kShowDeAndTime
},

79 {"sk","CTaskx)sk 1y10(cou)",
kCeTeTask
},

80 {"chgriܙy","ChgTask Priܙy,x)chgriܙy 1(ID2(Priܙy)",
kChgeTaskPriܙy
},

81 {"skli","Show Task Li",
kShowTaskLi
},

82 {"kask","End Task,x)kask 1(ID 0xffffffff(A Task)",
kKlTask
},

83 {"uld","Show Pross Ld",
kCPULd
},

84 {"mux","Te Mux Funi",
kTeMux
},

85 {"thad","Te Thad And ProsFuni",
kTeThad
},

86 {"showmrix","Show Mrix Sn",
kShowMrix
},

87 {"p","Te PIE Ccuti",
kTePIE
},

88 {"dymicmemfo","Show DymiMemy Infmi",
kShowDymicMemyInfmi
},

89 {"qloc","Te SequtAoti & Fe",
kTeSequtlAoti
},

90 {"oc","Te Rdom Aoti & Fe",
kTeRdomAoti
},

91 {"hddfo","Show HDD Infmi",
kShowHDDInfmi
},

92 {"ad","Rd HDD Se܃xd 0(LBA10(cou)",
kRdSe
},

93 {"wre","WrHDD Se܃x)wre 0(LBA10(cou)",
kWreSe
},

94 {"mouhdd","Mou HDD",
kMouHDD
},

95 {"fmhdd","Fm HDD",
kFmHDD
},

96 {"fesyemfo","Show FSyem Infmi",
kShowFeSyemInfmi
},

97 {"fe","CFe,x)fa.txt",
kCeFeInRoDey
},

98 {"defe","DFe,x)defa.txt",
kDeFeInRoDey
},

99 {"d","Show Dey",
kShowRoDey
},

100 {"wrefe","WrDTFe,x)wrefa.txt",
kWreDaToFe
},

101 {"adfe","Rd DFrom Fe,xdfa.txt",
kRdDaFromFe
},

102 {"feio","Te FI/O Funi",
kTeFeIO
},

106 vީ
QWORD
 
	ggs_qwRdomVue
 = 0;

110 
	$kSCseShl
()

112 
vcCommBufr
[
CONSOLESHELL_MAXCOMMANDBUFFERCOUNT
];

113 
iCommBufrIndex
=0;

114 
BYTE
 
bKey
;

115 
iCursX
, 
iCursY
;

118 
	`kPrtf
(
CONSOLESHELL_PROMPRTMESSAGE
);

123 
bKey
=
	`kGCh
();

125 if(
bKey
==
KEY_BACKSPACE
)

127 if(
iCommBufrIndex
>0)

130 
	`kGCurs
(&
iCursX
,&
iCursY
);

131 
	`kPrtSgXY
(
iCursX
-1,
iCursY
," ");

132 
	`kSCurs
(
iCursX
-1,
iCursY
);

133 
iCommBufrIndex
--;

137 if(
bKey
 =
KEY_ENTER
)

139 
	`kPrtf
("\n");

141 if(
iCommBufrIndex
>0)

144 
vcCommBufr
[
iCommBufrIndex
]='\0';

145 
	`kExecuCommd
(
vcCommBufr
);

149 
	`kPrtf
("%s",
CONSOLESHELL_PROMPRTMESSAGE
);

150 
	`kMemS
(
vcCommBufr
,'\0',
CONSOLESHELL_MAXCOMMANDBUFFERCOUNT
);

151 
iCommBufrIndex
=0;

154 if((
bKey
==
KEY_LSHIFT
)||(bKey==
KEY_RSHIFT
)||(bKey==
KEY_CAPSLOCK
)||(bKey==
KEY_NUMLOCK
)||(bKey==
KEY_SCROLLLOCK
))

161 if(
bKey
==
KEY_TAB
)

163 
bKey
=' ';

167 if(
iCommBufrIndex
<
CONSOLESHELL_MAXCOMMANDBUFFERCOUNT
)

169 
vcCommBufr
[
iCommBufrIndex
++]=
bKey
;

170 
	`kPrtf
("%c",
bKey
);

174 
	}
}

177 
	$kExecuCommd
(cڡ * 
pcCommdBufr
)

179 
i
, 
iSIndex
;

180 
iCommdBufrLgth
,
iCommdLgth
;

181 
iCou
;

184 
iCommdBufrLgth
=
	`kSL
(
pcCommdBufr
);

185 
iSIndex
=0;iSIndex<
iCommdBufrLgth
;iSpaceIndex++)

187 if(
pcCommdBufr
[
iSIndex
]==' ')

194 
iCou
=(
gs_vCommdTab
)/(
SHELLCOMMANDENTRY
);

196 
i
=0;i<
iCou
;i++)

198 
iCommdLgth
=
	`kSL
(
gs_vCommdTab
[
i
].
pcCommd
);

200 if((
iCommdLgth
==
iSIndex
)&&(
	`kMemCmp
(
gs_vCommdTab
[
i
].
pcCommd
,
pcCommdBufr
,iSpaceIndex)==0))

203 
gs_vCommdTab
[
i
].
	`pfFuni
(
pcCommdBufr
+
iSIndex
+1);

209 if(
i
>=
iCou
)

211 
	`kPrtf
("'%s',in found.\n",
pcCommdBufr
);

213 
	}
}

216 
	$kInlizePam
(
PARAMETERLIST
* 
pLi
,cڡ * 
pcPam
)

218 
pLi
->
pcBufr
=
pcPam
;

219 
pLi
->
iLgth
=
	`kSL
(
pcPam
);

220 
pLi
->
iCutPosi
=0;

221 
	}
}

224 
	$kGNextPam
(
PARAMETERLIST
* 
pLi
,* 
pcPam
)

226 
i
;

227 
iLgth
;

230 if(
pLi
->
iLgth
<Li->
iCutPosi
)

236 
i
=
pLi
->
iCutPosi
;i<pLi->
iLgth
;i++)

238 if(
pLi
->
pcBufr
[
i
]==' ')

245 
	`kMemCpy
(
pcPam
,
pLi
->
pcBufr
+pLi->
iCutPosi
,
i
);

246 
iLgth
=
i
-
pLi
->
iCutPosi
;

247 
pcPam
[
iLgth
]='\0';

250 
pLi
->
iCutPosi
+=
iLgth
+1;

251  
iLgth
;

252 
	}
}

256 
	$kHp
(cڡ * 
pcPamBufr
)

258 
i
;

259 
iCou
;

260 
iCursX
,
iCursY
;

261 
iLgth
,
iMaxcommdLgth
=0;

263 
	`kPrtf
("========================================================================\n");

264 
	`kPrtf
(" jk64 Shell Help \n");

265 
	`kPrtf
("========================================================================\n");

267 
iCou
=(
gs_vCommdTab
)/(
SHELLCOMMANDENTRY
);

270 
i
=0;i<
iCou
;i++)

272 
iLgth
=
	`kSL
(
gs_vCommdTab
[
i
].
pcCommd
);

273 if(
iLgth
>
iMaxcommdLgth
)

275 
iMaxcommdLgth
=
iLgth
;

280 
i
=0;i<
iCou
;i++)

282 
	`kPrtf
("%s",
gs_vCommdTab
[
i
].
pcCommd
);

283 
	`kGCurs
(&
iCursX
,&
iCursY
);

284 
	`kSCurs
(
iMaxcommdLgth
,
iCursY
);

285 
	`kPrtf
(" - %s\n",
gs_vCommdTab
[
i
].
pcHp
);

288 if((
i
!=0)&&((i%20)==0))

290 
	`kPrtf
("Preeny Keyo continue... ('q' isxit) :");

291 if(
	`kGCh
()=='q')

293 
	`kPrtf
("\n");

296 
	`kPrtf
("\n");

299 
	}
}

302 
	$kCls
(cڡ * 
pcPamBufr
)

305 
	`kCˬSn
();

306 
	`kSCurs
(0,1);

307 
	}
}

310 
	$kShowTٮRAMSize
(cڡ * 
pcPamBufr
)

312 
	`kPrtf
("Tٮ RAM Size=%d MB\n",
	`kGTٮRAMSize
());

313 
	}
}

316 
	$kSgToDecimHexText
(cڡ * 
pcPamBufr
)

318 
vcPam
[100];

319 
iLgth
;

320 
PARAMETERLIST
 
Li
;

321 
iCou
=0;

322 
iVue
;

325 
	`kInlizePam
(&
Li
,
pcPamBufr
);

330 
iLgth
=
	`kGNextPam
(&
Li
,
vcPam
);

331 if(
iLgth
==0)

337 
	`kPrtf
("Pam %d = '%s', Lgth = %d, ",
iCou
+1,
vcPam
,
iLgth
);

340 if(
	`kMemCmp
(
vcPam
,"0x",2)==0)

343 
iVue
=
	`kAToI
(
vcPam
+2,16);

344 
	`kPrtf
("HEX vu%q\n",
iVue
);

348 
iVue
=
	`kAToI
(
vcPam
,10);

349 
	`kPrtf
("Decim vu%d\n",
iVue
);

352 
iCou
++;

354 
	}
}

357 
	$kShutdown
(cڡ * 
pcPamBufr
)

359 
	`kPrtf
("System Shutdown Start...\n");

362 
	`kPrtf
("Press Any Keyo Reboot PC...");

363 
	`kGCh
();

364 
	`kRebo
();

365 
	}
}

368 
	$kSTim
(cڡ * 
pcPamBufr
)

370 
vcPam
[100];

371 
PARAMETERLIST
 
Li
;

372 
lVue
;

373 
BOOL
 
bPiodic
;

376 
	`kInlizePam
(&
Li
,
pcPamBufr
);

379 if(
	`kGNextPam
(&
Li
,
vcPam
)==0)

381 
	`kPrtf
("ex)settimer 10(ms) 1(periodic)\n");

384 
lVue
=
	`kAToI
(
vcPam
,10);

387 if(
	`kGNextPam
(&
Li
,
vcPam
)==0)

389 
	`kPrtf
("ex)settimer 10(ms) 1(periodic)\n");

393 
bPiodic
 = 
	`kAToI
(
vcPam
,10);

395 
	`kInlizePIT
(
	`MSTOCOUNT
(
lVue
),
bPiodic
);

396 
	`kPrtf
("Tim%d ms, Piodi%d ChgCome\n",
lVue
,
bPiodic
);

397 
	}
}

400 
	$kWaUsgPIT
(cڡ * 
pcPamBufr
)

402 
vcPam
[100];

403 
iLgth
;

404 
PARAMETERLIST
 
Li
;

405 
lMicd
;

406 
i
;

409 
	`kInlizePam
(&
Li
,
pcPamBufr
);

410 if(
	`kGNextPam
(&
Li
,
vcPam
)==0)

412 
	`kPrtf
("ex)wait 100(ms)\n");

416 
lMicd
 = 
	`kAToI
(
vcPam
,10);

417 
	`kPrtf
("%d mS˕ S...\n",
lMicd
);

420 
	`kDibIru
();

421 
i
=0;i<
lMicd
/30;i++)

423 
	`kWaUsgDePIT
(
	`MSTOCOUNT
(30));

425 
	`kWaUsgDePIT
(
	`MSTOCOUNT
(
lMicd
%30));

426 
	`kEbIru
();

427 
	`kPrtf
("%d mS˕ Come\n",
lMicd
);

430 
	`kInlizePIT
(
	`MSTOCOUNT
(1),
TRUE
);

431 
	}
}

434 
	$kRdTimeSmpCou
(cڡ * 
pcPamBufr
)

436 
QWORD
 
qwTSC
;

438 
qwTSC
 = 
	`kRdTSC
();

439 
	`kPrtf
("TimSmCou = %q\n",
qwTSC
);

440 
	}
}

443 
	$kMsurPssSed
(cڡ * 
pcPamBufr
)

445 
i
;

446 
QWORD
 
qwLaTSC
, 
qwTٮTSC
=0;

448 
	`kPrtf
("Now Measuring");

451 
	`kDibIru
();

452 
i
=0;i<200;i++)

454 
qwLaTSC
=
	`kRdTSC
();

455 
	`kWaUsgDePIT
(
	`MSTOCOUNT
(50));

456 
qwTٮTSC
+=
	`kRdTSC
()-
qwLaTSC
;

458 
	`kPrtf
(".");

462 
	`kInlizePIT
(
	`MSTOCOUNT
(1),
TRUE
);

463 
	`kEbIru
();

465 
	`kPrtf
("\nCPU Sed = %d MHz\n",
qwTٮTSC
/10/1000/1000);

466 
	}
}

469 
	$kShowDeAndTime
(cڡ * 
pcPamBufr
)

471 
BYTE
 
bSecd
, 
bMu
,
bHour
;

472 
BYTE
 
bDayOFWk
,
bDayOfMth
,
bMth
;

473 
WORD
 
wYr
;

476 
	`kRdRTCTime
(&
bHour
,&
bMu
,&
bSecd
);

477 
	`kRdRTCDa
(&
wYr
,&
bMth
,&
bDayOfMth
,&
bDayOFWk
);

479 
	`kPrtf
("D: %d/%d/%d %s",
wYr
,
bMth
,
bDayOfMth
,
	`kCvtDayOfWkToSg
(
bDayOFWk
));

480 
	`kPrtf
("Tim: %d:%d:%d\n",
bHour
,
bMu
,
bSecd
);

481 
	}
}

486 
	$kTeTask1
()

488 
BYTE
 
bDa
;

489 
i
=0,
iX
=0,
iY
=0,
iMg
,
j
;

490 
CHARACTER
* 
pSn
 = (CHARACTER*
CONSOLE_VIDEOMEMORYADDRESS
;

491 
TCB
* 
pRugTask
;

495 
pRugTask
 = 
	`kGRugTask
();

496 
iMg
 = (
pRugTask
->
Lk
.
qwID
&0xFFFFFFFF)%10+1;

499 
j
=0;j<20000;j++)

501 
i
)

504 
iX
++;

505 if(
iX
>=(
CONSOLE_WIDTH
-
iMg
))

507 
i
=1;

512 
iY
++;

513 if(
iY
>=(
CONSOLE_HEIGHT
-
iMg
))

515 
i
=2;

520 
iX
--;

521 if(
iX
<
iMg
)

523 
i
=3;

528 
iY
--;

529 if(
iY
<
iMg
)

531 
i
=0;

538 
pSn
[
iY
*
CONSOLE_WIDTH
+
iX
].
bCha
=
bDa
;

539 
pSn
[
iY
*
CONSOLE_WIDTH
+
iX
].
bAribu
=
bDa
&0x0F;

540 
bDa
++;

547 
	`kExTask
();

549 
	}
}

553 
	$kTeTask2
()

555 
i
=0,
iOfft
;

556 
CHARACTER
* 
pSn
 = (CHARACTER*)
CONSOLE_VIDEOMEMORYADDRESS
;

557 
TCB
* 
pRugTask
;

558 
vcDa
[4]={'-','\\','|','/'};

561 
pRugTask
 = 
	`kGRugTask
();

562 
iOfft
 = (
pRugTask
->
Lk
.
qwID
&0xFFFFFFFF)*2;

563 
iOfft
 = 
CONSOLE_WIDTH
*
CONSOLE_HEIGHT
-(iOffset%(CONSOLE_WIDTH*CONSOLE_HEIGHT));

568 
pSn
[
iOfft
].
bCha
 = 
vcDa
[
i
%4];

570 
pSn
[
iOfft
].
bAribu
 = (iOffset%15)+1;

571 
i
++;

576 
	}
}

579 
	$kCeTeTask
(cڡ * 
pcPamBufr
)

581 
PARAMETERLIST
 
Li
;

582 
vcTy
[30];

583 
vcCou
[30];

584 
i
;

587 
	`kInlizePam
(&
Li
,
pcPamBufr
);

588 
	`kGNextPam
(&
Li
,
vcTy
);

589 
	`kGNextPam
(&
Li
,
vcCou
);

591 
	`kAToI
(
vcTy
,10))

595 
i
=0;i<
	`kAToI
(
vcCou
,10);i++)

597 if(
	`kCeTask
(
TASK_FLAGS_LOW
|
TASK_FLAGS_THREAD
,0,0,(
QWORD
)
kTeTask1
)==
NULL
)

603 
	`kPrtf
("Task1 %d Ced\n",
i
);

608 
i
=0;i<
	`kAToI
(
vcCou
,10);i++)

610 if(
	`kCeTask
(
TASK_FLAGS_LOW
|
TASK_FLAGS_THREAD
,0,0,(
QWORD
)
kTeTask2
)==
NULL
)

616 
	`kPrtf
("Task2 %d ced\n",
i
);

620 
	}
}

623 
	$kChgeTaskPriܙy
(cڡ * 
pcPamBufr
)

625 
PARAMETERLIST
 
Li
;

626 
vcID
[30];

627 
vcPriܙy
[30];

628 
QWORD
 
qwID
;

629 
BYTE
 
bPriܙy
;

632 
	`kInlizePam
(&
Li
,
pcPamBufr
);

633 
	`kGNextPam
(&
Li
,
vcID
);

634 
	`kGNextPam
(&
Li
,
vcPriܙy
);

637 if(
	`kMemCmp
(
vcID
,"0x",2)==0)

639 
qwID
 = 
	`kAToI
(
vcID
+2,16);

643 
qwID
 = 
	`kAToI
(
vcID
,10);

646 
bPriܙy
 = 
	`kAToI
(
vcPriܙy
,10);

648 
	`kPrtf
("ChgTask Priܙy ID [0x%q] Priܙy[%d]",
qwID
,
bPriܙy
);

649 if(
	`kChgePriܙy
(
qwID
,
bPriܙy
)==
TRUE
)

651 
	`kPrtf
("Success\n");

655 
	`kPrtf
("Fail\n");

657 
	}
}

660 
	$kShowTaskLi
(cڡ * 
pcPamBufr
)

662 
i
;

663 
TCB
* 
pTCB
;

664 
iCou
=0;

666 
	`kPrtf
("============Task Tٮ Cou [%d] ===========\n",
	`kGTaskCou
());

667 
i
=0;i<
TASK_MAXCOUNT
;i++)

670 
pTCB
 = 
	`kGTCBInTCBPo
(
i
);

671 if((
pTCB
->
Lk
.
qwID
>>32)!=0)

674 if((
iCou
!=0)&&((iCount%10)==0))

676 
	`kPrtf
("Pressny keyo continue... ('q' isxit) : ");

677 if(
	`kGCh
()=='q')

679 
	`kPrtf
("\n");

682 
	`kPrtf
("\n");

685 
	`kPrtf
("[%d] Task ID[0x%Q], Priܙy[%d], Fgs[0x%Q], Thad[%d]\n",1+
iCou
++,
pTCB
->
Lk
.
qwID
,
	`GETPRIORITY
աTCB->
qwFgs
),pTCB->qwFgs,
	`kGLiCou
(&աTCB->
ChdThadLi
)));

686 
	`kPrtf
(" PPID[0x%Q], Memy Addss[0x%Q], Size[0x%Q]\n",
pTCB
->
qwPtProssID
,pTCB->
pvMemyAddss
,pTCB->
qwMemySize
);

691 
	}
}

694 
	$kKlTask
(cڡ * 
pcPamBufr
)

696 
PARAMETERLIST
 
Li
;

697 
vcID
[30];

698 
QWORD
 
qwID
;

699 
TCB
* 
pTCB
;

700 
i
;

703 
	`kInlizePam
(&
Li
,
pcPamBufr
);

704 
	`kGNextPam
(&
Li
,
vcID
);

707 if(
	`kMemCmp
(
vcID
,"0x",2)==0)

709 
qwID
 = 
	`kAToI
(
vcID
+2,16);

713 
qwID
 = 
	`kAToI
(
vcID
,10);

717 if(
qwID
!=0xFFFFFFFF)

719 
pTCB
 = 
	`kGTCBInTCBPo
(
	`GETTCBOFFSET
(
qwID
));

720 
qwID
 = 
pTCB
->
Lk
.qwID;

723 if(((
qwID
>>32)!=0)&&((
pTCB
->
qwFgs
&
TASK_FLAGS_SYSTEM
)==0x00))

725 
	`kPrtf
("KTask ID [0x%q]",
qwID
);

726 if(
	`kEndTask
(
qwID
)==
TRUE
)

728 
	`kPrtf
("Success\n");

732 
	`kPrtf
("Fail\n");

737 
	`kPrtf
("Task doesotxist orask is systemask\n");

744 
i
=0;i<
TASK_MAXCOUNT
;i++)

746 
pTCB
 = 
	`kGTCBInTCBPo
(
i
);

747 
qwID
 = 
pTCB
->
Lk
.qwID;

750 if(((
qwID
>>32)!=0)&&((
pTCB
->
qwFgs
&
TASK_FLAGS_SYSTEM
)==0x00))

752 
	`kPrtf
("KTask ID [0x%q]",
qwID
);

753 if(
	`kEndTask
(
qwID
)==
TRUE
)

755 
	`kPrtf
("Success\n");

759 
	`kPrtf
("Fail\n");

764 
	}
}

767 
	$kCPULd
(cڡ * 
pcPamBufr
)

769 
	`kPrtf
("Pross Ld : %d%%\n",
	`kGProssLd
());

771 
	}
}

775 
	$kPrtNumbTask
()

777 
i
;

778 
j
;

779 
QWORD
 
qwTickCou
;

783 
qwTickCou
 = 
	`kGTickCou
();

784 (
	`kGTickCou
()-
qwTickCou
)<50)

786 
	`kSchedu
();

790 
i
=0;i<5;i++)

792 
	`kLock
(&(
gs_Mux
));

793 
	`kPrtf
("Task ID [0x%Q] Vue[%d]\n",
	`kGRugTask
()->
Lk
.
qwID
,
gs_qwAdd
);

794 
gs_qwAdd
+=1;

795 
	`kUock
(&(
gs_Mux
));

798 
j
=0;j<30000;j++);

802 
qwTickCou
 = 
	`kGTickCou
();

803 (
	`kGTickCou
()-
qwTickCou
)<1000)

805 
	`kSchedu
();

809 
	`kExTask
();

810 
	}
}

813 
	$kTeMux
(cڡ * 
pcPamBufr
)

815 
i
;

817 
gs_qwAdd
=1;

820 
	`kInlizeMux
(&(
gs_Mux
));

822 
i
=0;i<3;i++)

825 
	`kCeTask
(
TASK_FLAGS_LOW
|
TASK_FLAGS_THREAD
,0,0,(
QWORD
)
kPrtNumbTask
);

827 
	`kPrtf
("Wa Ut %d Task End...\n",
i
);

828 
	`kGCh
();

829 
	}
}

832 
	$kCeThadTask
()

834 
i
;

836 
i
=0;i<3;i++)

838 
	`kCeTask
(
TASK_FLAGS_LOW
|
TASK_FLAGS_THREAD
,0,0,(
QWORD
)
kTeTask2
);

843 
	`kS˕
(1);

845 
	}
}

848 
	$kTeThad
(cڡ * 
pcPamBufr
)

850 
TCB
* 
pPross
;

852 
pPross
 = 
	`kCeTask
(
TASK_FLAGS_LOW
|
TASK_FLAGS_PROCESS
,(*)0xEEEEEEEE,0x1000,(
QWORD
)
kCeThadTask
);

854 if(
pPross
!=
NULL
)

856 
	`kPrtf
("Pros[0x%Q] CSucss\n",
pPross
->
Lk
.
qwID
);

860 
	`kPrtf
("Process Create Fail\n");

862 
	}
}

865 
QWORD
 
	$kRdom
()

867 
gs_qwRdomVue
 = (gs_qwRandomValue*412153 + 5571031)>>16;

868  
gs_qwRdomVue
;

869 
	}
}

872 
	$kDrChaThad
()

874 
iX
;

875 
i
;

876 
vcText
[2] = {0,};

878 
iX
 = 
	`kRdom
()%
CONSOLE_WIDTH
;

883 
	`kS˕
(
	`kRdom
()%20);

885 if((
	`kRdom
()%20)<15)

887 
vcText
[0]=' ';

888 
i
=0;i<
CONSOLE_HEIGHT
-1;i++)

890 
	`kPrtSgXY
(
iX
,
i
,
vcText
);

891 
	`kS˕
(50);

896 
i
=0;i<
CONSOLE_HEIGHT
-1;i++)

898 
vcText
[0]=
i
+
	`kRdom
();

899 
	`kPrtSgXY
(
iX
,
i
,
vcText
);

900 
	`kS˕
(50);

904 
	}
}

907 
	$kMrixPross
()

909 
i
;

911 
i
=0;i<300;i++)

913 if(
	`kCeTask
(
TASK_FLAGS_THREAD
|
TASK_FLAGS_LOW
,0,0,(
QWORD
)
kDrChaThad
)==
NULL
)

918 
	`kS˕
(
	`kRdom
()%5+5);

921 
	`kPrtf
("%d Thad id\n",
i
);

924 
	`kGCh
();

925 
	}
}

928 
	$kShowMrix
(cڡ * 
pcPamBufr
)

930 
TCB
* 
pPross
;

932 
pPross
 = 
	`kCeTask
(
TASK_FLAGS_PROCESS
|
TASK_FLAGS_LOW
,(*)0xE00000,0xE00000,(
QWORD
)
kMrixPross
);

934 if(
pPross
!=
NULL
)

936 
	`kPrtf
("Mrix Pros[0x%Q] CeSucss\n",
pPross
->
Lk
.
qwID
);

939 (
pPross
->
Lk
.
qwID
>>32)!=0)

941 
	`kS˕
(100);

946 
	`kPrtf
("Matrix Process Create Fail\n");

948 
	}
}

950 
	$kFPUTeTask
()

952 
dVue1
;

953 
dVue2
;

954 
TCB
* 
pRugTask
;

955 
QWORD
 
qwCou
=0;

956 
QWORD
 
qwRdomVue
;

957 
i
;

958 
iOfft
;

959 
vcDa
[4]={'-','\\','|','/'};

960 
CHARACTER
* 
pSn
 = (CHARACTER*)
CONSOLE_VIDEOMEMORYADDRESS
;

962 
pRugTask
 = 
	`kGRugTask
();

965 
iOfft
 = (
pRugTask
->
Lk
.
qwID
&0xFFFFFFFF)*2;

966 
iOfft
 = 
CONSOLE_WIDTH
*
CONSOLE_HEIGHT
-(iOffset%(CONSOLE_WIDTH*CONSOLE_HEIGHT));

971 
dVue1
=1;

972 
dVue2
=1;

975 
i
=0;i<10;i++)

977 
qwRdomVue
 = 
	`kRdom
();

978 
dVue1
*=()
qwRdomVue
;

979 
dVue2
*=()
qwRdomVue
;

981 
	`kS˕
(1);

983 
qwRdomVue
=
	`kRdom
();

984 
dVue1
/=()
qwRdomVue
;

985 
dVue2
/=()
qwRdomVue
;

988 if(
dVue1
!=
dVue2
)

990 
	`kPrtf
("Vuin same~!!! [%f] ![%f]\n",
dVue1
,
dVue2
);

994 
qwCou
++;

997 
pSn
[
iOfft
].
bCha
 = 
vcDa
[
qwCou
%4];

1000 
pSn
[
iOfft
].
bAribu
 = (iOffset%15)+1;

1002 
	}
}

1005 
	$kTePIE
(cڡ * 
pcPamBufr
)

1007 
dResu
;

1008 
i
;

1010 
	`kPrtf
("PIE Calculation Test\n");

1011 
	`kPrtf
("Result:355/133=");

1012 
dResu
 =()355/133;

1013 
	`kPrtf
("%d%d%d\n",(
QWORD
)
dResu
,((QWORD)(dResult*10)%10),((QWORD)(dResult*100)%10));

1016 
i
=0;i<100;i++)

1018 
	`kCeTask
(
TASK_FLAGS_LOW
|
TASK_FLAGS_THREAD
,0,0,(
QWORD
)
kFPUTeTask
);

1020 
	}
}

1023 
	$kShowDymicMemyInfmi
(cڡ * 
pcPamBufr
)

1025 
QWORD
 
qwSAddss
,
qwTٮSize
,
qwMaSize
,
qwUdSize
;

1027 
	`kGDymicMemyInfmi
(&
qwSAddss
,&
qwTٮSize
,&
qwMaSize
,&
qwUdSize
);

1029 
	`kPrtf
("================ Dynamic Memory Information =============\n");

1030 
	`kPrtf
("S Adds: [0x%Q]\n",
qwSAddss
);

1031 
	`kPrtf
("Tٮ Siz: [0x%Q]by, [%d]MB\n",
qwTٮSize
,qwTotalSize/1024/1024);

1032 
	`kPrtf
("MSize: [0x%Q]by, [%d]KB\n",
qwMaSize
,qwMetaSize/1024);

1033 
	`kPrtf
("Ud Size: [0x%Q]by, [%d]KB\n",
qwUdSize
,qwUsedSize/1024);

1034 
	}
}

1037 
	$kTeSequtlAoti
(cڡ * 
pcPamBufr
)

1039 
DYNAMICMEMORY
* 
pMemy
;

1040 
i
,
j
,
k
;

1041 
QWORD
* 
pqwBufr
;

1043 
	`kPrtf
("=============== Dynamic Memory Test =================\n");

1044 
pMemy
 = 
	`kGDymicMemyMag
();

1046 
i
=0;i<
pMemy
->
iMaxLevCou
;i++)

1048 
	`kPrtf
("Block Li [%d] Te S\n",
i
);

1049 
	`kPrtf
("Allocation And Compare: ");

1052 
j
=0;j<(
pMemy
->
iBlockCouOfSmˡBlock
>>
i
);j++)

1054 
pqwBufr
 = 
	`kAoMemy
(
DYNAMICMEMORY_MIN_SIZE
<<
i
);

1055 if(
pqwBufr
==
NULL
)

1057 
	`kPrtf
("\nAllocation Fail\n");

1062 
k
=0;k<(
DYNAMICMEMORY_MIN_SIZE
<<
i
)/8;k++)

1064 
pqwBufr
[
k
]=k;

1067 
k
=0;k<(
DYNAMICMEMORY_MIN_SIZE
<<
i
)/8;k++)

1069 if(
pqwBufr
[
k
]!=k)

1071 
	`kPrtf
("\nCompare Fail\n");

1077 
	`kPrtf
(".");

1080 
	`kPrtf
("\nFree: ");

1082 
j
=0;j<(
pMemy
->
iBlockCouOfSmˡBlock
>>
i
);j++)

1084 if(
	`kFeMemy
((*)(
pMemy
->
qwSAddss
+(
DYNAMICMEMORY_MIN_SIZE
<<
i
)*
j
))==
FALSE
)

1086 
	`kPrtf
("\n Free Fail\n");

1091 
	`kPrtf
(".");

1093 
	`kPrtf
("\n");

1095 
	}
}

1098 
	$kRdomAotiTask
()

1100 
TCB
* 
pTask
;

1101 
QWORD
 
qwMemySize
;

1102 
vcBufr
[200];

1103 
BYTE
* 
pbAotiBufr
;

1104 
i
,
j
;

1105 
iY
;

1107 
pTask
 = 
	`kGRugTask
();

1108 
iY
 = (
pTask
->
Lk
.
qwID
)%15+9;

1110 
j
=0;j<10;j++)

1115 
qwMemySize
 = ((
	`kRdom
()%(32*1024))+1)*1024;

1116 
pbAotiBufr
 = 
	`kAoMemy
(
qwMemySize
);

1120 if(
pbAotiBufr
==0)

1122 
	`kS˕
(1);

1124 } 
pbAotiBufr
==0);

1126 
	`kSPrtf
(
vcBufr
,"|Addss: [0x%Q] Size: [0x%Q] Aoti Sucss",
pbAotiBufr
,
qwMemySize
);

1128 
	`kPrtSgXY
(20,
iY
,
vcBufr
);

1129 
	`kS˕
(200);

1132 
	`kSPrtf
(
vcBufr
,"|Addss: [0x%Q] Size: [0x%Q] DWre...",
pbAotiBufr
,
qwMemySize
);

1133 
	`kPrtSgXY
(20,
iY
,
vcBufr
);

1134 
i
=0;i<
qwMemySize
/2;i++)

1136 
pbAotiBufr
[
i
] = 
	`kRdom
()&0xFF;

1137 
pbAotiBufr
[
i
+(
qwMemySize
/2)]=pbAllocationBuffer[i];

1140 
	`kS˕
(200);

1143 
	`kSPrtf
(
vcBufr
,"|Addss: [0x%Q] Size: [0x%Q] DVify...",
pbAotiBufr
,
qwMemySize
);

1144 
	`kPrtSgXY
(20,
iY
,
vcBufr
);

1145 
i
=0;i<
qwMemySize
/2;i++)

1147 if(
pbAotiBufr
[
i
]!bAotiBufr[i+(
qwMemySize
/2)])

1149 
	`kPrtf
("Task ID[0x%Q] Vify Fa\n",
pTask
->
Lk
.
qwID
);

1150 
	`kExTask
();

1153 
	`kFeMemy
(
pbAotiBufr
);

1154 
	`kS˕
(200);

1157 
	`kExTask
();

1158 
	}
}

1161 
	$kTeRdomAoti
(cڡ * 
pcPamBufr
)

1163 
i
;

1165 
i
=0;i<100;i++)

1167 
	`kCeTask
(
TASK_FLAGS_LOWEST
|
TASK_FLAGS_THREAD
,0,0,(
QWORD
)
kRdomAotiTask
);

1169 
	}
}

1172 
	$kShowHDDInfmi
(cڡ * 
pcPamBufr
)

1174 
HDDINFORMATION
 
HDD
;

1175 
vcBufr
[100];

1178 if(
	`kGHDDInfmi
(&
HDD
)==
FALSE
)

1180 
	`kPrtf
("HDD Information Read Fail\n");

1184 
	`kPrtf
("===================== Primary Master HDD Information ====================\n");

1187 
	`kMemCpy
(
vcBufr
,
HDD
.
vwModNumb
,(stHDD.vwModelNumber));

1188 
vcBufr
[(
HDD
.
vwModNumb
)-1]='\0';

1189 
	`kPrtf
("Mod Numb:\%s\n",
vcBufr
);

1192 
	`kMemCpy
(
vcBufr
,
HDD
.
vwSlNumb
,(stHDD.vwSerialNumber));

1193 
vcBufr
[(
HDD
.
vwSlNumb
)-1]='\0';

1194 
	`kPrtf
("SNumb:\%s\n",
vcBufr
);

1197 
	`kPrtf
("Hd Cou:\%d\n",
HDD
.
wNumbOfHd
);

1198 
	`kPrtf
("Cyld Cou:\%d\n",
HDD
.
wNumbOfCyld
);

1199 
	`kPrtf
("Se Cou:\%d\n",
HDD
.
wNumbOfSePCyld
);

1202 
	`kPrtf
("Tٮ Se:\%d Se, %dMB\n",
HDD
.
dwTٮSes
,stHDD.dwTotalSectors/2/1024);

1203 
	}
}

1206 
	$kRdSe
(cڡ * 
pcPamBufr
)

1208 
PARAMETERLIST
 
Li
;

1209 
vcLBA
[50],
vcSeCou
[50];

1210 
DWORD
 
dwLBA
;

1211 
iSeCou
;

1212 * 
pcBufr
;

1213 
i
,
j
;

1214 
BYTE
 
bDa
;

1215 
BOOL
 
bEx
=
FALSE
;

1218 
	`kInlizePam
(&
Li
,
pcPamBufr
);

1219 if((
	`kGNextPam
(&
Li
,
vcLBA
)==0)||(kGNextPam(&Li,
vcSeCou
)==0))

1221 
	`kPrtf
("ex)readsector 0(LBA) 10(count)\n");

1224 
dwLBA
 = 
	`kAToI
(
vcLBA
,10);

1225 
iSeCou
 = 
	`kAToI
(
vcSeCou
,10);

1228 
pcBufr
 = 
	`kAoMemy
(
iSeCou
*512);

1229 if(
	`kRdHDDSe
(
TRUE
,TRUE,
dwLBA
,
iSeCou
,
pcBufr
)==iSectorCount)

1231 
	`kPrtf
("LBA [%d] [%d] Se Rd Sucss~!!",
dwLBA
,
iSeCou
);

1233 
j
=0;j<
iSeCou
;j++)

1235 
i
=0;i<512;i++)

1237 if(!((
j
==0)&&(
i
==0))&&((i%256)==0))

1239 
	`kPrtf
("\nPressny keyo continue... ('q' isxit) : ");

1240 if(
	`kGCh
()=='q')

1242 
bEx
=
TRUE
;

1247 if((
i
%16)==0)

1249 
	`kPrtf
("\n[LBA:%d, Offt:%d]\t| ",
dwLBA
+
j
,
i
);

1253 
bDa
 = 
pcBufr
[
j
*512+
i
]&0xFF;

1254 if(
bDa
<16)

1256 
	`kPrtf
("0");

1258 
	`kPrtf
("%X ",
bDa
);

1261 if(
bEx
==
TRUE
)

1267 
	`kPrtf
("\n");

1271 
	`kPrtf
("Read Fail\n");

1274 
	`kFeMemy
(
pcBufr
);

1275 
	}
}

1278 
	$kWreSe
(cڡ * 
pcPamBufr
)

1280 
PARAMETERLIST
 
Li
;

1281 
vcLBA
[50],
vcSeCou
[50];

1282 
DWORD
 
dwLBA
;

1283 
iSeCou
;

1284 * 
pcBufr
;

1285 
i
,
j
;

1286 
BOOL
 
bEx
=
FALSE
;

1287 
BYTE
 
bDa
;

1288 
DWORD
 
s_dwWreCou
=0;

1291 
	`kInlizePam
(&
Li
,
pcPamBufr
);

1292 if((
	`kGNextPam
(&
Li
,
vcLBA
)==0)||(kGNextPam(&Li,
vcSeCou
)==0))

1294 
	`kPrtf
("ex)writesector 0(LBA) 10(count)\n");

1298 
dwLBA
 = 
	`kAToI
(
vcLBA
,10);

1299 
iSeCou
 = 
	`kAToI
(
vcSeCou
,10);

1301 
s_dwWreCou
++;

1304 
pcBufr
 = 
	`kAoMemy
(
iSeCou
*512);

1305 
j
=0;j<
iSeCou
;j++)

1307 
i
=0;i<512;i+=8)

1309 *(
DWORD
*)&(
pcBufr
[
j
*512+
i
])=
dwLBA
+j;

1310 *(
DWORD
*)&(
pcBufr
[
j
*512+
i
+4])=
s_dwWreCou
;

1315 if(
	`kWreHDDSe
(
TRUE
,TRUE,
dwLBA
,
iSeCou
,
pcBufr
)!=iSectorCount)

1317 
	`kPrtf
("Write Fail\n");

1320 
	`kPrtf
("LBA [%d], [%d] Se WrSucss~!!",
dwLBA
,
iSeCou
);

1323 
j
=0;j<
iSeCou
;j++)

1325 
i
=0;i<512;i++)

1327 if(!((
j
==0)&&(
i
==0))&&((i%256)==0))

1329 
	`kPrtf
("\nPressny keyo continue... ('q' isxit) : ");

1330 if(
	`kGCh
()=='q')

1332 
bEx
=
TRUE
;

1337 if((
i
%16)==0)

1339 
	`kPrtf
("\n[LBA:%d, Offt:%d]\t| ",
dwLBA
+
j
,
i
);

1343 
bDa
 = 
pcBufr
[
j
*512+
i
]&0xFF;

1344 if(
bDa
<16)

1346 
	`kPrtf
("0");

1348 
	`kPrtf
("%X ",
bDa
);

1351 if(
bEx
==
TRUE
)

1357 
	`kPrtf
("\n");

1358 
	`kFeMemy
(
pcBufr
);

1359 
	}
}

1362 
	$kMouHDD
(cڡ * 
pcPamBufr
)

1364 if(
	`kMou
()==
FALSE
)

1366 
	`kPrtf
("HDD Mount Fail\n");

1369 
	`kPrtf
("Hdd Mount Success\n");

1370 
	}
}

1373 
	$kFmHDD
(cڡ * 
pcPamBufr
)

1375 if(
	`kFm
()==
FALSE
)

1377 
	`kPrtf
("HDD Format Fail\n");

1381 
	`kPrtf
("HDD Format Success\n");

1382 
	}
}

1385 
	$kShowFeSyemInfmi
(cڡ * 
pcPamBufr
)

1387 
FILESYSTEMMANAGER
 
Mag
;

1389 
	`kGFeSyemInfmi
(&
Mag
);

1391 
	`kPrtf
("==================================== File System Information =================================\n");

1392 
	`kPrtf
("Moued:\t\t\t\t\%d\n",
Mag
.
bMoued
);

1393 
	`kPrtf
("Rerved Se Cou:\t\t\%d Se\n",
Mag
.
dwRervedSeCou
);

1394 
	`kPrtf
("Clu Lk Tab S Addss:\%d Se\n",
Mag
.
dwCluLkAaSAddss
);

1395 
	`kPrtf
("Clu Lk Tab Size:\t\%d Se\n",
Mag
.
dwCluLkAaSize
);

1396 
	`kPrtf
("DAS Addss:\t\%d Se\n",
Mag
.
dwDaAaSAddss
);

1397 
	`kPrtf
("Tٮ Clu Cou:\t\t\%d Clu\n",
Mag
.
dwTٮCluCou
);

1398 
	}
}

1401 
	$kCeFeInRoDey
(cڡ * 
pcPamBufr
)

1403 
PARAMETERLIST
 
Li
;

1404 
vcFeName
[50];

1405 
iLgth
;

1406 
DWORD
 
dwClu
;

1407 
DIRECTORYENTRY
 
Ery
;

1408 
i
;

1409 
FILE
* 
pFe
;

1412 
	`kInlizePam
(&
Li
,
pcPamBufr
);

1413 
iLgth
 = 
	`kGNextPam
(&
Li
,
vcFeName
);

1414 
vcFeName
[
iLgth
]='\0';

1415 if((
iLgth
>((
Ery
.
vcFeName
)-1))||(iLength==0))

1417 
	`kPrtf
("Tooong or Too short File Name\n");

1421 
pFe
 = 
	`fݒ
(
vcFeName
,"w");

1422 if(
pFe
==
NULL
)

1424 
	`kPrtf
("File Create Fail\n");

1427 
	`fo
(
pFe
);

1428 
	`kPrtf
("File Create Success\n");

1429 
	}
}

1432 
	$kDeFeInRoDey
(cڡ * 
pcPamBufr
)

1434 
PARAMETERLIST
 
Li
;

1435 
vcFeName
[50];

1436 
iLgth
;

1437 
DIRECTORYENTRY
 
Ery
;

1438 
iOfft
;

1441 
	`kInlizePam
(&
Li
,
pcPamBufr
);

1442 
iLgth
 = 
	`kGNextPam
(&
Li
,
vcFeName
);

1443 
vcFeName
[
iLgth
]='\0';

1445 if((
iLgth
>(
FILESYSTEM_MAXFILENAMELENGTH
-1))||(iLength==0))

1447 
	`kPrtf
("Too Long or Too Short File Name\n");

1451 if(
	`move
(
vcFeName
)!=0)

1453 
	`kPrtf
("File Not Found or File Opened\n");

1457 
	`kPrtf
("File Delete Success\n");

1458 
	}
}

1461 
	$kShowRoDey
(cڡ * 
pcPamBufr
)

1463 
DIR
* 
pDey
;

1464 
i
,
iTٮCou
,
iCou
;

1465 
dt
* 
pEry
;

1466 
vcBufr
[400];

1467 
vcTempVue
[50];

1468 
DWORD
 
dwTٮBy
;

1469 
DWORD
 
dwUdCluCou
;

1470 
FILESYSTEMMANAGER
 
Mag
;

1473 
	`kGFeSyemInfmi
(&
Mag
);

1476 
pDey
 = 
	`ݒd
("/");

1477 if(
pDey
==
NULL
)

1479 
	`kPrtf
("Root Directory Open Fail\n");

1484 
iTٮCou
=0;

1485 
dwTٮBy
=0;

1486 
dwUdCluCou
=0;

1491 
pEry
 = 
	`add
(
pDey
);

1493 if(
pEry
==
NULL
)

1497 
iTٮCou
++;

1498 
dwTٮBy
+=
pEry
->
dwFeSize
;

1501 if(
pEry
->
dwFeSize
==0)

1504 
dwUdCluCou
++;

1509 
dwUdCluCou
 +=(
pEry
->
dwFeSize
+
FILESYSTEM_CLUSTERSIZE
-1)/FILESYSTEM_CLUSTERSIZE;

1514 
	`wdd
(
pDey
);

1515 
iCou
=0;

1519 
pEry
 = 
	`add
(
pDey
);

1521 if(
pEry
==
NULL
)

1527 
	`kMemS
(
vcBufr
,' ',(vcBuffer)-1);

1528 
vcBufr
[(vcBuffer)-1]='\0';

1531 
	`kMemCpy
(
vcBufr
,
pEry
->
d_me
,
	`kSL
(pstEntry->d_name));

1534 
	`kSPrtf
(
vcTempVue
,"%d By",
pEry
->
dwFeSize
);

1535 
	`kMemCpy
(
vcBufr
+30,
vcTempVue
,
	`kSL
(vcTempValue));

1538 
	`kSPrtf
(
vcBufr
+55,"0x%X Clu",
pEry
->
dwSCluIndex
);

1539 
	`kPrtf
(" %s\n",
vcBufr
);

1541 if((
iCou
!=0)&&((iCount%20)==0))

1543 
	`kPrtf
("Preeny keyo continue... ('q' isxit) : ");

1544 if(
	`kGCh
()=='q')

1546 
	`kPrtf
("\n");

1550 
iCou
++;

1554 
	`kPrtf
("\t\tTٮ FCou: %d\n",
iTٮCou
);

1555 
	`kPrtf
("\t\tTٮ FSize: %d KBy (%d Clu)\n",
dwTٮBy
/1024,
dwUdCluCou
);

1558 
	`kPrtf
("\t\tFS: %d KBy (%d Clu)\n",(
Mag
.
dwTٮCluCou
-
dwUdCluCou
)*
FILESYSTEM_CLUSTERSIZE
/1024,stManager.dwTotalClusterCount-dwUsedClusterCount);

1561 
	`od
(
pDey
);

1562 
	}
}

1565 
	$kWreDaToFe
(cڡ * 
pcPamBufr
)

1567 
PARAMETERLIST
 
Li
;

1568 
vcFeName
[50];

1569 
iLgth
;

1570 
FILE
* 

;

1571 
iECou
;

1572 
BYTE
 
bKey
;

1575 
	`kInlizePam
(&
Li
,
pcPamBufr
);

1576 
iLgth
 = 
	`kGNextPam
(&
Li
,
vcFeName
);

1577 
vcFeName
[
iLgth
]='\0';

1578 if((
iLgth
>(
FILESYSTEM_MAXFILENAMELENGTH
-1))||(iLength==0))

1580 
	`kPrtf
("Too Long or Too Short File Name\n");

1585 

 = 
	`fݒ
(
vcFeName
,"w");

1586 if(

==
NULL
)

1588 
	`kPrtf
("%FOFa\n",
vcFeName
);

1593 
iECou
=0;

1596 
bKey
 = 
	`kGCh
();

1598 if(
bKey
==
KEY_ENTER
)

1600 
iECou
++;

1601 if(
iECou
>=3)

1609 
iECou
=0;

1612 
	`kPrtf
("%c",
bKey
);

1613 if(
	`fwre
(&
bKey
,1,1,

)!=1)

1615 
	`kPrtf
("File Write Fail\n");

1620 
	`kPrtf
("File Create Success\n");

1621 
	`fo
(

);

1622 
	}
}

1625 
	$kRdDaFromFe
(cڡ * 
pcPamBufr
)

1627 
PARAMETERLIST
 
Li
;

1628 
vcFeName
[50];

1629 
iLgth
;

1630 
FILE
* 

;

1631 
iECou
;

1632 
BYTE
 
bKey
;

1635 
	`kInlizePam
(&
Li
,
pcPamBufr
);

1636 
iLgth
 = 
	`kGNextPam
(&
Li
,
vcFeName
);

1637 
vcFeName
[
iLgth
]='\0';

1638 if((
iLgth
>(
FILESYSTEM_MAXFILENAMELENGTH
-1))||(iLength==0))

1640 
	`kPrtf
("Too Long or Too Short File Name\n");

1645 

 = 
	`fݒ
(
vcFeName
,"r");

1646 if(

==
NULL
)

1648 
	`kPrtf
("%FOFa\n",
vcFeName
);

1653 
iECou
=0;

1657 if(
	`d
(&
bKey
,1,1,

)!=1)

1662 
	`kPrtf
("%c",
bKey
);

1665 if(
bKey
==
KEY_ENTER
)

1667 
iECou
++;

1669 if((
iECou
!=0)&&((iEnterCount%20)==0))

1671 
	`kPrtf
("Pressny keto continue... ('q' isxit) :");

1672 if(
	`kGCh
()=='q')

1674 
	`kPrtf
("\n");

1677 
	`kPrtf
("\n");

1678 
iECou
=0;

1683 
	`fo
(

);

1684 
	}
}

1687 
	$kTeFeIO
(cڡ * 
pcPamBufr
)

1689 
FILE
* 
pFe
;

1690 
BYTE
* 
pbBufr
;

1691 
i
;

1692 
j
;

1693 
DWORD
 
dwRdomOfft
;

1694 
DWORD
 
dwByCou
;

1695 
BYTE
 
vbTempBufr
[1024];

1696 
DWORD
 
dwMaxFeSize
;

1698 
	`kPrtf
("============================== File I/O Function Test ===============================\n");

1701 
dwMaxFeSize
 = 4*1024*1024;

1702 
pbBufr
 = 
	`kAoMemy
(
dwMaxFeSize
);

1703 if(
pbBufr
==
NULL
)

1705 
	`kPrtf
("Memory Allocation Fail\n");

1710 
	`move
("testfileio.bin");

1715 
	`kPrtf
("1. File Open Fail Test...");

1717 
pFe
 = 
	`fݒ
("testfileio.bin","r");

1718 if(
pFe
==
NULL
)

1720 
	`kPrtf
("[Pass]\n");

1724 
	`kPrtf
("[Fail]\n");

1725 
	`fo
(
pFe
);

1731 
	`kPrtf
("2. File Create Test...");

1733 
pFe
 = 
	`fݒ
("testfileio.bin","w");

1734 if(
pFe
!=
NULL
)

1736 
	`kPrtf
("[Pass]\n");

1737 
	`kPrtf
(" FHd [0x%Q]\n",
pFe
);

1741 
	`kPrtf
("[Fail]\n");

1747 
	`kPrtf
("3. Sequential Write Test(Cluster Size)...");

1749 
i
=0;i<100;i++)

1751 
	`kMemS
(
pbBufr
,
i
,
FILESYSTEM_CLUSTERSIZE
);

1752 if(
	`fwre
(
pbBufr
,1,
FILESYSTEM_CLUSTERSIZE
,
pFe
)!=FILESYSTEM_CLUSTERSIZE)

1754 
	`kPrtf
("[Fail]\n");

1755 
	`kPrtf
(" %d Clu E\n",
i
);

1761 if(
i
>=100)

1763 
	`kPrtf
("[Pass]\n");

1769 
	`kPrtf
("4. Sequential Read And Verify Test(Cluster Size)...");

1771 
	`fek
(
pFe
,-100*
FILESYSTEM_CLUSTERSIZE
,
SEEK_END
);

1774 
i
=0;i<100;i++)

1777 if(
	`d
(
pbBufr
,1,
FILESYSTEM_CLUSTERSIZE
,
pFe
)!=FILESYSTEM_CLUSTERSIZE)

1779 
	`kPrtf
("[Fail]\n");

1784 
j
=0;j<
FILESYSTEM_CLUSTERSIZE
;j++)

1786 if(
pbBufr
[
j
]!=(
BYTE
)
i
)

1788 
	`kPrtf
("[Fail]\n");

1789 
	`kPrtf
(" %d Clu E. [%X] ![%X]\n",
i
,
pbBufr
[
j
],(
BYTE
)i);

1795 if(
i
>=100)

1797 
	`kPrtf
("[Pass]\n");

1803 
	`kPrtf
("5. Random Write Test...\n");

1806 
	`kMemS
(
pbBufr
,0,
dwMaxFeSize
);

1809 
	`fek
(
pFe
,-100*
FILESYSTEM_CLUSTERSIZE
,
SEEK_CUR
);

1810 
	`d
(
pbBufr
,1,
dwMaxFeSize
,
pFe
);

1813 
i
=0;i<100;i++)

1815 
dwByCou
 = (
	`kRdom
()%((
vbTempBufr
)-1))+1;

1816 
dwRdomOfft
 = 
	`kRdom
()%(
dwMaxFeSize
-
dwByCou
);

1818 
	`kPrtf
(" [%d] Off[%d] By [%d]...",
i
,
dwRdomOfft
,
dwByCou
);

1821 
	`fek
(
pFe
,
dwRdomOfft
,
SEEK_SET
);

1822 
	`kMemS
(
vbTempBufr
,
i
,
dwByCou
);

1825 if(
	`fwre
(
vbTempBufr
,1,
dwByCou
,
pFe
)!=dwByteCount)

1827 
	`kPrtf
("[Fail]\n");

1832 
	`kPrtf
("[Pass]\n");

1835 
	`kMemS
(
pbBufr
+
dwRdomOfft
,
i
,
dwByCou
);

1839 
	`fek
(
pFe
,
dwMaxFeSize
-1,
SEEK_SET
);

1840 
	`fwre
(&
i
,1,1,
pFe
);

1841 
pbBufr
[
dwMaxFeSize
-1]=(
BYTE
)
i
;

1847 
	`kPrtf
("6. Random Read And Verify Test...\n");

1849 
i
=0;i<100;i++)

1851 
dwByCou
 = (
	`kRdom
()%((
vbTempBufr
)-1))+1;

1852 
dwRdomOfft
 = 
	`kRdom
()%((
dwMaxFeSize
)-
dwByCou
);

1854 
	`kPrtf
(" [%d] Off[%d] By [%d]...",
i
,
dwRdomOfft
,
dwByCou
);

1857 
	`fek
(
pFe
,
dwRdomOfft
,
SEEK_SET
);

1860 if(
	`d
(
vbTempBufr
,1,
dwByCou
,
pFe
)!=dwByteCount)

1862 
	`kPrtf
("[Fail]\n");

1863 
	`kPrtf
(" Rd Fa\n",
dwRdomOfft
);

1868 if(
	`kMemCmp
(
pbBufr
+
dwRdomOfft
,
vbTempBufr
,
dwByCou
)!=0)

1870 
	`kPrtf
("[Fail]\n");

1871 
	`kPrtf
(" Com Fa\n",
dwRdomOfft
);

1875 
	`kPrtf
("[Pass]\n");

1881 
	`kPrtf
("7. Sequential Write, Read And Verify Test(1024 Byte)...\n");

1883 
	`fek
(
pFe
,-
dwMaxFeSize
,
SEEK_CUR
);

1886 
i
=0;i<(2*1024*1024/1024);i++)

1888 
	`kPrtf
(" [%d] Off[%d] By [%d] Wre...",
i
,i*1024,1024);

1891 if(
	`fwre
(
pbBufr
+(
i
*1024),1,1024,
pFe
)!=1024)

1893 
	`kPrtf
("[Fail]\n");

1898 
	`kPrtf
("[Pass]\n");

1903 
	`fek
(
pFe
,-
dwMaxFeSize
,
SEEK_SET
);

1907 
i
=0;i<(
dwMaxFeSize
/1024);i++)

1910 
	`kPrtf
(" [%d] Off[%d] By [%d] Rd And Vify...",
i
,i*1024,1024);

1913 if(
	`d
(
vbTempBufr
,1,1024,
pFe
)!=1024)

1915 
	`kPrtf
("[Fail]\n");

1919 if(
	`kMemCmp
(
pbBufr
+(
i
*1024),
vbTempBufr
,1024)!=0)

1921 
	`kPrtf
("[Fail]\n");

1926 
	`kPrtf
("[Pass]\n");

1933 
	`kPrtf
("8. File Delete Fail Test...");

1935 if(
	`move
("testfileio.bin")!=0)

1937 
	`kPrtf
("[Pass]\n");

1941 
	`kPrtf
("[Fail]\n");

1947 
	`kPrtf
("9. File Close Test...");

1949 if(
	`fo
(
pFe
)==0)

1951 
	`kPrtf
("[Pass]\n");

1955 
	`kPrtf
("[Fail]\n");

1961 
	`kPrtf
("10. File Delete Test...");

1963 if(
	`move
("testfileio.bin")==0)

1965 
	`kPrtf
("[Pass]\n");

1969 
	`kPrtf
("[Fail[\n");

1973 
	`kFeMemy
(
pbBufr
);

1974 
	}
}

	@/home/jk/os/MINT64/02.Kernel64/Source/ConsoleShell.h

1 #ide
__CONSOLESHELL_H__


2 
	#__CONSOLESHELL_H__


	)

4 
	~"Tys.h
"

7 
	#CONSOLESHELL_MAXCOMMANDBUFFERCOUNT
 300

	)

8 
	#CONSOLESHELL_PROMPRTMESSAGE
 "jk64>"

	)

11 (*
	tCommdFuni
)(cڡ * 
	tpcPam
);

15 #agm
	`ck
(
push
,1)

18 
	skShlCommdEryru


21 * 
pcCommd
;

23 * 
pcHp
;

25 
CommdFuni
 
pfFuni
;

26 } 
	tSHELLCOMMANDENTRY
;

29 
	skPamLiSu


32 cڡ * 
pcBufr
;

34 
iLgth
;

36 
iCutPosi
;

37 } 
	tPARAMETERLIST
;

39 #agm
	`ck
(
p
)

43 
	`kSCseShl
();

44 
	`kExecuCommd
(cڡ * 
pcCommdBufr
);

45 
	`kInlizePam
(
PARAMETERLIST
* 
pLi
,cڡ * 
pcPam
);

46 
	`kGNextPam
(
PARAMETERLIST
* 
pLi
,* 
pcPam
);

	@/home/jk/os/MINT64/02.Kernel64/Source/Descriptor.c

1 
	~"Dest.h
"

2 
	~"Uty.h
"

3 
	~"ISR.h
"

10 
	$kInlizeGDTTabAndTSS
 ()

12 
GDTR
* 
pGDTR
;

13 
GDTENTRY8
* 
pEry
;

14 
TSSSEGMENT
* 
pTSS
;

15 
i
;

18 
pGDTR
 = (
GDTR
*)
GDTR_STARTADDRESS
;

19 
pEry
 = (
GDTENTRY8
*)(
GDTR_STARTADDRESS
+(
GDTR
));

20 
pGDTR
->
wLim
 = 
GDT_TABLESIZE
-1;

21 
pGDTR
->
qwBaAddss
 = (
QWORD
)
pEry
;

23 
pTSS
 = (
TSSSEGMENT
*)((
QWORD
)
pEry
+
GDT_TABLESIZE
);

25 
	`kSGDTEry8
(&(
pEry
[0]),0,0,0,0,0);

26 
	`kSGDTEry8
(&(
pEry
[1]),0,0xFFFFF,
GDT_FLAGS_UPPER_CODE
,
GDT_FLAGS_LOWER_KERNELCODE
,
GDT_TYPE_CODE
);

27 
	`kSGDTEry8
(&(
pEry
[2]),0,0xFFFFF,
GDT_FLAGS_UPPER_DATA
,
GDT_FLAGS_LOWER_KERNELDATA
,
GDT_TYPE_DATA
);

28 
	`kSGDTEry16
((
GDTENTRY16
*)&(
pEry
[3]),(
QWORD
)
pTSS
,(
TSSSEGMENT
)-1,
GDT_FLAGS_UPPER_TSS
,
GDT_FLAGS_LOWER_TSS
,
GDT_TYPE_TSS
);

31 
	`kInlizeTSSSegmt
(
pTSS
);

32 
	}
}

36 
	$kSGDTEry8
(
GDTENTRY8
* 
pEry
,
DWORD
 
dwBaAddss
,DWORD 
dwLim
,
BYTE
 
bUFgs
,BYTE 
bLowFgs
,BYTE 
bTy
)

38 
pEry
->
wLowLim
=
dwLim
&0xFFFF;

39 
pEry
->
wLowBaAddss
 = 
dwBaAddss
&0xFFFF;

40 
pEry
->
bUBaAddss1
 = (
dwBaAddss
>>16)&0xFF;

41 
pEry
->
bTyAndLowFg
 = 
bLowFgs
 | 
bTy
;

42 
pEry
->
bULimAndUFg
 = ((
dwLim
>>16)&0xFF)|
bUFgs
;

43 
pEry
->
bUBaAddss2
 = (
dwBaAddss
>>24)&0xFF;

44 
	}
}

48 
	$kSGDTEry16
(
GDTENTRY16
* 
pEry
,
QWORD
 
qwBaAddss
,
DWORD
 
dwLim
,
BYTE
 
bUFgs
,BYTE 
bLowFgs
,BYTE 
bTy
)

50 
pEry
->
wLowLim
 = 
dwLim
&0xFFFF;

51 
pEry
->
wLowBaAddss
 = 
qwBaAddss
&0xFFFF;

52 
pEry
->
bMiddBaAddss1
 = (
qwBaAddss
>>16)&0xFF;

53 
pEry
->
bTyAndLowFg
 = 
bLowFgs
 | 
bTy
;

54 
pEry
->
bULimAndUFg
 = ((
dwLim
>>16)&&0xFF)|
bUFgs
;

55 
pEry
->
bMiddBaAddss2
 = (
qwBaAddss
>>24)&0xFF;

56 
pEry
->
dwUBaAddss
 = 
qwBaAddss
 >> 32;

57 
pEry
->
dwRerved
=0;

58 
	}
}

61 
	$kInlizeTSSSegmt
(
TSSSEGMENT
* 
pTSS
)

63 
	`kMemS
(
pTSS
,0,(
TSSSEGMENT
));

64 
pTSS
->
qwIST
[0]=
IST_STARTADDRESS
+
IST_SIZE
;

66 
pTSS
->
wIOMBaAddss
=0xFFFF;

67 
	}
}

74 
	$kInlizeIDTTabs
()

76 
IDTR
* 
pIDTR
;

77 
IDTENTRY
* 
pEry
;

78 
i
;

81 
pIDTR
 = (
IDTR
*)
IDTR_STARTADDRESS
;

83 
pEry
 = (
IDTENTRY
*)(
IDTR_STARTADDRESS
+(
IDTR
));

84 
pIDTR
->
qwBaAddss
 = (
QWORD
)
pEry
;

85 
pIDTR
->
wLim
 = 
IDT_TABLESIZE
-1;

90 
	`kSIDTEry
&
pEry
[ 0 ] ), 
kISRDivideE
, 0x08, 
IDT_FLAGS_IST1
,

91 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

92 
	`kSIDTEry
&
pEry
[ 1 ] ), 
kISRDebug
, 0x08, 
IDT_FLAGS_IST1
,

93 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

94 
	`kSIDTEry
&
pEry
[ 2 ] ), 
kISRNMI
, 0x08, 
IDT_FLAGS_IST1
,

95 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

96 
	`kSIDTEry
&
pEry
[ 3 ] ), 
kISRBakPot
, 0x08, 
IDT_FLAGS_IST1
,

97 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

98 
	`kSIDTEry
&
pEry
[ 4 ] ), 
kISROvow
, 0x08, 
IDT_FLAGS_IST1
,

99 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

100 
	`kSIDTEry
&
pEry
[ 5 ] ), 
kISRBoundRgeExeded
, 0x08, 
IDT_FLAGS_IST1
,

101 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

102 
	`kSIDTEry
&
pEry
[ 6 ] ), 
kISRInvidOpcode
, 0x08, 
IDT_FLAGS_IST1
,

103 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

104 
	`kSIDTEry
&
pEry
[ 7 ] ), 
kISRDeviNAvaab
, 0x08, 
IDT_FLAGS_IST1
,

105 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

106 
	`kSIDTEry
&
pEry
[ 8 ] ), 
kISRDoubFau
, 0x08, 
IDT_FLAGS_IST1
,

107 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

108 
	`kSIDTEry
&
pEry
[ 9 ] ), 
kISRCrossSegmtOvrun
, 0x08, 
IDT_FLAGS_IST1
,

109 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

110 
	`kSIDTEry
&
pEry
[ 10 ] ), 
kISRInvidTSS
, 0x08, 
IDT_FLAGS_IST1
,

111 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

112 
	`kSIDTEry
&
pEry
[ 11 ] ), 
kISRSegmtNP
, 0x08, 
IDT_FLAGS_IST1
,

113 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

114 
	`kSIDTEry
&
pEry
[ 12 ] ), 
kISRSckSegmtFau
, 0x08, 
IDT_FLAGS_IST1
,

115 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

116 
	`kSIDTEry
&
pEry
[ 13 ] ), 
kISRGPrei
, 0x08, 
IDT_FLAGS_IST1
,

117 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

118 
	`kSIDTEry
&
pEry
[ 14 ] ), 
kISRPageFau
, 0x08, 
IDT_FLAGS_IST1
,

119 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

120 
	`kSIDTEry
&
pEry
[ 15 ] ), 
kISR15
, 0x08, 
IDT_FLAGS_IST1
,

121 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

122 
	`kSIDTEry
&
pEry
[ 16 ] ), 
kISRFPUE
, 0x08, 
IDT_FLAGS_IST1
,

123 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

124 
	`kSIDTEry
&
pEry
[ 17 ] ), 
kISRAlignmtCheck
, 0x08, 
IDT_FLAGS_IST1
,

125 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

126 
	`kSIDTEry
&
pEry
[ 18 ] ), 
kISRMacheCheck
, 0x08, 
IDT_FLAGS_IST1
,

127 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

128 
	`kSIDTEry
&
pEry
[ 19 ] ), 
kISRSIMDE
, 0x08, 
IDT_FLAGS_IST1
,

129 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

130 
	`kSIDTEry
&
pEry
[ 20 ] ), 
kISRETCExi
, 0x08, 
IDT_FLAGS_IST1
,

131 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

133  
i
 = 21 ; i < 32 ; i++ )

135 
	`kSIDTEry
&
pEry
[ 
i
 ] ), 
kISRETCExi
, 0x08, 
IDT_FLAGS_IST1
,

136 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

141 
	`kSIDTEry
&
pEry
[ 32 ] ), 
kISRTim
, 0x08, 
IDT_FLAGS_IST1
,

142 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

143 
	`kSIDTEry
&
pEry
[ 33 ] ), 
kISRKeybrd
, 0x08, 
IDT_FLAGS_IST1
,

144 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

145 
	`kSIDTEry
&
pEry
[ 34 ] ), 
kISRSvePIC
, 0x08, 
IDT_FLAGS_IST1
,

146 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

147 
	`kSIDTEry
&
pEry
[ 35 ] ), 
kISRSl2
, 0x08, 
IDT_FLAGS_IST1
,

148 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

149 
	`kSIDTEry
&
pEry
[ 36 ] ), 
kISRSl1
, 0x08, 
IDT_FLAGS_IST1
,

150 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

151 
	`kSIDTEry
&
pEry
[ 37 ] ), 
kISRPl2
, 0x08, 
IDT_FLAGS_IST1
,

152 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

153 
	`kSIDTEry
&
pEry
[ 38 ] ), 
kISRFlpy
, 0x08, 
IDT_FLAGS_IST1
,

154 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

155 
	`kSIDTEry
&
pEry
[ 39 ] ), 
kISRPl1
, 0x08, 
IDT_FLAGS_IST1
,

156 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

157 
	`kSIDTEry
&
pEry
[ 40 ] ), 
kISRRTC
, 0x08, 
IDT_FLAGS_IST1
,

158 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

159 
	`kSIDTEry
&
pEry
[ 41 ] ), 
kISRRerved
, 0x08, 
IDT_FLAGS_IST1
,

160 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

161 
	`kSIDTEry
&
pEry
[ 42 ] ), 
kISRNUd1
, 0x08, 
IDT_FLAGS_IST1
,

162 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

163 
	`kSIDTEry
&
pEry
[ 43 ] ), 
kISRNUd2
, 0x08, 
IDT_FLAGS_IST1
,

164 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

165 
	`kSIDTEry
&
pEry
[ 44 ] ), 
kISRMou
, 0x08, 
IDT_FLAGS_IST1
,

166 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

167 
	`kSIDTEry
&
pEry
[ 45 ] ), 
kISRCross
, 0x08, 
IDT_FLAGS_IST1
,

168 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

169 
	`kSIDTEry
&
pEry
[ 46 ] ), 
kISRHDD1
, 0x08, 
IDT_FLAGS_IST1
,

170 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

171 
	`kSIDTEry
&
pEry
[ 47 ] ), 
kISRHDD2
, 0x08, 
IDT_FLAGS_IST1
,

172 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

174  
i
 = 48 ; i < 
IDT_MAXENTRYCOUNT
 ; i++ )

176 
	`kSIDTEry
&
pEry
[ 
i
 ] ), 
kISRETCIru
, 0x08, 
IDT_FLAGS_IST1
,

177 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

180 
	}
}

183 
	$kSIDTEry
(
IDTENTRY
* 
pEry
,* 
pvHdr
,
WORD
 
wSe
,
BYTE
 
bIST
,BYTE 
bFgs
,BYTE 
bTy
)

185 
pEry
->
wLowBaAddss
 = (
QWORD
)
pvHdr
&0xFFFF;

186 
pEry
->
wSegmtSe
 = 
wSe
;

187 
pEry
->
bIST
 = bIST&0x3;

188 
pEry
->
bTyAndFgs
 = 
bTy
|
bFgs
;

189 
pEry
->
wMiddBaAddss
=((
QWORD
)
pvHdr
>>16)&0xFFFF;

190 
pEry
->
dwUBaAddss
=(
QWORD
)
pvHdr
>>32;

191 
pEry
->
dwRerved
=0;

192 
	}
}

	@/home/jk/os/MINT64/02.Kernel64/Source/Descriptor.h

1 #ide
__DESCRIPTOR_H__


2 
	#__DESCRIPTOR_H__


	)

4 
	~"Tys.h
"

11 
	#GDT_TYPE_CODE
 0x0A

	)

12 
	#GDT_TYPE_DATA
 0x02

	)

13 
	#GDT_TYPE_TSS
 0x09

	)

14 
	#GDT_FLAGS_LOWER_S
 0x10

	)

15 
	#GDT_FLAGS_LOWER_DPL0
 0x00

	)

16 
	#GDT_FLAGS_LOWER_DPL1
 0x20

	)

17 
	#GDT_FLAGS_LOWER_DPL2
 0x40

	)

18 
	#GDT_FLAGS_LOWER_DPL3
 0x60

	)

19 
	#GDT_FLAGS_LOWER_P
 0x80

	)

20 
	#GDT_FLAGS_UPPER_L
 0x20

	)

21 
	#GDT_FLAGS_UPPER_DB
 0x40

	)

22 
	#GDT_FLAGS_UPPER_G
 0x80

	)

26 
	#GDT_FLAGS_LOWER_KERNELCODE
 (
GDT_TYPE_CODE
 | 
GDT_FLAGS_LOWER_S
 | 
GDT_FLAGS_LOWER_DPL0
 | 
GDT_FLAGS_LOWER_P
)

	)

27 
	#GDT_FLAGS_LOWER_KERNELDATA
 (
GDT_TYPE_DATA
 | 
GDT_FLAGS_LOWER_S
 | 
GDT_FLAGS_LOWER_DPL0
 | 
GDT_FLAGS_LOWER_P
)

	)

28 
	#GDT_FLAGS_LOWER_TSS
 (
GDT_FLAGS_LOWER_DPL0
 | 
GDT_FLAGS_LOWER_P
)

	)

29 
	#GDT_FLAGS_LOWER_USERCODE
 (
GDT_TYPE_CODE
 | 
GDT_FLAGS_LOWER_S
 | 
GDT_FLAGS_LOWER_DPL3
 | 
GDT_FLAGS_LOWER_P
)

	)

30 
	#GDT_FLAGS_LOWER_USERDATA
 (
GDT_TYPE_DATA
 | 
GDT_FLAGS_LOWER_S
 | 
GDT_FLAGS_LOWER_DPL3
 | 
GDT_FLAGS_LOWER_P
)

	)

33 
	#GDT_FLAGS_UPPER_CODE
 (
GDT_FLAGS_UPPER_G
 | 
GDT_FLAGS_UPPER_L
)

	)

34 
	#GDT_FLAGS_UPPER_DATA
 (
GDT_FLAGS_UPPER_G
 | 
GDT_FLAGS_UPPER_L
)

	)

35 
	#GDT_FLAGS_UPPER_TSS
 (
GDT_FLAGS_UPPER_G
)

	)

38 
	#GDT_KERNELCODESEGMENT
 0x08

	)

39 
	#GDT_KERNELDATASEGMENT
 0x10

	)

40 
	#GDT_TSSSEGMENT
 0x18

	)

44 
	#GDTR_STARTADDRESS
 0x142000

	)

46 
	#GDT_MAXENTRY8COUNT
 3

	)

48 
	#GDT_MAXENTRY16COUNT
 1

	)

50 
	#GDT_TABLESIZE
 (((
GDTENTRY8
)*
GDT_MAXENTRY8COUNT
+ ((
GDTENTRY16
)*
GDT_MAXENTRY16COUNT
))

	)

51 
	#TSS_SEGMENTSIZE
 ((
TSSSEGMENT
))

	)

58 
	#IDT_TYPE_INTERRUPT
 0x0E

	)

59 
	#IDT_TYPE_TRAP
 0x0F

	)

60 
	#IDT_FLAGS_DPL0
 0x00

	)

61 
	#IDT_FLAGS_DPL1
 0x20

	)

62 
	#IDT_FLAGS_DPL2
 0x40

	)

63 
	#IDT_FLAGS_DPL3
 0x60

	)

64 
	#IDT_FLAGS_P
 0x80

	)

65 
	#IDT_FLAGS_IST0
 0

	)

66 
	#IDT_FLAGS_IST1
 1

	)

70 
	#IDT_FLAGS_KERNEL
 (
IDT_FLAGS_DPL0
 | 
IDT_FLAGS_P
)

	)

71 
	#IDT_FLAGS_USER
 (
IDT_FLAGS_DPL3
 | 
IDT_FLAGS_P
)

	)

75 
	#IDT_MAXENTRYCOUNT
 100

	)

77 
	#IDTR_STARTADDRESS
 (
GDTR_STARTADDRESS
+(
GDTR
)+
GDT_TABLESIZE
+
TSS_SEGMENTSIZE
)

	)

79 
	#IDT_STARTADDRESS
 (
IDTR_STARTADDRESS
+(
IDTR
))

	)

81 
	#IDT_TABLESIZE
 (
IDT_MAXENTRYCOUNT
*(
IDTENTRY
))

	)

85 
	#IST_STARTADDRESS
 0x700000

	)

87 
	#IST_SIZE
 0x100000

	)

91 #agm
ck
(
push
,1)

94 
	skGDTRSu


96 
WORD
 
	mwLim
;

97 
QWORD
 
	mqwBaAddss
;

99 
WORD
 
	mwPadg
;

100 
DWORD
 
	mdwPadg
;

101 } 
	tGDTR
,
	tIDTR
;

104 
	skGDTEry8Su


106 
WORD
 
	mwLowLim
;

107 
WORD
 
	mwLowBaAddss
;

108 
BYTE
 
	mbUBaAddss1
;

110 
BYTE
 
	mbTyAndLowFg
;

112 
BYTE
 
	mbULimAndUFg
;

113 
BYTE
 
	mbUBaAddss2
;

114 } 
	tGDTENTRY8
;

117 
	skGDTEry16ru


119 
WORD
 
	mwLowLim
;

120 
WORD
 
	mwLowBaAddss
;

121 
BYTE
 
	mbMiddBaAddss1
;

123 
BYTE
 
	mbTyAndLowFg
;

125 
BYTE
 
	mbULimAndUFg
;

126 
BYTE
 
	mbMiddBaAddss2
;

127 
DWORD
 
	mdwUBaAddss
;

128 
DWORD
 
	mdwRerved
;

129 } 
	tGDTENTRY16
;

132 
	skTSSDaSu


134 
DWORD
 
	mdwRerved1
;

135 
QWORD
 
	mqwR
[3];

136 
QWORD
 
	mqwRerved2
;

137 
QWORD
 
	mqwIST
[7];

138 
QWORD
 
	mqwRerved3
;

139 
WORD
 
	mwRerved
;

140 
WORD
 
	mwIOMBaAddss
;

141 } 
	tTSSSEGMENT
;

144 
	skIDTErySu


146 
WORD
 
	mwLowBaAddss
;

147 
WORD
 
	mwSegmtSe
;

149 
BYTE
 
	mbIST
;

151 
BYTE
 
	mbTyAndFgs
;

152 
WORD
 
	mwMiddBaAddss
;

153 
DWORD
 
	mdwUBaAddss
;

154 
DWORD
 
	mdwRerved
;

155 } 
	tIDTENTRY
;

157 #agm
ck
(
p
)

160 
kInlizeGDTTabAndTSS
 ();

161 
kSGDTEry8
 (
GDTENTRY8
* 
pEry
,
DWORD
 
dwBaAddss
,DWORD 
dwLim
,
BYTE
 
bUFgs
,BYTE 
bLowFgs
,BYTE 
bTy
);

162 
kSGDTEry16
 (
GDTENTRY16
* 
pEry
,
QWORD
 
qwBaAddss
,
DWORD
 
dwLim
,
BYTE
 
bUFgs
,BYTE 
bLowFgs
,BYTE 
bTy
);

163 
kInlizeTSSSegmt
 (
TSSSEGMENT
* 
pTSS
);

165 
kInlizeIDTTabs
 ();

166 
kSIDTEry
(
IDTENTRY
* 
pEry
,* 
pvHdr
,
WORD
 
wSe
,
BYTE
 
bIST
,BYTE 
bFgs
,BYTE 
bTy
);

167 
kDummyHdr
 ();

	@/home/jk/os/MINT64/02.Kernel64/Source/DynamicMemory.c

1 
	~"DymicMemy.h
"

2 
	~"Uty.h
"

3 
	~"Task.h
"

5 
DYNAMICMEMORY
 
	ggs_DymicMemy
;

8 
QWORD
 
kCcuϋDymicMemySize
();

9 
kCcuϋMaBlockCou
(
QWORD
 
qwDymicRAMSize
);

10 
kAotiBuddyBlock
(
QWORD
 
qwAligdSize
);

11 
QWORD
 
kGBuddyBlockSize
(QWORD 
qwSize
);

12 
kGBlockLiIndexOfMchSize
(
QWORD
 
qwAligdSize
);

13 
kFdFeBlockInBm
(
iBlockLiIndex
);

14 
kSFgInBm
(
iBlockLiIndex
,
iOfft
,
BYTE
 
bFg
);

15 
BOOL
 
kFeBuddyBlock
(
iBlockLiIndex
,
iBlockOfft
);

16 
BYTE
 
kGFgInBm
(
iBlockLiIndex
,
iOfft
);

23 
	$kInlizeDymicMemy
()

25 
QWORD
 
qwDymicMemySize
;

26 
i
,
j
;

27 
BYTE
* 
pbCutBmPosi
;

28 
iBlockCouOfLev
, 
iMaBlockCoou
;

32 
qwDymicMemySize
 = 
	`kCcuϋDymicMemySize
();

33 
iMaBlockCoou
 = 
	`kCcuϋMaBlockCou
(
qwDymicMemySize
);

37 
gs_DymicMemy
.
iBlockCouOfSmˡBlock
 = (
qwDymicMemySize
/
DYNAMICMEMORY_MIN_SIZE
)-
iMaBlockCoou
;

40 
i
=0;(
gs_DymicMemy
.
iBlockCouOfSmˡBlock
>>i)>0;i++)

44 
gs_DymicMemy
.
iMaxLevCou
=
i
;

47 
gs_DymicMemy
.
pbAodBlockLiIndex
 = (
BYTE
*)
DYNAMICMEMORY_START_ADDRESS
;

48 
i
=0;i<
gs_DymicMemy
.
iBlockCouOfSmˡBlock
;i++)

50 
gs_DymicMemy
.
pbAodBlockLiIndex
[
i
]=0xFF;

54 
gs_DymicMemy
.
pBmOfLev
 = (
BITMAP
*)(
DYNAMICMEMORY_START_ADDRESS
+((
BYTE
)*gs_DymicMemy.
iBlockCouOfSmˡBlock
));

56 
pbCutBmPosi
 = ((
BYTE
*)
gs_DymicMemy
.
pBmOfLev
)+((
BITMAP
)*gs_DymicMemy.
iMaxLevCou
);

60 
j
=0;j<
gs_DymicMemy
.
iMaxLevCou
;j++)

62 
gs_DymicMemy
.
pBmOfLev
[
j
].
pbBm
 = 
pbCutBmPosi
;

63 
gs_DymicMemy
.
pBmOfLev
[
j
].
qwExiBCou
 = 0;

64 
iBlockCouOfLev
 = 
gs_DymicMemy
.
iBlockCouOfSmˡBlock
>>
j
;

68 
i
=0;i<
iBlockCouOfLev
/8;i++)

70 *
pbCutBmPosi
 = 0x00;

71 
pbCutBmPosi
++;

75 if((
iBlockCouOfLev
%8)!=0)

77 *
pbCutBmPosi
=0x00;

80 
i
 = 
iBlockCouOfLev
%8;

81 if((
i
%2)==1)

83 *
pbCutBmPosi
 |=(
DYNAMICMEMORY_EXIST
<<(
i
-1));

84 
gs_DymicMemy
.
pBmOfLev
[
j
].
qwExiBCou
=1;

86 
pbCutBmPosi
++;

91 
gs_DymicMemy
.
qwSAddss
 = 
DYNAMICMEMORY_START_ADDRESS
+
iMaBlockCoou
*
DYNAMICMEMORY_MIN_SIZE
;

92 
gs_DymicMemy
.
qwEndAddss
 = 
	`kCcuϋDymicMemySize
()+
DYNAMICMEMORY_START_ADDRESS
;

93 
gs_DymicMemy
.
qwUdSize
=0;

94 
	}
}

97 
QWORD
 
	$kCcuϋDymicMemySize
()

99 
QWORD
 
qwRAMSize
;

102 
qwRAMSize
 = (
	`kGTٮRAMSize
()*1024*1024);

103 if(
qwRAMSize
>(
QWORD
)3*1024*1024*1024)

105 
qwRAMSize
 = (
QWORD
)3*1024*1024*1024;

108  
qwRAMSize
 - 
DYNAMICMEMORY_START_ADDRESS
;

109 
	}
}

113 
	$kCcuϋMaBlockCou
(
QWORD
 
qwDymicRAMSize
)

115 
lBlockCouOfSmˡBlock
;

116 
DWORD
 
dwSizeOfAodBlockLiIndex
;

117 
DWORD
 
dwSizeOfBm
;

118 
i
;

121 
lBlockCouOfSmˡBlock
 = 
qwDymicRAMSize
/
DYNAMICMEMORY_MIN_SIZE
;

123 
dwSizeOfAodBlockLiIndex
 = 
lBlockCouOfSmˡBlock
*(
BYTE
);

126 
dwSizeOfBm
=0;

127 
i
=0;(
lBlockCouOfSmˡBlock
>>i)>0;i++)

130 
dwSizeOfBm
 +=(
BITMAP
);

132 
dwSizeOfBm
 +=((
lBlockCouOfSmˡBlock
>>
i
)+7)/8;

136  (
dwSizeOfAodBlockLiIndex
+
dwSizeOfBm
+
DYNAMICMEMORY_MIN_SIZE
-1)/DYNAMICMEMORY_MIN_SIZE;

137 
	}
}

140 * 
	$kAoMemy
(
QWORD
 
qwSize
)

142 
QWORD
 
qwAligdSize
;

143 
QWORD
 
qwRiveAddss
;

144 
lOfft
;

145 
iSizeAayOfft
;

146 
iIndexOfBlockLi
;

149 
qwAligdSize
 = 
	`kGBuddyBlockSize
(
qwSize
);

150 if(
qwAligdSize
 == 0)

153  
NULL
;

157 if(
gs_DymicMemy
.
qwSAddss
+gs_DymicMemy.
qwUdSize
+
qwAligdSize
>gs_DymicMemy.
qwEndAddss
)

160  
NULL
;

164 
lOfft
 = 
	`kAotiBuddyBlock
(
qwAligdSize
);

165 if(
lOfft
==-1)

168  
NULL
;

171 
iIndexOfBlockLi
 = 
	`kGBlockLiIndexOfMchSize
(
qwAligdSize
);

175 
qwRiveAddss
 = 
qwAligdSize
*
lOfft
;

176 
iSizeAayOfft
 = 
qwRiveAddss
/
DYNAMICMEMORY_MIN_SIZE
;

177 
gs_DymicMemy
.
pbAodBlockLiIndex
[
iSizeAayOfft
] = (
BYTE
)
iIndexOfBlockLi
;

178 
gs_DymicMemy
.
qwUdSize
 +=
qwAligdSize
;

180  (*)(
qwRiveAddss
+
gs_DymicMemy
.
qwSAddss
);

181 
	}
}

184 
QWORD
 
	$kGBuddyBlockSize
(
QWORD
 
qwSize
)

186 
i
;

188 
i
=0;i<
gs_DymicMemy
.
iMaxLevCou
;i++)

190 if(
qwSize
<=(
DYNAMICMEMORY_MIN_SIZE
<<
i
))

192  (
DYNAMICMEMORY_MIN_SIZE
<<
i
);

197 
	}
}

201 
	$kAotiBuddyBlock
(
QWORD
 
qwAligdSize
)

203 
iBlockLiIndex
,
iFeOfft
;

204 
i
;

205 
BOOL
 
bPviousIruFg
;

208 
iBlockLiIndex
 = 
	`kGBlockLiIndexOfMchSize
(
qwAligdSize
);

209 if(
iBlockLiIndex
==-1)

216 
bPviousIruFg
 = 
	`kLockFSyemDa
();

219 
i
=
iBlockLiIndex
;i<
gs_DymicMemy
.
iMaxLevCou
;i++)

222 
iFeOfft
 = 
	`kFdFeBlockInBm
(
i
);

223 if(
iFeOfft
!=-1)

230 if(
iFeOfft
==-1)

233 
	`kUockFSyemDa
(
bPviousIruFg
);

238 
	`kSFgInBm
(
i
,
iFeOfft
,
DYNAMICMEMORY_EMPTY
);

241 if(
i
>
iBlockLiIndex
)

245 
i
=i-1;i>=
iBlockLiIndex
;i--)

248 
	`kSFgInBm
(
i
,
iFeOfft
*2,
DYNAMICMEMORY_EMPTY
);

250 
	`kSFgInBm
(
i
,
iFeOfft
*2+1,
DYNAMICMEMORY_EXIST
);

252 
iFeOfft
 = iFreeOffset*2;

255 
	`kUockFSyemDa
(
bPviousIruFg
);

257  
iFeOfft
;

258 
	}
}

261 
	$kGBlockLiIndexOfMchSize
(
QWORD
 
qwAligdSize
)

263 
i
;

265 
i
=0;i<
gs_DymicMemy
.
iMaxLevCou
;i++)

267 if(
qwAligdSize
<=(
DYNAMICMEMORY_MIN_SIZE
<<
i
))

269  
i
;

273 
	}
}

276 
	$kFdFeBlockInBm
(
iBlockLiIndex
)

278 
i
,
iMaxCou
;

279 
BYTE
* 
pbBm
;

280 
QWORD
* 
pqwBm
;

283 if(
gs_DymicMemy
.
pBmOfLev
[
iBlockLiIndex
].
qwExiBCou
==0)

289 
iMaxCou
 = 
gs_DymicMemy
.
iBlockCouOfSmˡBlock
>>
iBlockLiIndex
;

290 
pbBm
 = 
gs_DymicMemy
.
pBmOfLev
[
iBlockLiIndex
].pbBitmap;

291 
i
=0;i<
iMaxCou
;)

294 if(((
iMaxCou
-
i
)/64)>0)

296 
pqwBm
 =(
QWORD
*)&(
pbBm
[
i
/8]);

298 if(*
pqwBm
==0)

300 
i
+=64;

305 if((
pbBm
[
i
/8]&(
DYNAMICMEMORY_EXIST
<<(i%8)))!=0)

307  
i
;

309 
i
++;

313 
	}
}

316 
	$kSFgInBm
(
iBlockLiIndex
,
iOfft
,
BYTE
 
bFg
)

318 
BYTE
* 
pbBm
;

319 
pbBm
 = 
gs_DymicMemy
.
pBmOfLev
[
iBlockLiIndex
].pbBitmap;

321 if(
bFg
==
DYNAMICMEMORY_EXIST
)

324 if((
pbBm
[
iOfft
/8]&(0x01<<(iOffset%8)))==0)

326 
gs_DymicMemy
.
pBmOfLev
[
iBlockLiIndex
].
qwExiBCou
++;

328 
pbBm
[
iOfft
/8]|=(0x01<<(iOffset%8));

333 if((
pbBm
[
iOfft
/8]&(0x01<<(iOffset%8)))!=0)

335 
gs_DymicMemy
.
pBmOfLev
[
iBlockLiIndex
].
qwExiBCou
--;

337 
pbBm
[
iOfft
/8]&=~(0x01<<(iOffset%8));

339 
	}
}

342 
BOOL
 
	$kFeMemy
(* 
pvAddss
)

344 
QWORD
 
qwRiveAddss
;

345 
iSizeAayOfft
;

346 
QWORD
 
qwBlockSize
;

347 
iBlockLiIndex
;

348 
iBmOfft
;

350 if(
pvAddss
==
NULL
)

352  
FALSE
;

356 
qwRiveAddss
 = ((
QWORD
)
pvAddss
)-
gs_DymicMemy
.
qwSAddss
;

357 
iSizeAayOfft
 = 
qwRiveAddss
/
DYNAMICMEMORY_MIN_SIZE
;

360 if(
gs_DymicMemy
.
pbAodBlockLiIndex
[
iSizeAayOfft
]==0xFF)

362  
FALSE
;

367 
iBlockLiIndex
 = ()
gs_DymicMemy
.
pbAodBlockLiIndex
[
iSizeAayOfft
];

368 
gs_DymicMemy
.
pbAodBlockLiIndex
[
iSizeAayOfft
]=0xFF;

370 
qwBlockSize
 = 
DYNAMICMEMORY_MIN_SIZE
<<
iBlockLiIndex
;

373 
iBmOfft
 = 
qwRiveAddss
/
qwBlockSize
;

374 if(
	`kFeBuddyBlock
(
iBlockLiIndex
,
iBmOfft
)==
TRUE
)

376 
gs_DymicMemy
.
qwUdSize
 -
qwBlockSize
;

377  
TRUE
;

380  
FALSE
;

381 
	}
}

384 
BOOL
 
	$kFeBuddyBlock
(
iBlockLiIndex
,
iBlockOfft
)

386 
iBuddyBlockOfft
;

387 
i
;

388 
BOOL
 
bFg
;

389 
BOOL
 
bPviousIruFg
;

392 
bPviousIruFg
 = 
	`kLockFSyemDa
();

395 
i
=
iBlockLiIndex
;i<
gs_DymicMemy
.
iMaxLevCou
;i++)

398 
	`kSFgInBm
(
i
,
iBlockOfft
,
DYNAMICMEMORY_EXIST
);

402 if((
iBlockOfft
%2)==0)

404 
iBuddyBlockOfft
 = 
iBlockOfft
+1;

408 
iBuddyBlockOfft
 = 
iBlockOfft
-1;

411 
bFg
 = 
	`kGFgInBm
(
i
,
iBuddyBlockOfft
);

414 if(
bFg
 =
DYNAMICMEMORY_EMPTY
)

421 
	`kSFgInBm
(
i
,
iBuddyBlockOfft
,
DYNAMICMEMORY_EMPTY
);

422 
	`kSFgInBm
(
i
,
iBlockOfft
,
DYNAMICMEMORY_EMPTY
);

425 
iBlockOfft
 = iBlockOffset/2;

428 
	`kUockFSyemDa
(
bPviousIruFg
);

429  
TRUE
;

430 
	}
}

433 
BYTE
 
	$kGFgInBm
(
iBlockLiIndex
,
iOfft
)

435 
BYTE
* 
pbBm
;

437 
pbBm
 = 
gs_DymicMemy
.
pBmOfLev
[
iBlockLiIndex
].pbBitmap;

438 if((
pbBm
[
iOfft
/8]&(0x01<<(iOffset%8)))!=0x00)

440  
DYNAMICMEMORY_EXIST
;

443  
DYNAMICMEMORY_EMPTY
;

444 
	}
}

447 
	$kGDymicMemyInfmi
(
QWORD
* 
pqwDymicMemySAddss
,QWORD* 
pqwDymicMemyTٮSize
,QWORD* 
pqwMaDaSize
,QWORD* 
pqwUdMemySize
)

449 *
pqwDymicMemySAddss
 = 
DYNAMICMEMORY_START_ADDRESS
;

450 *
pqwDymicMemyTٮSize
 = 
	`kCcuϋDymicMemySize
();

451 *
pqwMaDaSize
 = 
	`kCcuϋMaBlockCou
(*
pqwDymicMemyTٮSize
)*
DYNAMICMEMORY_MIN_SIZE
;

452 *
pqwUdMemySize
 = 
gs_DymicMemy
.
qwUdSize
;

453 
	}
}

456 
DYNAMICMEMORY
* 
	$kGDymicMemyMag
()

458  &
gs_DymicMemy
;

459 
	}
}

	@/home/jk/os/MINT64/02.Kernel64/Source/DynamicMemory.h

1 #ide
__DYNAMICMEMORY_H__


2 
	#__DYNAMICMEMORY_H__


	)

4 
	~"Tys.h
"

8 
	#DYNAMICMEMORY_START_ADDRESS
 ((
TASK_STACKPOOLADDRESS
+(
TASK_STACKSIZE
*
TASK_MAXCOUNT
)+0xfffff)&0xfffffffffff00000)

	)

12 
	#DYNAMICMEMORY_MIN_SIZE
 (1*1024)

	)

15 
	#DYNAMICMEMORY_EXIST
 0x01

	)

16 
	#DYNAMICMEMORY_EMPTY
 0x00

	)

20 
	skBmSu


22 
BYTE
* 
	mpbBm
;

23 
QWORD
 
	mqwExiBCou
;

24 } 
	tBITMAP
;

27 
	skDymicMemyMagSu


30 
	miMaxLevCou
;

31 
	miBlockCouOfSmˡBlock
;

32 
QWORD
 
	mqwUdSize
;

35 
QWORD
 
	mqwSAddss
;

36 
QWORD
 
	mqwEndAddss
;

39 
BYTE
* 
	mpbAodBlockLiIndex
;

40 
BITMAP
* 
	mpBmOfLev
;

41 } 
	tDYNAMICMEMORY
;

44 
kInlizeDymicMemy
();

45 * 
kAoMemy
(
QWORD
 
qwSize
);

46 
BOOL
 
kFeMemy
(* 
pvAddss
);

47 
kGDymicMemyInfmi
(
QWORD
* 
pqwDymicMemySAddss
,QWORD* 
pqwDymicMemyTٮSize
,QWORD* 
pqwMaDaSize
,QWORD* 
pqwUdMemySize
);

48 
DYNAMICMEMORY
* 
kGDymicMemyMag
();

	@/home/jk/os/MINT64/02.Kernel64/Source/EntryPoint.s

1 [
BITS
 64] ; 이하의 코드는 64비트 코드로 설정

3 
	gSECTION
 .
	gxt
 ; .text 섹션(세그먼트)을 정의

5 ; 외부에서 정의된 함수를 쓸 수 있도록 선언함(
	gimpt
)

6 
ma


13 
	gSTART
:

14 
mov
 
ax
, 0x10 ; 
	gIA
-32모드 커널용 데이터 세그먼트 디스크립터를 
	gAX
 레지스터에 저장

15 
mov
 
	gds
, 
	gax
 ; 
	gDS
 세그먼트 셀렉터에 설정

16 
mov
 
	ges
, 
	gax
 ; 
	gES
 세그먼트 셀렉터에 설정

17 
mov
 
	gfs
, 
	gax
 ; 
	gFS
 세그먼트 셀렉터에 설정

18 
mov
 
	ggs
, 
	gax
 ; 
	gGS
 세그먼트 셀렉터에 설정

20 ; 스택을 0x600000 ~ 0x6FFFFFF 영역에 1
	gMB
 크기로 생성

21 
mov
 
	gss
, 
	gax
 ; ss 세그먼트 셀렉터에 설정

22 
mov
 
	gr
, 0x6FFFF8 ; 
	gRSP
 레지스터의 어드레스를 0x6FFFF8로 설정

23 
mov
 
	grbp
, 0x6FFFF8 ; 
	gRBP
 레지스터의 어드레스를 0x6FFFF8로 설정

25 

 
	gma
 ; 
	gC
 언어 엔트리 포인트 함수(main) 호출

27 
jmp
 
	g$


	@/home/jk/os/MINT64/02.Kernel64/Source/FileSystem.c

1 
	~"FeSyem.h
"

2 
	~"HdDisk.h
"

3 
	~"DymicMemy.h
"

4 
	~"Task.h
"

5 
	~"Uty.h
"

8 
FILESYSTEMMANAGER
 
	ggs_FeSyemMag
;

10 
BYTE
 
	ggs_vbTempBufr
[
FILESYSTEM_SECTORPERCLUSTER
*512];

13 
fRdHDDInfmi
 
	ggs_pfRdHDDInfmi
 = 
NULL
;

14 
fRdHDDSe
 
	ggs_pfRdHDDSe
 =
NULL
;

15 
fWreHDDSe
 
	ggs_pfWreHDDSe
 =
NULL
;

18 
BOOL
 
kRdCluLkTab
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
);

19 
BOOL
 
kWreCluLkTab
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
);

20 
BOOL
 
kRdClu
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
);

21 
BOOL
 
kWreClu
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
);

22 
DWORD
 
kFdFeClu
();

23 
BOOL
 
kSCluLkDa
(
DWORD
 
dwCluIndex
,DWORD 
dwDa
);

24 
BOOL
 
kGCluLkDa
(
DWORD
 
dwCluIndex
,DWORD* 
pdwDa
);

25 
kFdFeDeyEry
();

26 
BOOL
 
kSDeyEryDa
(
iIndex
,
DIRECTORYENTRY
* 
pEry
);

27 
BOOL
 
kGDeyEryDa
(
iIndex
,
DIRECTORYENTRY
* 
pEry
);

28 
kFdDeyEry
(cڡ * 
pcFeName
,
DIRECTORYENTRY
* 
pEry
);

31 * 
kAoFeDeyHd
();

32 
kFeFeDeyHd
(
FILE
* 
pFe
);

33 
BOOL
 
kCeFe
(cڡ * 
pcFeName
,
DIRECTORYENTRY
* 
pEry
,* 
piDeyEryIndex
);

34 
BOOL
 
kFeCluUtEnd
(
DWORD
 
dwCluIndex
);

35 
BOOL
 
kUpdeDeyEry
(
FILEHANDLE
* 
pFeHd
);

38 
BOOL
 
	$kInlizeFeSyem
()

41 
	`kMemS
(&
gs_FeSyemMag
,0,(gs_stFileSystemManager));

42 
	`kInlizeMux
(&(
gs_FeSyemMag
.
Mux
));

45 if(
	`kInlizeHDD
()==
TRUE
)

48 
gs_pfRdHDDInfmi
 = 
kRdHDDInfmi
;

49 
gs_pfRdHDDSe
 = 
kRdHDDSe
;

50 
gs_pfWreHDDSe
 = 
kWreHDDSe
;

54  
FALSE
;

58 if(
	`kMou
()==
FALSE
)

60  
FALSE
;

64 
gs_FeSyemMag
.
pHdPo
 = (
FILE
*
	`kAoMemy
(
FILESYSTEM_HANDLE_MAXCOUNT
*(FILE));

67 if(
gs_FeSyemMag
.
pHdPo
 =
NULL
)

69 
gs_FeSyemMag
.
bMoued
 = 
FALSE
;

70  
FALSE
;

74 
	`kMemS
(
gs_FeSyemMag
.
pHdPo
,0,
FILESYSTEM_HANDLE_MAXCOUNT
*(
FILE
));

76  
TRUE
;

77 
	}
}

84 
BOOL
 
	$kMou
()

86 
MBR
* 
pMBR
;

89 
	`kLock
(&(
gs_FeSyemMag
.
Mux
));

92 if(
	`gs_pfRdHDDSe
(
TRUE
,TRUE,0,1,
gs_vbTempBufr
)==
FALSE
)

95 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

96  
FALSE
;

100 
pMBR
 = (
MBR
*)
gs_vbTempBufr
;

102 if(
pMBR
->
dwSigtu
 !
FILESYSTEM_SIGNATUR
)

105 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

106  
FALSE
;

110 
gs_FeSyemMag
.
bMoued
 = 
TRUE
;

113 
gs_FeSyemMag
.
dwRervedSeCou
 = 
pMBR
->dwReservedSectorCount;

114 
gs_FeSyemMag
.
dwCluLkAaSAddss
 = 
pMBR
->
dwRervedSeCou
+1;

115 
gs_FeSyemMag
.
dwCluLkAaSize
 = 
pMBR
->
dwCluLkSeCou
;

116 
gs_FeSyemMag
.
dwDaAaSAddss
 = 
pMBR
->
dwRervedSeCou
 +MBR->
dwCluLkSeCou
+1;

117 
gs_FeSyemMag
.
dwTٮCluCou
 = 
pMBR
->dwTotalClusterCount;

120 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

121  
TRUE
;

122 
	}
}

125 
BOOL
 
	$kFm
()

127 
HDDINFORMATION
* 
pHDD
;

128 
MBR
* 
pMBR
;

129 
DWORD
 
dwTٮSeCou
,
dwRemaSeCou
;

130 
DWORD
 
dwMaxCluCou
,
dwCluCou
;

131 
DWORD
 
dwCluLkSeCou
;

132 
DWORD
 
i
;

135 
	`kLock
(&(
gs_FeSyemMag
.
Mux
));

140 
pHDD
 = (
HDDINFORMATION
*)
gs_vbTempBufr
;

141 if(
	`gs_pfRdHDDInfmi
(
TRUE
,TRUE,
pHDD
)==
FALSE
)

144 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

145  
FALSE
;

148 
dwTٮSeCou
 = 
pHDD
->
dwTٮSes
;

151 
dwMaxCluCou
 = 
dwTٮSeCou
 / 
FILESYSTEM_SECTORPERCLUSTER
;

156 
dwCluLkSeCou
 = (
dwMaxCluCou
+127)/128;

161 
dwRemaSeCou
 = 
dwTٮSeCou
 - 
dwCluLkSeCou
 -1;

162 
dwCluCou
 = 
dwRemaSeCou
/
FILESYSTEM_SECTORPERCLUSTER
;

165 
dwCluLkSeCou
 = (
dwCluCou
+127)/128;

172 if(
	`gs_pfRdHDDSe
(
TRUE
,TRUE,0,1,
gs_vbTempBufr
)==
FALSE
)

175 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

176  
FALSE
;

180 
pMBR
 = (
MBR
*)
gs_vbTempBufr
;

181 
	`kMemS
(
pMBR
->
vPt
,0,(pstMBR->vstPartiton));

182 
pMBR
->
dwSigtu
 = 
FILESYSTEM_SIGNATUR
;

183 
pMBR
->
dwRervedSeCou
 = 0;

184 
pMBR
->
dwCluLkSeCou
 = dwClusterLinkSectorCount;

185 
pMBR
->
dwTٮCluCou
 = 
dwCluCou
;

188 if(
	`gs_pfWreHDDSe
(
TRUE
,TRUE,0,1,
gs_vbTempBufr
)==
FALSE
)

191 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

192  
FALSE
;

196 
	`kMemS
(
gs_vbTempBufr
,0,512);

197 
i
=0;i<(
dwCluLkSeCou
+
FILESYSTEM_SECTORPERCLUSTER
);i++)

200 if(
i
==0)

202 ((
DWORD
*)(
gs_vbTempBufr
))[0]=
FILESYSTEM_LASTCLUSTER
;

206 ((
DWORD
*)(
gs_vbTempBufr
))[0]=
FILESYSTEM_FREECLUSTER
;

210 if(
	`gs_pfWreHDDSe
(
TRUE
,TRUE,
i
+1,1,
gs_vbTempBufr
)==
FALSE
)

213 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

214  
FALSE
;

219 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

220  
TRUE
;

221 
	}
}

224 
BOOL
 
	$kGHDDInfmi
(
HDDINFORMATION
* 
pInfmi
)

226 
BOOL
 
bResu
;

229 
	`kLock
(&(
gs_FeSyemMag
.
Mux
));

231 
bResu
 = 
	`gs_pfRdHDDInfmi
(
TRUE
,TRUE,
pInfmi
);

234 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

236  
bResu
;

237 
	}
}

240 
BOOL
 
	$kRdCluLkTab
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
)

243  
	`gs_pfRdHDDSe
(
TRUE
,TRUE,
dwOfft
+
gs_FeSyemMag
.
dwCluLkAaSAddss
,1,
pbBufr
);

244 
	}
}

247 
BOOL
 
	$kWreCluLkTab
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
)

250  
	`gs_pfWreHDDSe
(
TRUE
,TRUE,
dwOfft
+
gs_FeSyemMag
.
dwCluLkAaSAddss
,1,
pbBufr
);

251 
	}
}

254 
BOOL
 
	$kRdClu
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
)

257  
	`gs_pfRdHDDSe
(
TRUE
,TRUE,(
dwOfft
*
FILESYSTEM_SECTORPERCLUSTER
)+
gs_FeSyemMag
.
dwDaAaSAddss
,FILESYSTEM_SECTORPERCLUSTER,
pbBufr
);

258 
	}
}

261 
BOOL
 
	$kWreClu
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
)

264  
	`gs_pfWreHDDSe
(
TRUE
,TRUE,(
dwOfft
*
FILESYSTEM_SECTORPERCLUSTER
)+
gs_FeSyemMag
.
dwDaAaSAddss
,FILESYSTEM_SECTORPERCLUSTER,
pbBufr
);

265 
	}
}

268 
DWORD
 
	$kFdFeClu
()

270 
DWORD
 
dwLkCouInSe
;

271 
DWORD
 
dwLaSeOfft
,
dwCutSeOfft
;

272 
DWORD
 
i
,
j
;

275 if(
gs_FeSyemMag
.
bMoued
==
FALSE
)

277  
FILESYSTEM_LASTCLUSTER
;

281 
dwLaSeOfft
 = 
gs_FeSyemMag
.
dwLaAoduLkSeOfft
;

284 
i
=0;i<
gs_FeSyemMag
.
dwCluLkAaSize
;i++)

288 if((
dwLaSeOfft
+
i
)==(
gs_FeSyemMag
.
dwCluLkAaSize
-1))

290 
dwLkCouInSe
 = 
gs_FeSyemMag
.
dwTٮCluCou
%128;

294 
dwLkCouInSe
 = 128;

298 
dwCutSeOfft
 = (
dwLaSeOfft
+
i
)%
gs_FeSyemMag
.
dwCluLkAaSize
;

299 if(
	`kRdCluLkTab
(
dwCutSeOfft
,
gs_vbTempBufr
)==
FALSE
)

301  
FILESYSTEM_LASTCLUSTER
;

305 
j
=0;j<
dwLkCouInSe
;j++)

307 if(((
DWORD
*)
gs_vbTempBufr
)[
j
]==
FILESYSTEM_FREECLUSTER
)

314 if(
j
!=
dwLkCouInSe
)

317 
gs_FeSyemMag
.
dwLaAoduLkSeOfft
 = 
dwCutSeOfft
;

320  (
dwCutSeOfft
*128)+
j
;

324  
FILESYSTEM_LASTCLUSTER
;

325 
	}
}

328 
BOOL
 
	$kSCluLkDa
(
DWORD
 
dwCluIndex
,DWORD 
dwDa
)

330 
DWORD
 
dwSeOfft
;

333 if(
gs_FeSyemMag
.
bMoued
==
FALSE
)

335 
	`kPrtf
("FileSystemot mounted\n");

336  
FALSE
;

340 
dwSeOfft
 = 
dwCluIndex
/128;

343 if(
	`kRdCluLkTab
(
dwSeOfft
,
gs_vbTempBufr
)==
FALSE
)

345 
	`kPrtf
("kReadClusterLinkTablerror\n");

346  
FALSE
;

349 ((
DWORD
*)
gs_vbTempBufr
)[
dwCluIndex
%128]=
dwDa
;

351 if(
	`kWreCluLkTab
(
dwSeOfft
,
gs_vbTempBufr
)==
FALSE
)

353 
	`kPrtf
("kWriteClusterLinkTablerror\n");

354  
FALSE
;

357  
TRUE
;

358 
	}
}

361 
BOOL
 
	$kGCluLkDa
(
DWORD
 
dwCluIndex
,DWORD* 
pdwDa
)

363 
DWORD
 
dwSeOfft
;

366 if(
gs_FeSyemMag
.
bMoued
==
FALSE
)

368  
FALSE
;

372 
dwSeOfft
 = 
dwCluIndex
/128;

374 if(
dwSeOfft
>
gs_FeSyemMag
.
dwCluLkAaSize
)

376  
FALSE
;

380 if(
	`kRdCluLkTab
(
dwSeOfft
,
gs_vbTempBufr
)==
FALSE
)

382  
FALSE
;

385 *
pdwDa
 = ((
DWORD
*)
gs_vbTempBufr
)[
dwCluIndex
%128];

386  
TRUE
;

387 
	}
}

390 
	$kFdFeDeyEry
()

392 
DIRECTORYENTRY
* 
pEry
;

393 
i
;

396 if(
gs_FeSyemMag
.
bMoued
==
FALSE
)

402 if(
	`kRdClu
(0,
gs_vbTempBufr
)==
FALSE
)

408 
pEry
 = (
DIRECTORYENTRY
*)
gs_vbTempBufr
;

409 
i
=0;i<
FILESYSTEM_MAXDIRECTORYENTRYCOUNT
;i++)

411 if(
pEry
[
i
].
dwSCluIndex
==0)

413  
i
;

418 
	}
}

421 
BOOL
 
	$kSDeyEryDa
(
iIndex
,
DIRECTORYENTRY
* 
pEry
)

423 
DIRECTORYENTRY
* 
pRoEry
;

426 if((
gs_FeSyemMag
.
bMoued
==
FALSE
)||(
iIndex
<0)||(iIndex>=
FILESYSTEM_MAXDIRECTORYENTRYCOUNT
))

428 
	`kPrtf
("FeSyem moued (Index=%d)\n",
iIndex
);

429  
FALSE
;

433 if(
	`kRdClu
(0,
gs_vbTempBufr
)==
FALSE
)

435 
	`kPrtf
("kReadClusterrror\n");

436  
FALSE
;

440 
pRoEry
 = (
DIRECTORYENTRY
*)
gs_vbTempBufr
;

441 
	`kMemCpy
(
pRoEry
+
iIndex
,
pEry
,(
DIRECTORYENTRY
));

444 if(
	`kWreClu
(0,
gs_vbTempBufr
)==
FALSE
)

446 
	`kPrtf
("kWriteClusterrror\n");

447  
FALSE
;

450  
TRUE
;

451 
	}
}

454 
BOOL
 
	$kGDeyEryDa
(
iIndex
,
DIRECTORYENTRY
* 
pEry
)

456 
DIRECTORYENTRY
* 
pRoEry
;

459 if((
gs_FeSyemMag
.
bMoued
==
FALSE
)||(
iIndex
<0)||(iIndex>=
FILESYSTEM_MAXDIRECTORYENTRYCOUNT
))

461  
FALSE
;

465 if(
	`kRdClu
(0,
gs_vbTempBufr
)==
FALSE
)

467  
FALSE
;

471 
pRoEry
 = (
DIRECTORYENTRY
*)
gs_vbTempBufr
;

472 
	`kMemCpy
(
pEry
,
pRoEry
+
iIndex
,(
DIRECTORYENTRY
));

473  
TRUE
;

474 
	}
}

477 
	$kFdDeyEry
(cڡ * 
pcFeName
,
DIRECTORYENTRY
* 
pEry
)

479 
DIRECTORYENTRY
* 
pRoEry
;

480 
i
;

481 
iLgth
;

484 if(
gs_FeSyemMag
.
bMoued
==
FALSE
)

490 if(
	`kRdClu
(0,
gs_vbTempBufr
)==
FALSE
)

495 
iLgth
 = 
	`kSL
(
pcFeName
);

497 
pRoEry
 = (
DIRECTORYENTRY
*)
gs_vbTempBufr
;

498 
i
=0;i<
FILESYSTEM_MAXDIRECTORYENTRYCOUNT
;i++)

500 if(
	`kMemCmp
(
pRoEry
[
i
].
vcFeName
,
pcFeName
,
iLgth
)==0)

502 
	`kMemCpy
(
pEry
,
pRoEry
+
i
,(
DIRECTORYENTRY
));

507 
	}
}

510 
	$kGFeSyemInfmi
(
FILESYSTEMMANAGER
* 
pMag
)

512 
	`kMemCpy
(
pMag
,&
gs_FeSyemMag
,(gs_stFileSystemManager));

513 
	}
}

519 * 
	$kAoFeDeyHd
()

521 
i
;

522 
FILE
* 
pFe
;

525 
pFe
 = 
gs_FeSyemMag
.
pHdPo
;

526 
i
=0;i<
FILESYSTEM_HANDLE_MAXCOUNT
;i++)

529 if(
pFe
->
bTy
 =
FILESYSTEM_TYPE_FREE
)

531 
pFe
->
bTy
 = 
FILESYSTEM_TYPE_FILE
;

532  
pFe
;

536 
pFe
++;

539  
NULL
;

540 
	}
}

543 
	$kFeFeDeyHd
(
FILE
* 
pFe
)

546 
	`kMemS
(
pFe
,0,(
FILE
));

549 
pFe
->
bTy
 = 
FILESYSTEM_TYPE_FREE
;

550 
	}
}

553 
BOOL
 
	$kCeFe
(cڡ * 
pcFeName
,
DIRECTORYENTRY
* 
pEry
,* 
piDeyEryIndex
)

555 
DWORD
 
dwClu
;

558 
dwClu
 = 
	`kFdFeClu
();

559 if((
dwClu
==
FILESYSTEM_LASTCLUSTER
)||(
	`kSCluLkDa
(dwClu,FILESYSTEM_LASTCLUSTER)==
FALSE
))

561  
FALSE
;

565 *
piDeyEryIndex
 = 
	`kFdFeDeyEry
();

566 if(*
piDeyEryIndex
==-1)

569 
	`kSCluLkDa
(
dwClu
,
FILESYSTEM_FREECLUSTER
);

570  
FALSE
;

574 
	`kMemCpy
(
pEry
->
vcFeName
,
pcFeName
,
	`kSL
(pcFileName)+1);

575 
pEry
->
dwSCluIndex
 = 
dwClu
;

576 
pEry
->
dwFeSize
 = 0;

579 if(
	`kSDeyEryDa
(*
piDeyEryIndex
,
pEry
)==
FALSE
)

582 
	`kSCluLkDa
(
dwClu
,
FILESYSTEM_FREECLUSTER
);

583  
FALSE
;

586  
TRUE
;

587 
	}
}

590 
BOOL
 
	$kFeCluUtEnd
(
DWORD
 
dwCluIndex
)

592 
DWORD
 
dwCutCluIndex
;

593 
DWORD
 
dwNextCluIndex
;

596 
dwCutCluIndex
 = 
dwCluIndex
;

598 
dwCutCluIndex
!=
FILESYSTEM_LASTCLUSTER
)

601 if(
	`kGCluLkDa
(
dwCutCluIndex
,&
dwNextCluIndex
)==
FALSE
)

603  
FALSE
;

607 if(
	`kSCluLkDa
(
dwCutCluIndex
,
FILESYSTEM_FREECLUSTER
)==
FALSE
)

609  
FALSE
;

613 
dwCutCluIndex
 = 
dwNextCluIndex
;

616  
TRUE
;

617 
	}
}

620 
FILE
* 
	$kOnFe
(cڡ * 
pcFeName
,cڡ * 
pcMode
)

622 
DIRECTORYENTRY
 
Ery
;

623 
iDeyEryOfft
;

624 
iFeNameLgth
;

625 
DWORD
 
dwSecdClu
;

626 
FILE
* 
pFe
;

629 
iFeNameLgth
 = 
	`kSL
(
pcFeName
);

630 if((
iFeNameLgth
>((
Ery
.
vcFeName
)-1))||(iFileNameLength==0))

632  
NULL
;

636 
	`kLock
(&(
gs_FeSyemMag
.
Mux
));

641 
iDeyEryOfft
 = 
	`kFdDeyEry
(
pcFeName
,&
Ery
);

642 if(
iDeyEryOfft
==-1)

645 if(
pcMode
[0]=='r')

648 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

649  
NULL
;

653 if(
	`kCeFe
(
pcFeName
,&
Ery
,&
iDeyEryOfft
)==
FALSE
)

656 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

657  
NULL
;

663 if(
pcMode
[0]=='w')

666 if(
	`kGCluLkDa
(
Ery
.
dwSCluIndex
,&
dwSecdClu
)==
FALSE
)

669 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

670  
NULL
;

674 if(
	`kSCluLkDa
(
Ery
.
dwSCluIndex
,
FILESYSTEM_LASTCLUSTER
)==
FALSE
)

677 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

678  
NULL
;

682 if(
	`kFeCluUtEnd
(
dwSecdClu
)==
FALSE
)

685 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

686  
NULL
;

690 
Ery
.
dwFeSize
 = 0;

691 if(
	`kSDeyEryDa
(
iDeyEryOfft
,&
Ery
)==
FALSE
)

694 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

695  
NULL
;

703 
pFe
 = 
	`kAoFeDeyHd
();

704 if(
pFe
==
NULL
)

707 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

708  
NULL
;

712 
pFe
->
bTy
 = 
FILESYSTEM_TYPE_FILE
;

713 
pFe
->
FeHd
.
iDeyEryOfft
 = iDirectoryEntryOffset;

714 
pFe
->
FeHd
.
dwFeSize
 = 
Ery
.dwFileSize;

715 
pFe
->
FeHd
.
dwSCluIndex
 = 
Ery
.dwStartClusterIndex;

716 
pFe
->
FeHd
.
dwCutCluIndex
 = 
Ery
.
dwSCluIndex
;

717 
pFe
->
FeHd
.
dwPviousCluIndex

Ery
.
dwSCluIndex
;

718 
pFe
->
FeHd
.
dwCutOfft
 =0;

721 if(
pcMode
[0]=='a')

723 
	`kSkFe
(
pFe
,0,
FILESYSTEM_SEEK_END
);

727 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

728  
pFe
;

729 
	}
}

732 
DWORD
 
	$kRdFe
(* 
pvBufr
,
DWORD
 
dwSize
,DWORD 
dwCou
,
FILE
* 
pFe
)

734 
DWORD
 
dwTٮCou
;

735 
DWORD
 
dwRdCou
;

736 
DWORD
 
dwOfftInClu
;

737 
DWORD
 
dwCySize
;

738 
FILEHANDLE
* 
pFeHd
;

739 
DWORD
 
dwNextCluIndex
;

742 if((
pFe
==
NULL
)||աFe->
bTy
!=
FILESYSTEM_TYPE_FILE
))

747 
pFeHd
 = &(
pFe
->
FeHd
);

750 if((
pFeHd
->
dwCutOfft
=FeHd->
dwFeSize
)||աFeHd->
dwCutCluIndex
==
FILESYSTEM_LASTCLUSTER
))

756 
dwTٮCou
 = 
	`MIN
(
dwSize
*
dwCou
,
pFeHd
->
dwFeSize
-pFeHd->
dwCutOfft
);

759 
	`kLock
(&(
gs_FeSyemMag
.
Mux
));

762 
dwRdCou
=0;

763 
dwRdCou
!=
dwTٮCou
)

769 if(
	`kRdClu
(
pFeHd
->
dwCutCluIndex
,
gs_vbTempBufr
)==
FALSE
)

775 
dwOfftInClu
 = 
pFeHd
->
dwCutOfft
%
FILESYSTEM_CLUSTERSIZE
;

778 
dwCySize
 = 
	`MIN
(
FILESYSTEM_CLUSTERSIZE
-
dwOfftInClu
,
dwTٮCou
-
dwRdCou
);

780 
	`kMemCpy
((*)
pvBufr
+
dwRdCou
,
gs_vbTempBufr
+
dwOfftInClu
,
dwCySize
);

783 
dwRdCou
 +=
dwCySize
;

784 
pFeHd
->
dwCutOfft
 +=
dwCySize
;

789 if((
pFeHd
->
dwCutOfft
%
FILESYSTEM_CLUSTERSIZE
)==0)

792 if(
	`kGCluLkDa
(
pFeHd
->
dwCutCluIndex
,&
dwNextCluIndex
)==
FALSE
)

798 
pFeHd
->
dwPviousCluIndex
FeHd->
dwCutCluIndex
;

799 
pFeHd
->
dwCutCluIndex
=
dwNextCluIndex
;

804 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

807  
dwRdCou
;

808 
	}
}

811 
BOOL
 
	$kUpdeDeyEry
(
FILEHANDLE
* 
pFeHd
)

813 
DIRECTORYENTRY
 
Ery
;

816 if((
pFeHd
==
NULL
)||(
	`kGDeyEryDa
աFeHd->
iDeyEryOfft
,&
Ery
)==
FALSE
))

818  
FALSE
;

822 
Ery
.
dwFeSize
 = 
pFeHd
->dwFileSize;

823 
Ery
.
dwSCluIndex
 = 
pFeHd
->dwStartClusterIndex;

826 if(
	`kSDeyEryDa
(
pFeHd
->
iDeyEryOfft
,&
Ery
)==
FALSE
)

828  
FALSE
;

831  
TRUE
;

832 
	}
}

835 
DWORD
 
	$kWreFe
(cڡ * 
pvBufr
,
DWORD
 
dwSize
,DWORD 
dwCou
,
FILE
* 
pFe
)

837 
DWORD
 
dwWreCou
;

838 
DWORD
 
dwTٮCou
;

839 
DWORD
 
dwOfftInClu
;

840 
DWORD
 
dwCySize
;

841 
DWORD
 
dwAodCluIndex
;

842 
DWORD
 
dwNextCluIndex
;

843 
DWORD
 
dwUFeSize
;

844 
FILEHANDLE
* 
pFeHd
;

847 if((
pFe
==
NULL
)||աFe->
bTy
!=
FILESYSTEM_TYPE_FILE
))

852 
pFeHd
 = &(
pFe
->
FeHd
);

855 if(
pFeHd
->
dwFeSize
==0)

857 
dwUFeSize
=
FILESYSTEM_CLUSTERSIZE
;

861 
dwUFeSize
 = ((
pFeHd
->
dwFeSize
+
FILESYSTEM_CLUSTERSIZE
-1)/FILESYSTEM_CLUSTERSIZE)*FILESYSTEM_CLUSTERSIZE;

865 
dwTٮCou
 = 
dwSize
*
dwCou
;

868 
	`kLock
(&(
gs_FeSyemMag
.
Mux
));

871 
dwWreCou
=0;

872 
dwWreCou
!=
dwTٮCou
)

875 if(
dwUFeSize
<=
pFeHd
->
dwCutOfft
)

878 
dwAodCluIndex
 = 
	`kFdFeClu
();

879 if(
dwAodCluIndex
==
FILESYSTEM_LASTCLUSTER
)

885 if(
	`kSCluLkDa
(
dwAodCluIndex
,
FILESYSTEM_LASTCLUSTER
)==
FALSE
)

891 if(
	`kSCluLkDa
(
pFeHd
->
dwPviousCluIndex
,
dwAodCluIndex
)==
FALSE
)

894 
	`kSCluLkDa
(
dwAodCluIndex
,
FILESYSTEM_FREECLUSTER
);

899 
pFeHd
->
dwCutCluIndex
 = 
dwAodCluIndex
;

904 if(
pFeHd
->
dwCutOfft
%
FILESYSTEM_CLUSTERSIZE
!=0)

906 if(
pFeHd
->
dwCutCluIndex
==
FILESYSTEM_LASTCLUSTER
)

908 if(
	`kRdClu
(
pFeHd
->
dwPviousCluIndex
,
gs_vbTempBufr
)==
FALSE
)

917 if(
	`kRdClu
(
pFeHd
->
dwCutCluIndex
,
gs_vbTempBufr
)==
FALSE
)

926 
dwOfftInClu
 = 
pFeHd
->
dwCutOfft
%
FILESYSTEM_CLUSTERSIZE
;

929 
dwCySize
 = 
	`MIN
(
FILESYSTEM_CLUSTERSIZE
-
dwOfftInClu
,
dwTٮCou
-
dwWreCou
);

930 
	`kMemCpy
(
gs_vbTempBufr
+
dwOfftInClu
,(*)
pvBufr
+
dwWreCou
,
dwCySize
);

933 if(
	`kWreClu
(
pFeHd
->
dwCutCluIndex
,
gs_vbTempBufr
)==
FALSE
)

939 
dwWreCou
+=
dwCySize
;

940 
pFeHd
->
dwCutOfft
+=
dwCySize
;

942 if(
	`kGCluLkDa
(
pFeHd
->
dwCutCluIndex
,&
dwNextCluIndex
)==
FALSE
)

948 
pFeHd
->
dwPviousCluIndex
 =FeHd->
dwCutCluIndex
;

949 
pFeHd
->
dwCutCluIndex
 = 
dwNextCluIndex
;

955 if(
pFeHd
->
dwFeSize
<pFeHd->
dwCutOfft
)

957 
pFeHd
->
dwFeSize
FeHd->
dwCutOfft
;

958 
	`kUpdeDeyEry
(
pFeHd
);

962 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

963  
dwWreCou
;

964 
	}
}

967 
BOOL
 
	$kWreZo
(
FILE
* 
pFe
,
DWORD
 
dwCou
)

969 
BYTE
* 
pbBufr
;

970 
DWORD
 
dwRemaCou
;

971 
DWORD
 
dwWreCou
;

974 if(
pFe
==
NULL
)

976  
FALSE
;

980 
pbBufr
 = (
BYTE
*)
	`kAoMemy
(
FILESYSTEM_CLUSTERSIZE
);

981 if(
pbBufr
==
NULL
)

983  
FALSE
;

987 
	`kMemS
(
pbBufr
,0,
FILESYSTEM_CLUSTERSIZE
);

988 
dwRemaCou
 = 
dwCou
;

991 
dwRemaCou
!=0)

993 
dwWreCou
 = 
	`MIN
(
dwRemaCou
,
FILESYSTEM_CLUSTERSIZE
);

994 if(
	`kWreFe
(
pbBufr
,1,
dwWreCou
,
pFe
)!=dwWriteCount)

996 
	`kFeMemy
(
pbBufr
);

997  
FALSE
;

1000 
dwRemaCou
 ==
dwWreCou
;

1003 
	`kFeMemy
(
pbBufr
);

1004  
TRUE
;

1005 
	}
}

1008 
	$kSkFe
(
FILE
* 
pFe
,
iOfft
,
iOrig
)

1010 
DWORD
 
dwRlOfft
;

1011 
DWORD
 
dwCluOfftToMove
;

1012 
DWORD
 
dwCutCluOfft
;

1013 
DWORD
 
dwLaCluOfft
;

1014 
DWORD
 
dwMoveCou
;

1015 
DWORD
 
i
;

1016 
DWORD
 
dwSCluIndex
;

1017 
DWORD
 
dwPviousCluIndex
;

1018 
DWORD
 
dwCutCluIndex
;

1019 
FILEHANDLE
* 
pFeHd
;

1022 if((
pFe
==
NULL
)||աFe->
bTy
!=
FILESYSTEM_TYPE_FILE
))

1027 
pFeHd
 = &(
pFe
->
FeHd
);

1034 
iOrig
)

1037 
FILESYSTEM_SEEK_SET
:

1039 if(
iOfft
<=0)

1041 
dwRlOfft
=0;

1045 
dwRlOfft
=
iOfft
;

1050 
FILESYSTEM_SEEK_CUR
:

1053 if((
iOfft
<=0)&&(
pFeHd
->
dwCutOfft
<=(
DWORD
)-iOffset))

1055 
dwRlOfft
=0;

1059 
dwRlOfft
 = 
pFeHd
->
dwCutOfft
+
iOfft
;

1064 
FILESYSTEM_SEEK_END
:

1067 if((
iOfft
<0)&&(
pFeHd
->
dwFeSize
<=(
DWORD
)-iOffset))

1069 
dwRlOfft
=0;

1073 
dwRlOfft
 = 
pFeHd
->
dwFeSize
+
iOfft
;

1083 
dwLaCluOfft
 = 
pFeHd
->
dwFeSize
/
FILESYSTEM_CLUSTERSIZE
;

1085 
dwCluOfftToMove
 = 
dwRlOfft
/
FILESYSTEM_CLUSTERSIZE
;

1087 
dwCutCluOfft
 = 
pFeHd
->
dwCutOfft
/
FILESYSTEM_CLUSTERSIZE
;

1091 if(
dwLaCluOfft
<
dwCluOfftToMove
)

1093 
dwMoveCou
 = 
dwLaCluOfft
-
dwCutCluOfft
;

1094 
dwSCluIndex
 = 
pFeHd
->
dwCutCluIndex
;

1098 if(
dwCutCluOfft
<=
dwCluOfftToMove
)

1100 
dwMoveCou
 = 
dwCluOfftToMove
-
dwCutCluOfft
;

1101 
dwSCluIndex
 = 
pFeHd
->
dwCutCluIndex
;

1106 
dwMoveCou
 = 
dwCluOfftToMove
;

1107 
dwSCluIndex
 = 
pFeHd
->dwStartClusterIndex;

1111 
	`kLock
(&(
gs_FeSyemMag
.
Mux
));

1114 
dwCutCluIndex
 = 
dwSCluIndex
;

1115 
i
=0;i<
dwMoveCou
;i++)

1118 
dwPviousCluIndex
 = 
dwCutCluIndex
;

1121 if(
	`kGCluLkDa
(
dwPviousCluIndex
,&
dwCutCluIndex
)==
FALSE
)

1124 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1130 if(
dwMoveCou
>0)

1132 
pFeHd
->
dwPviousCluIndex
 = dwPreviousClusterIndex;

1133 
pFeHd
->
dwCutCluIndex
 = dwCurrentClusterIndex;

1136 if(
dwSCluIndex
==
pFeHd
->dwStartClusterIndex)

1138 
pFeHd
->
dwPviousCluIndex
 =FeHd->
dwSCluIndex
;

1139 
pFeHd
->
dwCutCluIndex
 =FeHd->
dwSCluIndex
;

1147 if(
dwLaCluOfft
<
dwCluOfftToMove
)

1149 
pFeHd
->
dwCutOfft
 =FeHd->
dwFeSize
;

1151 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1154 if(
	`kWreZo
(
pFe
,
dwRlOfft
-
pFeHd
->
dwFeSize
)==
FALSE
)

1160 
pFeHd
->
dwCutOfft
 = 
dwRlOfft
;

1163 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1166 
	}
}

1169 
	$kCloFe
(
FILE
* 
pFe
)

1172 if((
pFe
==
NULL
)||աFe->
bTy
!=
FILESYSTEM_TYPE_FILE
))

1178 
	`kFeFeDeyHd
(
pFe
);

1180 
	}
}

1183 
BOOL
 
	$kIsFeOd
(cڡ 
DIRECTORYENTRY
* 
pEry
)

1185 
i
;

1186 
FILE
* 
pFe
;

1189 
pFe
 = 
gs_FeSyemMag
.
pHdPo
;

1190 
i
=0;i<
FILESYSTEM_HANDLE_MAXCOUNT
;i++)

1193 if((
pFe
[
i
].
bTy
==
FILESYSTEM_TYPE_FILE
)&&աFe[i].
FeHd
.
dwSCluIndex
==
pEry
->dwStartClusterIndex))

1195  
TRUE
;

1199  
FALSE
;

1200 
	}
}

1203 
	$kRemoveFe
(cڡ * 
pcFeName
)

1205 
DIRECTORYENTRY
 
Ery
;

1206 
iDeyEryOfft
;

1207 
iFeNameLgth
;

1210 
iFeNameLgth
 = 
	`kSL
(
pcFeName
);

1211 if((
iFeNameLgth
>((
Ery
.
vcFeName
)-1))||(iFileNameLength==0))

1213  
NULL
;

1217 
	`kLock
(&(
gs_FeSyemMag
.
Mux
));

1220 
iDeyEryOfft
 = 
	`kFdDeyEry
(
pcFeName
,&
Ery
);

1221 if(
iDeyEryOfft
==-1)

1224 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1229 if(
	`kIsFeOd
(&
Ery
)==
TRUE
)

1232 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1237 if(
	`kFeCluUtEnd
(
Ery
.
dwSCluIndex
)==
FALSE
)

1240 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1245 
	`kMemS
(&
Ery
,0,(stEntry));

1246 if(
	`kSDeyEryDa
(
iDeyEryOfft
,&
Ery
)==
FALSE
)

1249 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1254 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1256 
	}
}

1259 
DIR
* 
	$kOnDey
(cڡ * 
pcDeyName
)

1261 
DIR
* 
pDey
;

1262 
DIRECTORYENTRY
* 
pDeyBufr
;

1265 
	`kLock
(&(
gs_FeSyemMag
.
Mux
));

1268 
pDey
 = 
	`kAoFeDeyHd
();

1269 if(
pDey
==
NULL
)

1272 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1273  
NULL
;

1277 
pDeyBufr
 = (
DIRECTORYENTRY
*)
	`kAoMemy
(
FILESYSTEM_CLUSTERSIZE
);

1278 if(
pDeyBufr
==
NULL
)

1281 
	`kFeFeDeyHd
(
pDey
);

1283 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1284  
NULL
;

1288 if(
	`kRdClu
(0,(
BYTE
*)
pDeyBufr
)==
FALSE
)

1291 
	`kFeFeDeyHd
(
pDey
);

1292 
	`kFeMemy
(
pDeyBufr
);

1295 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1296  
NULL
;

1300 
pDey
->
bTy
 = 
FILESYSTEM_TYPE_DIRECTORY
;

1301 
pDey
->
DeyHd
.
iCutOfft
 = 0;

1302 
pDey
->
DeyHd
.
pDeyBufr
 =stDirectoryBuffer;

1305 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1306  
pDey
;

1307 
	}
}

1310 
kDeyErySu
* 
	$kRdDey
(
DIR
* 
pDey
)

1312 
DIRECTORYHANDLE
* 
pDeyHd
;

1313 
DIRECTORYENTRY
* 
pEry
;

1316 if((
pDey
==
NULL
)||աDey->
bTy
!=
FILESYSTEM_TYPE_DIRECTORY
))

1318  
NULL
;

1321 
pDeyHd
 = &(
pDey
->
DeyHd
);

1324 if((
pDeyHd
->
iCutOfft
<0)||աDeyHd->iCutOfft>=
FILESYSTEM_MAXDIRECTORYENTRYCOUNT
))

1326  
NULL
;

1330 
	`kLock
(&(
gs_FeSyemMag
.
Mux
));

1333 
pEry
 = 
pDeyHd
->
pDeyBufr
;

1334 
pDeyHd
->
iCutOfft
<
FILESYSTEM_MAXDIRECTORYENTRYCOUNT
)

1337 if(
pEry
[
pDeyHd
->
iCutOfft
].
dwSCluIndex
!=0)

1340 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1341  &(
pEry
[
pDeyHd
->
iCutOfft
++]);

1344 
pDeyHd
->
iCutOfft
++;

1348 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1349  
NULL
;

1350 
	}
}

1353 
	$kRewdDey
(
DIR
* 
pDey
)

1355 
DIRECTORYHANDLE
* 
pDeyHd
;

1358 if((
pDey
==
NULL
)||աDey->
bTy
!=
FILESYSTEM_TYPE_DIRECTORY
))

1363 
pDeyHd
=&(
pDey
->
DeyHd
);

1366 
	`kLock
(&(
gs_FeSyemMag
.
Mux
));

1369 
pDeyHd
->
iCutOfft
=0;

1372 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1373 
	}
}

1376 
	$kCloDey
(
DIR
* 
pDey
)

1378 
DIRECTORYHANDLE
* 
pDeyHd
;

1381 if((
pDey
==
NULL
)||աDey->
bTy
!=
FILESYSTEM_TYPE_DIRECTORY
))

1386 
pDeyHd
 = &(
pDey
->
DeyHd
);

1389 
	`kLock
(&(
gs_FeSyemMag
.
Mux
));

1392 
	`kFeMemy
(
pDeyHd
->
pDeyBufr
);

1393 
	`kFeFeDeyHd
(
pDey
);

1396 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1399 
	}
}

	@/home/jk/os/MINT64/02.Kernel64/Source/FileSystem.h

1 #ide
__FILESYSTEM_H__


2 
	#__FILESYSTEM_H__


	)

4 
	~"Tys.h
"

5 
	~"Synchrizi.h
"

6 
	~"HdDisk.h
"

10 
	#FILESYSTEM_SIGNATUR
 0x7E38CF10

	)

12 
	#FILESYSTEM_SECTORPERCLUSTER
 8

	)

14 
	#FILESYSTEM_LASTCLUSTER
 0xFFFFFFFF

	)

16 
	#FILESYSTEM_FREECLUSTER
 0x00

	)

18 
	#FILESYSTEM_MAXDIRECTORYENTRYCOUNT
 ((
FILESYSTEM_SECTORPERCLUSTER
*512)/(
DIRECTORYENTRY
))

	)

20 
	#FILESYSTEM_CLUSTERSIZE
 (
FILESYSTEM_SECTORPERCLUSTER
*512)

	)

23 
	#FILESYSTEM_HANDLE_MAXCOUNT
 (
TASK_MAXCOUNT
*3)

	)

26 
	#FILESYSTEM_MAXFILENAMELENGTH
 24

	)

29 
	#FILESYSTEM_TYPE_FREE
 0

	)

30 
	#FILESYSTEM_TYPE_FILE
 1

	)

31 
	#FILESYSTEM_TYPE_DIRECTORY
 2

	)

34 
	#FILESYSTEM_SEEK_SET
 0

	)

35 
	#FILESYSTEM_SEEK_CUR
 1

	)

36 
	#FILESYSTEM_SEEK_END
 2

	)

39 
	$BOOL
 (*
	tfRdHDDInfmi
(
	tBOOL
 
	tbPrimy
,BOOL 
	tbMa
,
	tHDDINFORMATION
* 
	tpHDDInfmi
);

40 (*
	tfRdHDDSe
(
	tBOOL
 
	tbPrimy
,BOOL 
	tbMa
,
	tDWORD
 
	tdwLBA
,
	tiSeCou
,* 
	tpcBufr
);

41 (*
	tfWreHDDSe
(
	tBOOL
 
	tbPrimy
,BOOL 
	tbMa
,
	tDWORD
 
	tdwLBA
,
	tiSeCou
,* 
	tpcBufr
);

44 
	#fݒ
 
kOnFe


	)

45 
	#d
 
kRdFe


	)

46 
	#fwre
 
kWreFe


	)

47 
	#fek
 
kSkFe


	)

48 
	#fo
 
kCloFe


	)

49 
	#move
 
kRemoveFe


	)

50 
	#ݒd
 
kOnDey


	)

51 
	#add
 
kRdDey


	)

52 
	#wdd
 
kRewdDey


	)

53 
	#od
 
kCloDey


	)

56 
	#SEEK_SET
 
FILESYSTEM_SEEK_SET


	)

57 
	#SEEK_CUR
 
FILESYSTEM_SEEK_CUR


	)

58 
	#SEEK_END
 
FILESYSTEM_SEEK_END


	)

61 
	#size_t
 
DWORD


	)

62 
	#dt
 
kDeyErySu


	)

63 
	#d_me
 
vcFeName


	)

67 #agm
	`ck
(
push
,1)

70 
	skPtiSu


73 
BYTE
 
bBoabFg
;

75 
BYTE
 
vbSgCHSAddss
[3];

77 
BYTE
 
bPtiTy
;

79 
BYTE
 
vbEndgCHSAddss
[3];

81 
DWORD
 
dwSgLBAAddss
;

83 
DWORD
 
dwSizeInSe
;

84 } 
	tPARTITION
;

87 
	skMBRSu


90 
BYTE
 
vbBoCode
[430];

93 
DWORD
 
dwSigtu
;

95 
DWORD
 
dwRervedSeCou
;

97 
DWORD
 
dwCluLkSeCou
;

99 
DWORD
 
dwTٮCluCou
;

102 
PARTITION
 
vPt
[4];

105 
BYTE
 
vbBoLdSigtu
[2];

106 } 
	tMBR
;

109 
	skDeyErySu


112 
vcFeName
[
FILESYSTEM_MAXFILENAMELENGTH
];

114 
DWORD
 
dwFeSize
;

116 
DWORD
 
dwSCluIndex
;

117 } 
	tDIRECTORYENTRY
;

120 
	skFeHdSu


123 
iDeyEryOfft
;

125 
DWORD
 
dwFeSize
;

127 
DWORD
 
dwSCluIndex
;

129 
DWORD
 
dwCutCluIndex
;

131 
DWORD
 
dwPviousCluIndex
;

133 
DWORD
 
dwCutOfft
;

134 } 
	tFILEHANDLE
;

137 
	skDeyHdSu


140 
DIRECTORYENTRY
* 
pDeyBufr
;

143 
iCutOfft
;

144 } 
	tDIRECTORYHANDLE
;

147 
	skFeDeyHdSu


150 
BYTE
 
bTy
;

156 
FILEHANDLE
 
FeHd
;

158 
DIRECTORYHANDLE
 
DeyHd
;

160 } 
	tFILE
, 
	tDIR
;

164 
	skFeSyemMagSu


167 
BOOL
 
bMoued
;

170 
DWORD
 
dwRervedSeCou
;

171 
DWORD
 
dwCluLkAaSAddss
;

172 
DWORD
 
dwCluLkAaSize
;

173 
DWORD
 
dwDaAaSAddss
;

175 
DWORD
 
dwTٮCluCou
;

178 
DWORD
 
dwLaAoduLkSeOfft
;

181 
MUTEX
 
Mux
;

184 
FILE
* 
pHdPo
;

185 } 
	tFILESYSTEMMANAGER
;

187 #agm
	`ck
(
p
)

190 
BOOL
 
	`kInlizeFeSyem
();

191 
BOOL
 
	`kFm
();

192 
BOOL
 
	`kMou
();

193 
BOOL
 
	`kGHDDInfmi
(
HDDINFORMATION
* 
pInfmi
);

196 
	`kGFeSyemInfmi
(
FILESYSTEMMANAGER
* 
pMag
);

199 
FILE
* 
	`kOnFe
(cڡ * 
pcFeName
,cڡ * 
pcMode
);

200 
DWORD
 
	`kRdFe
(* 
pvBufr
,DWORD 
dwSize
,DWORD 
dwCou
,
FILE
* 
pFe
);

201 
DWORD
 
	`kWreFe
(cڡ * 
pvBufr
,DWORD 
dwSize
,DWORD 
dwCou
,
FILE
* 
pFe
);

202 
	`kSkFe
(
FILE
* 
pFe
,
iOfft
,
iOrig
);

203 
	`kCloFe
(
FILE
* 
pFe
);

204 
	`kRemoveFe
(cڡ * 
pcFeName
);

205 
DIR
* 
	`kOnDey
(cڡ * 
pcDeyName
);

206 
kDeyErySu
* 
	`kRdDey
(
DIR
* 
pDey
);

207 
	`kRewdDey
(
DIR
* 
pDey
);

208 
	`kCloDey
(
DIR
* 
pDey
);

209 
BOOL
 
	`kWreZo
(
FILE
* 
pFe
,
DWORD
 
dwCou
);

210 
BOOL
 
	`kIsFeOd
(cڡ 
DIRECTORYENTRY
* 
pEry
);

	@/home/jk/os/MINT64/02.Kernel64/Source/HardDisk.c

1 
	~"HdDisk.h
"

4 
HDDMANAGER
 
	ggs_HDDMag
;

7 
kSwByInWd
(
WORD
* 
pwDa
,
iWdCou
);

8 
BYTE
 
kRdHDDStus
(
BOOL
 
bPrimy
);

9 
BOOL
 
kIsHDDBusy
(BOOL 
bPrimy
);

10 
BOOL
 
kISHDDRdy
(BOOL 
bPrimy
);

11 
BOOL
 
kWaFHDDNoBusy
(BOOL 
bPrimy
);

12 
BOOL
 
kWaFHDDIru
(BOOL 
bPrimy
);

15 
BOOL
 
	$kInlizeHDD
()

18 
	`kInlizeMux
(&(
gs_HDDMag
.
Mux
));

21 
gs_HDDMag
.
bPrimyIruOccur
 = 
FALSE
;

22 
gs_HDDMag
.
bSecdyIruOccur
 = 
FALSE
;

26 
	`kOutPtBy
(
HDD_PORT_PRIMARYBASE
+
HDD_PORT_INDEX_DIGITALOUTPUT
,0);

27 
	`kOutPtBy
(
HDD_PORT_SECONDARYBASE
+
HDD_PORT_INDEX_DIGITALOUTPUT
,0);

30 if(
	`kRdHDDInfmi
(
TRUE
,TRUE,&(
gs_HDDMag
.
HDDInfmi
))==
FALSE
)

32 
gs_HDDMag
.
bHDDDeed
 = 
FALSE
;

33 
gs_HDDMag
.
bCWre
 = 
FALSE
;

34  
FALSE
;

38 
gs_HDDMag
.
bHDDDeed
 = 
TRUE
;

39 if(
	`kMemCmp
(
gs_HDDMag
.
HDDInfmi
.
vwModNumb
,"QEMU",4)==0)

41 
gs_HDDMag
.
bCWre
 = 
TRUE
;

45 
gs_HDDMag
.
bCWre
 = 
FALSE
;

48  
TRUE
;

49 
	}
}

52 
BYTE
 
	$kRdHDDStus
(
BOOL
 
bPrimy
)

54 if(
bPrimy
 =
TRUE
)

57  
	`kInPtBy
(
HDD_PORT_PRIMARYBASE
+
HDD_PORT_INDEX_STATUS
);

60  
	`kInPtBy
(
HDD_PORT_SECONDARYBASE
+
HDD_PORT_INDEX_STATUS
);

61 
	}
}

64 
BOOL
 
	$kWaFHDDNoBusy
(
BOOL
 
bPrimy
)

66 
QWORD
 
qwSTickCou
;

67 
BYTE
 
bStus
;

70 
qwSTickCou
 = 
	`kGTickCou
();

73 (
	`kGTickCou
()-
qwSTickCou
)<=
HDD_WAITTIME
)

76 
bStus
 = 
	`kRdHDDStus
(
bPrimy
);

79 if((
bStus
&
HDD_STATUS_BUSY
)!=HDD_STATUS_BUSY)

81  
TRUE
;

84 
	`kS˕
(1);

87  
FALSE
;

88 
	}
}

91 
BOOL
 
	$kWaFHDDRdy
(
BOOL
 
bPrimy
)

93 
QWORD
 
qwSTickCou
;

94 
BYTE
 
bStus
;

97 
qwSTickCou
 = 
	`kGTickCou
();

100 (
	`kGTickCou
()-
qwSTickCou
)<=
HDD_WAITTIME
)

103 
bStus
 = 
	`kRdHDDStus
(
bPrimy
);

106 if((
bStus
&
HDD_STATUS_READY
)==HDD_STATUS_READY)

108  
TRUE
;

111 
	`kS˕
(1);

114  
FALSE
;

115 
	}
}

118 
	$kSHDDIruFg
(
BOOL
 
bPrimy
,BOOL 
bFg
)

120 if(
bPrimy
==
TRUE
)

122 
gs_HDDMag
.
bPrimyIruOccur
 = 
bFg
;

126 
gs_HDDMag
.
bSecdyIruOccur
 = 
bFg
;

128 
	}
}

131 
BOOL
 
	$kWaFHDDIru
(
BOOL
 
bPrimy
)

133 
QWORD
 
qwTickCou
;

136 
qwTickCou
 = 
	`kGTickCou
();

139 (
	`kGTickCou
()-
qwTickCou
)<=
HDD_WAITTIME
)

142 if((
bPrimy
==
TRUE
)&&(
gs_HDDMag
.
bPrimyIruOccur
==TRUE))

144  
TRUE
;

146 if((
bPrimy
==
FALSE
)&&(
gs_HDDMag
.
bSecdyIruOccur
==
TRUE
))

148  
TRUE
;

153  
FALSE
;

154 
	}
}

157 
BOOL
 
	$kRdHDDInfmi
(
BOOL
 
bPrimy
,BOOL 
bMa
,
HDDINFORMATION
* 
pHDDInfmi
)

159 
WORD
 
wPtBa
;

160 
QWORD
 
qwLaTickCou
;

161 
BYTE
 
bStus
;

162 
BYTE
 
bDriveFg
;

163 
i
;

164 
WORD
 
wTemp
;

165 
BOOL
 
bWaResu
;

168 if(
bPrimy
==
TRUE
)

171 
wPtBa
 = 
HDD_PORT_PRIMARYBASE
;

176 
wPtBa
 = 
HDD_PORT_SECONDARYBASE
;

180 
	`kLock
(&(
gs_HDDMag
.
Mux
));

183 if(
	`kWaFHDDNoBusy
(
bPrimy
)==
FALSE
)

186 
	`kUock
(&(
gs_HDDMag
.
Mux
));

187  
FALSE
;

195 if(
bMa
==
TRUE
)

198 
bDriveFg
 = 
HDD_DRIVEANDHEAD_LBA
;

203 
bDriveFg
 = 
HDD_DRIVEANDHEAD_LBA
 | 
HDD_DRIVEANDHEAD_SLAVE
;

207 
	`kOutPtBy
(
wPtBa
+
HDD_PORT_INDEX_DRIVEANDHEAD
,
bDriveFg
);

213 if(
	`kWaFHDDRdy
(
bPrimy
)==
FALSE
)

216 
	`kUock
(&(
gs_HDDMag
.
Mux
));

217  
FALSE
;

221 
	`kSHDDIruFg
(
bPrimy
,
FALSE
);

224 
	`kOutPtBy
(
wPtBa
+
HDD_PORT_INDEX_COMMAND
,
HDD_COMMAND_IDENTIFY
);

227 
bWaResu
 = 
	`kWaFHDDIru
(
bPrimy
);

229 
bStus
 = 
	`kRdHDDStus
(
bPrimy
);

230 if((
bWaResu
==
FALSE
)||((
bStus
&
HDD_STATUS_ERROR
)==HDD_STATUS_ERROR))

233 
	`kUock
(&(
gs_HDDMag
.
Mux
));

234  
FALSE
;

241 
i
=0;i<512/2;i++)

243 ((
WORD
*)
pHDDInfmi
)[
i
]=
	`kInPtWd
(
wPtBa
+
HDD_PORT_INDEX_DATA
);

247 
	`kSwByInWd
(
pHDDInfmi
->
vwModNumb
,(pstHDDInformation->vwModelNumber)/2);

248 
	`kSwByInWd
(
pHDDInfmi
->
vwSlNumb
,(pstHDDInformation->vwSerialNumber)/2);

251 
	`kUock
(&(
gs_HDDMag
.
Mux
));

252  
TRUE
;

253 
	}
}

256 
	$kSwByInWd
(
WORD
* 
pwDa
,
iWdCou
)

258 
i
;

259 
WORD
 
wTemp
;

261 
i
=0;i<
iWdCou
;i++)

263 
wTemp
 = 
pwDa
[
i
];

264 
pwDa
[
i
]=(
wTemp
>>8)|(wTemp<<8);

266 
	}
}

271 
	$kRdHDDSe
(
BOOL
 
bPrimy
,BOOL 
bMa
,
DWORD
 
dwLBA
,
iSeCou
,* 
pcBufr
)

273 
WORD
 
wPtBa
;

274 
i
,
j
;

275 
BYTE
 
bDriveFg
;

276 
BYTE
 
bStus
;

277 
lRdCou
=0;

278 
BOOL
 
bWaResu
;

281 if((
gs_HDDMag
.
bHDDDeed
==
FALSE
)||(
iSeCou
<=0)||(256<iSeCou)||((
dwLBA
+iSeCou)>=gs_HDDMag.
HDDInfmi
.
dwTٮSes
))

287 if(
bPrimy
==
TRUE
)

290 
wPtBa
 = 
HDD_PORT_PRIMARYBASE
;

295 
wPtBa
 = 
HDD_PORT_SECONDARYBASE
;

299 
	`kLock
(&(
gs_HDDMag
.
Mux
));

302 if(
	`kWaFHDDNoBusy
(
bPrimy
)==
FALSE
)

305 
	`kUock
(&(
gs_HDDMag
.
Mux
));

306  
FALSE
;

314 
	`kOutPtBy
(
wPtBa
+
HDD_PORT_INDEX_SECTORCOUNT
,
iSeCou
);

316 
	`kOutPtBy
(
wPtBa
+
HDD_PORT_INDEX_SECTORNUMBER
,
dwLBA
);

318 
	`kOutPtBy
(
wPtBa
+
HDD_PORT_INDEX_CYLINDERLSB
,
dwLBA
>>8);

320 
	`kOutPtBy
(
wPtBa
+
HDD_PORT_INDEX_CYLINDERMSB
,
dwLBA
>>16);

322 if(
bMa
==
TRUE
)

324 
bDriveFg
 = 
HDD_DRIVEANDHEAD_LBA
;

328 
bDriveFg
 = 
HDD_DRIVEANDHEAD_LBA
|
HDD_DRIVEANDHEAD_SLAVE
;

332 
	`kOutPtBy
(
wPtBa
+
HDD_PORT_INDEX_DRIVEANDHEAD
,
bDriveFg
|((
dwLBA
>>24)&0x0F));

338 if(
	`kWaFHDDRdy
(
bPrimy
)==
FALSE
)

341 
	`kUock
(&(
gs_HDDMag
.
Mux
));

342  
FALSE
;

346 
	`kSHDDIruFg
(
bPrimy
,
FALSE
);

349 
	`kOutPtBy
(
wPtBa
+
HDD_PORT_INDEX_COMMAND
,
HDD_COMMAND_READ
);

355 
i
=0;i<
iSeCou
;i++)

358 
bStus
 = 
	`kRdHDDStus
(
bPrimy
);

359 if((
bStus
&
HDD_STATUS_ERROR
)==HDD_STATUS_ERROR)

361 
	`kPrtf
("Error Occur\n");

363 
	`kUock
(&(
gs_HDDMag
.
Mux
));

364  
i
;

368 if((
bStus
&
HDD_STATUS_DATAREQUEST
)!=HDD_STATUS_DATAREQUEST)

371 
bWaResu
 = 
	`kWaFHDDIru
(
bPrimy
);

372 
	`kSHDDIruFg
(
bPrimy
,
FALSE
);

374 if(
bWaResu
==
FALSE
)

376 
	`kPrtf
("Interrupt Not Occur\n");

378 
	`kUock
(&(
gs_HDDMag
.
Mux
));

379  
FALSE
;

384 
j
=0;j<512/2;j++)

386 ((
WORD
*)
pcBufr
)[
lRdCou
++]=
	`kInPtWd
(
wPtBa
+
HDD_PORT_INDEX_DATA
);

391 
	`kUock
(&(
gs_HDDMag
.
Mux
));

392  
i
;

393 
	}
}

398 
	$kWreHDDSe
(
BOOL
 
bPrimy
,BOOL 
bMa
,
DWORD
 
dwLBA
,
iSeCou
,* 
pcBufr
)

400 
WORD
 
wPtBa
;

401 
WORD
 
WTemp
;

402 
i
,
j
;

403 
BYTE
 
bDriveFg
;

404 
BYTE
 
bStus
;

405 
lRdCou
=0;

406 
BOOL
 
bWaResu
;

409 if((
gs_HDDMag
.
bCWre
==
FALSE
)||(
iSeCou
<=0)||(256<iSeCou)||((
dwLBA
+iSeCou)>=gs_HDDMag.
HDDInfmi
.
dwTٮSes
))

415 if(
bPrimy
==
TRUE
)

418 
wPtBa
 = 
HDD_PORT_PRIMARYBASE
;

423 
wPtBa
 = 
HDD_PORT_SECONDARYBASE
;

427 if(
	`kWaFHDDNoBusy
(
bPrimy
)==
FALSE
)

429  
FALSE
;

433 
	`kLock
(&(
gs_HDDMag
.
Mux
));

439 
	`kOutPtBy
(
wPtBa
+
HDD_PORT_INDEX_SECTORCOUNT
,
iSeCou
);

441 
	`kOutPtBy
(
wPtBa
+
HDD_PORT_INDEX_SECTORNUMBER
,
dwLBA
);

443 
	`kOutPtBy
(
wPtBa
+
HDD_PORT_INDEX_CYLINDERLSB
,
dwLBA
>>8);

445 
	`kOutPtBy
(
wPtBa
+
HDD_PORT_INDEX_CYLINDERMSB
,
dwLBA
>>16);

447 if(
bMa
==
TRUE
)

449 
bDriveFg
 = 
HDD_DRIVEANDHEAD_LBA
;

453 
bDriveFg
 = 
HDD_DRIVEANDHEAD_LBA
|
HDD_DRIVEANDHEAD_SLAVE
;

457 
	`kOutPtBy
(
wPtBa
+
HDD_PORT_INDEX_DRIVEANDHEAD
,
bDriveFg
|((
dwLBA
>>24)&0x0F));

463 if(
	`kWaFHDDRdy
(
bPrimy
)==
FALSE
)

466 
	`kUock
(&(
gs_HDDMag
.
Mux
));

467  
FALSE
;

472 
	`kOutPtBy
(
wPtBa
+
HDD_PORT_INDEX_COMMAND
,
HDD_COMMAND_WRITE
);

477 
bStus
 = 
	`kRdHDDStus
(
bPrimy
);

479 if((
bStus
&
HDD_STATUS_ERROR
)==HDD_STATUS_ERROR)

482 
	`kUock
(&(
gs_HDDMag
.
Mux
));

487 if((
bStus
&
HDD_STATUS_DATAREQUEST
)==HDD_STATUS_DATAREQUEST)

492 
	`kS˕
(1);

499 
i
=0;i<
iSeCou
;i++)

502 
	`kSHDDIruFg
(
bPrimy
,
FALSE
);

503 
j
=0;j<512/2;j++)

505 
	`kOutPtWd
(
wPtBa
+
HDD_PORT_INDEX_DATA
,((
WORD
*)
pcBufr
)[
lRdCou
++]);

509 
bStus
 = 
	`kRdHDDStus
(
bPrimy
);

510 if((
bStus
&
HDD_STATUS_ERROR
)==HDD_STATUS_ERROR)

513 
	`kUock
(&(
gs_HDDMag
.
Mux
));

514  
i
;

518 if((
bStus
&
HDD_STATUS_DATAREQUEST
)!=HDD_STATUS_DATAREQUEST)

521 
bWaResu
 = 
	`kWaFHDDIru
(
bPrimy
);

522 
	`kSHDDIruFg
(
bPrimy
,
FALSE
);

524 if(
bWaResu
==
FALSE
)

527 
	`kUock
(&(
gs_HDDMag
.
Mux
));

528  
FALSE
;

535 
	`kUock
(&(
gs_HDDMag
.
Mux
));

536  
i
;

537 
	}
}

	@/home/jk/os/MINT64/02.Kernel64/Source/HardDisk.h

1 #ide
__HARDDISK_H__


2 
	#__HARDDISK_H__


	)

4 
	~"Tys.h
"

5 
	~"Synchrizi.h
"

9 
	#HDD_PORT_PRIMARYBASE
 0x1F0

	)

10 
	#HDD_PORT_SECONDARYBASE
 0x170

	)

13 
	#HDD_PORT_INDEX_DATA
 0x00

	)

14 
	#HDD_PORT_INDEX_SECTORCOUNT
 0x02

	)

15 
	#HDD_PORT_INDEX_SECTORNUMBER
 0x03

	)

16 
	#HDD_PORT_INDEX_CYLINDERLSB
 0x04

	)

17 
	#HDD_PORT_INDEX_CYLINDERMSB
 0x05

	)

18 
	#HDD_PORT_INDEX_DRIVEANDHEAD
 0x06

	)

19 
	#HDD_PORT_INDEX_STATUS
 0x07

	)

20 
	#HDD_PORT_INDEX_COMMAND
 0x07

	)

21 
	#HDD_PORT_INDEX_DIGITALOUTPUT
 0x206

	)

24 
	#HDD_COMMAND_READ
 0x20

	)

25 
	#HDD_COMMAND_WRITE
 0x30

	)

26 
	#HDD_COMMAND_IDENTIFY
 0xEC

	)

29 
	#HDD_STATUS_ERROR
 0x01

	)

30 
	#HDD_STATUS_INDEX
 0x02

	)

31 
	#HDD_STATUS_CORRECTEDDATA
 0x04

	)

32 
	#HDD_STATUS_DATAREQUEST
 0x08

	)

33 
	#HDD_STATUS_SEEKCOMPLETE
 0x10

	)

34 
	#HDD_STATUS_WRITEFAULT
 0x20

	)

35 
	#HDD_STATUS_READY
 0x40

	)

36 
	#HDD_STATUS_BUSY
 0x80

	)

39 
	#HDD_DRIVEANDHEAD_LBA
 0xE0

	)

40 
	#HDD_DRIVEANDHEAD_SLAVE
 0x10

	)

43 
	#HDD_DIGITALOUTPUT_RESET
 0x04

	)

44 
	#HDD_DIGITALOUTPUT_DISABLEINTERRUPT
 0x01

	)

47 
	#HDD_WAITTIME
 500

	)

49 
	#HDD_MAXBULKSECTORCOUNT
 256

	)

53 #agm
ck
(
push
,1)

55 
	skHDDInfmiSu


58 
WORD
 
	mwCfigui
;

61 
WORD
 
	mwNumbOfCyld
;

62 
WORD
 
	mwRerved1
;

65 
WORD
 
	mwNumbOfHd
;

66 
WORD
 
	mwUnfmdByPTck
;

67 
WORD
 
	mwUnfmdByPSe
;

70 
WORD
 
	mwNumbOfSePCyld
;

71 
WORD
 
	mwISeG
;

72 
WORD
 
	mwBysInPhaLock
;

73 
WORD
 
	mwNumbOfVdUniqueStusWd
;

76 
WORD
 
	mvwSlNumb
[10];

77 
WORD
 
	mwCڌrTy
;

78 
WORD
 
	mwBufrSize
;

79 
WORD
 
	mwNumbOfECCBys
;

80 
WORD
 
	mvwFmweRevisi
[4];

83 
WORD
 
	mvwModNumb
[20];

84 
WORD
 
	mvwRerved2
[13];

87 
DWORD
 
	mdwTٮSes
;

88 
WORD
 
	mvwRerved3
[196];

89 } 
	tHDDINFORMATION
;

91 #agm
ck
(
p
)

94 
	skHDDMagSu


97 
BOOL
 
	mbHDDDeed
;

98 
BOOL
 
	mbCWre
;

101 vީ
BOOL
 
	mbPrimyIruOccur
;

102 vީ
BOOL
 
	mbSecdyIruOccur
;

103 
MUTEX
 
	mMux
;

106 
HDDINFORMATION
 
	mHDDInfmi
;

107 } 
	tHDDMANAGER
;

109 
BOOL
 
kInlizeHDD
();

110 
BOOL
 
kRdHDDInfmi
(BOOL 
bPrimy
,BOOL 
bMa
,
HDDINFORMATION
* 
pHDDInfmi
);

111 
kRdHDDSe
(
BOOL
 
bPrimy
,BOOL 
bMa
,
DWORD
 
dwLBA
,
iSeCou
,* 
pcBufr
);

112 
kWreHDDSe
(
BOOL
 
bPrimy
,BOOL 
bMa
,
DWORD
 
dwLBA
,
iSeCou
,* 
pcBufr
);

113 
kSHDDIruFg
(
BOOL
 
bPrimy
,BOOL 
bFg
);

	@/home/jk/os/MINT64/02.Kernel64/Source/ISR.asm

1 [
BITS
 64] ; 이하의 코드는 64비트 코드로 설정

3 
	gSECTION
 .
	gxt
 ;ext 섹션(세그먼트)을 정의

5 ; 외부에서 정의된 함수를 쓸 수 있도록 선엄함(
	gImpt
)

6 
kCommExiHdr
, 
kCommIruHdr
, 
kKeybrdHdr


7 
kTimHdr
, 
kDeviNAvaabHdr
, 
kHDDHdr


9 ; 
	gC
 언어에서 호출할 수 있도록 이름을 노출함(
	gExpt
)

10 ; 예외(
	gExi
처리를 위한 
ISR


11 
glob
 
	gkISRDivideE
, 
	gkISRDebug
, 
	gkISRNMI
, 
	gkISRBakPot
, 
kISROvow


12 
glob
 
	gkISRBoundRgeExeded
, 
	gkISRInvidOpcode
, 
	gkISRDeviNAvaab
, 
	gkISRDoubFau
,

13 
glob
 
	gkISRCrossSegmtOvrun
, 
	gkISRInvidTSS
, 
kISRSegmtNP


14 
glob
 
	gkISRSckSegmtFau
, 
	gkISRGPrei
, 
	gkISRPageFau
, 
kISR15


15 
glob
 
	gkISRFPUE
, 
	gkISRAlignmtCheck
, 
	gkISRMacheCheck
, 
	gkISRSIMDE
, 
	gkISRETCExi


17 ; 인터럽트(
	gIru
처리를 위한 
ISR


18 
glob
 
	gkISRTim
, 
	gkISRKeybrd
, 
	gkISRSvePIC
, 
	gkISRSl2
, 
	gkISRSl1
, 
kISRPl2


19 
glob
 
	gkISRFlpy
, 
	gkISRPl1
, 
	gkISRRTC
, 
	gkISRRerved
, 
	gkISRNUd1
, 
kISRNUd2


20 
glob
 
	gkISRMou
, 
	gkISRCross
, 
	gkISRHDD1
, 
	gkISRHDD2
, 
	gkISRETCIru


22 ; 
	gcڋxt
를 저장하고 셀렉터를 교체하는 매크로

23 %
mao
 
	gKSAVECONTEXT
 0 ; 파라미터를 전달받지 않는 KSAVECONTEXT 매크로 정의

24 ; 
	gRBP
 레지스터부터 
	gGS
 세그먼트 셀렉터까지 모두 스택에 삽입

25 
push
 
rbp


26 
mov
 
	grbp
, 
r


27 
push
 
x


28 
push
 
rbx


29 
push
 
rcx


30 
push
 
rdx


31 
push
 
rdi


32 
push
 
rsi


33 
push
 
r8


34 
push
 
r9


35 
push
 
r10


36 
push
 
r11


37 
push
 
r12


38 
push
 
r13


39 
push
 
r14


40 
push
 
r15


42 
mov
 
	gax
, 
	gds
 ; 
	gDS
 세그먼트 셀렉터와 
	gES
 세그먼트 셀렉터는 스택에 직접 삽입할 수 없으므로 
	gRAX
 레지스터에 저장한 후 스택에 삽입

43 
push
 
x


44 
mov
 
	gax
, 
es


45 
push
 
x


46 
push
 
fs


47 
push
 
	ggs


50 
mov
 
	gax
, 0x10 ; 
	gAX
 레지스터에 커널 데이터 세그먼트 디스크립터 저장

51 
mov
 
	gds
, 
	gax
 ; 
	gDS
 세그먼트 셀렉터부터 
	gFS
 세그먼트 셀렉터까지 모두 커널 데이터 세그먼트로 교체

52 
mov
 
	ges
, 
ax


53 
mov
 
	ggs
, 
ax


54 
mov
 
	gfs
, 
	gax


55 %
	gdmao
 ; 매크로 끝

58 ; 
	gcڋxt
를 복원하는 매크로

59 %
mao
 
	gKLOADCONTEXT
 0 ; 파라미터를 전달받지 않는 KLOADCONTEXT 매크로 정의

60 ; 
	gGS
 세그먼트 셀렉터부터 
	gRBP
 레지스터까지 모두 스택에서 꺼내 복원

61 
p
 
gs


62 
p
 
fs


63 
p
 
x


64 
mov
 
	ges
, 
	gax
 ; 
	gES
 세그먼트 셀렉터와 
	gDS
 세그먼트 셀렉터는 스택에 직접 꺼내 복원할 수 없으므로 
	gRAX
 레지스터에 저장한 뒤에 복원

65 
p
 
x


66 
mov
 
	gds
, 
ax


68 
p
 
r15


69 
p
 
r14


70 
p
 
r13


71 
p
 
r12


72 
p
 
r11


73 
p
 
r10


74 
p
 
r9


75 
p
 
r8


76 
p
 
rsi


77 
p
 
rdi


78 
p
 
rdx


79 
p
 
rcx


80 
p
 
rbx


81 
p
 
x


82 
p
 
	grbp


83 %
	gdmao
 ; 매크로 끝

90 ; #0, 
Divide
 
E
 
ISR


91 
	gkISRDivideE
:

92 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

95 
mov
 
	grdi
, 0

96 

 
kCommExiHdr


98 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

99 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

101 ; #1, 
Debug
 
ISR


102 
	gkISRDebug
:

103 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

106 
mov
 
	grdi
, 1

107 

 
kCommExiHdr


109 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

110 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

112 ; #2, 
NMI
 
ISR


113 
	gkISRNMI
:

114 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

117 
mov
 
	grdi
, 2

118 

 
kCommExiHdr


120 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

121 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

123 ; #3, 
BakPot
 
ISR


124 
	gkISRBakPot
:

125 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

128 
mov
 
	grdi
, 3

129 

 
kCommExiHdr


131 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

132 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

134 ; #4, 
Ovow
 
ISR


135 
	gkISROvow
:

136 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

139 
mov
 
	grdi
, 4

140 

 
kCommExiHdr


142 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

143 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

145 ; #5, 
Bound
 
Rge
 
Exeded
 
ISR


146 
	gkISRBoundRgeExeded
:

147 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

150 
mov
 
	grdi
, 5

151 

 
kCommExiHdr


153 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

154 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

156 ; #6, 
Invid
 
Opcode
 
ISR


157 
	gkISRInvidOpcode
:

158 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

161 
mov
 
	grdi
, 6

162 

 
kCommExiHdr


164 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

165 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

167 ; #7, 
Devi
 
N
 
Avaab
 
ISR


168 
	gkISRDeviNAvaab
:

169 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

172 
mov
 
	grdi
, 7

173 

 
kDeviNAvaabHdr


175 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

176 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

178 ; #8, 
Doub
 
Fau
 
ISR


179 
	gkISRDoubFau
:

180 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

183 
mov
 
	grdi
, 8

184 
mov
 
	grsi
,
	gqwd
[
rbp
+8]

185 

 
kCommExiHdr


187 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

188 
add
 
	gr
,8 ; 에러 코드를 스택에서 제거

189 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

191 ; #9, 
Cross
 
Segmt
 
Ovrun
 
ISR


192 
	gkISRCrossSegmtOvrun
:

193 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

196 
mov
 
	grdi
, 9

197 

 
kCommExiHdr


199 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

200 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

202 ; #10, 
Invid
 
TSS
 
ISR


203 
	gkISRInvidTSS
:

204 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

207 
mov
 
	grdi
, 10

208 
mov
 
	grsi
, 
	gqwd
[
rbp
+8]

209 

 
kCommExiHdr


211 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

212 
add
 
	gr
, 8 ; 에러 코드를 스택에서 제거

213 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

215 ; #11, 
Segmt
 
N
 
P
 
ISR


216 
	gkISRSegmtNP
:

217 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

220 
mov
 
	grdi
, 11

221 
mov
 
	grsi
, 
	gqwd
[
rbp
+8]

222 

 
kCommExiHdr


224 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

225 
add
 
	gr
, 8 ; 에러 코드를 스택에서 제거

226 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

228 ; #12, 
Sck
 
Segmt
 
Fau
 
ISR


229 
	gkISRSckSegmtFau
:

230 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

233 
mov
 
	grdi
, 12

234 
mov
 
	grsi
, 
	gqwd
[
rbp
+8]

235 

 
kCommExiHdr


237 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

238 
add
 
	gr
, 8 ; 에러 코드를 스택에서 제거

239 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

241 ; #13, 
G
 
Prei
 
ISR


242 
	gkISRGPrei
:

243 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

246 
mov
 
	grdi
, 13

247 
mov
 
	grsi
, 
	gqwd
[
rbp
+8]

248 

 
kCommExiHdr


250 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

251 
add
 
	gr
, 8 ; 에러 코드를 스택에서 제거

252 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

254 ; #14, 
Page
 
Fau
 
ISR


255 
	gkISRPageFau
:

256 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

259 
mov
 
	grdi
, 14

260 
mov
 
	grsi
, 
	gqwd
[
rbp
+8]

261 

 
kCommExiHdr


263 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

264 
add
 
	gr
, 8 ; 에러 코드를 스택에서 제거

265 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

267 ; #15, 
Rerved
 
ISR


268 
	gkISR15
:

269 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

272 
mov
 
	grdi
, 15

273 

 
kCommExiHdr


275 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

276 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

278 ; #16, 
FPU
 
E
 
ISR


279 
	gkISRFPUE
:

280 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

283 
mov
 
	grdi
, 16

284 

 
kCommExiHdr


286 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

287 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

289 ; #17, 
Alignmt
 
Check
 
ISR


290 
	gkISRAlignmtCheck
:

291 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

294 
mov
 
	grdi
, 17

295 
mov
 
	grsi
, 
	gqwd
[
rbp
+8]

296 

 
kCommExiHdr


298 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

299 
add
 
	gr
, 8 ; 에러 코드를 스택에서 제거

300 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

302 ; #18, 
Mache
 
Check
 
ISR


303 
	gkISRMacheCheck
:

304 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

307 
mov
 
	grdi
, 18

308 

 
kCommExiHdr


310 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

311 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

313 ; #19, 
SIME
 
Fltg
 
Pot
 
Exi
 
ISR


314 
	gkISRSIMDE
:

315 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

318 
mov
 
	grdi
, 19

319 

 
kCommExiHdr


321 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

322 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

324 ; #20~#31, 
Rerved
 
ISR


325 
	gkISRETCExi
:

326 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

329 
mov
 
	grdi
, 20

330 

 
kCommExiHdr


332 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

333 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

341 ; #32, 타이머 
ISR


342 
	gkISRTim
:

343 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

346 
mov
 
	grdi
, 32

347 

 
kTimHdr


349 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

350 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

352 ; #33, 키보드 
ISR


353 
	gkISRKeybrd
:

354 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

357 
mov
 
	grdi
, 33

358 

 
kKeybrdHdr


360 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

361 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

363 ; #34, 슬레이브 
PIC
 
ISR


364 
	gkISRSvePIC
:

365 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

368 
mov
 
	grdi
, 34

369 

 
kCommIruHdr


371 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

372 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

374 ; #35, 시리얼 포트 2 
ISR


375 
	gkISRSl2
:

376 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

379 
mov
 
	grdi
, 35

380 

 
kCommIruHdr


382 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

383 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

385 ; #36, 시리얼 포트 1 
ISR


386 
	gkISRSl1
:

387 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

390 
mov
 
	grdi
, 36

391 

 
kCommIruHdr


393 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

394 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

396 ; #37, 패러렐 포트 2 
ISR


397 
	gkISRPl2
:

398 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

401 
mov
 
	grdi
, 37

402 

 
kCommIruHdr


404 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

405 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

407 ; #38, 플로피 디스크 컨트롤러 
ISR


408 
	gkISRFlpy
:

409 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

412 
mov
 
	grdi
, 38

413 

 
kCommIruHdr


415 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

416 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

418 ; #39, 패러렐 포트 1 
ISR


419 
	gkISRPl1
:

420 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

423 
mov
 
	grdi
, 39

424 

 
kCommIruHdr


426 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

427 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

429 ; #40, 
RTC
 
ISR


430 
	gkISRRTC
:

431 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

434 
mov
 
	grdi
, 40

435 

 
kCommIruHdr


437 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

438 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

440 ; #41, 예약된 인터럽트의 
ISR


441 
	gkISRRerved
:

442 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

445 
mov
 
	grdi
, 41

446 

 
kCommIruHdr


448 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

449 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

452 
	gkISRNUd1
:

453 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

456 
mov
 
	grdi
, 42

457 

 
kCommIruHdr


459 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

460 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

463 
	gkISRNUd2
:

464 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

467 
mov
 
	grdi
, 43

468 

 
kCommIruHdr


470 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

471 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

473 ; #44, 마우스 
ISR


474 
	gkISRMou
:

475 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

478 
mov
 
	grdi
, 44

479 

 
kCommIruHdr


481 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

482 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

484 ; #45, 코프로세서 
ISR


485 
	gkISRCross
:

486 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

489 
mov
 
	grdi
, 45

490 

 
kCommIruHdr


492 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

493 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

495 ; #46, 하드 디스크 1 
ISR


496 
	gkISRHDD1
:

497 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

500 
mov
 
	grdi
, 46

501 

 
kHDDHdr


503 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

504 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

506 ; #47, 하드 디스크 2 
ISR


507 
	gkISRHDD2
:

508 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

511 
mov
 
	grdi
, 47

512 

 
kHDDHdr


514 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

515 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

517 ; #48, 이외의 모든 인터럽트에 대한 
ISR


518 
	gkISRETCIru
:

519 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

522 
mov
 
	grdi
, 48

523 

 
kCommIruHdr


525 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

526 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

	@/home/jk/os/MINT64/02.Kernel64/Source/ISR.h

1 #ide
__ISR_H__


2 
	#__ISR_H__


	)

6 
kISRDivideE
( );

7 
kISRDebug
( );

8 
kISRNMI
( );

9 
kISRBakPot
( );

10 
kISROvow
( );

11 
kISRBoundRgeExeded
( );

12 
kISRInvidOpcode
();

13 
kISRDeviNAvaab
( );

14 
kISRDoubFau
( );

15 
kISRCrossSegmtOvrun
( );

16 
kISRInvidTSS
( );

17 
kISRSegmtNP
( );

18 
kISRSckSegmtFau
( );

19 
kISRGPrei
( );

20 
kISRPageFau
( );

21 
kISR15
( );

22 
kISRFPUE
( );

23 
kISRAlignmtCheck
( );

24 
kISRMacheCheck
( );

25 
kISRSIMDE
( );

26 
kISRETCExi
( );

29 
kISRTim
( );

30 
kISRKeybrd
( );

31 
kISRSvePIC
( );

32 
kISRSl2
( );

33 
kISRSl1
( );

34 
kISRPl2
( );

35 
kISRFlpy
( );

36 
kISRPl1
( );

37 
kISRRTC
( );

38 
kISRRerved
( );

39 
kISRNUd1
( );

40 
kISRNUd2
( );

41 
kISRMou
( );

42 
kISRCross
( );

43 
kISRHDD1
( );

44 
kISRHDD2
( );

45 
kISRETCIru
( );

	@/home/jk/os/MINT64/02.Kernel64/Source/InterruptHandler.c

1 
	~"IruHdr.h
"

2 
	~"PIC.h
"

3 
	~"Keybrd.h
"

4 
	~"Cse.h
"

5 
	~"Uty.h
"

6 
	~"Task.h
"

7 
	~"Dest.h
"

8 
	~"AsmblyUty.h
"

9 
	~"HdDisk.h
"

12 
	$kCommExiHdr
(
iVeNumb
,
QWORD
 
qwECode
)

14 
vcBufr
[3]={0,};

17 
vcBufr
[0] = '0'+
iVeNumb
/10;

18 
vcBufr
[1] = '0'+
iVeNumb
%10;

20 
	`kPrtSgXY
( 0, 0, "====================================================" );

21 
	`kPrtSgXY
( 0, 1, " Exception Occur~!!!! " );

22 
	`kPrtSgXY
( 0, 2, " Vector: " );

23 
	`kPrtSgXY
27,2,
vcBufr
);

24 
	`kPrtSgXY
( 0, 3, "====================================================" );

27 
	}
}

30 
	$kCommIruHdr
(
iVeNumb
)

32 
vcBufr
[] ="[INT: , ]";

33 
g_iCommIruCou
=0;

37 
vcBufr
[5]='0'+
iVeNumb
/10;

38 
vcBufr
[6]='0'+
iVeNumb
%10;

40 
vcBufr
[8]='0'+
g_iCommIruCou
;

41 
g_iCommIruCou
=(g_iCommonInterruptCount+1)%10;

42 
	`kPrtSgXY
(70,0,
vcBufr
);

45 
	`kSdEOIToPIC
(
iVeNumb
-
PIC_IRQSTARTVECTOR
);

46 
	}
}

49 
	$kKeybrdHdr
(
iVeNumb
)

52 
vcBufr
[] ="[INT: , ]";

53 
g_iKeybrdIruCou
=0;

54 
BYTE
 
bTemp
;

58 
vcBufr
[5]='0'+
iVeNumb
/10;

59 
vcBufr
[6]='0'+
iVeNumb
%10;

61 
vcBufr
[8]='0'+
g_iKeybrdIruCou
;

62 
g_iKeybrdIruCou
=(g_iKeyboardInterruptCount+1)%10;

63 
	`kPrtSgXY
(0,0,
vcBufr
);

66 if(
	`kIsOuutBufrFu
()==
TRUE
)

68 
bTemp
=
	`kGKeybrdSnCode
();

69 
	`kCvtSnCodeAndPutQueue
(
bTemp
);

73 
	`kSdEOIToPIC
(
iVeNumb
-
PIC_IRQSTARTVECTOR
);

75 
	}
}

78 
	$kTimHdr
(
iVeNumb
)

80 
vcBufr
[] ="[INT: , ]";

81 
g_iTimIruCou
=0;

85 
vcBufr
[5]='0'+
iVeNumb
/10;

86 
vcBufr
[6]='0'+
iVeNumb
%10;

88 
vcBufr
[8]='0'+
g_iTimIruCou
;

89 
g_iTimIruCou
=(g_iTimerInterruptCount+1)%10;

90 
	`kPrtSgXY
(70,0,
vcBufr
);

93 
	`kSdEOIToPIC
(
iVeNumb
-
PIC_IRQSTARTVECTOR
);

96 
g_qwTickCou
++;

99 
	`kDeProssTime
();

101 if(
	`kIsProssTimeExped
()==
TRUE
)

103 
	`kScheduInIru
();

105 
	}
}

109 
	$kDeviNAvaabHdr
(
iVeNumb
)

111 
TCB
* 
pFPUTask
,* 
pCutTask
;

112 
QWORD
 
qwLaFPUTaskID
;

116 
vcBufr
[] = "[EXC: , ]";

117 
g_iFPUIruCou
=0;

120 
vcBufr
[5] = '0' + 
iVeNumb
/10;

121 
vcBufr
[7] = '0' + 
iVeNumb
%10;

123 
vcBufr
[8] = '0' + 
g_iFPUIruCou
;

124 
g_iFPUIruCou
 = (g_iFPUInterruptCount+1)%10;

125 
	`kPrtSgXY
(0,0,
vcBufr
);

129 
	`kCˬTS
();

132 
qwLaFPUTaskID
 = 
	`kGLaFPUUdTaskID
();

133 
pCutTask
 = 
	`kGRugTask
();

136 if
qwLaFPUTaskID
 =
pCutTask
->
Lk
.
qwID
)

141 if(
qwLaFPUTaskID
!=
TASK_INVALIDID
)

143 
pFPUTask
 = 
	`kGTCBInTCBPo
(
	`GETTCBOFFSET
(
qwLaFPUTaskID
));

144 if((
pFPUTask
!=
NULL
)&&աFPUTask->
Lk
.
qwID
==
qwLaFPUTaskID
))

146 
	`kSaveFPUCڋxt
(
pFPUTask
->
vqwFPUCڋxt
);

152 if(
pCutTask
->
bFPUUd
 ==
FALSE
)

154 
	`kInlizeFPU
();

155 
pCutTask
->
bFPUUd
 = 
TRUE
;

159 
	`kLdFPUCڋxt
(
pCutTask
->
vqwFPUCڋxt
);

163 
	`kSLaFPUUdTaskID
(
pCutTask
->
Lk
.
qwID
);

164 
	}
}

167 
	$kHDDHdr
(
iVeNumb
)

169 
vcBufr
[]="[INT: , ]";

170 
g_iHDDIruCou
=0;

171 
BYTE
 
bTemp
;

176 
vcBufr
[5] = '0' + 
iVeNumb
/10;

177 
vcBufr
[6] = '0' + 
iVeNumb
%10;

179 
vcBufr
[8] = '0' + 
g_iHDDIruCou
;

180 
g_iHDDIruCou
 = (g_iHDDInterruptCount+1)%10;

182 
	`kPrtSgXY
(10,0,
vcBufr
);

186 if(
iVeNumb
 - 
PIC_IRQSTARTVECTOR
 == 14)

189 
	`kSHDDIruFg
(
TRUE
,TRUE);

195 
	`kSHDDIruFg
(
FALSE
,
TRUE
);

199 
	`kSdEOIToPIC
(
iVeNumb
-
PIC_IRQSTARTVECTOR
);

200 
	}
}

	@/home/jk/os/MINT64/02.Kernel64/Source/InterruptHandler.h

1 #ide
__INTERRUPTHANDLER_H__


2 
	#__INTERRUPTHANDLER_H__


	)

4 
	~"Tys.h
"

7 
kCommExiHdr
(
iVeNumb
,
QWORD
 
qwECode
);

8 
kCommIruHdr
(
iVeNumb
);

9 
kKeybrdHdr
(
iVeNumb
);

10 
kTimHdr
(
iVeNumb
);

11 
kDeviNAvaabHdr
(
iVeNumb
);

12 
kHDDHdr
(
iVeNumb
);

	@/home/jk/os/MINT64/02.Kernel64/Source/Keyboard.c

1 
	~"Tys.h
"

2 
	~"AsmblyUty.h
"

3 
	~"Keybrd.h
"

4 
	~"Queue.h
"

5 
	~"Synchrizi.h
"

11 
BOOL
 
	$kIsOuutBufrFu
()

15 if(
	`kInPtBy
(0x64)&0x01)

17  
TRUE
;

19  
FALSE
;

20 
	}
}

23 
BOOL
 
	$kIsIutBufrFu
()

27 if(
	`kInPtBy
(0x64)&0x02)

29  
TRUE
;

31  
FALSE
;

32 
	}
}

35 
BOOL
 
	$kAiveKeybrd
()

37 
i
;

38 
j
;

42 
	`kOutPtBy
(0x64,0xAE);

47 
i
=0;i<0xFFFF;i++)

50 if(
	`kIsIutBufrFu
()==
FALSE
)

58 
	`kOutPtBy
(0x60,0xF4);

63 
j
=0;j<100;j++)

68 
i
=0;i<0xFFFF;i++)

70 if(
	`kIsOuutBufrFu
()==
TRUE
)

77 if(
	`kInPtBy
(0x60)==0xFA)

79  
TRUE
;

84  
FALSE
;

85 
	}
}

89 
BYTE
 
	$kGKeybrdSnCode
()

92 
	`kIsOuutBufrFu
()==
FALSE
)

97  
	`kInPtBy
(0x60);

98 
	}
}

101 
BOOL
 
	$kChgeKeybrdLED
(
BOOL
 
bCsLockOn
,BOOL 
bNumLockOn
,BOOL 
bSlLockOn
)

103 
i
,
j
;

105 
i
=0;i<0xFFFF;i++)

108 if(
	`kIsIutBufrFu
()==
FALSE
)

115 
	`kOutPtBy
(0x60,0xED);

116 
i
=0;i<0xFFFF;i++)

119 if(
	`kIsIutBufrFu
()==
FALSE
)

126 
j
=0;j<100;j++)

131 
i
=0;i<0xFFFF;i++)

133 if(
	`kIsOuutBufrFu
()==
TRUE
)

140 if(
	`kInPtBy
(0x60)==0xFA)

148 if(
j
>=100)

150  
FALSE
;

154 
	`kOutPtBy
(0x60,(
bCsLockOn
<<2)|(
bNumLockOn
<<1)|
bSlLockOn
);

155 
i
=0;i<0xFFFF;i++)

158 if(
	`kIsIutBufrFu
()==
FALSE
)

165 
j
=0;j<100;j++)

170 
i
=0;i<0xFFFF;i++)

172 if(
	`kIsOuutBufrFu
()==
TRUE
)

179 if(
	`kInPtBy
(0x60)==0xFA)

186 if(
j
>=100)

188  
FALSE
;

191  
TRUE
;

192 
	}
}

195 
	$kEbA20Ge
()

197 
BYTE
 
bOuutPtDa
;

198 
i
;

201 
	`kOutPtBy
(0x64,0xD0);

204 
i
=0;i<0xFFFF;i++)

208 if(
	`kIsOuutBufrFu
()==
TRUE
)

215 
bOuutPtDa
 = 
	`kInPtBy
(0x60);

218 
bOuutPtDa
 |=0x01;

221 
i
=0;i<0xFFFF;i++)

224 if(
	`kIsIutBufrFu
()==
FALSE
)

231 
	`kOutPtBy
(0x64,0xD1);

234 
	`kOutPtBy
(0x60,
bOuutPtDa
);

235 
	}
}

238 
	$kRebo
()

240 
i
;

243 
i
=0;i<0xFFFF;i++)

246 if(
	`kIsIutBufrFu
()==
FALSE
)

253 
	`kOutPtBy
(0x64,0xD1);

256 
	`kOutPtBy
(0x60,0x00);

262 
	}
}

269 
KEYBOARDMANAGER
 
	ggs_KeybrdMag
={0,};

272 
QUEUE
 
	ggs_KeyQueue
;

273 
KEYDATA
 
	ggs_vKeyQueueBufr
[
KEY_MAXQUEUECOUNT
];

276 
KEYMAPPINGENTRY
 
	ggs_vKeyMpgTab
[
KEY_MAPPINGTABLEMAXCOUNT
]=

277 { { 
KEY_NONE
 , KEY_NONE },

278  { 
KEY_ESC
 , KEY_ESC },

291  { 
KEY_BACKSPACE
 , KEY_BACKSPACE },

292  { 
KEY_TAB
 , KEY_TAB },

306  { 
KEY_CTRL
 , KEY_CTRL },

319  { 
KEY_LSHIFT
 , KEY_LSHIFT },

331  { 
KEY_RSHIFT
 , KEY_RSHIFT },

333  { 
KEY_LALT
 , KEY_LALT },

335  { 
KEY_CAPSLOCK
 , KEY_CAPSLOCK },

336  { 
KEY_F1
 , KEY_F1 },

337  { 
KEY_F2
 , KEY_F2 },

338  { 
KEY_F3
 , KEY_F3 },

339  { 
KEY_F4
 , KEY_F4 },

340  { 
KEY_F5
 , KEY_F5 },

341  { 
KEY_F6
 , KEY_F6 },

342  { 
KEY_F7
 , KEY_F7 },

343  { 
KEY_F8
 , KEY_F8 },

344  { 
KEY_F9
 , KEY_F9 },

345  { 
KEY_F10
 , KEY_F10 },

346  { 
KEY_NUMLOCK
 , KEY_NUMLOCK },

347  { 
KEY_SCROLLLOCK
 , KEY_SCROLLLOCK },

349  { 
KEY_HOME
 , '7' },

350  { 
KEY_UP
 , '8' },

351  { 
KEY_PAGEUP
 , '9' },

353  { 
KEY_LEFT
 , '4' },

354  { 
KEY_CENTER
 , '5' },

355  { 
KEY_RIGHT
 , '6' },

357  { 
KEY_END
 , '1' },

358  { 
KEY_DOWN
 , '2' },

359  { 
KEY_PAGEDOWN
 , '3' },

360  { 
KEY_INS
 , '0' },

361  { 
KEY_DEL
 , '.' },

362  { 
KEY_NONE
 , KEY_NONE },

363  { 
KEY_NONE
 , KEY_NONE },

364  { 
KEY_NONE
 , KEY_NONE },

365  { 
KEY_F11
 , KEY_F11 },

366  { 
KEY_F12
 , KEY_F12 }

370 
BOOL
 
	$kIsAhabSnCode
(
BYTE
 
bSnCode
)

373 if(('a'<=
gs_vKeyMpgTab
[
bSnCode
].
bNmCode
)&&(gs_vstKeyMappingTable[bScanCode].bNormalCode<='z'))

375  
TRUE
;

378  
FALSE
;

379 
	}
}

382 
BOOL
 
	$kIsNumbOrSymbSnCode
(
BYTE
 
bSnCode
)

385 if((2<=
bSnCode
)&&(bSnCode<=53)&&(
	`kIsAhabSnCode
(bSnCode)==
FALSE
))

387  
TRUE
;

390  
FALSE
;

391 
	}
}

394 
BOOL
 
	$kIsNumbPadSnCode
(
BYTE
 
bSnCode
)

397 if((71<=
bSnCode
)&&(bScanCode<=83))

399  
TRUE
;

402  
FALSE
;

403 
	}
}

406 
BOOL
 
	$kIsUCombedCode
(
BYTE
 
bSnCode
)

408 
BYTE
 
bDownSnCode
;

409 
BOOL
 
bUCombedKey
=
FALSE
;

411 
bDownSnCode
 = 
bSnCode
&0x7F;

414 if(
	`kIsAhabSnCode
(
bDownSnCode
)==
TRUE
)

417 if(
gs_KeybrdMag
.
bShiDown
^gs_KeybrdMag.
bCsLockOn
)

419 
bUCombedKey
=
TRUE
;

423 
bUCombedKey
=
FALSE
;

427 if(
	`kIsNumbOrSymbSnCode
(
bDownSnCode
)==
TRUE
)

430 if(
gs_KeybrdMag
.
bShiDown
==
TRUE
)

432 
bUCombedKey
=
TRUE
;

436 
bUCombedKey
=
FALSE
;

441 if((
	`kIsNumbPadSnCode
(
bDownSnCode
)==
TRUE
)&&(
gs_KeybrdMag
.
bExndedCodeIn
==
FALSE
))

444 if(
gs_KeybrdMag
.
bNumLockOn
==
TRUE
)

446 
bUCombedKey
=
TRUE
;

450 
bUCombedKey
=
FALSE
;

454  
bUCombedKey
;

455 
	}
}

458 
	$UpdeCombiKeyStusAndLED
(
BYTE
 
bSnCode
)

460 
BOOL
 
bDown
;

461 
BYTE
 
bDownSnCode
;

462 
BOOL
 
bLEDStusChged
=
FALSE
;

465 if(
bSnCode
&0x80)

467 
bDown
=
FALSE
;

468 
bDownSnCode
=
bSnCode
&0x7F;

472 
bDown
=
TRUE
;

473 
bDownSnCode
=
bSnCode
;

478 if((
bDownSnCode
==42)||(bDownScanCode==54))

480 
gs_KeybrdMag
.
bShiDown
=
bDown
;

483 if((
bDownSnCode
==58)&&(
bDown
==
TRUE
))

485 
gs_KeybrdMag
.
bCsLockOn
^=
TRUE
;

486 
bLEDStusChged
=
TRUE
;

489 if((
bDownSnCode
==69)&&(
bDown
==
TRUE
))

491 
gs_KeybrdMag
.
bNumLockOn
^=
TRUE
;

492 
bLEDStusChged
=
TRUE
;

495 if((
bDownSnCode
==70)&&(
bDown
==
TRUE
))

497 
gs_KeybrdMag
.
bSlLockOn
^=
TRUE
;

498 
bLEDStusChged
=
TRUE
;

503 if(
bLEDStusChged
==
TRUE
)

505 
	`kChgeKeybrdLED
(
gs_KeybrdMag
.
bCsLockOn
,gs_KeybrdMag.
bNumLockOn
,gs_KeybrdMag.
bSlLockOn
);

507 
	}
}

510 
BOOL
 
	$kCvtSnCodeToASCIICode
(
BYTE
 
bSnCode
,BYTE* 
pbASCIICODE
,
BOOL
* 
pbFgs
)

512 
BOOL
 
bUCombedKey
;

515 if(
gs_KeybrdMag
.
iSkCouFPau
>0)

517 
gs_KeybrdMag
.
iSkCouFPau
--;

518  
FALSE
;

522 if(
bSnCode
==0xE1)

524 *
pbASCIICODE
==
KEY_PAUSE
;

525 *
pbFgs
=
KEY_FLAGS_DOWN
;

526 
gs_KeybrdMag
.
iSkCouFPau
=
KEY_SKIPCOUNTFORPAUSE
;

527  
TRUE
;

530 if(
bSnCode
==0xE0)

532 
gs_KeybrdMag
.
bExndedCodeIn
=
TRUE
;

533  
FALSE
;

537 
bUCombedKey
=
	`kIsUCombedCode
(
bSnCode
);

540 if(
bUCombedKey
==
TRUE
)

542 *
pbASCIICODE
=
gs_vKeyMpgTab
[
bSnCode
&0x7F].
bCombedCode
;

546 *
pbASCIICODE
=
gs_vKeyMpgTab
[
bSnCode
&0x7F].
bNmCode
;

550 if(
gs_KeybrdMag
.
bExndedCodeIn
==
TRUE
)

552 *
pbFgs
=
KEY_FLAGS_EXTENDEDKEY
;

553 
gs_KeybrdMag
.
bExndedCodeIn
=
FALSE
;

557 *
pbFgs
=0;

560 if((
bSnCode
&0x80)==0)

562 *
pbFgs
|=
KEY_FLAGS_DOWN
;

566 
	`UpdeCombiKeyStusAndLED
(
bSnCode
);

567  
TRUE
;

568 
	}
}

571 
BOOL
 
	$kInlizeKeybrd
()

574 
	`kInlizeQueue
(&
gs_KeyQueue
,
gs_vKeyQueueBufr
,
KEY_MAXQUEUECOUNT
,(
KEYDATA
));

577  
	`kAiveKeybrd
();

578 
	}
}

583 
BOOL
 
	$kCvtSnCodeAndPutQueue
(
BYTE
 
bSnCode
)

585 
KEYDATA
 
Da
;

586 
BOOL
 
bResu
 = 
FALSE
;

587 
BOOL
 
bPviousIru
;

590 
Da
.
bSnCode
 = bScanCode;

593 if(
	`kCvtSnCodeToASCIICode
(
bSnCode
,&(
Da
.
bASCIICode
),&(Da.
bFgs
))==
TRUE
)

596 
bPviousIru
 = 
	`kLockFSyemDa
();

598 
bResu
=
	`kPutQueue
(&
gs_KeyQueue
,&
Da
);

601 
	`kUockFSyemDa
(
bPviousIru
);

604  
bResu
;

605 
	}
}

608 
BOOL
 
	$kGKeyFromKeyQueue
(
KEYDATA
* 
pDa
)

610 
BOOL
 
bResu
;

611 
BOOL
 
bPviousIru
;

614 
bPviousIru
 = 
	`kLockFSyemDa
();

617 
bResu
 = 
	`kGQueue
(&
gs_KeyQueue
,
pDa
);

620 
	`kUockFSyemDa
(
bPviousIru
);

621  
bResu
;

622 
	}
}

	@/home/jk/os/MINT64/02.Kernel64/Source/Keyboard.h

1 #ide
__KEYBOARD_H__


2 
	#__KEYBOARD_H__


	)

4 
	~"Tys.h
"

8 
	#KEY_SKIPCOUNTFORPAUSE
 2

	)

11 
	#KEY_FLAGS_UP
 0x00

	)

12 
	#KEY_FLAGS_DOWN
 0x01

	)

13 
	#KEY_FLAGS_EXTENDEDKEY
 0x02

	)

16 
	#KEY_MAPPINGTABLEMAXCOUNT
 89

	)

18 
	#KEY_NONE
 0x00

	)

19 
	#KEY_ENTER
 '\n'

	)

20 
	#KEY_TAB
 '\t'

	)

21 
	#KEY_ESC
 0x1B

	)

22 
	#KEY_BACKSPACE
 0x08

	)

24 
	#KEY_CTRL
 0x81

	)

25 
	#KEY_LSHIFT
 0x82

	)

26 
	#KEY_RSHIFT
 0x83

	)

27 
	#KEY_PRINTSCREEN
 0x84

	)

28 
	#KEY_LALT
 0x85

	)

29 
	#KEY_CAPSLOCK
 0x86

	)

30 
	#KEY_F1
 0x87

	)

31 
	#KEY_F2
 0x88

	)

32 
	#KEY_F3
 0x89

	)

33 
	#KEY_F4
 0x8A

	)

34 
	#KEY_F5
 0x8B

	)

35 
	#KEY_F6
 0x8C

	)

36 
	#KEY_F7
 0x8D

	)

37 
	#KEY_F8
 0x8E

	)

38 
	#KEY_F9
 0x8F

	)

39 
	#KEY_F10
 0x90

	)

40 
	#KEY_NUMLOCK
 0x91

	)

41 
	#KEY_SCROLLLOCK
 0x92

	)

42 
	#KEY_HOME
 0x93

	)

43 
	#KEY_UP
 0x94

	)

44 
	#KEY_PAGEUP
 0x95

	)

45 
	#KEY_LEFT
 0x96

	)

46 
	#KEY_CENTER
 0x97

	)

47 
	#KEY_RIGHT
 0x98

	)

48 
	#KEY_END
 0x99

	)

49 
	#KEY_DOWN
 0x9A

	)

50 
	#KEY_PAGEDOWN
 0x9B

	)

51 
	#KEY_INS
 0x9C

	)

52 
	#KEY_DEL
 0x9D

	)

53 
	#KEY_F11
 0x9E

	)

54 
	#KEY_F12
 0x9F

	)

55 
	#KEY_PAUSE
 0xA0

	)

58 
	#KEY_MAXQUEUECOUNT
 100

	)

61 #agm
ck

push
, 1 )

64 
	skKeyMpgErySu


67 
BYTE
 
	mbNmCode
;

70 
BYTE
 
	mbCombedCode
;

71 } 
	tKEYMAPPINGENTRY
;

74 
	skKeybrdMagSu


77 
BOOL
 
	mbShiDown
;

78 
BOOL
 
	mbCsLockOn
;

79 
BOOL
 
	mbNumLockOn
;

80 
BOOL
 
	mbSlLockOn
;

83 
BOOL
 
	mbExndedCodeIn
;

84 
	miSkCouFPau
;

85 } 
	tKEYBOARDMANAGER
;

88 
	skKeyDaSu


91 
BYTE
 
	mbSnCode
;

93 
BYTE
 
	mbASCIICode
;

95 
BYTE
 
	mbFgs
;

96 } 
	tKEYDATA
;

98 #agm
ck

p
 )

101 
BOOL
 
kIsOuutBufrFu
( );

102 
BOOL
 
kIsIutBufrFu
( );

103 
BOOL
 
kAiveKeybrd
( );

104 
BYTE
 
kGKeybrdSnCode
( );

105 
BOOL
 
kChgeKeybrdLED
BOOL 
bCsLockOn
, BOOL 
bNumLockOn
, BOOL 
bSlLockOn
 );

106 
kEbA20Ge
( );

107 
kRebo
( );

108 
BOOL
 
kIsAhabSnCode

BYTE
 
bSnCode
 );

109 
BOOL
 
kIsNumbOrSymbSnCode

BYTE
 
bSnCode
 );

110 
BOOL
 
kIsNumbPadSnCode

BYTE
 
bSnCode
 );

111 
BOOL
 
kIsUCombedCode

BYTE
 
bSnCode
 );

112 
UpdeCombiKeyStusAndLED

BYTE
 
bSnCode
 );

113 
BOOL
 
kCvtSnCodeToASCIICode

BYTE
 
bSnCode
, BYTE* 
pbASCIICode
, BOOL* 
pbFgs
 );

114 
BOOL
 
kInlizeKeybrd
();

115 
BOOL
 
kCvtSnCodeAndPutQueue
(
BYTE
 
bSnCode
);

116 
BOOL
 
kGKeyFromKeyQueue
(
KEYDATA
* 
pDa
);

	@/home/jk/os/MINT64/02.Kernel64/Source/List.c

1 
	~"Li.h
"

4 
	$kInlizeLi
(
LIST
* 
pLi
)

6 
pLi
->
iImCou
 = 0;

7 
pLi
->
pvHd
 = 
NULL
;

8 
pLi
->
pvTa
 = 
NULL
;

9 
	}
}

12 
	$kGLiCou
(cڡ 
LIST
* 
pLi
)

14  
pLi
->
iImCou
;

15 
	}
}

18 
	$kAddLiToTa
(
LIST
* 
pLi
,* 
pvIm
)

20 
LISTLINK
* 
pLk
;

23 
pLk
 = (
LISTLINK
*)
pvIm
;

24 
pLk
->
pvNext
=
NULL
;

25 
pLk
->
pvPvious
=
pLi
->
pvTa
;

28 if(
pLi
->
pvHd
==
NULL
)

30 
pLi
->
pvHd
=
pvIm
;

31 
pLi
->
pvTa
=
pvIm
;

32 
pLi
->
iImCou
=1;

37 ((
LISTLINK
*)
pLi
->
pvTa
)->
pvNext
=
pLk
;

40 
pLi
->
pvTa
=
pvIm
;

41 
pLi
->
iImCou
++;

42 
	}
}

45 
	$kAddLiToHd
(
LIST
* 
pLi
,* 
pvIm
)

47 
LISTLINK
* 
pLk
;

50 
pLk
=(
LISTLINK
*)
pvIm
;

51 
pLk
->
pvNext
=
pLi
->
pvHd
;

52 
pLk
->
pvPvious
=
NULL
;

55 if(
pLi
->
pvHd
==
NULL
)

57 
pLi
->
pvHd
=
pvIm
;

58 
pLi
->
pvTa
=
pvIm
;

59 
pLi
->
iImCou
=1;

64 ((
LISTLINK
*)
pLi
->
pvHd
)->
pvPvious
=
pLk
;

65 
pLi
->
pvHd
=
pvIm
;

66 
pLi
->
iImCou
++;

67 
	}
}

70 * 
	$kRemoveLi
(
LIST
* 
pLi
,
QWORD
 
qwID
)

72 
LISTLINK
* 
pLk
;

73 
pLk
=
	`kFdLi
(
pLi
,
qwID
);

75 if(
pLk
!=
NULL
)

78 if((
pLk
==
pLi
->
pvHd
)&&աLk=Li->
pvTa
))

80 
pLi
->
pvHd
=
NULL
;

81 
pLi
->
pvTa
=
NULL
;

84 if(
pLk
==
pLi
->
pvHd
)

86 
pLi
->
pvHd
=
pLk
->
pvNext
;

87 ((
LISTLINK
*)
pLi
->
pvHd
)->
pvPvious
=
NULL
;

90 if(
pLk
==
pLi
->
pvTa
)

92 
pLi
->
pvTa
=
pLk
->
pvPvious
;

93 ((
LISTLINK
*)
pLi
->
pvTa
)->
pvNext
=
NULL
;

97 ((
LISTLINK
*)
pLk
->
pvPvious
)->
pvNext
=pstLink->pvNext;

98 ((
LISTLINK
*)
pLk
->
pvNext
)->
pvPvious
=pstLink->pvPrevious;

100 
pLi
->
iImCou
--;

101  
pLk
;

104  
NULL
;

105 
	}
}

108 * 
	$kRemoveLiFromHd
(
LIST
* 
pLi
)

110 
LISTLINK
* 
pLk
;

111 if(
pLi
->
iImCou
==0)

113  
NULL
;

117 
pLk
=(
LISTLINK
*)
pLi
->
pvHd
;

118  
	`kRemoveLi
(
pLi
,
pLk
->
qwID
);

119 
	}
}

122 * 
	$kRemoveLiFromTa
(
LIST
* 
pLi
)

124 
LISTLINK
* 
pLk
;

125 if(
pLi
->
iImCou
==0)

127  
NULL
;

131 
pLk
=(
LISTLINK
*)
pLi
->
pvTa
;

132  
	`kRemoveLi
(
pLi
,
pLk
->
qwID
);

133 
	}
}

137 * 
	$kFdLi
(cڡ 
LIST
* 
pLi
,
QWORD
 
qwID
)

139 
LISTLINK
* 
pLk
;

141 
pLk
=(
LISTLINK
*)
pLi
->
pvHd
;pLk!=
NULL
;pLkLk->
pvNext
)

144 if(
pLk
->
qwID
==qwID)

146  
pLk
;

149  
NULL
;

150 
	}
}

153 * 
	$kGHdFromLi
(cڡ 
LIST
* 
pLi
)

155  
pLi
->
pvHd
;

156 
	}
}

159 * 
	$kGTaFromLi
(cڡ 
LIST
* 
pLi
)

161  
pLi
->
pvTa
;

162 
	}
}

165 * 
	$kGNextFromLi
(cڡ 
LIST
* 
pLi
,* 
pCut
)

167 
LISTLINK
* 
pLk
;

168 
pLk
=(
LISTLINK
*)
pCut
;

169  
pLk
->
pvNext
;

170 
	}
}

173 * 
	$kGPviousFromLi
(cڡ 
LIST
* 
pLi
,* 
pCut
)

175 
LISTLINK
* 
pLk
;

176 
pLk
=(
LISTLINK
*)
pCut
;

177  
pLk
->
pvPvious
;

178 
	}
}

	@/home/jk/os/MINT64/02.Kernel64/Source/List.h

1 #ide
__LIST_H__


2 
	#__LIST_H__


	)

4 
	~"Tys.h
"

8 #agm
ck
(
push
,1)

12 
	skLiLkSu


15 * 
	mpvNext
;

16 * 
	mpvPvious
;

17 
QWORD
 
	mqwID
;

18 } 
	tLISTLINK
;

35 
	skLiMagSu


38 
	miImCou
;

41 * 
	mpvHd
;

42 * 
	mpvTa
;

43 } 
	tLIST
;

45 #agm
ck
(
p
)

48 
kInlizeLi
(
LIST
* 
pLi
);

49 
kGLiCou
(cڡ 
LIST
* 
pLi
);

50 
kAddLiToTa
(
LIST
* 
pLi
,* 
pvIm
);

51 
kAddLiToHd
(
LIST
* 
pLi
,* 
pvIm
);

52 * 
kRemoveLi
(
LIST
* 
pLi
,
QWORD
 
qwID
);

53 * 
kRemoveLiFromHd
(
LIST
* 
pLi
);

54 * 
kRemoveLiFromTa
(
LIST
* 
pLi
);

55 * 
kFdLi
(cڡ 
LIST
* 
pLi
,
QWORD
 
qwID
);

56 * 
kGHdFromLi
(cڡ 
LIST
* 
pLi
);

57 * 
kGTaFromLi
(cڡ 
LIST
* 
pLi
);

58 * 
kGNextFromLi
(cڡ 
LIST
* 
pLi
,* 
pCut
);

59 * 
kGPviousFromLi
(cڡ 
LIST
* 
pLi
,* 
pCut
);

	@/home/jk/os/MINT64/02.Kernel64/Source/PIC.c

1 
	~"PIC.h
"

4 
	$kInlizePIC
()

9 
	`kOutPtBy
(
PIC_MASTER_PORT1
,0x11);

12 
	`kOutPtBy
(
PIC_MASTER_PORT2
,
PIC_IRQSTARTVECTOR
);

16 
	`kOutPtBy
(
PIC_MASTER_PORT2
,0x04);

19 
	`kOutPtBy
(
PIC_MASTER_PORT2
,0x01);

24 
	`kOutPtBy
(
PIC_SLAVE_PORT1
,0x11);

27 
	`kOutPtBy
(
PIC_SLAVE_PORT2
,
PIC_IRQSTARTVECTOR
+8);

31 
	`kOutPtBy
(
PIC_SLAVE_PORT2
,0x02);

34 
	`kOutPtBy
(
PIC_SLAVE_PORT2
,0x01);

35 
	}
}

38 
	$kMaskPICIru
(
WORD
 
wIRQBmask
)

42 
	`kOutPtBy
(
PIC_MASTER_PORT2
,(
BYTE
)
wIRQBmask
);

46 
	`kOutPtBy
(
PIC_SLAVE_PORT2
,(
BYTE
)
wIRQBmask
>>8);

47 
	}
}

52 
	$kSdEOIToPIC
(
iIRQNumb
)

56 
	`kOutPtBy
(
PIC_MASTER_PORT1
,0x20);

59 if(
iIRQNumb
>=8)

62 
	`kOutPtBy
(
PIC_SLAVE_PORT1
,0x20);

64 
	}
}

	@/home/jk/os/MINT64/02.Kernel64/Source/PIC.h

1 #ide
__PIC_H__


2 
	#__PIC_H__


	)

4 
	~"Tys.h
"

8 
	#PIC_MASTER_PORT1
 0x20

	)

9 
	#PIC_MASTER_PORT2
 0x21

	)

10 
	#PIC_SLAVE_PORT1
 0xA0

	)

11 
	#PIC_SLAVE_PORT2
 0xA1

	)

14 
	#PIC_IRQSTARTVECTOR
 0x20

	)

17 
kInlizePIC
( );

18 
kMaskPICIru

WORD
 
wIRQBmask
 );

19 
kSdEOIToPIC

iIRQNumb
 );

	@/home/jk/os/MINT64/02.Kernel64/Source/PIT.c

1 
	~"PIT.h
"

2 
	~"AsmblyUty.h
"

5 
	$kInlizePIT
(
WORD
 
wCou
,
BOOL
 
bPiodic
)

9 if(
bPiodic
==
TRUE
)

12 
	`kOutPtBy
(
PIT_PORT_CONTROL
,
PIT_COUNTER0_PERIODIC
);

16 
	`kOutPtBy
(
PIT_PORT_CONTROL
,
PIT_COUNTER0_ONCE
);

20 
	`kOutPtBy
(
PIT_PORT_COUNTER0
,
wCou
);

21 
	`kOutPtBy
(
PIT_PORT_COUNTER0
,
wCou
>>8);

22 
	}
}

25 
WORD
 
	$kRdCou0
()

27 
BYTE
 
bHighBy
,
bLowBy
;

28 
WORD
 
wTemp
=0;

31 
	`kOutPtBy
(
PIT_PORT_CONTROL
,
PIT_CONTER0_LATCH
);

34 
bLowBy
 = 
	`kInPtBy
(
PIT_PORT_COUNTER0
);

35 
bHighBy
 = 
	`kInPtBy
(
PIT_PORT_COUNTER0
);

38 
wTemp
 = 
bHighBy
;

39 
wTemp
 = (wTemp<<8)|
bLowBy
;

40  
wTemp
;

41 
	}
}

47 
	$kWaUsgDePIT
(
WORD
 
wCou
)

49 
WORD
 
wLaCou0
;

50 
WORD
 
wCuCou0
;

53 
	`kInlizePIT
(0,
TRUE
);

56 
wLaCou0
 = 
	`kRdCou0
();

60 
wCuCou0
=
	`kRdCou0
();

61 if(((
wLaCou0
-
wCuCou0
)&0xFFFF)>=
wCou
)

66 
	}
}

	@/home/jk/os/MINT64/02.Kernel64/Source/PIT.h

1 #ide
__PIT_H__


2 
	#__PIT_H__


	)

4 
	~"Tys.h
"

7 
	#PIT_FREQUENCY
 1193182

	)

8 
	#MSTOCOUNT
(
x
(
PIT_FREQUENCY
*(x)/1000)

	)

9 
	#USTOCOUNT
(
x
(
PIT_FREQUENCY
*(x)/1000000)

	)

12 
	#PIT_PORT_CONTROL
 0x43

	)

13 
	#PIT_PORT_COUNTER0
 0x40

	)

14 
	#PIT_PORT_COUNTER1
 0x41

	)

15 
	#PIT_PORT_COUNTER2
 0x42

	)

18 
	#PIT_CONTROL_COUNTER0
 0x00

	)

19 
	#PIT_CONTROL_COUNTER1
 0x40

	)

20 
	#PIT_CONTROL_COUNTER2
 0x80

	)

21 
	#PIT_CONTROL_LSBMSBRW
 0x30

	)

22 
	#PIT_CONTROL_LATCH
 0x00

	)

23 
	#PIT_CONTROL_MODE0
 0x00

	)

24 
	#PIT_CONTROL_MODE2
 0x04

	)

27 
	#PIT_CONTROL_BINARYCOUNTER
 0x00

	)

28 
	#PIT_CONTROL_BCDCOUNTER
 0x01

	)

30 
	#PIT_COUNTER0_ONCE
 (
PIT_CONTROL_COUNTER0
|
PIT_CONTROL_LSBMSBRW
|
PIT_CONTROL_MODE0
|
PIT_CONTROL_BINARYCOUNTER
)

	)

31 
	#PIT_COUNTER0_PERIODIC
 (
PIT_CONTROL_COUNTER0
|
PIT_CONTROL_LSBMSBRW
|
PIT_CONTROL_MODE2
|
PIT_CONTROL_BINARYCOUNTER
)

	)

32 
	#PIT_CONTER0_LATCH
 (
PIT_CONTROL_COUNTER0
|
PIT_CONTROL_LATCH
)

	)

35 
kInlizePIT
(
WORD
 
wCou
,
BOOL
 
bPiodic
);

36 
WORD
 
kRdCou0
();

37 
kWaUsgDePIT
(
WORD
 
wCou
);

	@/home/jk/os/MINT64/02.Kernel64/Source/Queue.c

1 
	~"Queue.h
"

2 
	~"Uty.h
"

5 
	$kInlizeQueue
(
QUEUE
* 
pQueue
,* 
pvQueueBufr
,
iMaxDaCou
,
iDaSize
)

8 
pQueue
->
iMaxDaCou
=iMaxDataCount;

9 
pQueue
->
iDaSize
=iDataSize;

10 
pQueue
->
pvQueueAay
=
pvQueueBufr
;

13 
pQueue
->
iPutIndex
=0;

14 
pQueue
->
iGdex
=0;

15 
pQueue
->
bLaOiPut
=
FALSE
;

16 
	}
}

19 
BOOL
 
	$kIsQueueFu
(cڡ 
QUEUE
* 
pQueue
)

22 if((
pQueue
->
iGdex
=Queue->
iPutIndex
)&&աQueue->
bLaOiPut
==
TRUE
))

24  
TRUE
;

26  
FALSE
;

27 
	}
}

30 
BOOL
 
	$kIsQueueEmy
(cڡ 
QUEUE
* 
pQueue
)

33 if((
pQueue
->
iGdex
=Queue->
iPutIndex
)&&աQueue->
bLaOiPut
==
FALSE
))

35  
TRUE
;

37  
FALSE
;

38 
	}
}

41 
BOOL
 
	$kPutQueue
(
QUEUE
* 
pQueue
,cڡ * 
pvDa
)

43 if(
	`kIsQueueFu
(
pQueue
)==
TRUE
)

45  
FALSE
;

49 
	`kMemCpy
((*)
pQueue
->
pvQueueAay
+աQueue->
iDaSize
*pQueue->
iPutIndex
),
pvDa
,pstQueue->iDataSize);

52 
pQueue
->
iPutIndex
=աQueue->iPutIndex+1)%pQueue->
iMaxDaCou
;

53 
pQueue
->
bLaOiPut
=
TRUE
;

54  
TRUE
;

55 
	}
}

58 
BOOL
 
	$kGQueue
(
QUEUE
* 
pQueue
,* 
pvDa
)

61 if(
	`kIsQueueEmy
(
pQueue
)==
TRUE
)

63  
FALSE
;

67 
	`kMemCpy
(
pvDa
,(*)
pQueue
->
pvQueueAay
+աQueue->
iDaSize
*pQueue->
iGdex
),pstQueue->iDataSize);

70 
pQueue
->
iGdex
=աQueue->iGdex+1)%pQueue->
iMaxDaCou
;

71 
pQueue
->
bLaOiPut
=
FALSE
;

72  
TRUE
;

73 
	}
}

	@/home/jk/os/MINT64/02.Kernel64/Source/Queue.h

1 #ide
__QUEUE_H__


2 
	#__QUEUE_H__


	)

4 
	~"Tys.h
"

8 #agm
ck
(
push
,1)

11 
	skQueueMagSu


14 
	miDaSize
;

15 
	miMaxDaCou
;

18 * 
	mpvQueueAay
;

19 
	miPutIndex
;

20 
	miGdex
;

23 
BOOL
 
	mbLaOiPut
;

24 } 
	tQUEUE
;

26 #agm
ck
(
p
)

29 
kInlizeQueue
(
QUEUE
* 
pQueue
,* 
pvQueueBufr
,
iMaxDaCou
,
iDaSize
);

30 
BOOL
 
kIsQueueFu
(cڡ 
QUEUE
* 
pQueue
);

31 
BOOL
 
kIsQueueEmy
(cڡ 
QUEUE
* 
pQueue
);

32 
BOOL
 
kPutQueue
(
QUEUE
* 
pQueue
,cڡ * 
pvDa
);

33 
BOOL
 
kGQueue
(
QUEUE
* 
pQueue
,* 
pvDa
);

	@/home/jk/os/MINT64/02.Kernel64/Source/RTC.c

1 
	~"RTC.h
"

2 
	~"AsmblyUty.h
"

5 
	$kRdRTCTime
(
BYTE
* 
pbHour
,BYTE* 
pbMu
,BYTE* 
pbSecd
)

7 
BYTE
 
bDa
;

10 
	`kOutPtBy
(
RTC_CMOSADDRESS
,
RTC_ADDRESS_HOUR
);

12 
bDa
 = 
	`kInPtBy
(
RTC_CMOSDATA
);

13 *
pbHour
 = 
	`RTC_BCDTOBINARY
(
bDa
);

16 
	`kOutPtBy
(
RTC_CMOSADDRESS
,
RTC_ADDRESS_MINUTE
);

18 
bDa
 = 
	`kInPtBy
(
RTC_CMOSDATA
);

19 *
pbMu
 = 
	`RTC_BCDTOBINARY
(
bDa
);

22 
	`kOutPtBy
(
RTC_CMOSADDRESS
,
RTC_ADDRESS_SECOND
);

24 
bDa
 = 
	`kInPtBy
(
RTC_CMOSDATA
);

25 *
pbSecd
 = 
	`RTC_BCDTOBINARY
(
bDa
);

26 
	}
}

29 
	$kRdRTCDa
(
WORD
* 
pwYr
,
BYTE
* 
pbMth
,BYTE* 
pbDayOfMth
,BYTE* 
pbDayOfWk
)

31 
BYTE
 
bDa
;

34 
	`kOutPtBy
(
RTC_CMOSADDRESS
,
RTC_ADDRESS_YEAR
);

36 
bDa
 = 
	`kInPtBy
(
RTC_CMOSDATA
);

37 *
pwYr
 = 
	`RTC_BCDTOBINARY
(
bDa
)+2000;

40 
	`kOutPtBy
(
RTC_CMOSADDRESS
,
RTC_ADDRESS_MONTH
);

42 
bDa
 = 
	`kInPtBy
(
RTC_CMOSDATA
);

43 *
pbMth
 = 
	`RTC_BCDTOBINARY
(
bDa
);

46 
	`kOutPtBy
(
RTC_CMOSADDRESS
,
RTC_ADDRESS_DAYOFMONTH
);

48 
bDa
 = 
	`kInPtBy
(
RTC_CMOSDATA
);

49 *
pbDayOfMth
 = 
	`RTC_BCDTOBINARY
(
bDa
);

52 
	`kOutPtBy
(
RTC_CMOSADDRESS
,
RTC_ADDRESS_DAYOFWEEK
);

54 
bDa
 = 
	`kInPtBy
(
RTC_CMOSDATA
);

55 *
pbDayOfWk
 = 
	`RTC_BCDTOBINARY
(
bDa
);

56 
	}
}

59 * 
	$kCvtDayOfWkToSg
(
BYTE
 
bDayOfWk
)

61 * 
vpcDayOfWkSg
[8] = {"Error","Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"};

64 if(
bDayOfWk
>=8)

66  
vpcDayOfWkSg
[0];

70  
vpcDayOfWkSg
[
bDayOfWk
];

71 
	}
}

	@/home/jk/os/MINT64/02.Kernel64/Source/RTC.h

1 #ide
__RTC_H__


2 
	#__RTC_H__


	)

4 
	~"Tys.h
"

8 
	#RTC_CMOSADDRESS
 0x70

	)

9 
	#RTC_CMOSDATA
 0x71

	)

12 
	#RTC_ADDRESS_SECOND
 0x00

	)

13 
	#RTC_ADDRESS_MINUTE
 0x02

	)

14 
	#RTC_ADDRESS_HOUR
 0x04

	)

15 
	#RTC_ADDRESS_DAYOFWEEK
 0x06

	)

16 
	#RTC_ADDRESS_DAYOFMONTH
 0x07

	)

17 
	#RTC_ADDRESS_MONTH
 0x08

	)

18 
	#RTC_ADDRESS_YEAR
 0x09

	)

21 
	#RTC_BCDTOBINARY
(
x
((((x)>>4)*10)+((x)&0x0F))

	)

24 
kRdRTCTime
(
BYTE
* 
pbHour
,BYTE* 
pbMu
,BYTE* 
pbSecd
);

25 
kRdRTCDa
(
WORD
* 
pwYr
,
BYTE
* 
pbMth
,BYTE* 
pbDayOfMth
,BYTE* 
pbDayOfWk
);

26 * 
kCvtDayOfWkToSg
(
BYTE
 
bDayOfWk
);

	@/home/jk/os/MINT64/02.Kernel64/Source/Synchronization.c

1 
	~"Synchrizi.h
"

2 
	~"Uty.h
"

3 
	~"Task.h
"

6 
BOOL
 
	$kLockFSyemDa
()

8  
	`kSIruFg
(
FALSE
);

9 
	}
}

12 
	$kUockFSyemDa
(
BOOL
 
bIruFg
)

14 
	`kSIruFg
(
bIruFg
);

15 
	}
}

18 
	$kInlizeMux
(
MUTEX
* 
pMux
)

21 
pMux
->
bLockFg
 = 
FALSE
;

22 
pMux
->
dwLockCou
=0;

23 
pMux
->
qwTaskID
=
TASK_INVALIDID
;

24 
	}
}

27 
	$kLock
(
MUTEX
* 
pMux
)

30 if(
	`kTeAndS
(&(
pMux
->
bLockFg
),0,1)==
FALSE
)

33 if(
pMux
->
qwTaskID
==
	`kGRugTask
()->
Lk
.
qwID
)

35 
pMux
->
dwLockCou
++;

40 
	`kTeAndS
(&(
pMux
->
bLockFg
),0,1)==
FALSE
)

42 
	`kSchedu
();

47 
pMux
->
dwLockCou
 =1;

48 
pMux
->
qwTaskID
=
	`kGRugTask
()->
Lk
.
qwID
;

50 
	}
}

53 
	$kUock
(
MUTEX
* 
pMux
)

56 if((
pMux
->
bLockFg
==
FALSE
)||աMux->
qwTaskID
!=
	`kGRugTask
()->
Lk
.
qwID
))

62 if(
pMux
->
dwLockCou
>1)

64 
pMux
->
dwLockCou
--;

69 
pMux
->
qwTaskID
 = 
TASK_INVALIDID
;

70 
pMux
->
dwLockCou
 = 0;

71 
pMux
->
bLockFg
=
FALSE
;

73 
	}
}

	@/home/jk/os/MINT64/02.Kernel64/Source/Synchronization.h

1 #ide
__SYNCHRONIZATION_H__


2 
	#__SYNCHRONIZATION_H__


	)

4 
	~"Tys.h
"

8 #agm
ck
(
push
,1)

11 
	skMuxtSu


14 vީ
QWORD
 
	mqwTaskID
;

15 vީ
DWORD
 
	mdwLockCou
;

18 vީ
BOOL
 
	mbLockFg
;

21 
BYTE
 
	mvbPaddg
[3];

22 } 
	tMUTEX
;

24 #agm
ck
(
p
)

27 
BOOL
 
kLockFSyemDa
();

28 
kUockFSyemDa
(
BOOL
 
bIruFg
);

30 
kInlizeMux
(
MUTEX
* 
pMux
);

31 
kLock
(
MUTEX
* 
pMux
);

32 
kUock
(
MUTEX
* 
pMux
);

	@/home/jk/os/MINT64/02.Kernel64/Source/Task.c

1 
	~"Task.h
"

2 
	~"Dest.h
"

3 
	~"Synchrizi.h
"

6 
SCHEDULER
 
	ggs_Schedur
;

7 
TCBPOOLMANAGER
 
	ggs_TCBPoMag
;

11 
kInlizeTCBPo
();

12 
TCB
* 
kAoTCB
();

13 
kFeTCB
(
QWORD
 
qwID
);

14 
kSUpTask
(
TCB
* 
pTCB
,
QWORD
 
qwFgs
,QWORD 
qwEryPotAddss
,* 
pvSckAddss
,QWORD 
qwSckSize
);

17 
TCB
* 
kGNextTaskToRun
();

18 
BOOL
 
kAddTaskToRdyLi
(
TCB
* 
pTask
);

19 
TCB
* 
kRemoveTaskFromRdyLi
(
QWORD
 
qwTaskID
);

20 
TCB
* 
kGProssByThad
(TCB* 
pThad
);

27 
	$kInlizeTCBPo
()

29 
i
;

31 
	`kMemS
(&(
gs_TCBPoMag
),0,(gs_stTCBPoolManager));

34 
gs_TCBPoMag
.
pSAddss
=(
TCB
*)
TASK_TCBPOOLADDRESS
;

35 
	`kMemS
(
TASK_TCBPOOLADDRESS
,0,(
TCB
)*
TASK_MAXCOUNT
);

38 
i
=0;i<
TASK_MAXCOUNT
;i++)

40 
gs_TCBPoMag
.
pSAddss
[
i
].
Lk
.
qwID
=i;

44 
gs_TCBPoMag
.
iMaxCou
=
TASK_MAXCOUNT
;

45 
gs_TCBPoMag
.
iAodCou
=1;

46 
gs_TCBPoMag
.
iUCou
=0;

47 
	}
}

50 
TCB
* 
	$kAoTCB
()

52 
TCB
* 
pEmyTCB
;

53 
i
;

55 if(
gs_TCBPoMag
.
iUCou
==gs_TCBPoMag.
iMaxCou
)

57  
NULL
;

60 
i
=0;i<
gs_TCBPoMag
.
iMaxCou
;i++)

63 if((
gs_TCBPoMag
.
pSAddss
[
i
].
Lk
.
qwID
>>32)==0)

65 
pEmyTCB
=&(
gs_TCBPoMag
.
pSAddss
[
i
]);

71 
pEmyTCB
->
Lk
.
qwID
=((
QWORD
)
gs_TCBPoMag
.
iAodCou
<<32)|
i
;

72 
gs_TCBPoMag
.
iUCou
++;

73 
gs_TCBPoMag
.
iAodCou
++;

74 if(
gs_TCBPoMag
.
iAodCou
==0)

76 
gs_TCBPoMag
.
iAodCou
=1;

78  
pEmyTCB
;

79 
	}
}

82 
	$kFeTCB
(
QWORD
 
qwID
)

84 
i
;

87 
i
 = 
	`GETTCBOFFSET
(
qwID
);

90 
	`kMemS
(&(
gs_TCBPoMag
.
pSAddss
[
i
].
Cڋxt
),0,(
CONTEXT
));

91 
gs_TCBPoMag
.
pSAddss
[
i
].
Lk
.
qwID
=i;

93 
gs_TCBPoMag
.
iUCou
--;

94 
	}
}

99 
TCB
* 
	$kCeTask
(
QWORD
 
qwFgs
,* 
pvMemyAddss
,QWORD 
qwMemySize
,QWORD 
qwEryPotAddss
)

101 
TCB
* 
pTask
,* 
pPross
;

102 * 
pvSckAddss
;

103 
BOOL
 
bPviousFg
;

106 
bPviousFg
 = 
	`kLockFSyemDa
();

107 
pTask
=
	`kAoTCB
();

108 if(
pTask
==
NULL
)

111 
	`kUockFSyemDa
(
bPviousFg
);

112  
NULL
;

116 
pPross
 = 
	`kGProssByThad
(
	`kGRugTask
());

118 if(
pPross
==
NULL
)

120 
	`kFeTCB
(
pTask
->
Lk
.
qwID
);

122 
	`kUockFSyemDa
(
bPviousFg
);

123  
NULL
;

127 if(
qwFgs
&
TASK_FLAGS_THREAD
)

130 
pTask
->
qwPtProssID
 = 
pPross
->
Lk
.
qwID
;

131 
pTask
->
pvMemyAddss
 = 
pPross
->pvMemoryAddress;

132 
pTask
->
qwMemySize
 = 
pPross
->qwMemorySize;

135 
	`kAddLiToTa
(&(
pPross
->
ChdThadLi
),&(
pTask
->
ThadLk
));

140 
pTask
->
qwPtProssID
 = 
pPross
->
Lk
.
qwID
;

141 
pTask
->
pvMemyAddss
 =vMemoryAddress;

142 
pTask
->
qwMemySize
 = qwMemorySize;

146 
pTask
->
ThadLk
.
qwID
 =Task->
Lk
.qwID;

149 
	`kUockFSyemDa
(
bPviousFg
);

152 
pvSckAddss
=(*)(
TASK_STACKPOOLADDRESS
+(
TASK_STACKSIZE
*
	`GETTCBOFFSET
(
pTask
->
Lk
.
qwID
)));

155 
	`kSUpTask
(
pTask
,
qwFgs
,
qwEryPotAddss
,
pvSckAddss
,
TASK_STACKSIZE
);

158 
	`kInlizeLi
(&(
pTask
->
ChdThadLi
));

161 
pTask
->
bFPUUd
 = 
FALSE
;

164 
bPviousFg
 = 
	`kLockFSyemDa
();

167 
	`kAddTaskToRdyLi
(
pTask
);

170 
	`kUockFSyemDa
(
bPviousFg
);

172  
pTask
;

173 
	}
}

176 
	$kSUpTask
(
TCB
* 
pTCB
,
QWORD
 
qwFgs
,QWORD 
qwEryPotAddss
,* 
pvSckAddss
,QWORD 
qwSckSize
)

179 
	`kMemS
(
pTCB
->
Cڋxt
.
vqRegi
,0,(pstTCB->stContext.vqRegister));

182 
pTCB
->
Cڋxt
.
vqRegi
[
TASK_RSPOFFSET
]=(
QWORD
)
pvSckAddss
+
qwSckSize
-8;

183 
pTCB
->
Cڋxt
.
vqRegi
[
TASK_RBPOFFSET
]=(
QWORD
)
pvSckAddss
+
qwSckSize
-8;

187 *(
QWORD
*)((QWORD)
pvSckAddss
+
qwSckSize
-8)=(QWORD)
kExTask
;

190 
pTCB
->
Cڋxt
.
vqRegi
[
TASK_CSOFFSET
]=
GDT_KERNELCODESEGMENT
;

191 
pTCB
->
Cڋxt
.
vqRegi
[
TASK_DSOFFSET
]=
GDT_KERNELDATASEGMENT
;

192 
pTCB
->
Cڋxt
.
vqRegi
[
TASK_ESOFFSET
]=
GDT_KERNELDATASEGMENT
;

193 
pTCB
->
Cڋxt
.
vqRegi
[
TASK_FSOFFSET
]=
GDT_KERNELDATASEGMENT
;

194 
pTCB
->
Cڋxt
.
vqRegi
[
TASK_GSOFFSET
]=
GDT_KERNELDATASEGMENT
;

195 
pTCB
->
Cڋxt
.
vqRegi
[
TASK_SSOFFSET
]=
GDT_KERNELDATASEGMENT
;

198 
pTCB
->
Cڋxt
.
vqRegi
[
TASK_RIPOFFSET
]=
qwEryPotAddss
;

201 
pTCB
->
Cڋxt
.
vqRegi
[
TASK_RFLAGSOFFSET
]|=0x0200;

204 
pTCB
->
pvSckAddss
=pvStackAddress;

205 
pTCB
->
qwSckSize
=qwStackSize;

206 
pTCB
->
qwFgs
=qwFlags;

207 
	}
}

214 
	$kInlizeSchedur
()

216 
i
;

217 
TCB
* 
pTask
;

220 
	`kInlizeTCBPo
();

223 
i
=0;i<
TASK_MAXREADYLISTCOUNT
;i++)

225 
	`kInlizeLi
(&(
gs_Schedur
.
vRdyLi
[
i
]));

226 
gs_Schedur
.
viExecuCou
[
i
]=0;

228 
	`kInlizeLi
(&(
gs_Schedur
.
WaLi
));

231 
pTask
 = 
	`kAoTCB
();

232 
gs_Schedur
.
pRugTask
 = 
pTask
;

233 
pTask
->
qwFgs
 = 
TASK_FLAGS_HIGHEST
 | 
TASK_FLAGS_PROCESS
 | 
TASK_FLAGS_SYSTEM
;

234 
pTask
->
qwPtProssID
 =Task->
Lk
.
qwID
;

235 
pTask
->
pvMemyAddss
 = (*)0x100000;

236 
pTask
->
qwMemySize
 = 0x500000;

237 
pTask
->
pvSckAddss
 = (*)0x600000;

238 
pTask
->
qwSckSize
 = 0x100000;

239 
	`kInlizeLi
(&(
pTask
->
ChdThadLi
));

242 
gs_Schedur
.
qwSndProssTimeInIdTask
=0;

243 
gs_Schedur
.
qwProssLd
=0;

246 
gs_Schedur
.
qwLaFPUUdTaskID
 = 
TASK_INVALIDID
;

248 
	}
}

252 
	$kSRugTask
(
TCB
* 
pTask
)

254 
BOOL
 
bPviousFg
;

257 
bPviousFg
 = 
	`kLockFSyemDa
();

259 
gs_Schedur
.
pRugTask
=
pTask
;

262 
	`kUockFSyemDa
(
bPviousFg
);

263 
	}
}

266 
TCB
* 
	$kGRugTask
()

268 
BOOL
 
bPviousFg
;

269 
TCB
* 
pRugTask
;

272 
bPviousFg
 = 
	`kLockFSyemDa
();

274 
pRugTask
 = 
gs_Schedur
.pstRunningTask;

277 
	`kUockFSyemDa
(
bPviousFg
);

279  
pRugTask
;

280 
	}
}

286 
	$kSchedu
()

288 
TCB
* 
pRugTask
, * 
pNextTask
;

289 
BOOL
 
bPviousFg
;

292 if(
	`kGRdyTaskCou
()<1)

299 
bPviousFg
=
	`kLockFSyemDa
();

302 
pNextTask
=
	`kGNextTaskToRun
();

303 if(
pNextTask
==
NULL
)

306 
	`kUockFSyemDa
(
bPviousFg
);

311 
pRugTask
=
gs_Schedur
.pstRunningTask;

312 
gs_Schedur
.
pRugTask
=
pNextTask
;

315 if((
pRugTask
->
qwFgs
&
TASK_FLAGS_IDLE
)==TASK_FLAGS_IDLE)

317 
gs_Schedur
.
qwSndProssTimeInIdTask
+=
TASK_PROCESSORTIME
-gs_Schedur.
iProssTime
;

321 if(
gs_Schedur
.
qwLaFPUUdTaskID
!=
pNextTask
->
Lk
.
qwID
)

323 
	`kSTS
();

327 
	`kCˬTS
();

336 
gs_Schedur
.
iProssTime
=
TASK_PROCESSORTIME
;

339 if(
pRugTask
->
qwFgs
&
TASK_FLAGS_ENDTASK
)

341 
	`kAddLiToTa
(&(
gs_Schedur
.
WaLi
),
pRugTask
);

342 
	`kSwchCڋxt
(
NULL
,&(
pNextTask
->
Cڋxt
));

346 
	`kAddTaskToRdyLi
(
pRugTask
);

347 
	`kSwchCڋxt
(&(
pRugTask
->
Cڋxt
),&(
pNextTask
->stContext));

353 
	`kUockFSyemDa
(
bPviousFg
);

354 
	}
}

365 
BOOL
 
	$kScheduInIru
()

367 
TCB
* 
pRugTask
, * 
pNextTask
;

368 * 
pcCڋxtAddss
;

369 
BOOL
 
bPviousFg
;

372 
bPviousFg
 = 
	`kLockFSyemDa
();

375 
pNextTask
=
	`kGNextTaskToRun
();

376 if(
pNextTask
==
NULL
)

379 
	`kUockFSyemDa
(
bPviousFg
);

380  
FALSE
;

387 
pcCڋxtAddss
=(*)
IST_STARTADDRESS
+
IST_SIZE
-(
CONTEXT
);

390 
pRugTask
 = 
gs_Schedur
.pstRunningTask;

391 
gs_Schedur
.
pRugTask
 = 
pNextTask
;

395 if((
pRugTask
->
qwFgs
&
TASK_FLAGS_IDLE
)==TASK_FLAGS_IDLE)

397 
gs_Schedur
.
qwSndProssTimeInIdTask
+=
TASK_PROCESSORTIME
-gs_Schedur.
iProssTime
;

401 if(
pRugTask
->
qwFgs
&
TASK_FLAGS_ENDTASK
)

403 
	`kAddLiToTa
(&(
gs_Schedur
.
WaLi
),
pRugTask
);

409 
	`kMemCpy
(&(
pRugTask
->
Cڋxt
),
pcCڋxtAddss
,(
CONTEXT
));

410 
	`kAddTaskToRdyLi
(
pRugTask
);

414 
	`kUockFSyemDa
(
bPviousFg
);

417 if(
gs_Schedur
.
qwLaFPUUdTaskID
!=
pNextTask
->
Lk
.
qwID
)

419 
	`kSTS
();

423 
	`kCˬTS
();

428 
	`kMemCpy
(
pcCڋxtAddss
,&(
pNextTask
->
Cڋxt
),(
CONTEXT
));

431 
gs_Schedur
.
iProssTime
=
TASK_PROCESSORTIME
;

432  
TRUE
;

433 
	}
}

436 
	$kDeProssTime
()

438 if(
gs_Schedur
.
iProssTime
>0)

440 
gs_Schedur
.
iProssTime
--;

442 
	}
}

445 
BOOL
 
	$kIsProssTimeExped
()

447 if(
gs_Schedur
.
iProssTime
<=0)

449  
TRUE
;

451  
FALSE
;

452 
	}
}

455 
TCB
* 
	$kGNextTaskToRun
()

457 
TCB
* 
pTg
=
NULL
;

458 
iTaskCou
,
i
,
j
;

462 
j
=0;j<2;j++)

465 
i
=0;i<
TASK_MAXREADYLISTCOUNT
;i++)

467 
iTaskCou
 = 
	`kGLiCou
(&(
gs_Schedur
.
vRdyLi
[
i
]));

470 if(
gs_Schedur
.
viExecuCou
[
i
]<
iTaskCou
)

472 
pTg
=(
TCB
*)
	`kRemoveLiFromHd
(&(
gs_Schedur
.
vRdyLi
[
i
]));

473 
gs_Schedur
.
viExecuCou
[
i
]++;

479 
gs_Schedur
.
viExecuCou
[
i
]=0;

484 if(
pTg
!=
NULL
)

490  
pTg
;

491 
	}
}

494 
BOOL
 
	$kAddTaskToRdyLi
(
TCB
* 
pTask
)

496 
BYTE
 
bPriܙy
;

498 
bPriܙy
 = 
	`GETPRIORITY
(
pTask
->
qwFgs
);

499 if(
bPriܙy
>=
TASK_MAXREADYLISTCOUNT
)

501  
FALSE
;

504 
	`kAddLiToTa
(&(
gs_Schedur
.
vRdyLi
[
bPriܙy
]),
pTask
);

505  
TRUE
;

506 
	}
}

509 
TCB
* 
	$kRemoveTaskFromRdyLi
(
QWORD
 
qwTaskID
)

511 
TCB
* 
pTg
;

512 
BYTE
 
bPriܙy
;

515 if(
	`GETTCBOFFSET
(
qwTaskID
)>=
TASK_MAXCOUNT
)

517  
NULL
;

521 
pTg
=&(
gs_TCBPoMag
.
pSAddss
[
	`GETTCBOFFSET
(
qwTaskID
)]);

522 if(
pTg
->
Lk
.
qwID
!=
qwTaskID
)

524  
NULL
;

528 
bPriܙy
 = 
	`GETPRIORITY
(
pTg
->
qwFgs
);

530 
pTg
 = 
	`kRemoveLi
(&(
gs_Schedur
.
vRdyLi
[
bPriܙy
]),
qwTaskID
);

531  
pTg
;

532 
	}
}

535 
BOOL
 
	$kChgePriܙy
(
QWORD
 
qwTaskID
,
BYTE
 
bPriܙy
)

537 
TCB
* 
pTg
;

538 
BOOL
 
bPviousFg
;

541 if(
bPriܙy
>
TASK_MAXREADYLISTCOUNT
)

543  
FALSE
;

547 
bPviousFg
 = 
	`kLockFSyemDa
();

552 
pTg
 = 
gs_Schedur
.
pRugTask
;

553 if(
pTg
->
Lk
.
qwID
 =
qwTaskID
)

555 
	`SETPRIORITY
(
pTg
->
qwFgs
,
bPriܙy
);

561 
pTg
 = 
	`kRemoveTaskFromRdyLi
(
qwTaskID
);

562 if(
pTg
==
NULL
)

567 
pTg
 = 
	`kGTCBInTCBPo
(
	`GETTCBOFFSET
(
qwTaskID
));

568 if((
pTg
!=
NULL
)&&(
qwTaskID
=Tg->
Lk
.
qwID
))

571 
	`SETPRIORITY
(
pTg
->
qwFgs
,
bPriܙy
);

573  
FALSE
;

578 
	`SETPRIORITY
(
pTg
->
qwFgs
,
bPriܙy
);

579 
	`kAddTaskToRdyLi
(
pTg
);

584 
	`kUockFSyemDa
(
bPviousFg
);

585  
TRUE
;

586 
	}
}

589 
BOOL
 
	$kEndTask
(
QWORD
 
qwTaskID
)

591 
TCB
* 
pTg
;

592 
BYTE
 
bPriܙy
;

593 
BOOL
 
bPviousFg
;

596 
bPviousFg
 = 
	`kLockFSyemDa
();

599 
pTg
 = 
gs_Schedur
.
pRugTask
;

600 if(
pTg
->
Lk
.
qwID
==
qwTaskID
)

602 
pTg
->
qwFgs
|=
TASK_FLAGS_ENDTASK
;

604 
	`SETPRIORITY
(
pTg
->
qwFgs
,
TASK_FLAGS_WAIT
);

607 
	`kUockFSyemDa
(
bPviousFg
);

609 
	`kSchedu
();

618 
pTg
=
	`kRemoveTaskFromRdyLi
(
qwTaskID
);

619 if(
pTg
==
NULL
)

626 
pTg
 = 
	`kGTCBInTCBPo
(
	`GETTCBOFFSET
(
qwTaskID
));

627 if((
pTg
!=
NULL
)&&աTg->
Lk
.
qwID
==
qwTaskID
))

629 
pTg
->
qwFgs
|=
TASK_FLAGS_ENDTASK
;

630 
	`SETPRIORITY
(
pTg
->
qwFgs
,
TASK_FLAGS_WAIT
);

634 
	`kUockFSyemDa
(
bPviousFg
);

635  
FALSE
;

638 
pTg
->
qwFgs
|=
TASK_FLAGS_ENDTASK
;

639 
	`SETPRIORITY
(
pTg
->
qwFgs
,
TASK_FLAGS_WAIT
);

640 
	`kAddLiToTa
(&(
gs_Schedur
.
WaLi
),
pTg
);

644 
	`kUockFSyemDa
(
bPviousFg
);

645  
TRUE
;

646 
	}
}

649 
	$kExTask
()

651 
	`kEndTask
(
gs_Schedur
.
pRugTask
->
Lk
.
qwID
);

652 
	}
}

655 
	$kGRdyTaskCou
()

657 
iTٮCou
=0;

658 
i
;

659 
BOOL
 
bPviousFg
;

662 
bPviousFg
 = 
	`kLockFSyemDa
();

665 
i
=0;i<
TASK_MAXREADYLISTCOUNT
;i++)

667 
iTٮCou
+=
	`kGLiCou
(&(
gs_Schedur
.
vRdyLi
[
i
]));

670 
	`kUockFSyemDa
(
bPviousFg
);

671  
iTٮCou
;

672 
	}
}

675 
	$kGTaskCou
()

677 
iTٮCou
;

678 
BOOL
 
bPviousFg
;

681 
iTٮCou
=
	`kGRdyTaskCou
();

684 
bPviousFg
 = 
	`kLockFSyemDa
();

686 
iTٮCou
+=
	`kGLiCou
(&(
gs_Schedur
.
WaLi
))+1;

689 
	`kUockFSyemDa
(
bPviousFg
);

690  
iTٮCou
;

691 
	}
}

694 
TCB
* 
	$kGTCBInTCBPo
(
iOfft
)

696 if((
iOfft
<-1)||(iOfft>
TASK_MAXCOUNT
))

698  
NULL
;

701  &(
gs_TCBPoMag
.
pSAddss
[
iOfft
]);

702 
	}
}

705 
BOOL
 
	$kIsTaskExi
(
QWORD
 
qwID
)

707 
TCB
* 
pTCB
;

710 
pTCB
 = 
	`kGTCBInTCBPo
(
	`GETTCBOFFSET
(
qwID
));

712 if((
pTCB
==
NULL
)||աTCB->
Lk
.
qwID
!=qwID))

714  
FALSE
;

717  
TRUE
;

718 
	}
}

721 
QWORD
 
	$kGProssLd
()

723  
gs_Schedur
.
qwProssLd
;

724 
	}
}

727 
TCB
* 
	$kGProssByThad
(
TCB
* 
pThad
)

729 
TCB
* 
pPross
;

732 if(
pThad
->
qwFgs
&
TASK_FLAGS_PROCESS
)

734  
pThad
;

739 
pPross
 = 
	`kGTCBInTCBPo
(
	`GETTCBOFFSET
(
pThad
->
qwPtProssID
));

742 if((
pPross
==
NULL
)||աPross->
Lk
.
qwID
!=
pThad
->
qwPtProssID
))

744  
NULL
;

747  
pPross
;

748 
	}
}

755 
	$kIdTask
()

757 
TCB
* 
pTask
,* 
pChdThad
,* 
pPross
;

758 
QWORD
 
qwLaMsuTickCou
,
qwLaSndTickInIdTask
;

759 
QWORD
 
qwCutMsuTickCou
,
qwCutSndTickInIdTask
;

760 
BOOL
 
bPviousFg
;

761 
i
, 
iCou
;

762 
QWORD
 
qwTaskID
;

763 * 
pThadLk
;

766 
qwLaSndTickInIdTask
 = 
gs_Schedur
.
qwSndProssTimeInIdTask
;

767 
qwLaMsuTickCou
 = 
	`kGTickCou
();

772 
qwCutMsuTickCou
 = 
	`kGTickCou
();

773 
qwCutSndTickInIdTask
 = 
gs_Schedur
.
qwSndProssTimeInIdTask
;

777 if(
qwCutMsuTickCou
-
qwLaMsuTickCou
==0)

779 
gs_Schedur
.
qwProssLd
=0;

783 
gs_Schedur
.
qwProssLd
=100-(
qwCutSndTickInIdTask
-
qwLaSndTickInIdTask
)*100/(
qwCutMsuTickCou
-
qwLaMsuTickCou
);

786 
qwLaMsuTickCou
 = 
qwCutMsuTickCou
;

787 
qwLaSndTickInIdTask
 = 
qwCutSndTickInIdTask
;

790 
	`kHtProssByLd
();

793 if(
	`kGLiCou
(&(
gs_Schedur
.
WaLi
))>=0)

798 
bPviousFg
 = 
	`kLockFSyemDa
();

799 
pTask
=
	`kRemoveLiFromHd
(&(
gs_Schedur
.
WaLi
));

800 if(
pTask
==
NULL
)

803 
	`kUockFSyemDa
(
bPviousFg
);

807 if(
pTask
->
qwFgs
&
TASK_FLAGS_PROCESS
)

818 
iCou
 = 
	`kGLiCou
(&(
pTask
->
ChdThadLi
));

819 
i
=0;i<
iCou
;i++)

822 
pThadLk
 = (
TCB
*)
	`kRemoveLiFromHd
(&(
pTask
->
ChdThadLi
));

823 if(
pThadLk
==
NULL
)

831 
pChdThad
 = 
	`GETTCBFROMTHREADLINK
(
pThadLk
);

832 
	`kAddLiToTa
(&(
pTask
->
ChdThadLi
),&(
pChdThad
->
ThadLk
));

835 
	`kEndTask
(
pChdThad
->
Lk
.
qwID
);

840 if(
	`kGLiCou
(&(
pTask
->
ChdThadLi
))>0)

842 
	`kAddLiToTa
(&(
gs_Schedur
.
WaLi
),
pTask
);

845 
	`kUockFSyemDa
(
bPviousFg
);

854 if(
pTask
->
qwFgs
&
TASK_FLAGS_THREAD
)

857 
pPross
 = 
	`kGProssByThad
(
pTask
);

858 if(
pPross
!=
NULL
)

860 
	`kRemoveLi
(&(
pPross
->
ChdThadLi
),
pTask
->
Lk
.
qwID
);

865 
qwTaskID
 = 
pTask
->
Lk
.
qwID
;

866 
	`kFeTCB
(
qwTaskID
);

868 
	`kUockFSyemDa
(
bPviousFg
);

869 
	`kPrtf
("IDLE: Task Id[0x%q] icomynded.\n",
qwTaskID
);

874 
	`kSchedu
();

876 
	}
}

879 
	$kHtProssByLd
()

881 if(
gs_Schedur
.
qwProssLd
<40)

883 
	`kH
();

884 
	`kH
();

885 
	`kH
();

887 if(
gs_Schedur
.
qwProssLd
<80)

889 
	`kH
();

890 
	`kH
();

892 if(
gs_Schedur
.
qwProssLd
<95)

894 
	`kH
();

896 
	}
}

902 
QWORD
 
	$kGLaFPUUdTaskID
()

904  
gs_Schedur
.
qwLaFPUUdTaskID
;

905 
	}
}

908 
	$kSLaFPUUdTaskID
(
QWORD
 
qwTaskID
)

910 
gs_Schedur
.
qwLaFPUUdTaskID
 = 
qwTaskID
;

911 
	}
}

	@/home/jk/os/MINT64/02.Kernel64/Source/Task.h

1 #ide
__TASK_H__


2 
	#__TASK_H__


	)

4 
	~"Tys.h
"

5 
	~"Li.h
"

9 
	#TASK_REGISTERCOUNT
 (5+19)

	)

10 
	#TASK_REGISTERSIZE
 8

	)

13 
	#TASK_GSOFFSET
 0

	)

14 
	#TASK_FSOFFSET
 1

	)

15 
	#TASK_ESOFFSET
 2

	)

16 
	#TASK_DSOFFSET
 3

	)

17 
	#TASK_R15OFFSET
 4

	)

18 
	#TASK_R14OFFSET
 5

	)

19 
	#TASK_R13OFFSET
 6

	)

20 
	#TASK_R12OFFSET
 7

	)

21 
	#TASK_R11OFFSET
 8

	)

22 
	#TASK_R10OFFSET
 9

	)

23 
	#TASK_R9OFFSET
 10

	)

24 
	#TASK_R8OFFSET
 11

	)

25 
	#TASK_RSIOFFSET
 12

	)

26 
	#TASK_RDIOFFSET
 13

	)

27 
	#TASK_RDXOFFSET
 14

	)

28 
	#TASK_RCXOFFSET
 15

	)

29 
	#TASK_RBXOFFSET
 16

	)

30 
	#TASK_RAXOFFSET
 17

	)

31 
	#TASK_RBPOFFSET
 18

	)

32 
	#TASK_RIPOFFSET
 19

	)

33 
	#TASK_CSOFFSET
 20

	)

34 
	#TASK_RFLAGSOFFSET
 21

	)

35 
	#TASK_RSPOFFSET
 22

	)

36 
	#TASK_SSOFFSET
 23

	)

39 
	#TASK_TCBPOOLADDRESS
 0x800000

	)

40 
	#TASK_MAXCOUNT
 1024

	)

43 
	#TASK_STACKPOOLADDRESS
 (
TASK_TCBPOOLADDRESS
+(
TCB
)*
TASK_MAXCOUNT
)

	)

44 
	#TASK_STACKSIZE
 8192

	)

47 
	#TASK_INVALIDID
 0xFFFFFFFFFFFFFFFF

	)

50 
	#TASK_PROCESSORTIME
 5

	)

53 
	#TASK_MAXREADYLISTCOUNT
 5

	)

56 
	#TASK_FLAGS_HIGHEST
 0

	)

57 
	#TASK_FLAGS_HIGH
 1

	)

58 
	#TASK_FLAGS_MEDIUM
 2

	)

59 
	#TASK_FLAGS_LOW
 3

	)

60 
	#TASK_FLAGS_LOWEST
 4

	)

61 
	#TASK_FLAGS_WAIT
 0xFF

	)

64 
	#TASK_FLAGS_ENDTASK
 0x8000000000000000

	)

65 
	#TASK_FLAGS_SYSTEM
 0x4000000000000000

	)

66 
	#TASK_FLAGS_PROCESS
 0x2000000000000000

	)

67 
	#TASK_FLAGS_THREAD
 0x1000000000000000

	)

68 
	#TASK_FLAGS_IDLE
 0x0800000000000000

	)

71 
	#GETPRIORITY
(
x
((x)&0xFF)

	)

72 
	#SETPRIORITY
(
x
,
iܙy
((x)=((x)&0xFFFFFFFFFFFFFF00)|riܙy))

	)

73 
	#GETTCBOFFSET
(
x
((x)&0xFFFFFFFF)

	)

76 
	#GETTCBFROMTHREADLINK
(
x
(
TCB
*)((
QWORD
)(x)-
	`offtof
(TCB,
ThadLk
))

	)

80 #agm
ck
(
push
,1)

83 
	skCڋxtSu


85 
QWORD
 
	mvqRegi
[
TASK_REGISTERCOUNT
];

86 } 
	tCONTEXT
;

90 
	skTaskCڌBlockSu


93 
LISTLINK
 
	mLk
;

96 
QWORD
 
	mqwFgs
;

99 * 
	mpvMemyAddss
;

100 
QWORD
 
	mqwMemySize
;

106 
LISTLINK
 
	mThadLk
;

109 
QWORD
 
	mqwPtProssID
;

112 
QWORD
 
	mvqwFPUCڋxt
[512/8];

115 
LIST
 
	mChdThadLi
;

118 
CONTEXT
 
	mCڋxt
;

121 * 
	mpvSckAddss
;

122 
QWORD
 
	mqwSckSize
;

125 
BOOL
 
	mbFPUUd
;

128 
	mvcPaddg
[11];

129 } 
	tTCB
;

132 
	skTCBPoMagSu


135 
TCB
* 
	mpSAddss
;

136 
	miMaxCou
;

137 
	miUCou
;

140 
	miAodCou
;

141 } 
	tTCBPOOLMANAGER
;

144 
	skSchedurSu


147 
TCB
* 
	mpRugTask
;

150 
	miProssTime
;

153 
LIST
 
	mvRdyLi
[
TASK_MAXREADYLISTCOUNT
];

156 
LIST
 
	mWaLi
;

159 
	mviExecuCou
[
TASK_MAXREADYLISTCOUNT
];

162 
QWORD
 
	mqwProssLd
;

165 
QWORD
 
	mqwSndProssTimeInIdTask
;

168 
QWORD
 
	mqwLaFPUUdTaskID
;

170 } 
	tSCHEDULER
;

173 #agm
ck
(
p
)

180 
TCB
* 
kCeTask
(
QWORD
 
qwFgs
,* 
pvMemyAddss
,QWORD 
qwMemySize
,QWORD 
qwEryPotAddss
);

186 
kInlizeSchedur
();

187 
kSRugTask
(
TCB
* 
pTask
);

188 
TCB
* 
kGRugTask
();

189 
kSchedu
();

190 
BOOL
 
kScheduInIru
();

191 
kDeProssTime
();

192 
BOOL
 
kIsProssTimeExped
();

193 
BOOL
 
kChgePriܙy
(
QWORD
 
qwID
,
BYTE
 
bPriܙy
);

194 
BOOL
 
kEndTask
(
QWORD
 
qwTaskID
);

195 
kExTask
();

196 
kGRdyTaskCou
();

197 
kGTaskCou
();

198 
TCB
* 
kGTCBInTCBPo
(
iOfft
);

199 
BOOL
 
kIsTaskExi
(
QWORD
 
qwID
);

200 
QWORD
 
kGProssLd
();

206 
kIdTask
();

207 
kHtProssByLd
();

212 
QWORD
 
kGLaFPUUdTaskID
();

213 
kSLaFPUUdTaskID
(
QWORD
 
qwTaskID
);

	@/home/jk/os/MINT64/02.Kernel64/Source/Types.h

1 #ide
__TYPES_H__


2 
	#__TYPES_H__


	)

4 
	#BYTE
 

	)

5 
	#WORD
 

	)

6 
	#DWORD
 

	)

7 
	#QWORD
 

	)

8 
	#BOOL
 

	)

10 
	#TRUE
 1

	)

11 
	#FALSE
 0

	)

12 
	#NULL
 0

	)

15 
	#offtof
(
TYPE
,
MEMBER

	`__but_offtof
(TYPE,MEMBER)

	)

17 #agm
ck
(
push
,1)

19 
	skChaSu


21 
BYTE
 
	mbCha
;

22 
BYTE
 
	mbAribu
;

23 } 
	tCHARACTER
;

25 #agm
ck
(
p
)

	@/home/jk/os/MINT64/02.Kernel64/Source/Utility.c

1 
	~"Uty.h
"

2 
	~"AsmblyUty.h
"

3 
	~<dg.h
>

6 vީ
QWORD
 
	gg_qwTickCou
=0;

9 
	$kMemS
(* 
pvDei
,
BYTE
 
bDa
,
iSize
)

11 
i
;

13 
i
=0;i<
iSize
;i++)

15 ((*)
pvDei
)[
i
]=
bDa
;

17 
	}
}

20 
	$kMemCpy
(* 
pvDei
,cڡ * 
pvSour
,
iSize
)

22 
i
;

24 
i
=0;i<
iSize
;i++)

26 ((*)
pvDei
)[
i
]=((*)
pvSour
)[i];

29  
iSize
;

30 
	}
}

33 
	$kMemCmp
(cڡ * 
pvDei
,cڡ * 
pvSour
,
iSize
)

35 
i
;

36 
cTemp
;

38 
i
=0;i<
iSize
;i++)

40 
cTemp
=((*)
pvDei
)[
i
]-((*)
pvSour
)[i];

42 if(
cTemp
!=0)

44  ()
cTemp
;

49 
	}
}

52 
BOOL
 
	$kSIruFg
(
BOOL
 
bEbIru
)

54 
QWORD
 
qwRFLAGS
;

57 
qwRFLAGS
=
	`kRdRFLAGS
();

58 if(
bEbIru
==
TRUE
)

60 
	`kEbIru
();

64 
	`kDibIru
();

68 if(
qwRFLAGS
&0x0200)

70  
TRUE
;

73  
FALSE
;

74 
	}
}

77 
	$kSL
(cڡ * 
pcBufr
)

79 
i
;

81 
i
=0;;i++)

83 if(
pcBufr
[
i
]=='\0')

89  
i
;

90 
	}
}

93 
	ggs_qwTٮRAMMBSize
=0;

96 
	$kCheckTٮRAMSize
()

98 
DWORD
* 
pdwCutAddss
;

99 
DWORD
 
dwPviousVue
;

102 
pdwCutAddss
 =(
DWORD
*)0x4000000;

106 
dwPviousVue
 = *
pdwCutAddss
;

108 *
pdwCutAddss
 = 0x12345678;

109 if(*
pdwCutAddss
!=0x12345678)

115 *
pdwCutAddss
=
dwPviousVue
;

117 
pdwCutAddss
+=(0x400000/4);

122 
gs_qwTٮRAMMBSize
 = (
QWORD
)
pdwCutAddss
/0x100000;

123 
	}
}

126 
QWORD
 
	$kGTٮRAMSize
()

128  
gs_qwTٮRAMMBSize
;

129 
	}
}

132 
	$kAToI
(cڡ * 
pcBufr
,
iRadix
)

134 
lRu
;

136 
iRadix
)

141 
lRu
 = 
	`kHexSgToQwd
(
pcBufr
);

147 
lRu
 = 
	`kDecimSgToLg
(
pcBufr
);

151  
lRu
;

152 
	}
}

155 
QWORD
 
	$kHexSgToQwd
(cڡ * 
pcBufr
)

157 
QWORD
 
qwVue
 = 0;

158 
i
;

161 
i
=0;
pcBufr
[i]!='\0';i++)

163 
qwVue
*=16;

164 if(('A'<=
pcBufr
[
i
])&&(pcBuffer[i]<='Z'))

166 
qwVue
+=((
pcBufr
[
i
]-'A')+10);

168 if(('a'<=
pcBufr
[
i
])&&(pcBuffer[i]<='z'))

170 
qwVue
+=((
pcBufr
[
i
]-'a')+10);

174 
qwVue
+=(
pcBufr
[
i
]-'0');

178  
qwVue
;

179 
	}
}

182 
	$kDecimSgToLg
(cڡ * 
pcBufr
)

184 
lVue
=0;

185 
i
;

188 if(
pcBufr
[0]=='-')

190 
i
=1;

194 
i
=0;

198 ;
pcBufr
[
i
]!='\0';i++)

200 
lVue
*=10;

201 
lVue
+=
pcBufr
[
i
]-'0';

205 if(
pcBufr
[0]=='-')

207 
lVue
=-lValue;

210  
lVue
;

211 
	}
}

214 
	$kIToA
(
lVue
,* 
pcBufr
,
iRadix
)

216 
iRu
;

218 
iRadix
)

223 
iRu
=
	`kHexToSg
(
lVue
,
pcBufr
);

229 
iRu
=
	`kDecimTorg
(
lVue
,
pcBufr
);

233  
iRu
;

234 
	}
}

237 
	$kHexToSg
(
QWORD
 
qwVue
,* 
pcBufr
)

239 
QWORD
 
i
;

240 
QWORD
 
qwCutVue
;

243 if(
qwVue
==0)

245 
pcBufr
[0]='0';

246 
pcBufr
[1]='\0';

251 
i
=0;
qwVue
>0;i++)

253 
qwCutVue
=
qwVue
%16;

254 if(
qwCutVue
>=10)

256 
pcBufr
[
i
]='A'+(
qwCutVue
-10);

260 
pcBufr
[
i
]='0'+
qwCutVue
;

263 
qwVue
=qwValue/16;

266 
pcBufr
[
i
]='\0';

269 
	`kRevSg
(
pcBufr
);

270  
i
;

271 
	}
}

274 
	$kDecimTorg
(
lVue
,* 
pcBufr
)

276 
i
;

279 if(
lVue
==0)

281 
pcBufr
[0]='0';

282 
pcBufr
[1]='\0';

287 if(
lVue
<0)

289 
i
=1;

290 
pcBufr
[0]='-';

291 
lVue
=-lValue;

295 
i
=0;

299 ;
lVue
>0;
i
++)

301 
pcBufr
[
i
]='0'+
lVue
%10;

302 
lVue
=lValue/10;

304 
pcBufr
[
i
]='\0';

307 if(
pcBufr
[0]=='-')

310 
	`kRevSg
(&(
pcBufr
[1]));

314 
	`kRevSg
(
pcBufr
);

317  
i
;

318 
	}
}

321 
	$kRevSg
(* 
pcBufr
)

323 
iLgth
;

324 
i
;

325 
cTemp
;

328 
iLgth
=
	`kSL
(
pcBufr
);

329 
i
=0;i<
iLgth
/2;i++)

331 
cTemp
=
pcBufr
[
i
];

332 
pcBufr
[
i
]cBufr[
iLgth
-1-i];

333 
pcBufr
[
iLgth
-1-
i
]=
cTemp
;

335 
	}
}

338 
	$kSPrtf
(* 
pcBufr
,cڡ * 
pcFmSg
,...)

340 
va_li
 

;

341 
iRu
;

344 
	`va_t
(

,
pcFmSg
);

345 
iRu
=
	`kVSPrtf
(
pcBufr
,
pcFmSg
,

);

346 
	`va_d
(

);

348  
iRu
;

349 
	}
}

353 
	$kVSPrtf
(* 
pcBufr
,cڡ * 
pcFmSg
,
va_li
 

)

355 
QWORD
 
i
,
j
,
k
;

356 
iBufrIndex
=0;

357 
iFmLgth
,
iCyLgth
;

358 * 
pcCySg
;

359 
QWORD
 
qwVue
;

360 
iVue
;

361 
dVue
;

364 
iFmLgth
=
	`kSL
(
pcFmSg
);

365 
i
=0;i<
iFmLgth
;i++)

368 if(
pcFmSg
[
i
]=='%')

371 
i
++;

372 
pcFmSg
[
i
])

377 
pcCySg
=(*)(
	`va_g
(

,*));

378 
iCyLgth
=
	`kSL
(
pcCySg
);

380 
	`kMemCpy
(
pcBufr
+
iBufrIndex
,
pcCySg
,
iCyLgth
);

381 
iBufrIndex
+=
iCyLgth
;

387 
pcBufr
[
iBufrIndex
]=()(
	`va_g
(

,));

388 
iBufrIndex
++;

396 
iVue
=()(
	`va_g
(

,));

397 
iBufrIndex
+=
	`kIToA
(
iVue
,
pcBufr
+iBufferIndex,10);

405 
qwVue
=(
DWORD
)(
	`va_g
(

,DWORD))&0xFFFFFFFF;

406 
iBufrIndex
+=
	`kIToA
(
qwVue
,
pcBufr
+iBufferIndex,16);

415 
qwVue
=(
QWORD
)(
	`va_g
(

,QWORD));

416 
iBufrIndex
+=
	`kIToA
(
qwVue
,
pcBufr
+iBufferIndex,16);

420 
dVue
 = ()(
	`va_g
(

,));

422 
dVue
 +=0.005;

424 
pcBufr
[
iBufrIndex
]='0'+(
QWORD
)(
dVue
*100)%10;

425 
pcBufr
[
iBufrIndex
+1]='0'+(
QWORD
)(
dVue
*10)%10;

426 
pcBufr
[
iBufrIndex
+2]='.';

428 
k
=0;;k++)

431 if(((
QWORD
)
dVue
==0)&&(
k
!=0))

435 
pcBufr
[
iBufrIndex
+3+
k
]='0'+((
QWORD
)
dVue
%10);

436 
dVue
=dValue/10;

438 
pcBufr
[
iBufrIndex
+3+
k
]='\0';

440 
	`kRevSg
(
pcBufr
+
iBufrIndex
);

441 
iBufrIndex
+=3+
k
;

446 
pcBufr
[
iBufrIndex
]=
pcFmSg
[
i
];

447 
iBufrIndex
++;

455 
pcBufr
[
iBufrIndex
] = 
pcFmSg
[
i
];

456 
iBufrIndex
++;

461 
pcBufr
[
iBufrIndex
]='\0';

462  
iBufrIndex
;

463 
	}
}

466 
QWORD
 
	$kGTickCou
()

468  
g_qwTickCou
;

469 
	}
}

472 
	$kS˕
(
QWORD
 
qwMlicd
)

474 
QWORD
 
qwLaTickCou
;

476 
qwLaTickCou
 = 
g_qwTickCou
;

478 (
g_qwTickCou
-
qwLaTickCou
)<=
qwMlicd
)

480 
	`kSchedu
();

482 
	}
}

	@/home/jk/os/MINT64/02.Kernel64/Source/Utility.h

1 #ide
__UTILITY_H__


2 
	#__UTILITY_H__


	)

4 
	~"/u/oss/lib/gcc/x86_64-pc-lux/4.8.2/ude/dg.h
"

5 
	~"Tys.h
"

8 
	#MIN
(
x
,
y
(((x)<(y))?(x):(y))

	)

9 
	#MAX
(
x
,
y
(((x)<(y))?(x):(y))

	)

12 
kMemS
(* 
pvDei
, 
BYTE
 
bDa
, 
iSize
);

13 
kMemCpy
(* 
pvDei
,cڡ * 
pvSour
,
iSize
);

14 
kMemCmp
(cڡ * 
pvDei
,cڡ * 
pvSour
,
iSize
);

15 
BOOL
 
kSIruFg
(BOOL 
bEbIru
);

16 
kCheckTٮRAMSize
();

17 
QWORD
 
kGTٮRAMSize
();

18 
kRevSg
(* 
pcBufr
);

19 
kAToI
(cڡ * 
pcBufr
,
iRadix
);

20 
QWORD
 
kHexSgToQwd
(cڡ * 
pcBufr
);

21 
kDecimSgToLg
(cڡ * 
pcBufr
);

22 
kIToA
(
lvue
,* 
pcBufr
,
iRadix
);

23 
kHexToSg
(
QWORD
 
qwVue
,* 
Bufr
);

24 
kDecimTorg
(
lVue
,* 
pcBufr
);

25 
kSPrtf
(* 
pcBufr
,cڡ * 
pcFmSg
,...);

26 
kVSPrtf
(* 
pcBufr
,cڡ * 
pcFmSg
,
va_li
 

);

27 
QWORD
 
kGTickCou
();

28 
kS˕
(
QWORD
 
qwMlicd
);

31 vީ
QWORD
 
g_qwTickCou
;

	@/home/jk/os/MINT64/02.Kernel64/Source/main.c

1 
	~"Tys.h
"

2 
	~"Keybrd.h
"

3 
	~"Dest.h
"

4 
	~"PIC.h
"

5 
	~"Cse.h
"

6 
	~"CseShl.h
"

7 
	~"Task.h
"

8 
	~"PIT.h
"

9 
	~"DymicMemy.h
"

10 
	~"HdDisk.h
"

11 
	~"FeSyem.h
"

13 
	$ma
( )

15 
iCursX
, 
iCursY
;

18 
	`kInlizeCse
( 0, 10 );

19 
	`kPrtf
( "Switch To IA-32e Mode Success~!!\n" );

20 
	`kPrtf
( "IA-32e C Language Kernel Start..............[Pass]\n" );

21 
	`kPrtf
( "Initialize Console..........................[Pass]\n" );

24 
	`kGCurs
&
iCursX
, &
iCursY
 );

25 
	`kPrtf
( "GDT Initialize And Switch For IA-32e Mode...[ ]" );

26 
	`kInlizeGDTTabAndTSS
();

27 
	`kLdGDTR

GDTR_STARTADDRESS
 );

28 
	`kSCurs
45, 
iCursY
++ );

29 
	`kPrtf
( "Pass\n" );

31 
	`kPrtf
( "TSS Segment Load............................[ ]" );

32 
	`kLdTR

GDT_TSSSEGMENT
 );

33 
	`kSCurs
45, 
iCursY
++ );

34 
	`kPrtf
( "Pass\n" );

36 
	`kPrtf
( "IDT Initialize..............................[ ]" );

37 
	`kInlizeIDTTabs
();

38 
	`kLdIDTR

IDTR_STARTADDRESS
 );

39 
	`kSCurs
45, 
iCursY
++ );

40 
	`kPrtf
( "Pass\n" );

42 
	`kPrtf
( "Total RAM Size Check........................[ ]" );

43 
	`kCheckTٮRAMSize
();

44 
	`kSCurs
45, 
iCursY
++ );

45 
	`kPrtf
"Pass], Siz%d MB\n", 
	`kGTٮRAMSize
() );

47 
	`kPrtf
("TCB Poll And Scheduler Initialize...........[Pass]\n");

48 
iCursY
++;

49 
	`kInlizeSchedur
();

52 
	`kPrtf
("Dynamic Memory Initialize...................[Pass]\n");

53 
iCursY
++;

54 
	`kInlizeDymicMemy
();

57 
	`kInlizePIT
(
	`MSTOCOUNT
(1),1);

59 
	`kPrtf
( "Keyboard Activate And Queue Initialize......[ ]" );

61 if
	`kInlizeKeybrd
(=
TRUE
 )

63 
	`kSCurs
45, 
iCursY
++ );

64 
	`kPrtf
( "Pass\n" );

65 
	`kChgeKeybrdLED

FALSE
, FALSE, FALSE );

69 
	`kSCurs
45, 
iCursY
++ );

70 
	`kPrtf
( "Fail\n" );

74 
	`kPrtf
( "PIC Controller And Interrupt Initialize.....[ ]" );

76 
	`kInlizePIC
();

77 
	`kMaskPICIru
( 0 );

78 
	`kEbIru
();

79 
	`kSCurs
45, 
iCursY
++ );

80 
	`kPrtf
( "Pass\n" );

83 
	`kPrtf
("HDD Initialize..............................[ ]");

84 if(
	`kInlizeHDD
()==
TRUE
)

86 
	`kSCurs
(45,
iCursY
++);

87 
	`kPrtf
("Pass\n");

91 
	`kSCurs
(45,
iCursY
++);

92 
	`kPrtf
("Fail\n");

96 
	`kPrtf
("File System Initialize......................[ ]");

97 if(
	`kInlizeFeSyem
()==
TRUE
)

99 
	`kSCurs
(45,
iCursY
++);

100 
	`kPrtf
("Pass\n");

104 
	`kSCurs
(45,
iCursY
++);

105 
	`kPrtf
("Fail\n");

109 
	`kCeTask
(
TASK_FLAGS_LOWEST
 | 
TASK_FLAGS_THREAD
 | 
TASK_FLAGS_SYSTEM
 | 
TASK_FLAGS_IDLE
,0,0,(
QWORD
)
kIdTask
);

110 
	`kSCseShl
();

111 
	}
}

	@/home/jk/os/MINT64/04.Utility/00.ImageMaker/ImageMaker.c

1 
	~<dio.h
>

2 
	~<dlib.h
>

3 
	~<f.h
>

5 
	~<sys/tys.h
>

6 
	~<sys/.h
>

7 
	~<o.h
>

9 
	#BYTESOFSECTOR
 512

	)

11 
AdjuInSeSize

iFd
, 
iSourSize
 );

12 
WreKlInfmi

iTgFd
, 
iTٮKlSeCou
,
iKlSeCou
 );

13 
CyFe

iSourFd
, 
iTgFd
 );

15 
	$ma
(
gc
, * 
gv
[])

17 
iSourFd
;

18 
iTgFd
;

19 
iBoLdSize
;

20 
iKl32SeCou
;

21 
iKl64SeCou
;

22 
iSourSize
;

24 if
gc
 < 4 )

26 
	`rtf

dr
, "[ERROR] ImageMaker BootLoader.bin Kernel32.bin KErnel64.bin\n" );

27 
	`ex
( -1 );

30 if
iTgFd
 = 
	`ݒ
"Disk.img", 
O_RDWR
 | 
O_CREAT
 | 
O_TRUNC
 |

31 
S_IREAD
 | 
S_IWRITE
 ) ) == -1 )

33 
	`rtf

dr
 , "[ERROR] Disk.img open fail.\n" );

34 
	`ex
( -1 );

37 
	`tf
( "[INFO] Copy bootoadero image file\n" );

38 if
iSourFd
 = 
	`ݒ

gv
[ 1 ], 
O_RDONLY
 ) ) == -1 )

40 
	`rtf

dr
, "[ERROR] %ݒ fa\n", 
gv
[ 1 ] );

41 
	`ex
( -1 );

44 
iSourSize
 = 
	`CyFe

iSourFd
, 
iTgFd
 );

45 
	`o

iSourFd
 );

47 
iBoLdSize
 = 
	`AdjuInSeSize

iTgFd
 , 
iSourSize
 );

48 
	`tf
( "[INFO] %s size = [%d]nd sector count = [%d]\n",

49 
gv
[ 1 ], 
iSourSize
, 
iBoLdSize
 );

51 
	`tf
( "[INFO] Copyrotected mode kernelo image file\n" );

52 if
iSourFd
 = 
	`ݒ

gv
[ 2 ], 
O_RDONLY
) ) == -1 )

54 
	`rtf

dr
, "[ERROR] %ݒ fa\n", 
gv
[ 2 ] );

55 
	`ex
( -1 );

58 
iSourSize
 = 
	`CyFe

iSourFd
, 
iTgFd
 );

59 
	`o

iSourFd
 );

61 
iKl32SeCou
 = 
	`AdjuInSeSize

iTgFd
, 
iSourSize
 );

62 
	`tf
( "[INFO] %s size = [%d]nd sector count = [%d]\n",

63 
gv
[ 2 ], 
iSourSize
, 
iKl32SeCou
 );

66 
	`tf
("[INFO] Copy IA-32e mode kernelo image file\n");

67 if((
iSourFd
=
	`ݒ
(
gv
[3],
O_RDONLY
))==-1)

69 
	`rtf
(
dr
,"[ERROR] %ݒ fa\n",
gv
[3]);

70 
	`ex
(-1);

73 
iSourSize
=
	`CyFe
(
iSourFd
,
iTgFd
);

74 
	`o
(
iSourFd
);

76 
iKl64SeCou
 = 
	`AdjuInSeSize
(
iTgFd
,
iSourSize
);

77 
	`tf
("[INFO] %siz[%d]nd se cou = [%d]\n",
gv
[3],
iSourSize
,
iKl64SeCou
);

79 
	`tf
( "[INFO] Starto write kernel information\n" );

80 
	`WreKlInfmi

iTgFd
,
iKl64SeCou
+
iKl32SeCou
, iKernel32SectorCount );

81 
	`tf
( "[INFO] Image file create complete\n" );

83 
	`o

iTgFd
 );

85 
	}
}

87 
	$AdjuInSeSize

iFd
, 
iSourSize
 )

89 
i
;

90 
iAdjuSizeToSe
;

91 
cCh
;

92 
iSeCou
;

94 
iAdjuSizeToSe
 = 
iSourSize
 % 
BYTESOFSECTOR
;

95 
cCh
 = 0x00;

97 if
iAdjuSizeToSe
 != 0 )

99 
iAdjuSizeToSe
 = 512 - iAdjustSizeToSector;

100 
	`tf
"[INFO] Fsiz[%d]nd f[%d] by\n", 
iSourSize
,

101 
iAdjuSizeToSe
 );

102  
i
 = 0 ; i < 
iAdjuSizeToSe
 ; i++ )

104 
	`wre

iFd
 , &
cCh
 , 1 );

109 
	`tf
( "[INFO] File size isligned 512 byte\n" );

112 
iSeCou
 = ( 
iSourSize
 + 
iAdjuSizeToSe
 ) / 
BYTESOFSECTOR
;

113  
iSeCou
;

114 
	}
}

116 
	$WreKlInfmi

iTgFd
, 
iTٮKlSeCou
, 
iKlSeCou
 )

118 
usDa
;

119 
lPosi
;

121 
lPosi
 = 
	`lek

iTgFd
, 5, 
SEEK_SET
 );

122 if
lPosi
 == -1 )

124 
	`rtf

dr
, "lseek fail. Return value = %ld,rrno = %d, %d\n",

125 
lPosi
, 
o
, 
SEEK_SET
 );

126 
	`ex
( -1 );

129 
usDa
 = (
iTٮKlSeCou
;

130 
	`wre
(
iTgFd
,&
usDa
,2);

131 
usDa
 = ( 
iKlSeCou
;

132 
	`wre

iTgFd
, &
usDa
, 2 );

135 
	`tf
( "[INFO] Total sector countxcept bootoader [%d]\n",

136 
iTٮKlSeCou
 );

137 
	`tf
"[INFO] Tٮ se cou oeed modk[%d]\n",
iKlSeCou
);

139 
	}
}

141 
	$CyFe

iSourFd
, 
iTgFd
 )

143 
iSourFeSize
;

144 
iRd
;

145 
iWre
;

146 
vcBufr
[ 
BYTESOFSECTOR
 ];

148 
iSourFeSize
 = 0;

151 
iRd
 = 
	`ad

iSourFd
, 
vcBufr
, ( vcBuffer ) );

152 
iWre
 = 
	`wre

iTgFd
, 
vcBufr
, 
iRd
 );

154 if
iRd
 !
iWre
 )

156 
	`rtf

dr
, "[ERROR] iRead != iWrite.. \n" );

157 
	`ex
(-1);

159 
iSourFeSize
 +
iRd
;

161 if
iRd
 !
vcBufr
 ) )

166  
iSourFeSize
;

167 
	}
}

	@/home/jk/os/MINT64/testdata.c

1 
	~<dio.h
>

2 
	ga
;

3 
	gc
;

4 
	gd
=0;

5 
	gb
 =1;

7 
	$ma
()

9 
	`tf
("%d %d\n",
a
,
b
);

10  
a
+
b
;

11 
	}
}

	@/usr/cross/lib/gcc/x86_64-pc-linux/4.8.2/include/stdarg.h

28 #ide
_STDARG_H


29 #ide
_ANSI_STDARG_H_


30 #ide
__ed___va_li


31 
	#_STDARG_H


	)

32 
	#_ANSI_STDARG_H_


	)

34 #unde
__ed___va_li


38 #ide
__GNUC_VA_LIST


39 
	#__GNUC_VA_LIST


	)

40 
__but_va_li
 
	t__gnuc_va_li
;

45 #ifde
_STDARG_H


47 
	#va_t
(
v
,
l

	`__but_va_t
(v,l)

	)

48 
	#va_d
(
v

	`__but_va_d
(v)

	)

49 
	#va_g
(
v
,
l

	`__but_va_g
(v,l)

	)

50 #i!
defed
(
__STRICT_ANSI__
|| 
__STDC_VERSION__
 + 0 >199900L || defed(
__GXX_EXPERIMENTAL_CXX0X__
)

51 
	#va_cy
(
d
,
s

	`__but_va_cy
(d,s)

	)

53 
	#__va_cy
(
d
,
s

	`__but_va_cy
(d,s)

	)

62 #ifde
_BSD_VA_LIST


63 #unde
_BSD_VA_LIST


66 #i
defed
(
__svr4__
|| (defed(
_SCO_DS
&& !defed(
__VA_LIST
))

71 #ide
_VA_LIST_


72 
	#_VA_LIST_


	)

73 #ifde
__i860__


74 #ide
_VA_LIST


75 
	#_VA_LIST
 
va_li


	)

78 
__gnuc_va_li
 
	tva_li
;

79 #ifde
_SCO_DS


80 
	#__VA_LIST


	)

89 #i!
defed
 (
_VA_LIST_
|| defed (
__BSD_NET2__
|| defed (
____386BSD____
|| defed (
__bsdi__
|| defed (
__qut__
|| defed (
__FeBSD__
|| defed(
WINNT
)

91 #ide
_VA_LIST_DEFINED


93 #ide
_VA_LIST


95 #ide
_VA_LIST_T_H


97 #ide
__va_li__


98 
__gnuc_va_li
 
	tva_li
;

103 #i!(
defed
 (
__BSD_NET2__
|| defed (
____386BSD____
|| defed (
__bsdi__
|| defed (
__qut__
|| defed (
__FeBSD__
))

104 
	#_VA_LIST_


	)

106 #ide
_VA_LIST


107 
	#_VA_LIST


	)

109 #ide
_VA_LIST_DEFINED


110 
	#_VA_LIST_DEFINED


	)

112 #ide
_VA_LIST_T_H


113 
	#_VA_LIST_T_H


	)

115 #ide
__va_li__


116 
	#__va_li__


	)

	@/usr/include/errno.h

22 #idef 
_ERRNO_H


26 #idef 
__ed_Emh


27 
	#_ERRNO_H
 1

	)

28 
	~<us.h
>

31 
	g__BEGIN_DECLS


35 
	~<bs/o.h
>

36 #unde
__ed_Emh


38 #ifdef 
_ERRNO_H


45 #idef 
o


46 
o
;

49 #ifde
__USE_GNU


54 *
ogm_voti_me
, *
ogm_voti_sht_me
;

58 
	g__END_DECLS


66 #i
defed
 
__USE_GNU
 || defed 
__ed_r_t


67 #ide
__r_t_defed


68 
	tr_t
;

69 
	#__r_t_defed
 1

	)

71 #unde
__ed_r_t


	@/usr/include/fcntl.h

22 #idef 
_FCNTL_H


23 
	#_FCNTL_H
 1

	)

25 
	~<us.h
>

28 
	g__BEGIN_DECLS


31 
	~<bs/tys.h
>

35 
	~<bs/f.h
>

40 #ide
__mode_t_defed


41 
__mode_t
 
	tmode_t
;

42 
	#__mode_t_defed


	)

45 #ide
__off_t_defed


46 #ide
__USE_FILE_OFFSET64


47 
__off_t
 
	toff_t
;

49 
__off64_t
 
	toff_t
;

51 
	#__off_t_defed


	)

54 #i
defed
 
__USE_LARGEFILE64
 && !defed 
__off64_t_defed


55 
__off64_t
 
	toff64_t
;

56 
	#__off64_t_defed


	)

59 #ide
__pid_t_defed


60 
__pid_t
 
	tpid_t
;

61 
	#__pid_t_defed


	)

65 #i
defed
 
__USE_XOPEN
 || defed 
__USE_XOPEN2K8


66 
	#__ed_timeec


	)

67 
	~<time.h
>

68 
	~<bs/.h
>

70 
	#S_IFMT
 
__S_IFMT


	)

71 
	#S_IFDIR
 
__S_IFDIR


	)

72 
	#S_IFCHR
 
__S_IFCHR


	)

73 
	#S_IFBLK
 
__S_IFBLK


	)

74 
	#S_IFREG
 
__S_IFREG


	)

75 #ifde
__S_IFIFO


76 
	#S_IFIFO
 
__S_IFIFO


	)

78 #ifde
__S_IFLNK


79 
	#S_IFLNK
 
__S_IFLNK


	)

81 #i(
defed
 
__USE_UNIX98
 || defed 
__USE_XOPEN2K8
&& defed 
__S_IFSOCK


82 
	#S_IFSOCK
 
__S_IFSOCK


	)

87 
	#S_ISUID
 
__S_ISUID


	)

88 
	#S_ISGID
 
__S_ISGID


	)

90 #i
defed
 
__USE_BSD
 || defed 
__USE_MISC
 || defed 
__USE_XOPEN


92 
	#S_ISVTX
 
__S_ISVTX


	)

95 
	#S_IRUSR
 
__S_IREAD


	)

96 
	#S_IWUSR
 
__S_IWRITE


	)

97 
	#S_IXUSR
 
__S_IEXEC


	)

99 
	#S_IRWXU
 (
__S_IREAD
|
__S_IWRITE
|
__S_IEXEC
)

	)

101 
	#S_IRGRP
 (
S_IRUSR
 >> 3

	)

102 
	#S_IWGRP
 (
S_IWUSR
 >> 3

	)

103 
	#S_IXGRP
 (
S_IXUSR
 >> 3

	)

105 
	#S_IRWXG
 (
S_IRWXU
 >> 3)

	)

107 
	#S_IROTH
 (
S_IRGRP
 >> 3

	)

108 
	#S_IWOTH
 (
S_IWGRP
 >> 3

	)

109 
	#S_IXOTH
 (
S_IXGRP
 >> 3

	)

111 
	#S_IRWXO
 (
S_IRWXG
 >> 3)

	)

114 #ifdef 
__USE_MISC


115 #ide
R_OK


118 
	#R_OK
 4

	)

119 
	#W_OK
 2

	)

120 
	#X_OK
 1

	)

121 
	#F_OK
 0

	)

126 #i
defed
 
__USE_XOPEN
 || defed 
__USE_XOPEN2K8


127 
	#SEEK_SET
 0

	)

128 
	#SEEK_CUR
 1

	)

129 
	#SEEK_END
 2

	)

137 
f
 (
__fd
, 
__cmd
, ...);

145 #ide
__USE_FILE_OFFSET64


146 
	$ݒ
 (cڡ *
__fe
, 
__oag
, ...
	`__nnu
 ((1));

148 #ifde
__REDIRECT


149 
	`__REDIRECT
 (
ݒ
, (cڡ *
__fe
, 
__oag
, ...), 
ݒ64
)

150 
	`__nnu
 ((1));

152 
	#ݒ
 
ݒ64


	)

155 #ifde
__USE_LARGEFILE64


156 
	$ݒ64
 (cڡ *
__fe
, 
__oag
, ...
	`__nnu
 ((1));

159 #ifde
__USE_ATFILE


169 #ide
__USE_FILE_OFFSET64


170 
	$ݒ
 (
__fd
, cڡ *
__fe
, 
__oag
, ...)

171 
	`__nnu
 ((2));

173 #ifde
__REDIRECT


174 
	`__REDIRECT
 (
ݒ
, (
__fd
, cڡ *
__fe
, 
__oag
,

175 ...), 
ݒ64

	`__nnu
 ((2));

177 
	#ݒ
 
ݒ64


	)

180 #ifde
__USE_LARGEFILE64


181 
	$ݒ64
 (
__fd
, cڡ *
__fe
, 
__oag
, ...)

182 
	`__nnu
 ((2));

191 #ide
__USE_FILE_OFFSET64


192 
	$t
 (cڡ *
__fe
, 
mode_t
 
__mode

	`__nnu
 ((1));

194 #ifde
__REDIRECT


195 
	`__REDIRECT
 (
t
, (cڡ *
__fe
, 
mode_t
 
__mode
),

196 
t64

	`__nnu
 ((1));

198 
	#t
 
t64


	)

201 #ifde
__USE_LARGEFILE64


202 
	$t64
 (cڡ *
__fe
, 
mode_t
 
__mode

	`__nnu
 ((1));

205 #i!
defed
 
F_LOCK
 && (defed 
__USE_MISC
 || (defed 
__USE_XOPEN_EXTENDED
 \

206 && !
defed
 
__USE_POSIX
))

215 
	#F_ULOCK
 0

	)

216 
	#F_LOCK
 1

	)

217 
	#F_TLOCK
 2

	)

218 
	#F_TEST
 3

	)

220 #ide
__USE_FILE_OFFSET64


221 
	`lockf
 (
__fd
, 
__cmd
, 
off_t
 
__n
);

223 #ifde
__REDIRECT


224 
	`__REDIRECT
 (
lockf
, (
__fd
, 
__cmd
, 
__off64_t
 
__n
), 
lockf64
);

226 
	#lockf
 
lockf64


	)

229 #ifde
__USE_LARGEFILE64


230 
	`lockf64
 (
__fd
, 
__cmd
, 
off64_t
 
__n
);

234 #ifde
__USE_XOPEN2K


237 #ide
__USE_FILE_OFFSET64


238 
	$posix_dvi
 (
__fd
, 
off_t
 
__offt
, off_
__n
,

239 
__advi

__THROW
;

241 #ifde
__REDIRECT_NTH


242 
	`__REDIRECT_NTH
 (
posix_dvi
, (
__fd
, 
__off64_t
 
__offt
,

243 
__off64_t
 
__n
, 
__advi
),

244 
posix_dvi64
);

246 
	#posix_dvi
 
posix_dvi64


	)

249 #ifde
__USE_LARGEFILE64


250 
	$posix_dvi64
 (
__fd
, 
off64_t
 
__offt
, off64_
__n
,

251 
__advi

__THROW
;

259 #ide
__USE_FILE_OFFSET64


260 
	`posix_o
 (
__fd
, 
off_t
 
__offt
, off_
__n
);

262 #ifde
__REDIRECT


263 
	`__REDIRECT
 (
posix_o
, (
__fd
, 
__off64_t
 
__offt
,

264 
__off64_t
 
__n
),

265 
posix_o64
);

267 
	#posix_o
 
posix_o64


	)

270 #ifde
__USE_LARGEFILE64


271 
	`posix_o64
 (
__fd
, 
off64_t
 
__offt
, off64_
__n
);

277 #i
__USE_FORTIFY_LEVEL
 > 0 && 
defed
 
__ftify_funi
 \

278 && 
defed
 
__va_g_ck_n


279 
	~<bs/f2.h
>

282 
__END_DECLS


	@/usr/include/stdio.h

23 #ide
_STDIO_H


25 #i!
defed
 
__ed_FILE
 && !defed 
__ed___FILE


26 
	#_STDIO_H
 1

	)

27 
	~<us.h
>

29 
	g__BEGIN_DECLS


31 
	#__ed_size_t


	)

32 
	#__ed_NULL


	)

33 
	~<ddef.h
>

35 
	~<bs/tys.h
>

36 
	#__ed_FILE


	)

37 
	#__ed___FILE


	)

41 #i!
defed
 
__FILE_defed
 && defed 
__ed_FILE


44 
	g_IO_FILE
;

46 
__BEGIN_NAMESPACE_STD


48 
_IO_FILE
 
	tFILE
;

49 
	g__END_NAMESPACE_STD


50 #i
defed
 
__USE_LARGEFILE64
 || defed 
__USE_SVID
 || defed 
__USE_POSIX
 \

51 || 
defed
 
	g__USE_BSD
 || defed 
	g__USE_ISOC99
 || defed 
	g__USE_XOPEN
 \

52 || 
defed
 
__USE_POSIX2


53 
	$__USING_NAMESPACE_STD
(
FILE
)

56 
	#__FILE_defed
 1

	)

58 #unde
__ed_FILE


61 #i!
defed
 
____FILE_defed
 && defed 
__ed___FILE


64 
_IO_FILE
 
	t__FILE
;

66 
	#____FILE_defed
 1

	)

68 #unde
__ed___FILE


71 #ifdef 
_STDIO_H


72 
	#_STDIO_USES_IOSTREAM


	)

74 
	~<libio.h
>

76 #i
defed
 
__USE_XOPEN
 || defed 
__USE_XOPEN2K8


77 #ifde
__GNUC__


78 #ide
_VA_LIST_DEFINED


79 
_G_va_li
 
	tva_li
;

80 
	#_VA_LIST_DEFINED


	)

83 
	~<dg.h
>

87 #ifde
__USE_XOPEN2K8


88 #ide
__off_t_defed


89 #ide
__USE_FILE_OFFSET64


90 
__off_t
 
	toff_t
;

92 
__off64_t
 
	toff_t
;

94 
	#__off_t_defed


	)

96 #i
defed
 
__USE_LARGEFILE64
 && !defed 
__off64_t_defed


97 
__off64_t
 
	toff64_t
;

98 
	#__off64_t_defed


	)

101 #ide
__ssize_t_defed


102 
__ssize_t
 
	tssize_t
;

103 
	#__ssize_t_defed


	)

108 
__BEGIN_NAMESPACE_STD


109 #ide
__USE_FILE_OFFSET64


110 
_G_os_t
 
	tos_t
;

112 
_G_os64_t
 
	tos_t
;

114 
__END_NAMESPACE_STD


115 #ifde
__USE_LARGEFILE64


116 
_G_os64_t
 
	tos64_t
;

120 
	#_IOFBF
 0

	)

121 
	#_IOLBF
 1

	)

122 
	#_IONBF
 2

	)

126 #ide
BUFSIZ


127 
	#BUFSIZ
 
_IO_BUFSIZ


	)

133 #ide
EOF


134 
	#EOF
 (-1)

	)

140 
	#SEEK_SET
 0

	)

141 
	#SEEK_CUR
 1

	)

142 
	#SEEK_END
 2

	)

143 #ifde
__USE_GNU


144 
	#SEEK_DATA
 3

	)

145 
	#SEEK_HOLE
 4

	)

149 #i
defed
 
__USE_SVID
 || defed 
__USE_XOPEN


151 
	#P_tmpd
 "/tmp"

	)

164 
	~<bs/dio_lim.h
>

168 
_IO_FILE
 *
d
;

169 
_IO_FILE
 *
dout
;

170 
_IO_FILE
 *
dr
;

172 
	#d
 
d


	)

173 
	#dout
 
dout


	)

174 
	#dr
 
dr


	)

176 
__BEGIN_NAMESPACE_STD


178 
	$move
 (cڡ *
__fame

__THROW
;

180 
	$me
 (cڡ *
__d
, cڡ *
__w

__THROW
;

181 
__END_NAMESPACE_STD


183 #ifde
__USE_ATFILE


185 
	$mt
 (
__dfd
, cڡ *
__d
, 
__wfd
,

186 cڡ *
__w

__THROW
;

189 
__BEGIN_NAMESPACE_STD


194 #ide
__USE_FILE_OFFSET64


195 
FILE
 *
	$tmpfe
 (
__wur
;

197 #ifde
__REDIRECT


198 
FILE
 *
	`__REDIRECT
 (
tmpfe
, (), 
tmpfe64

__wur
;

200 
	#tmpfe
 
tmpfe64


	)

204 #ifde
__USE_LARGEFILE64


205 
FILE
 *
	$tmpfe64
 (
__wur
;

209 *
	$tmam
 (*
__s

__THROW
 
__wur
;

210 
__END_NAMESPACE_STD


212 #ifde
__USE_MISC


215 *
	$tmam_r
 (*
__s

__THROW
 
__wur
;

219 #i
defed
 
__USE_SVID
 || defed 
__USE_XOPEN


227 *
	$mam
 (cڡ *
__d
, cڡ *
__pfx
)

228 
__THROW
 
__ibu_mloc__
 
__wur
;

232 
__BEGIN_NAMESPACE_STD


237 
	`fo
 (
FILE
 *
__am
);

242 
	`fush
 (
FILE
 *
__am
);

243 
__END_NAMESPACE_STD


245 #ifde
__USE_MISC


252 
	`fush_uocked
 (
FILE
 *
__am
);

255 #ifde
__USE_GNU


262 
	`fol
 ();

266 
__BEGIN_NAMESPACE_STD


267 #ide
__USE_FILE_OFFSET64


272 
FILE
 *
	$fݒ
 (cڡ *
__ri
 
__fame
,

273 cڡ *
__ri
 
__modes

__wur
;

278 
FILE
 *
	$eݒ
 (cڡ *
__ri
 
__fame
,

279 cڡ *
__ri
 
__modes
,

280 
FILE
 *
__ri
 
__am

__wur
;

282 #ifde
__REDIRECT


283 
FILE
 *
	`__REDIRECT
 (
fݒ
, (cڡ *
__ri
 
__fame
,

284 cڡ *
__ri
 
__modes
), 
fݒ64
)

285 
__wur
;

286 
FILE
 *
	`__REDIRECT
 (
eݒ
, (cڡ *
__ri
 
__fame
,

287 cڡ *
__ri
 
__modes
,

288 
FILE
 *
__ri
 
__am
), 
eݒ64
)

289 
__wur
;

291 
	#fݒ
 
fݒ64


	)

292 
	#eݒ
 
eݒ64


	)

295 
__END_NAMESPACE_STD


296 #ifde
__USE_LARGEFILE64


297 
FILE
 *
	$fݒ64
 (cڡ *
__ri
 
__fame
,

298 cڡ *
__ri
 
__modes

__wur
;

299 
FILE
 *
	$eݒ64
 (cڡ *
__ri
 
__fame
,

300 cڡ *
__ri
 
__modes
,

301 
FILE
 *
__ri
 
__am

__wur
;

304 #ifdef 
__USE_POSIX


306 
FILE
 *
	$fdݒ
 (
__fd
, cڡ *
__modes

__THROW
 
__wur
;

309 #ifdef 
__USE_GNU


312 
FILE
 *
	$fݒcook
 (*
__ri
 
__magic_cook
,

313 cڡ *
__ri
 
__modes
,

314 
_IO_cook_io_funis_t
 
__io_funcs

__THROW
 
__wur
;

317 #ifde
__USE_XOPEN2K8


319 
FILE
 *
	$fmemݒ
 (*
__s
, 
size_t
 
__n
, cڡ *
__modes
)

320 
__THROW
 
__wur
;

325 
FILE
 *
	$ݒ_memam
 (**
__buoc
, 
size_t
 *
__sizoc

__THROW
 
__wur
;

329 
__BEGIN_NAMESPACE_STD


332 
	$tbuf
 (
FILE
 *
__ri
 
__am
, *__ri 
__buf

__THROW
;

336 
	$tvbuf
 (
FILE
 *
__ri
 
__am
, *__ri 
__buf
,

337 
__modes
, 
size_t
 
__n

__THROW
;

338 
__END_NAMESPACE_STD


340 #ifdef 
__USE_BSD


343 
	$tbufr
 (
FILE
 *
__ri
 
__am
, *__ri 
__buf
,

344 
size_t
 
__size

__THROW
;

347 
	$ebuf
 (
FILE
 *
__am

__THROW
;

351 
__BEGIN_NAMESPACE_STD


356 
	`rtf
 (
FILE
 *
__ri
 
__am
,

357 cڡ *
__ri
 
__fm
, ...);

362 
	`tf
 (cڡ *
__ri
 
__fm
, ...);

364 
	$rtf
 (*
__ri
 
__s
,

365 cڡ *
__ri
 
__fm
, ...
__THROWNL
;

371 
	`vrtf
 (
FILE
 *
__ri
 
__s
, cڡ *__ri 
__fm
,

372 
_G_va_li
 
__g
);

377 
	`vtf
 (cڡ *
__ri
 
__fm
, 
_G_va_li
 
__g
);

379 
	$vrtf
 (*
__ri
 
__s
, cڡ *__ri 
__fm
,

380 
_G_va_li
 
__g

__THROWNL
;

381 
__END_NAMESPACE_STD


383 #i
defed
 
__USE_BSD
 || defed 
__USE_ISOC99
 || defed 
__USE_UNIX98


384 
__BEGIN_NAMESPACE_C99


386 
	$tf
 (*
__ri
 
__s
, 
size_t
 
__maxn
,

387 cڡ *
__ri
 
__fm
, ...)

388 
__THROWNL
 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 3, 4)));

390 
	$vtf
 (*
__ri
 
__s
, 
size_t
 
__maxn
,

391 cڡ *
__ri
 
__fm
, 
_G_va_li
 
__g
)

392 
__THROWNL
 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 3, 0)));

393 
__END_NAMESPACE_C99


396 #ifde
__USE_GNU


399 
	$vartf
 (**
__ri
 
__r
, cڡ *__ri 
__f
,

400 
_G_va_li
 
__g
)

401 
__THROWNL
 
	`__ibu__
 ((
	$__fm__
 (
__tf__
, 2, 0))
__wur
;

402 
	$__artf
 (**
__ri
 
__r
,

403 cڡ *
__ri
 
__fmt
, ...)

404 
__THROWNL
 
	`__ibu__
 ((
	$__fm__
 (
__tf__
, 2, 3))
__wur
;

405 
	$artf
 (**
__ri
 
__r
,

406 cڡ *
__ri
 
__fmt
, ...)

407 
__THROWNL
 
	`__ibu__
 ((
	$__fm__
 (
__tf__
, 2, 3))
__wur
;

410 #ifde
__USE_XOPEN2K8


412 
	$vdtf
 (
__fd
, cڡ *
__ri
 
__fmt
,

413 
_G_va_li
 
__g
)

414 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 2, 0)));

415 
	$dtf
 (
__fd
, cڡ *
__ri
 
__fmt
, ...)

416 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 2, 3)));

420 
__BEGIN_NAMESPACE_STD


425 
	$fsnf
 (
FILE
 *
__ri
 
__am
,

426 cڡ *
__ri
 
__fm
, ...
__wur
;

431 
	$snf
 (cڡ *
__ri
 
__fm
, ...
__wur
;

433 
	$ssnf
 (cڡ *
__ri
 
__s
,

434 cڡ *
__ri
 
__fm
, ...
__THROW
;

436 #i
defed
 
__USE_ISOC99
 && !defed 
__USE_GNU
 \

437 && (!
defed
 
__LDBL_COMPAT
 || !defed 
__REDIRECT
) \

438 && (
defed
 
__STRICT_ANSI__
 || defed 
__USE_XOPEN2K
)

439 #ifde
__REDIRECT


443 
	`__REDIRECT
 (
fsnf
, (
FILE
 *
__ri
 
__am
,

444 cڡ *
__ri
 
__fm
, ...),

445 
__isoc99_fsnf

__wur
;

446 
	`__REDIRECT
 (
snf
, (cڡ *
__ri
 
__fm
, ...),

447 
__isoc99_snf

__wur
;

448 
	`__REDIRECT_NTH
 (
ssnf
, (cڡ *
__ri
 
__s
,

449 cڡ *
__ri
 
__fm
, ...),

450 
__isoc99_ssnf
);

452 
	$__isoc99_fsnf
 (
FILE
 *
__ri
 
__am
,

453 cڡ *
__ri
 
__fm
, ...
__wur
;

454 
	$__isoc99_snf
 (cڡ *
__ri
 
__fm
, ...
__wur
;

455 
	$__isoc99_ssnf
 (cڡ *
__ri
 
__s
,

456 cڡ *
__ri
 
__fm
, ...
__THROW
;

457 
	#fsnf
 
__isoc99_fsnf


	)

458 
	#snf
 
__isoc99_snf


	)

459 
	#ssnf
 
__isoc99_ssnf


	)

463 
__END_NAMESPACE_STD


465 #ifdef 
__USE_ISOC99


466 
__BEGIN_NAMESPACE_C99


471 
	$vfsnf
 (
FILE
 *
__ri
 
__s
, cڡ *__ri 
__fm
,

472 
_G_va_li
 
__g
)

473 
	`__ibu__
 ((
	$__fm__
 (
__snf__
, 2, 0))
__wur
;

479 
	$vsnf
 (cڡ *
__ri
 
__fm
, 
_G_va_li
 
__g
)

480 
	`__ibu__
 ((
	$__fm__
 (
__snf__
, 1, 0))
__wur
;

483 
	$vssnf
 (cڡ *
__ri
 
__s
,

484 cڡ *
__ri
 
__fm
, 
_G_va_li
 
__g
)

485 
__THROW
 
	`__ibu__
 ((
	`__fm__
 (
__snf__
, 2, 0)));

487 #i!
defed
 
__USE_GNU
 \

488 && (!
defed
 
__LDBL_COMPAT
 || !defed 
__REDIRECT
) \

489 && (
defed
 
__STRICT_ANSI__
 || defed 
__USE_XOPEN2K
)

490 #ifde
__REDIRECT


494 
	`__REDIRECT
 (
vfsnf
,

495 (
FILE
 *
__ri
 
__s
,

496 cڡ *
__ri
 
__fm
, 
_G_va_li
 
__g
),

497 
__isoc99_vfsnf
)

498 
	`__ibu__
 ((
	$__fm__
 (
__snf__
, 2, 0))
__wur
;

499 
	`__REDIRECT
 (
vsnf
, (cڡ *
__ri
 
__fm
,

500 
_G_va_li
 
__g
), 
__isoc99_vsnf
)

501 
	`__ibu__
 ((
	$__fm__
 (
__snf__
, 1, 0))
__wur
;

502 
	`__REDIRECT_NTH
 (
vssnf
,

503 (cڡ *
__ri
 
__s
,

504 cڡ *
__ri
 
__fm
,

505 
_G_va_li
 
__g
), 
__isoc99_vssnf
)

506 
	`__ibu__
 ((
	`__fm__
 (
__snf__
, 2, 0)));

508 
	$__isoc99_vfsnf
 (
FILE
 *
__ri
 
__s
,

509 cڡ *
__ri
 
__fm
,

510 
_G_va_li
 
__g

__wur
;

511 
	$__isoc99_vsnf
 (cڡ *
__ri
 
__fm
,

512 
_G_va_li
 
__g

__wur
;

513 
	$__isoc99_vssnf
 (cڡ *
__ri
 
__s
,

514 cڡ *
__ri
 
__fm
,

515 
_G_va_li
 
__g

__THROW
;

516 
	#vfsnf
 
__isoc99_vfsnf


	)

517 
	#vsnf
 
__isoc99_vsnf


	)

518 
	#vssnf
 
__isoc99_vssnf


	)

522 
__END_NAMESPACE_C99


526 
__BEGIN_NAMESPACE_STD


531 
	`fgc
 (
FILE
 *
__am
);

532 
	`gc
 (
FILE
 *
__am
);

538 
	`gch
 ();

539 
__END_NAMESPACE_STD


543 
	#gc
(
_

	`_IO_gc
 (_)

	)

545 #i
defed
 
__USE_POSIX
 || defed 
__USE_MISC


550 
	`gc_uocked
 (
FILE
 *
__am
);

551 
	`gch_uocked
 ();

554 #ifde
__USE_MISC


561 
	`fgc_uocked
 (
FILE
 *
__am
);

565 
__BEGIN_NAMESPACE_STD


573 
	`utc
 (
__c
, 
FILE
 *
__am
);

574 
	`putc
 (
__c
, 
FILE
 *
__am
);

580 
	`putch
 (
__c
);

581 
__END_NAMESPACE_STD


585 
	#putc
(
_ch
, 
_

	`_IO_putc
 (_ch, _)

	)

587 #ifde
__USE_MISC


594 
	`utc_uocked
 (
__c
, 
FILE
 *
__am
);

597 #i
defed
 
__USE_POSIX
 || defed 
__USE_MISC


602 
	`putc_uocked
 (
__c
, 
FILE
 *
__am
);

603 
	`putch_uocked
 (
__c
);

607 #i
defed
 
__USE_SVID
 || defed 
__USE_MISC
 \

608 || (
defed
 
__USE_XOPEN
 && !defed 
__USE_XOPEN2K
)

610 
	`gw
 (
FILE
 *
__am
);

613 
	`putw
 (
__w
, 
FILE
 *
__am
);

617 
__BEGIN_NAMESPACE_STD


622 *
	$fgs
 (*
__ri
 
__s
, 
__n
, 
FILE
 *__ri 
__am
)

623 
__wur
;

625 #i!
defed
 
__USE_ISOC11
 \

626 || (
defed
 
__lulus
 && __cplusplus <= 201103L)

638 *
	$gs
 (*
__s

__wur
 
__ibu_dd__
;

640 
__END_NAMESPACE_STD


642 #ifde
__USE_GNU


649 *
	$fgs_uocked
 (*
__ri
 
__s
, 
__n
,

650 
FILE
 *
__ri
 
__am

__wur
;

654 #ifdef 
__USE_XOPEN2K8


665 
_IO_ssize_t
 
	$__gdim
 (**
__ri
 
__l
,

666 
size_t
 *
__ri
 
__n
, 
__dim
,

667 
FILE
 *
__ri
 
__am

__wur
;

668 
_IO_ssize_t
 
	$gdim
 (**
__ri
 
__l
,

669 
size_t
 *
__ri
 
__n
, 
__dim
,

670 
FILE
 *
__ri
 
__am

__wur
;

678 
_IO_ssize_t
 
	$gle
 (**
__ri
 
__l
,

679 
size_t
 *
__ri
 
__n
,

680 
FILE
 *
__ri
 
__am

__wur
;

684 
__BEGIN_NAMESPACE_STD


689 
	`uts
 (cڡ *
__ri
 
__s
, 
FILE
 *__ri 
__am
);

695 
	`puts
 (cڡ *
__s
);

702 
	`ungc
 (
__c
, 
FILE
 *
__am
);

709 
size_t
 
	$d
 (*
__ri
 
__r
, 
size_t
 
__size
,

710 
size_t
 
__n
, 
FILE
 *
__ri
 
__am

__wur
;

715 
size_t
 
	`fwre
 (cڡ *
__ri
 
__r
, size_
__size
,

716 
size_t
 
__n
, 
FILE
 *
__ri
 
__s
);

717 
__END_NAMESPACE_STD


719 #ifde
__USE_GNU


726 
	`uts_uocked
 (cڡ *
__ri
 
__s
,

727 
FILE
 *
__ri
 
__am
);

730 #ifde
__USE_MISC


737 
size_t
 
	$d_uocked
 (*
__ri
 
__r
, 
size_t
 
__size
,

738 
size_t
 
__n
, 
FILE
 *
__ri
 
__am

__wur
;

739 
size_t
 
	`fwre_uocked
 (cڡ *
__ri
 
__r
, size_
__size
,

740 
size_t
 
__n
, 
FILE
 *
__ri
 
__am
);

744 
__BEGIN_NAMESPACE_STD


749 
	`fek
 (
FILE
 *
__am
, 
__off
, 
__wh
);

754 
	$l
 (
FILE
 *
__am

__wur
;

759 
	`wd
 (
FILE
 *
__am
);

760 
__END_NAMESPACE_STD


767 #i
defed
 
__USE_LARGEFILE
 || defed 
__USE_XOPEN2K


768 #ide
__USE_FILE_OFFSET64


773 
	`feko
 (
FILE
 *
__am
, 
__off_t
 
__off
, 
__wh
);

778 
__off_t
 
	$lo
 (
FILE
 *
__am

__wur
;

780 #ifde
__REDIRECT


781 
	`__REDIRECT
 (
feko
,

782 (
FILE
 *
__am
, 
__off64_t
 
__off
, 
__wh
),

783 
feko64
);

784 
__off64_t
 
	`__REDIRECT
 (
lo
, (
FILE
 *
__am
), 
lo64
);

786 
	#feko
 
feko64


	)

787 
	#lo
 
lo64


	)

792 
__BEGIN_NAMESPACE_STD


793 #ide
__USE_FILE_OFFSET64


798 
	`fgpos
 (
FILE
 *
__ri
 
__am
, 
os_t
 *__ri 
__pos
);

803 
	`fos
 (
FILE
 *
__am
, cڡ 
os_t
 *
__pos
);

805 #ifde
__REDIRECT


806 
	`__REDIRECT
 (
fgpos
, (
FILE
 *
__ri
 
__am
,

807 
os_t
 *
__ri
 
__pos
), 
fgpos64
);

808 
	`__REDIRECT
 (
fos
,

809 (
FILE
 *
__am
, cڡ 
os_t
 *
__pos
), 
fos64
);

811 
	#fgpos
 
fgpos64


	)

812 
	#fos
 
fos64


	)

815 
__END_NAMESPACE_STD


817 #ifde
__USE_LARGEFILE64


818 
	`feko64
 (
FILE
 *
__am
, 
__off64_t
 
__off
, 
__wh
);

819 
__off64_t
 
	$lo64
 (
FILE
 *
__am

__wur
;

820 
	`fgpos64
 (
FILE
 *
__ri
 
__am
, 
os64_t
 *__ri 
__pos
);

821 
	`fos64
 (
FILE
 *
__am
, cڡ 
os64_t
 *
__pos
);

824 
__BEGIN_NAMESPACE_STD


826 
	$
 (
FILE
 *
__am

__THROW
;

828 
	$of
 (
FILE
 *
__am

__THROW
 
__wur
;

830 
	$
 (
FILE
 *
__am

__THROW
 
__wur
;

831 
__END_NAMESPACE_STD


833 #ifde
__USE_MISC


835 
	$_uocked
 (
FILE
 *
__am

__THROW
;

836 
	$of_uocked
 (
FILE
 *
__am

__THROW
 
__wur
;

837 
	$_uocked
 (
FILE
 *
__am

__THROW
 
__wur
;

841 
__BEGIN_NAMESPACE_STD


846 
	`
 (cڡ *
__s
);

847 
__END_NAMESPACE_STD


853 
	~<bs/sys_i.h
>

856 #ifdef 
__USE_POSIX


858 
	$fo
 (
FILE
 *
__am

__THROW
 
__wur
;

861 #ifde
__USE_MISC


863 
	$fo_uocked
 (
FILE
 *
__am

__THROW
 
__wur
;

867 #i(
defed
 
__USE_POSIX2
 || defed 
__USE_SVID
 || defed 
__USE_BSD
 || \

868 
defed
 
__USE_MISC
)

873 
FILE
 *
	$pݒ
 (cڡ *
__commd
, cڡ *
__modes

__wur
;

879 
	`po
 (
FILE
 *
__am
);

883 #ifdef 
__USE_POSIX


885 *
	$mid
 (*
__s

__THROW
;

889 #ifde
__USE_XOPEN


891 *
	`curid
 (*
__s
);

895 #ifdef 
__USE_GNU


896 
oback
;

899 
	$oback_tf
 (
oback
 *
__ri
 
__oback
,

900 cڡ *
__ri
 
__fm
, ...)

901 
__THROWNL
 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 2, 3)));

902 
	$oback_vtf
 (
oback
 *
__ri
 
__oback
,

903 cڡ *
__ri
 
__fm
,

904 
_G_va_li
 
__gs
)

905 
__THROWNL
 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 2, 0)));

909 #i
defed
 
__USE_POSIX
 || defed 
__USE_MISC


913 
	$ockfe
 (
FILE
 *
__am

__THROW
;

917 
	$rylockfe
 (
FILE
 *
__am

__THROW
 
__wur
;

920 
	$fuockfe
 (
FILE
 *
__am

__THROW
;

923 #i
defed
 
__USE_XOPEN
 && !defed 
__USE_XOPEN2K
 && !defed 
__USE_GNU


927 
	#__ed_gt


	)

928 
	~<gt.h
>

933 #ifde
__USE_EXTERN_INLINES


934 
	~<bs/dio.h
>

936 #i
__USE_FORTIFY_LEVEL
 > 0 && 
defed
 
__ex_ways_le


937 
	~<bs/dio2.h
>

939 #ifde
__LDBL_COMPAT


940 
	~<bs/dio-ldbl.h
>

943 
__END_DECLS


	@/usr/include/stdlib.h

22 #idef 
_STDLIB_H


24 
	~<us.h
>

27 
	#__ed_size_t


	)

28 #ide
__ed_mloc_d_oc


29 
	#__ed_wch_t


	)

30 
	#__ed_NULL


	)

32 
	~<ddef.h
>

34 
	g__BEGIN_DECLS


36 #ide
__ed_mloc_d_oc


37 
	#_STDLIB_H
 1

	)

39 #i(
defed
 
__USE_XOPEN
 || defed 
__USE_XOPEN2K8
&& !defed 
_SYS_WAIT_H


41 
	~<bs/waags.h
>

42 
	~<bs/waus.h
>

44 #ifde
__USE_BSD


49 #i
defed
 
__GNUC__
 && !defed 
__lulus


50 
	#__WAIT_INT
(
us
) \

51 (
	`__exnsi__
 (((uni { 
	`__tyof
(
us

__
; 
__i
; }) \

52 { .
__
 = (
us
}).
__i
))

	)

54 
	#__WAIT_INT
(
us
(*(*&(us))

	)

62 #i!
defed
 
__GNUC__
 || __GNUC__ < 2 || defed 
__lulus


63 
	#__WAIT_STATUS
 *

	)

64 
	#__WAIT_STATUS_DEFN
 *

	)

69 
wa
 *
	m__ur
;

70 *
	m__
;

71 } 
	t__WAIT_STATUS
 
	t__ibu__
 ((
	t__t_uni__
));

72 
	#__WAIT_STATUS_DEFN
 *

	)

77 
	#__WAIT_INT
(
us
(us)

	)

78 
	#__WAIT_STATUS
 *

	)

79 
	#__WAIT_STATUS_DEFN
 *

	)

84 
	#WEXITSTATUS
(
us

	`__WEXITSTATUS
 (
	`__WAIT_INT
 (us))

	)

85 
	#WTERMSIG
(
us

	`__WTERMSIG
 (
	`__WAIT_INT
 (us))

	)

86 
	#WSTOPSIG
(
us

	`__WSTOPSIG
 (
	`__WAIT_INT
 (us))

	)

87 
	#WIFEXITED
(
us

	`__WIFEXITED
 (
	`__WAIT_INT
 (us))

	)

88 
	#WIFSIGNALED
(
us

	`__WIFSIGNALED
 (
	`__WAIT_INT
 (us))

	)

89 
	#WIFSTOPPED
(
us

	`__WIFSTOPPED
 (
	`__WAIT_INT
 (us))

	)

90 #ifde
__WIFCONTINUED


91 
	#WIFCONTINUED
(
us

	`__WIFCONTINUED
 (
	`__WAIT_INT
 (us))

	)

95 
__BEGIN_NAMESPACE_STD


99 
	mqu
;

100 
	mm
;

101 } 
	tdiv_t
;

104 #ide
__ldiv_t_defed


107 
	mqu
;

108 
	mm
;

109 } 
	tldiv_t
;

110 
	#__ldiv_t_defed
 1

	)

112 
	g__END_NAMESPACE_STD


114 #i
defed
 
__USE_ISOC99
 && !defed 
__div_t_defed


115 
__BEGIN_NAMESPACE_C99


117 
__exnsi__
 struct

119 
	mqu
;

120 
	mm
;

121 } 
	tdiv_t
;

122 
	#__div_t_defed
 1

	)

123 
	g__END_NAMESPACE_C99


128 
	#RAND_MAX
 2147483647

	)

133 
	#EXIT_FAILURE
 1

	)

134 
	#EXIT_SUCCESS
 0

	)

138 
	#MB_CUR_MAX
 (
	`__y_g_mb_cur_max
 ())

	)

139 
size_t
 
	$__y_g_mb_cur_max
 (
__THROW
 
__wur
;

142 
__BEGIN_NAMESPACE_STD


144 
	$of
 (cڡ *
__Ō
)

145 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1)
__wur
;

147 
	$oi
 (cڡ *
__Ō
)

148 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1)
__wur
;

150 
	$
 (cڡ *
__Ō
)

151 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1)
__wur
;

152 
__END_NAMESPACE_STD


154 #i
defed
 
__USE_ISOC99
 || defed 
__USE_MISC


155 
__BEGIN_NAMESPACE_C99


157 
__exnsi__
 
	$l
 (cڡ *
__Ō
)

158 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1)
__wur
;

159 
__END_NAMESPACE_C99


162 
__BEGIN_NAMESPACE_STD


164 
	$od
 (cڡ *
__ri
 
__Ō
,

165 **
__ri
 
__dr
)

166 
__THROW
 
	`__nnu
 ((1));

167 
__END_NAMESPACE_STD


169 #ifdef 
__USE_ISOC99


170 
__BEGIN_NAMESPACE_C99


172 
	$of
 (cڡ *
__ri
 
__Ō
,

173 **
__ri
 
__dr

__THROW
 
	`__nnu
 ((1));

175 
	$d
 (cڡ *
__ri
 
__Ō
,

176 **
__ri
 
__dr
)

177 
__THROW
 
	`__nnu
 ((1));

178 
__END_NAMESPACE_C99


181 
__BEGIN_NAMESPACE_STD


183 
	$
 (cڡ *
__ri
 
__Ō
,

184 **
__ri
 
__dr
, 
__ba
)

185 
__THROW
 
	`__nnu
 ((1));

187 
	$oul
 (cڡ *
__ri
 
__Ō
,

188 **
__ri
 
__dr
, 
__ba
)

189 
__THROW
 
	`__nnu
 ((1));

190 
__END_NAMESPACE_STD


192 #ifde
__USE_BSD


194 
__exnsi__


195 
	$oq
 (cڡ *
__ri
 
__Ō
,

196 **
__ri
 
__dr
, 
__ba
)

197 
__THROW
 
	`__nnu
 ((1));

199 
__exnsi__


200 
	$ouq
 (cڡ *
__ri
 
__Ō
,

201 **
__ri
 
__dr
, 
__ba
)

202 
__THROW
 
	`__nnu
 ((1));

205 #i
defed
 
__USE_ISOC99
 || defed 
__USE_MISC


206 
__BEGIN_NAMESPACE_C99


208 
__exnsi__


209 
	$l
 (cڡ *
__ri
 
__Ō
,

210 **
__ri
 
__dr
, 
__ba
)

211 
__THROW
 
	`__nnu
 ((1));

213 
__exnsi__


214 
	$ou
 (cڡ *
__ri
 
__Ō
,

215 **
__ri
 
__dr
, 
__ba
)

216 
__THROW
 
	`__nnu
 ((1));

217 
__END_NAMESPACE_C99


221 #ifde
__USE_GNU


235 
	~<xlo.h
>

239 
	$_l
 (cڡ *
__ri
 
__Ō
,

240 **
__ri
 
__dr
, 
__ba
,

241 
__lo_t
 
__loc

__THROW
 
	`__nnu
 ((1, 4));

243 
	$oul_l
 (cڡ *
__ri
 
__Ō
,

244 **
__ri
 
__dr
,

245 
__ba
, 
__lo_t
 
__loc
)

246 
__THROW
 
	`__nnu
 ((1, 4));

248 
__exnsi__


249 
	$l_l
 (cڡ *
__ri
 
__Ō
,

250 **
__ri
 
__dr
, 
__ba
,

251 
__lo_t
 
__loc
)

252 
__THROW
 
	`__nnu
 ((1, 4));

254 
__exnsi__


255 
	$ou_l
 (cڡ *
__ri
 
__Ō
,

256 **
__ri
 
__dr
,

257 
__ba
, 
__lo_t
 
__loc
)

258 
__THROW
 
	`__nnu
 ((1, 4));

260 
	$od_l
 (cڡ *
__ri
 
__Ō
,

261 **
__ri
 
__dr
, 
__lo_t
 
__loc
)

262 
__THROW
 
	`__nnu
 ((1, 3));

264 
	$of_l
 (cڡ *
__ri
 
__Ō
,

265 **
__ri
 
__dr
, 
__lo_t
 
__loc
)

266 
__THROW
 
	`__nnu
 ((1, 3));

268 
	$d_l
 (cڡ *
__ri
 
__Ō
,

269 **
__ri
 
__dr
,

270 
__lo_t
 
__loc
)

271 
__THROW
 
	`__nnu
 ((1, 3));

275 #ifde
__USE_EXTERN_INLINES


276 
__BEGIN_NAMESPACE_STD


277 
__ex_le
 

278 
	`__NTH
 (
	$oi
 (cڡ *
__Ō
))

280  (
	`
 (
__Ō
, (**
NULL
, 10);

281 
	}
}

282 
__ex_le
 

283 
__NTH
 (
	$
 (cڡ *
__Ō
))

285  
	`
 (
__Ō
, (**
NULL
, 10);

286 
	}
}

287 
	g__END_NAMESPACE_STD


289 #i
defed
 
__USE_MISC
 || defed 
__USE_ISOC99


290 
__BEGIN_NAMESPACE_C99


291 
__exnsi__
 
__ex_le
 

292 
__NTH
 (
	$l
 (cڡ *
__Ō
))

294  
	`l
 (
__Ō
, (**
NULL
, 10);

295 
	}
}

296 
	g__END_NAMESPACE_C99


301 #i
defed
 
__USE_SVID
 || defed 
__USE_XOPEN_EXTENDED


305 *
	$l64a
 (
__n

__THROW
 
__wur
;

308 
	$a64l
 (cڡ *
__s
)

309 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1)
__wur
;

313 #i
defed
 
__USE_SVID
 || defed 
__USE_XOPEN_EXTENDED
 || defed 
__USE_BSD


314 
	~<sys/tys.h
>

321 
	$ndom
 (
__THROW
;

324 
	$dom
 (
__ed

__THROW
;

330 *
	$e
 (
__ed
, *
__ebuf
,

331 
size_t
 
__

__THROW
 
	`__nnu
 ((2));

335 *
	$te
 (*
__ebuf

__THROW
 
	`__nnu
 ((1));

338 #ifde
__USE_MISC


343 
	sndom_da


345 
t32_t
 *

;

346 
t32_t
 *

;

347 
t32_t
 *
e
;

348 
nd_ty
;

349 
nd_deg
;

350 
nd_p
;

351 
t32_t
 *
d_r
;

354 
	$ndom_r
 (
ndom_da
 *
__ri
 
__buf
,

355 
t32_t
 *
__ri
 
__su

__THROW
 
	`__nnu
 ((1, 2));

357 
	$dom_r
 (
__ed
, 
ndom_da
 *
__buf
)

358 
__THROW
 
	`__nnu
 ((2));

360 
	$e_r
 (
__ed
, *
__ri
 
__ebuf
,

361 
size_t
 
__
,

362 
ndom_da
 *
__ri
 
__buf
)

363 
__THROW
 
	`__nnu
 ((2, 4));

365 
	$te_r
 (*
__ri
 
__ebuf
,

366 
ndom_da
 *
__ri
 
__buf
)

367 
__THROW
 
	`__nnu
 ((1, 2));

372 
__BEGIN_NAMESPACE_STD


374 
	$nd
 (
__THROW
;

376 
	$d
 (
__ed

__THROW
;

377 
__END_NAMESPACE_STD


379 #ifde
__USE_POSIX


381 
	$nd_r
 (*
__ed

__THROW
;

385 #i
defed
 
__USE_SVID
 || defed 
__USE_XOPEN


389 
	$dnd48
 (
__THROW
;

390 
	$d48
 (
__xsubi
[3]
__THROW
 
	`__nnu
 ((1));

393 
	$̪d48
 (
__THROW
;

394 
	$Īd48
 (
__xsubi
[3])

395 
__THROW
 
	`__nnu
 ((1));

398 
	$mnd48
 (
__THROW
;

399 
	$jnd48
 (
__xsubi
[3])

400 
__THROW
 
	`__nnu
 ((1));

403 
	$d48
 (
__edv

__THROW
;

404 *
	$ed48
 (
__ed16v
[3])

405 
__THROW
 
	`__nnu
 ((1));

406 
	$lcg48
 (
__m
[7]
__THROW
 
	`__nnu
 ((1));

408 #ifde
__USE_MISC


412 
	sdnd48_da


414 
__x
[3];

415 
__d_x
[3];

416 
__c
;

417 
__
;

418 
__exnsi__
 
__a
;

423 
	$dnd48_r
 (
dnd48_da
 *
__ri
 
__bufr
,

424 *
__ri
 
__su

__THROW
 
	`__nnu
 ((1, 2));

425 
	$d48_r
 (
__xsubi
[3],

426 
dnd48_da
 *
__ri
 
__bufr
,

427 *
__ri
 
__su

__THROW
 
	`__nnu
 ((1, 2));

430 
	$̪d48_r
 (
dnd48_da
 *
__ri
 
__bufr
,

431 *
__ri
 
__su
)

432 
__THROW
 
	`__nnu
 ((1, 2));

433 
	$Īd48_r
 (
__xsubi
[3],

434 
dnd48_da
 *
__ri
 
__bufr
,

435 *
__ri
 
__su
)

436 
__THROW
 
	`__nnu
 ((1, 2));

439 
	$mnd48_r
 (
dnd48_da
 *
__ri
 
__bufr
,

440 *
__ri
 
__su
)

441 
__THROW
 
	`__nnu
 ((1, 2));

442 
	$jnd48_r
 (
__xsubi
[3],

443 
dnd48_da
 *
__ri
 
__bufr
,

444 *
__ri
 
__su
)

445 
__THROW
 
	`__nnu
 ((1, 2));

448 
	$d48_r
 (
__edv
, 
dnd48_da
 *
__bufr
)

449 
__THROW
 
	`__nnu
 ((2));

451 
	$ed48_r
 (
__ed16v
[3],

452 
dnd48_da
 *
__bufr

__THROW
 
	`__nnu
 ((1, 2));

454 
	$lcg48_r
 (
__m
[7],

455 
dnd48_da
 *
__bufr
)

456 
__THROW
 
	`__nnu
 ((1, 2));

462 #ide
__mloc_d_oc_defed


463 
	#__mloc_d_oc_defed


	)

464 
__BEGIN_NAMESPACE_STD


466 *
	$mloc
 (
size_t
 
__size

__THROW
 
__ibu_mloc__
 
__wur
;

468 *
	$oc
 (
size_t
 
__nmemb
, size_
__size
)

469 
__THROW
 
__ibu_mloc__
 
__wur
;

470 
__END_NAMESPACE_STD


473 #ide
__ed_mloc_d_oc


474 
__BEGIN_NAMESPACE_STD


480 *
	$loc
 (*
__r
, 
size_t
 
__size
)

481 
__THROW
 
__ibu_wn_unud_su__
;

483 
	$
 (*
__r

__THROW
;

484 
__END_NAMESPACE_STD


486 #ifdef 
__USE_MISC


488 
	$c
 (*
__r

__THROW
;

491 #i
defed
 
__USE_GNU
 || defed 
__USE_BSD
 || defed 
__USE_MISC


492 
	~<lo.h
>

495 #i(
defed
 
__USE_XOPEN_EXTENDED
 && !defed 
__USE_XOPEN2K
) \

496 || 
defed
 
__USE_BSD


498 *
	$vloc
 (
size_t
 
__size

__THROW
 
__ibu_mloc__
 
__wur
;

501 #ifde
__USE_XOPEN2K


503 
	$posix_memign
 (**
__memr
, 
size_t
 
__ignmt
, size_
__size
)

504 
__THROW
 
	`__nnu
 ((1)
__wur
;

507 #ifde
__USE_ISOC11


509 *
	$igd_loc
 (
size_t
 
__ignmt
, size_
__size
)

510 
__THROW
 
__ibu_mloc__
 
	`__ibu_loc_size__
 ((2)
__wur
;

513 
__BEGIN_NAMESPACE_STD


515 
	$abt
 (
__THROW
 
	`__ibu__
 ((
__nܑu__
));

519 
	`ex
 ((*
__func
()
__THROW
 
	`__nnu
 ((1));

521 #i
defed
 
__USE_ISOC11
 || defed 
__USE_ISOCXX11


523 #ifde
__lulus


524 "C++" 
	`_quick_ex
 ((*
__func
) ())

525 
__THROW
 
	`__asm
 ("_quick_ex"
	`__nnu
 ((1));

527 
	`_quick_ex
 ((*
__func
()
__THROW
 
	`__nnu
 ((1));

530 
__END_NAMESPACE_STD


532 #ifdef 
__USE_MISC


535 
	`_ex
 ((*
__func
(
__us
, *
__g
), *__arg)

536 
__THROW
 
	`__nnu
 ((1));

539 
__BEGIN_NAMESPACE_STD


543 
	$ex
 (
__us

__THROW
 
	`__ibu__
 ((
__nܑu__
));

545 #i
defed
 
__USE_ISOC11
 || defed 
__USE_ISOCXX11


549 
	$quick_ex
 (
__us

__THROW
 
	`__ibu__
 ((
__nܑu__
));

551 
__END_NAMESPACE_STD


553 #ifde
__USE_ISOC99


554 
__BEGIN_NAMESPACE_C99


557 
	$_Ex
 (
__us

__THROW
 
	`__ibu__
 ((
__nܑu__
));

558 
__END_NAMESPACE_C99


562 
__BEGIN_NAMESPACE_STD


564 *
	$gv
 (cڡ *
__me

__THROW
 
	`__nnu
 ((1)
__wur
;

565 
__END_NAMESPACE_STD


567 #ifde
__USE_GNU


570 *
	$cu_gv
 (cڡ *
__me
)

571 
__THROW
 
	`__nnu
 ((1)
__wur
;

574 #i
defed
 
__USE_SVID
 || defed 
__USE_XOPEN


578 
	$punv
 (*
__rg

__THROW
 
	`__nnu
 ((1));

581 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN2K


584 
	$nv
 (cڡ *
__me
, cڡ *
__vue
, 
__a
)

585 
__THROW
 
	`__nnu
 ((2));

588 
	$unnv
 (cڡ *
__me

__THROW
 
	`__nnu
 ((1));

591 #ifdef 
__USE_MISC


595 
	$nv
 (
__THROW
;

599 #i
defed
 
__USE_MISC
 \

600 || (
defed
 
__USE_XOPEN_EXTENDED
 && !defed 
__USE_XOPEN2K8
)

606 *
	$mkmp
 (*
__me

__THROW
 
	`__nnu
 ((1));

609 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN_EXTENDED
 \

610 || 
defed
 
__USE_XOPEN2K8


619 #ide
__USE_FILE_OFFSET64


620 
	$mkemp
 (*
__me

	`__nnu
 ((1)
__wur
;

622 #ifde
__REDIRECT


623 
	`__REDIRECT
 (
mkemp
, (*
__me
), 
mkemp64
)

624 
	`__nnu
 ((1)
__wur
;

626 
	#mkemp
 
mkemp64


	)

629 #ifde
__USE_LARGEFILE64


630 
	$mkemp64
 (*
__me

	`__nnu
 ((1)
__wur
;

634 #ifde
__USE_MISC


641 #ide
__USE_FILE_OFFSET64


642 
	$mkemps
 (*
__me
, 
__suffixn

	`__nnu
 ((1)
__wur
;

644 #ifde
__REDIRECT


645 
	`__REDIRECT
 (
mkemps
, (*
__me
, 
__suffixn
),

646 
mkemps64

	`__nnu
 ((1)
__wur
;

648 
	#mkemps
 
mkemps64


	)

651 #ifde
__USE_LARGEFILE64


652 
	$mkemps64
 (*
__me
, 
__suffixn
)

653 
	`__nnu
 ((1)
__wur
;

657 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN2K8


663 *
	$mkdmp
 (*
__me

__THROW
 
	`__nnu
 ((1)
__wur
;

666 #ifde
__USE_GNU


673 #ide
__USE_FILE_OFFSET64


674 
	$mkoemp
 (*
__me
, 
__ags

	`__nnu
 ((1)
__wur
;

676 #ifde
__REDIRECT


677 
	`__REDIRECT
 (
mkoemp
, (*
__me
, 
__ags
), 
mkoemp64
)

678 
	`__nnu
 ((1)
__wur
;

680 
	#mkoemp
 
mkoemp64


	)

683 #ifde
__USE_LARGEFILE64


684 
	$mkoemp64
 (*
__me
, 
__ags

	`__nnu
 ((1)
__wur
;

693 #ide
__USE_FILE_OFFSET64


694 
	$mkoemps
 (*
__me
, 
__suffixn
, 
__ags
)

695 
	`__nnu
 ((1)
__wur
;

697 #ifde
__REDIRECT


698 
	`__REDIRECT
 (
mkoemps
, (*
__me
, 
__suffixn
,

699 
__ags
), 
mkoemps64
)

700 
	`__nnu
 ((1)
__wur
;

702 
	#mkoemps
 
mkoemps64


	)

705 #ifde
__USE_LARGEFILE64


706 
	$mkoemps64
 (*
__me
, 
__suffixn
, 
__ags
)

707 
	`__nnu
 ((1)
__wur
;

712 
__BEGIN_NAMESPACE_STD


717 
	$syem
 (cڡ *
__commd

__wur
;

718 
__END_NAMESPACE_STD


721 #ifdef 
__USE_GNU


724 *
	$nilize_fe_me
 (cڡ *
__me
)

725 
__THROW
 
	`__nnu
 ((1)
__wur
;

728 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN_EXTENDED


734 *
	$th
 (cڡ *
__ri
 
__me
,

735 *
__ri
 
__sved

__THROW
 
__wur
;

740 #ide
__COMPAR_FN_T


741 
	#__COMPAR_FN_T


	)

742 (*
	t__comr__t
) (const *, const *);

744 #ifdef 
__USE_GNU


745 
__comr__t
 
	tcomris__t
;

748 #ifde
__USE_GNU


749 (*
	t__comr_d__t
) (const *, const *, *);

752 
__BEGIN_NAMESPACE_STD


755 *
	$bch
 (cڡ *
__key
, cڡ *
__ba
,

756 
size_t
 
__nmemb
, size_
__size
, 
__comr__t
 
__comr
)

757 
	`__nnu
 ((1, 2, 5)
__wur
;

759 #ifde
__USE_EXTERN_INLINES


760 
	~<bs/dlib-bch.h
>

765 
	$qst
 (*
__ba
, 
size_t
 
__nmemb
, size_
__size
,

766 
__comr__t
 
__comr

	`__nnu
 ((1, 4));

767 #ifde
__USE_GNU


768 
	$qst_r
 (*
__ba
, 
size_t
 
__nmemb
, size_
__size
,

769 
__comr_d__t
 
__comr
, *
__g
)

770 
	`__nnu
 ((1, 4));

775 
	$abs
 (
__x

__THROW
 
	`__ibu__
 ((
__cڡ__
)
__wur
;

776 
	$bs
 (
__x

__THROW
 
	`__ibu__
 ((
__cڡ__
)
__wur
;

777 
__END_NAMESPACE_STD


779 #ifde
__USE_ISOC99


780 
__exnsi__
 
	$abs
 (
__x
)

781 
__THROW
 
	`__ibu__
 ((
__cڡ__
)
__wur
;

785 
__BEGIN_NAMESPACE_STD


789 
div_t
 
	$div
 (
__num
, 
__dom
)

790 
__THROW
 
	`__ibu__
 ((
__cڡ__
)
__wur
;

791 
ldiv_t
 
	$ldiv
 (
__num
, 
__dom
)

792 
__THROW
 
	`__ibu__
 ((
__cڡ__
)
__wur
;

793 
__END_NAMESPACE_STD


795 #ifde
__USE_ISOC99


796 
__BEGIN_NAMESPACE_C99


797 
__exnsi__
 
div_t
 
	$div
 (
__num
,

798 
__dom
)

799 
__THROW
 
	`__ibu__
 ((
__cڡ__
)
__wur
;

800 
__END_NAMESPACE_C99


804 #i(
defed
 
__USE_XOPEN_EXTENDED
 && !defed 
__USE_XOPEN2K8
) \

805 || 
defed
 
__USE_SVID


812 *
	$ecvt
 (
__vue
, 
__ndig
, *
__ri
 
__det
,

813 *
__ri
 
__sign

__THROW
 
	`__nnu
 ((3, 4)
__wur
;

818 *
	$fcvt
 (
__vue
, 
__ndig
, *
__ri
 
__det
,

819 *
__ri
 
__sign

__THROW
 
	`__nnu
 ((3, 4)
__wur
;

824 *
	$gcvt
 (
__vue
, 
__ndig
, *
__buf
)

825 
__THROW
 
	`__nnu
 ((3)
__wur
;

828 #ifde
__USE_MISC


830 *
	$qecvt
 (
__vue
, 
__ndig
,

831 *
__ri
 
__det
, *__ri 
__sign
)

832 
__THROW
 
	`__nnu
 ((3, 4)
__wur
;

833 *
	$qfcvt
 (
__vue
, 
__ndig
,

834 *
__ri
 
__det
, *__ri 
__sign
)

835 
__THROW
 
	`__nnu
 ((3, 4)
__wur
;

836 *
	$qgcvt
 (
__vue
, 
__ndig
, *
__buf
)

837 
__THROW
 
	`__nnu
 ((3)
__wur
;

842 
	$ecvt_r
 (
__vue
, 
__ndig
, *
__ri
 
__det
,

843 *
__ri
 
__sign
, *__ri 
__buf
,

844 
size_t
 
__n

__THROW
 
	`__nnu
 ((3, 4, 5));

845 
	$fcvt_r
 (
__vue
, 
__ndig
, *
__ri
 
__det
,

846 *
__ri
 
__sign
, *__ri 
__buf
,

847 
size_t
 
__n

__THROW
 
	`__nnu
 ((3, 4, 5));

849 
	$qecvt_r
 (
__vue
, 
__ndig
,

850 *
__ri
 
__det
, *__ri 
__sign
,

851 *
__ri
 
__buf
, 
size_t
 
__n
)

852 
__THROW
 
	`__nnu
 ((3, 4, 5));

853 
	$qfcvt_r
 (
__vue
, 
__ndig
,

854 *
__ri
 
__det
, *__ri 
__sign
,

855 *
__ri
 
__buf
, 
size_t
 
__n
)

856 
__THROW
 
	`__nnu
 ((3, 4, 5));

860 
__BEGIN_NAMESPACE_STD


863 
	$mbn
 (cڡ *
__s
, 
size_t
 
__n

__THROW
;

866 
	$mbtowc
 (
wch_t
 *
__ri
 
__pwc
,

867 cڡ *
__ri
 
__s
, 
size_t
 
__n

__THROW
;

870 
	$womb
 (*
__s
, 
wch_t
 
__wch

__THROW
;

874 
size_t
 
	$mbowcs
 (
wch_t
 *
__ri
 
__pwcs
,

875 cڡ *
__ri
 
__s
, 
size_t
 
__n

__THROW
;

877 
size_t
 
	$wcombs
 (*
__ri
 
__s
,

878 cڡ 
wch_t
 *
__ri
 
__pwcs
, 
size_t
 
__n
)

879 
__THROW
;

880 
__END_NAMESPACE_STD


883 #ifde
__USE_SVID


888 
	$mch
 (cڡ *
__ڣ

__THROW
 
	`__nnu
 ((1)
__wur
;

892 #i
defed
 
__USE_XOPEN_EXTENDED
 || defed 
__USE_XOPEN2K8


899 
	$gsubt
 (**
__ri
 
__tip
,

900 *cڡ *
__ri
 
__toks
,

901 **
__ri
 
__vu
)

902 
__THROW
 
	`__nnu
 ((1, 2, 3)
__wur
;

906 #ifde
__USE_XOPEN


908 
	$tkey
 (cڡ *
__key

__THROW
 
	`__nnu
 ((1));

914 #ifde
__USE_XOPEN2KXSI


916 
	$posix_ݒ
 (
__oag

__wur
;

919 #ifde
__USE_XOPEN


924 
	$g
 (
__fd

__THROW
;

928 
	$uock
 (
__fd

__THROW
;

933 *
	$ame
 (
__fd

__THROW
 
__wur
;

936 #ifde
__USE_GNU


940 
	$ame_r
 (
__fd
, *
__buf
, 
size_t
 
__bu
)

941 
__THROW
 
	`__nnu
 ((2));

944 
	`g
 ();

947 #ifde
__USE_BSD


951 
	$gldavg
 (
__ldavg
[], 
__m
)

952 
__THROW
 
	`__nnu
 ((1));

955 
	~<bs/dlib-t.h
>

958 #i
__USE_FORTIFY_LEVEL
 > 0 && 
defed
 
__ftify_funi


959 
	~<bs/dlib.h
>

961 #ifde
__LDBL_COMPAT


962 
	~<bs/dlib-ldbl.h
>

966 #unde
__ed_mloc_d_oc


968 
__END_DECLS


	@/usr/include/sys/stat.h

22 #idef 
_SYS_STAT_H


23 
	#_SYS_STAT_H
 1

	)

25 
	~<us.h
>

27 
	~<bs/tys.h
>

29 #i
defed
 
__USE_XOPEN
 || defed 
__USE_XOPEN2K
 || defed 
__USE_MISC
 \

30 || 
defed
 
	g__USE_ATFILE


31 #i
defed
 
__USE_XOPEN
 || defed 
__USE_XOPEN2K


32 
	#__ed_time_t


	)

34 #i
defed
 
__USE_MISC
 || defed 
__USE_ATFILE


35 
	#__ed_timeec


	)

37 
	~<time.h
>

40 #i
defed
 
__USE_XOPEN
 || defed 
__USE_XOPEN2K


43 #ide
__dev_t_defed


44 
__dev_t
 
	tdev_t
;

45 
	#__dev_t_defed


	)

48 #ide
__gid_t_defed


49 
__gid_t
 
	tgid_t
;

50 
	#__gid_t_defed


	)

53 #ide
__o_t_defed


54 #ide
__USE_FILE_OFFSET64


55 
__o_t
 
	to_t
;

57 
__o64_t
 
	to_t
;

59 
	#__o_t_defed


	)

62 #ide
__mode_t_defed


63 
__mode_t
 
	tmode_t
;

64 
	#__mode_t_defed


	)

67 #ide
__ƚk_t_defed


68 
__ƚk_t
 
	tƚk_t
;

69 
	#__ƚk_t_defed


	)

72 #ide
__off_t_defed


73 #ide
__USE_FILE_OFFSET64


74 
__off_t
 
	toff_t
;

76 
__off64_t
 
	toff_t
;

78 
	#__off_t_defed


	)

81 #ide
__uid_t_defed


82 
__uid_t
 
	tuid_t
;

83 
	#__uid_t_defed


	)

87 #ifde
__USE_UNIX98


88 #ide
__blkt_t_defed


89 #ide
__USE_FILE_OFFSET64


90 
__blkt_t
 
	tblkt_t
;

92 
__blkt64_t
 
	tblkt_t
;

94 
	#__blkt_t_defed


	)

97 #ide
__blksize_t_defed


98 
__blksize_t
 
	tblksize_t
;

99 
	#__blksize_t_defed


	)

103 
	g__BEGIN_DECLS


105 
	~<bs/.h
>

107 #i
defed
 
__USE_BSD
 || defed 
__USE_MISC
 || defed 
__USE_XOPEN


108 
	#S_IFMT
 
__S_IFMT


	)

109 
	#S_IFDIR
 
__S_IFDIR


	)

110 
	#S_IFCHR
 
__S_IFCHR


	)

111 
	#S_IFBLK
 
__S_IFBLK


	)

112 
	#S_IFREG
 
__S_IFREG


	)

113 #ifde
__S_IFIFO


114 
	#S_IFIFO
 
__S_IFIFO


	)

116 #ifde
__S_IFLNK


117 
	#S_IFLNK
 
__S_IFLNK


	)

119 #i(
defed
 
__USE_BSD
 || defed 
__USE_MISC
 || defed 
__USE_UNIX98
) \

120 && 
defed
 
	g__S_IFSOCK


121 
	#S_IFSOCK
 
__S_IFSOCK


	)

127 
	#__S_ISTYPE
(
mode
, 
mask
(((mode& 
__S_IFMT
=(mask))

	)

129 
	#S_ISDIR
(
mode

	`__S_ISTYPE
((mode), 
__S_IFDIR
)

	)

130 
	#S_ISCHR
(
mode

	`__S_ISTYPE
((mode), 
__S_IFCHR
)

	)

131 
	#S_ISBLK
(
mode

	`__S_ISTYPE
((mode), 
__S_IFBLK
)

	)

132 
	#S_ISREG
(
mode

	`__S_ISTYPE
((mode), 
__S_IFREG
)

	)

133 #ifde
__S_IFIFO


134 
	#S_ISFIFO
(
mode

	`__S_ISTYPE
((mode), 
__S_IFIFO
)

	)

136 #ifde
__S_IFLNK


137 
	#S_ISLNK
(
mode

	`__S_ISTYPE
((mode), 
__S_IFLNK
)

	)

140 #i
defed
 
__USE_BSD
 && !defed 
__S_IFLNK


141 
	#S_ISLNK
(
mode
0

	)

144 #i(
defed
 
__USE_BSD
 || defed 
__USE_UNIX98
 || defed 
__USE_XOPEN2K
) \

145 && 
defed
 
	g__S_IFSOCK


146 
	#S_ISSOCK
(
mode

	`__S_ISTYPE
((mode), 
__S_IFSOCK
)

	)

147 #i
defed
 
__USE_XOPEN2K


148 
	#S_ISSOCK
(
mode
0

	)

155 #ifdef 
__USE_POSIX199309


156 
	#S_TYPEISMQ
(
buf

	`__S_TYPEISMQ
(buf)

	)

157 
	#S_TYPEISSEM
(
buf

	`__S_TYPEISSEM
(buf)

	)

158 
	#S_TYPEISSHM
(
buf

	`__S_TYPEISSHM
(buf)

	)

164 
	#S_ISUID
 
__S_ISUID


	)

165 
	#S_ISGID
 
__S_ISGID


	)

167 #i
defed
 
__USE_BSD
 || defed 
__USE_MISC
 || defed 
__USE_XOPEN


169 
	#S_ISVTX
 
__S_ISVTX


	)

172 
	#S_IRUSR
 
__S_IREAD


	)

173 
	#S_IWUSR
 
__S_IWRITE


	)

174 
	#S_IXUSR
 
__S_IEXEC


	)

176 
	#S_IRWXU
 (
__S_IREAD
|
__S_IWRITE
|
__S_IEXEC
)

	)

178 #i
defed
 
__USE_MISC
 && defed 
__USE_BSD


179 
	#S_IREAD
 
S_IRUSR


	)

180 
	#S_IWRITE
 
S_IWUSR


	)

181 
	#S_IEXEC
 
S_IXUSR


	)

184 
	#S_IRGRP
 (
S_IRUSR
 >> 3

	)

185 
	#S_IWGRP
 (
S_IWUSR
 >> 3

	)

186 
	#S_IXGRP
 (
S_IXUSR
 >> 3

	)

188 
	#S_IRWXG
 (
S_IRWXU
 >> 3)

	)

190 
	#S_IROTH
 (
S_IRGRP
 >> 3

	)

191 
	#S_IWOTH
 (
S_IWGRP
 >> 3

	)

192 
	#S_IXOTH
 (
S_IXGRP
 >> 3

	)

194 
	#S_IRWXO
 (
S_IRWXG
 >> 3)

	)

197 #ifdef 
__USE_BSD


199 
	#ACCESSPERMS
 (
S_IRWXU
|
S_IRWXG
|
S_IRWXO


	)

200 
	#ALLPERMS
 (
S_ISUID
|
S_ISGID
|
S_ISVTX
|
S_IRWXU
|
S_IRWXG
|
S_IRWXO
)

	)

201 
	#DEFFILEMODE
 (
S_IRUSR
|
S_IWUSR
|
S_IRGRP
|
S_IWGRP
|
S_IROTH
|
S_IWOTH
)

	)

203 
	#S_BLKSIZE
 512

	)

207 #ide
__USE_FILE_OFFSET64


209 
	$
 (cڡ *
__ri
 
__fe
,

210 

 *
__ri
 
__buf

__THROW
 
	`__nnu
 ((1, 2));

214 
	$f
 (
__fd
, 

 *
__buf

__THROW
 
	`__nnu
 ((2));

216 #ifde
__REDIRECT_NTH


217 
	`__REDIRECT_NTH
 (

, (cڡ *
__ri
 
__fe
,

218 

 *
__ri
 
__buf
), 
64
)

219 
	`__nnu
 ((1, 2));

220 
	`__REDIRECT_NTH
 (
f
, (
__fd
, 

 *
__buf
), 
f64
)

221 
	`__nnu
 ((2));

223 
	#
 
64


	)

224 
	#f
 
f64


	)

227 #ifde
__USE_LARGEFILE64


228 
	$64
 (cڡ *
__ri
 
__fe
,

229 
64
 *
__ri
 
__buf

__THROW
 
	`__nnu
 ((1, 2));

230 
	$f64
 (
__fd
, 
64
 *
__buf

__THROW
 
	`__nnu
 ((2));

233 #ifde
__USE_ATFILE


237 #ide
__USE_FILE_OFFSET64


238 
	$f
 (
__fd
, cڡ *
__ri
 
__fe
,

239 

 *
__ri
 
__buf
, 
__ag
)

240 
__THROW
 
	`__nnu
 ((2, 3));

242 #ifde
__REDIRECT_NTH


243 
	`__REDIRECT_NTH
 (
f
, (
__fd
, cڡ *
__ri
 
__fe
,

244 

 *
__ri
 
__buf
,

245 
__ag
),

246 
f64

	`__nnu
 ((2, 3));

248 
	#f
 
f64


	)

252 #ifde
__USE_LARGEFILE64


253 
	$f64
 (
__fd
, cڡ *
__ri
 
__fe
,

254 
64
 *
__ri
 
__buf
, 
__ag
)

255 
__THROW
 
	`__nnu
 ((2, 3));

259 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN_EXTENDED
 || defed 
__USE_XOPEN2K


260 #ide
__USE_FILE_OFFSET64


263 
	$l
 (cڡ *
__ri
 
__fe
,

264 

 *
__ri
 
__buf

__THROW
 
	`__nnu
 ((1, 2));

266 #ifde
__REDIRECT_NTH


267 
	`__REDIRECT_NTH
 (
l
,

268 (cڡ *
__ri
 
__fe
,

269 

 *
__ri
 
__buf
), 
l64
)

270 
	`__nnu
 ((1, 2));

272 
	#l
 
l64


	)

275 #ifde
__USE_LARGEFILE64


276 
	$l64
 (cڡ *
__ri
 
__fe
,

277 
64
 *
__ri
 
__buf
)

278 
__THROW
 
	`__nnu
 ((1, 2));

284 
	$chmod
 (cڡ *
__fe
, 
__mode_t
 
__mode
)

285 
__THROW
 
	`__nnu
 ((1));

287 #ifde
__USE_BSD


291 
	$lchmod
 (cڡ *
__fe
, 
__mode_t
 
__mode
)

292 
__THROW
 
	`__nnu
 ((1));

296 #i
defed
 
__USE_BSD
 || defed 
__USE_POSIX


297 
	$fchmod
 (
__fd
, 
__mode_t
 
__mode

__THROW
;

300 #ifde
__USE_ATFILE


303 
	$fchmod
 (
__fd
, cڡ *
__fe
, 
__mode_t
 
__mode
,

304 
__ag
)

305 
__THROW
 
	`__nnu
 ((2)
__wur
;

312 
__mode_t
 
	$umask
 (
__mode_t
 
__mask

__THROW
;

314 #ifdef 
__USE_GNU


317 
__mode_t
 
	$gumask
 (
__THROW
;

321 
	$mkd
 (cڡ *
__th
, 
__mode_t
 
__mode
)

322 
__THROW
 
	`__nnu
 ((1));

324 #ifde
__USE_ATFILE


328 
	$mkd
 (
__fd
, cڡ *
__th
, 
__mode_t
 
__mode
)

329 
__THROW
 
	`__nnu
 ((2));

335 #i
defed
 
__USE_MISC
 || defed 
__USE_BSD
 || defed 
__USE_XOPEN_EXTENDED


336 
	$mknod
 (cڡ *
__th
, 
__mode_t
 
__mode
, 
__dev_t
 
__dev
)

337 
__THROW
 
	`__nnu
 ((1));

339 #ifde
__USE_ATFILE


343 
	$mknod
 (
__fd
, cڡ *
__th
, 
__mode_t
 
__mode
,

344 
__dev_t
 
__dev

__THROW
 
	`__nnu
 ((2));

350 
	$mkfifo
 (cڡ *
__th
, 
__mode_t
 
__mode
)

351 
__THROW
 
	`__nnu
 ((1));

353 #ifde
__USE_ATFILE


357 
	$mkfift
 (
__fd
, cڡ *
__th
, 
__mode_t
 
__mode
)

358 
__THROW
 
	`__nnu
 ((2));

361 #ifde
__USE_ATFILE


364 
	$utimt
 (
__fd
, cڡ *
__th
,

365 cڡ 
timeec
 
__times
[2],

366 
__ags
)

367 
__THROW
 
	`__nnu
 ((2));

370 #ifde
__USE_XOPEN2K8


372 
	$futims
 (
__fd
, cڡ 
timeec
 
__times
[2]
__THROW
;

390 #ide
_STAT_VER


391 
	#_STAT_VER
 0

	)

393 #ide
_MKNOD_VER


394 
	#_MKNOD_VER
 0

	)

398 #ide
__USE_FILE_OFFSET64


399 
	$__fx
 (
__v
, 
__fdes
, 

 *
___buf
)

400 
__THROW
 
	`__nnu
 ((3));

401 
	$__x
 (
__v
, cڡ *
__fame
,

402 

 *
___buf

__THROW
 
	`__nnu
 ((2, 3));

403 
	$__lx
 (
__v
, cڡ *
__fame
,

404 

 *
___buf

__THROW
 
	`__nnu
 ((2, 3));

405 
	$__fx
 (
__v
, 
__fdes
, cڡ *
__fame
,

406 

 *
___buf
, 
__ag
)

407 
__THROW
 
	`__nnu
 ((3, 4));

409 #ifde
__REDIRECT_NTH


410 
	`__REDIRECT_NTH
 (
__fx
, (
__v
, 
__fdes
,

411 

 *
___buf
), 
__fx64
)

412 
	`__nnu
 ((3));

413 
	`__REDIRECT_NTH
 (
__x
, (
__v
, cڡ *
__fame
,

414 

 *
___buf
), 
__x64
)

415 
	`__nnu
 ((2, 3));

416 
	`__REDIRECT_NTH
 (
__lx
, (
__v
, cڡ *
__fame
,

417 

 *
___buf
), 
__lx64
)

418 
	`__nnu
 ((2, 3));

419 
	`__REDIRECT_NTH
 (
__fx
, (
__v
, 
__fdes
,

420 cڡ *
__fame
,

421 

 *
___buf
, 
__ag
),

422 
__fx64

	`__nnu
 ((3, 4));

425 
	#__fx
 
__fx64


	)

426 
	#__x
 
__x64


	)

427 
	#__lx
 
__lx64


	)

431 #ifde
__USE_LARGEFILE64


432 
	$__fx64
 (
__v
, 
__fdes
, 
64
 *
___buf
)

433 
__THROW
 
	`__nnu
 ((3));

434 
	$__x64
 (
__v
, cڡ *
__fame
,

435 
64
 *
___buf

__THROW
 
	`__nnu
 ((2, 3));

436 
	$__lx64
 (
__v
, cڡ *
__fame
,

437 
64
 *
___buf

__THROW
 
	`__nnu
 ((2, 3));

438 
	$__fx64
 (
__v
, 
__fdes
, cڡ *
__fame
,

439 
64
 *
___buf
, 
__ag
)

440 
__THROW
 
	`__nnu
 ((3, 4));

442 
	$__xmknod
 (
__v
, cڡ *
__th
, 
__mode_t
 
__mode
,

443 
__dev_t
 *
__dev

__THROW
 
	`__nnu
 ((2, 4));

445 
	$__xmknod
 (
__v
, 
__fd
, cڡ *
__th
,

446 
__mode_t
 
__mode
, 
__dev_t
 *
__dev
)

447 
__THROW
 
	`__nnu
 ((3, 5));

449 #ifde
__USE_EXTERN_INLINES


452 
__ex_le
 

453 
	`__NTH
 (
	$
 (cڡ *
__th
, 

 *
__buf
))

455  
	`__x
 (
_STAT_VER
, 
__th
, 
__buf
);

456 
	}
}

458 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN_EXTENDED


459 
__ex_le
 

460 
__NTH
 (
	$l
 (cڡ *
__th
, 

 *
__buf
))

462  
	`__lx
 (
_STAT_VER
, 
__th
, 
__buf
);

463 
	}
}

466 
__ex_le
 

467 
__NTH
 (
	$f
 (
__fd
, 

 *
__buf
))

469  
	`__fx
 (
_STAT_VER
, 
__fd
, 
__buf
);

470 
	}
}

472 #ifde
__USE_ATFILE


473 
__ex_le
 

474 
__NTH
 (
	$f
 (
__fd
, cڡ *
__fame
, 

 *
__buf
,

475 
__ag
))

477  
	`__fx
 (
_STAT_VER
, 
__fd
, 
__fame
, 
__buf
, 
__ag
);

478 
	}
}

481 #i
defed
 
__USE_MISC
 || defed 
__USE_BSD


482 
__ex_le
 

483 
__NTH
 (
	$mknod
 (cڡ *
__th
, 
__mode_t
 
__mode
, 
__dev_t
 
__dev
))

485  
	`__xmknod
 (
_MKNOD_VER
, 
__th
, 
__mode
, &
__dev
);

486 
	}
}

489 #ifde
__USE_ATFILE


490 
__ex_le
 

491 
__NTH
 (
	$mknod
 (
__fd
, cڡ *
__th
, 
__mode_t
 
__mode
,

492 
__dev_t
 
__dev
))

494  
	`__xmknod
 (
_MKNOD_VER
, 
__fd
, 
__th
, 
__mode
, &
__dev
);

495 
	}
}

498 #i
defed
 
__USE_LARGEFILE64
 \

499 && (! 
defed
 
	g__USE_FILE_OFFSET64
 \

500 || (
defed
 
	g__REDIRECT_NTH
 && defed 
	g__OPTIMIZE__
))

501 
__ex_le
 

502 
__NTH
 (
	$64
 (cڡ *
__th
, 
64
 *
__buf
))

504  
	`__x64
 (
_STAT_VER
, 
__th
, 
__buf
);

505 
	}
}

507 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN_EXTENDED


508 
__ex_le
 

509 
__NTH
 (
	$l64
 (cڡ *
__th
, 
64
 *
__buf
))

511  
	`__lx64
 (
_STAT_VER
, 
__th
, 
__buf
);

512 
	}
}

515 
__ex_le
 

516 
__NTH
 (
	$f64
 (
__fd
, 
64
 *
__buf
))

518  
	`__fx64
 (
_STAT_VER
, 
__fd
, 
__buf
);

519 
	}
}

521 #ifde
__USE_ATFILE


522 
__ex_le
 

523 
__NTH
 (
	$f64
 (
__fd
, cڡ *
__fame
, 
64
 *
__buf
,

524 
__ag
))

526  
	`__fx64
 (
_STAT_VER
, 
__fd
, 
__fame
, 
__buf
, 
__ag
);

527 
	}
}

534 
	g__END_DECLS


	@/usr/include/sys/types.h

22 #idef 
_SYS_TYPES_H


23 
	#_SYS_TYPES_H
 1

	)

25 
	~<us.h
>

27 
	g__BEGIN_DECLS


29 
	~<bs/tys.h
>

31 #ifdef 
__USE_BSD


32 #ide
__u_ch_defed


33 
__u_ch
 
	tu_ch
;

34 
__u_sht
 
	tu_sht
;

35 
__u_t
 
	tu_t
;

36 
__u_lg
 
	tu_lg
;

37 
__quad_t
 
	tquad_t
;

38 
__u_quad_t
 
	tu_quad_t
;

39 
__fsid_t
 
	tfsid_t
;

40 
	#__u_ch_defed


	)

44 
__loff_t
 
	tloff_t
;

46 #ide
__o_t_defed


47 #ide
__USE_FILE_OFFSET64


48 
__o_t
 
	to_t
;

50 
__o64_t
 
	to_t
;

52 
	#__o_t_defed


	)

54 #i
defed
 
__USE_LARGEFILE64
 && !defed 
__o64_t_defed


55 
__o64_t
 
	to64_t
;

56 
	#__o64_t_defed


	)

59 #ide
__dev_t_defed


60 
__dev_t
 
	tdev_t
;

61 
	#__dev_t_defed


	)

64 #ide
__gid_t_defed


65 
__gid_t
 
	tgid_t
;

66 
	#__gid_t_defed


	)

69 #ide
__mode_t_defed


70 
__mode_t
 
	tmode_t
;

71 
	#__mode_t_defed


	)

74 #ide
__ƚk_t_defed


75 
__ƚk_t
 
	tƚk_t
;

76 
	#__ƚk_t_defed


	)

79 #ide
__uid_t_defed


80 
__uid_t
 
	tuid_t
;

81 
	#__uid_t_defed


	)

84 #ide
__off_t_defed


85 #ide
__USE_FILE_OFFSET64


86 
__off_t
 
	toff_t
;

88 
__off64_t
 
	toff_t
;

90 
	#__off_t_defed


	)

92 #i
defed
 
__USE_LARGEFILE64
 && !defed 
__off64_t_defed


93 
__off64_t
 
	toff64_t
;

94 
	#__off64_t_defed


	)

97 #ide
__pid_t_defed


98 
__pid_t
 
	tpid_t
;

99 
	#__pid_t_defed


	)

102 #i(
defed
 
__USE_SVID
 || defed 
__USE_XOPEN
 || defed 
__USE_XOPEN2K8
) \

103 && !
defed
 
__id_t_defed


104 
__id_t
 
	tid_t
;

105 
	#__id_t_defed


	)

108 #ide
__ssize_t_defed


109 
__ssize_t
 
	tssize_t
;

110 
	#__ssize_t_defed


	)

113 #ifdef 
__USE_BSD


114 #ide
__daddr_t_defed


115 
__daddr_t
 
	tdaddr_t
;

116 
__ddr_t
 
	tddr_t
;

117 
	#__daddr_t_defed


	)

121 #i(
defed
 
__USE_SVID
 || defed 
__USE_XOPEN
&& !defed 
__key_t_defed


122 
__key_t
 
	tkey_t
;

123 
	#__key_t_defed


	)

126 #i
defed
 
__USE_XOPEN
 || defed 
__USE_XOPEN2K8


127 
	#__ed_ock_t


	)

129 
	#__ed_time_t


	)

130 
	#__ed_tim_t


	)

131 
	#__ed_ockid_t


	)

132 
	~<time.h
>

134 #ifde
__USE_XOPEN


135 #ide
__ucds_t_defed


136 
__ucds_t
 
	tucds_t
;

137 
	#__ucds_t_defed


	)

139 #ide
__sucds_t_defed


140 
__sucds_t
 
	tsucds_t
;

141 
	#__sucds_t_defed


	)

145 
	#__ed_size_t


	)

146 
	~<ddef.h
>

148 #ifde
__USE_MISC


150 
	tulg
;

151 
	tusht
;

152 
	tut
;

157 #i!
__GNUC_PREREQ
 (2, 7)

160 #ide
__t8_t_defed


161 
	#__t8_t_defed


	)

162 
	tt8_t
;

163 
	tt16_t
;

164 
	tt32_t
;

165 #i
__WORDSIZE
 == 64

166 
	tt64_t
;

168 
__exnsi__
 
	tt64_t
;

173 
	tu_t8_t
;

174 
	tu_t16_t
;

175 
	tu_t32_t
;

176 #i
__WORDSIZE
 == 64

177 
	tu_t64_t
;

179 
__exnsi__
 
	tu_t64_t
;

182 
	tgi_t
;

187 
	#__tN_t
(
N
, 
MODE
) \

188 ##
	tN
##
	t_t
 
	t__ibu__
 ((
	t__mode__
 (
	tMODE
)))

	)

189 
	t__u_tN_t
(
	tN
, 
	tMODE
) \

190 
	tu_t
##
	tN
##
	t_t
 
	t__ibu__
 ((
	t__mode__
 (
	tMODE
)))

	)

192 #ide
	t__t8_t_defed


193 
	t__t8_t_defed


	)

194 
	t__tN_t
 (8, 
	t__QI__
);

195 
__tN_t
 (16, 
__HI__
);

196 
__tN_t
 (32, 
__SI__
);

197 
__tN_t
 (64, 
__DI__
);

200 
__u_tN_t
 (8, 
__QI__
);

201 
__u_tN_t
 (16, 
__HI__
);

202 
__u_tN_t
 (32, 
__SI__
);

203 
__u_tN_t
 (64, 
__DI__
);

205 
	tgi_t
 
	t__ibu__
 ((
	t__mode__
 (
	t__wd__
)));

211 
	#__BIT_TYPES_DEFINED__
 1

	)

214 #ifdef 
__USE_BSD


216 
	~<dn.h
>

219 
	~<sys/.h
>

222 
	~<sys/sysmaos.h
>

226 #i(
defed
 
__USE_UNIX98
 || defed 
__USE_XOPEN2K8
) \

227 && !
defed
 
__blksize_t_defed


228 
__blksize_t
 
	tblksize_t
;

229 
	#__blksize_t_defed


	)

233 #ide
__USE_FILE_OFFSET64


234 #ide
__blkt_t_defed


235 
__blkt_t
 
	tblkt_t
;

236 
	#__blkt_t_defed


	)

238 #ide
__fsblkt_t_defed


239 
__fsblkt_t
 
	tfsblkt_t
;

240 
	#__fsblkt_t_defed


	)

242 #ide
__fsft_t_defed


243 
__fsft_t
 
	tfsft_t
;

244 
	#__fsft_t_defed


	)

247 #ide
__blkt_t_defed


248 
__blkt64_t
 
	tblkt_t
;

249 
	#__blkt_t_defed


	)

251 #ide
__fsblkt_t_defed


252 
__fsblkt64_t
 
	tfsblkt_t
;

253 
	#__fsblkt_t_defed


	)

255 #ide
__fsft_t_defed


256 
__fsft64_t
 
	tfsft_t
;

257 
	#__fsft_t_defed


	)

261 #ifde
__USE_LARGEFILE64


262 
__blkt64_t
 
	tblkt64_t
;

263 
__fsblkt64_t
 
	tfsblkt64_t
;

264 
__fsft64_t
 
	tfsft64_t
;

269 #i
defed
 
__USE_POSIX199506
 || defed 
__USE_UNIX98


270 
	~<bs/hadtys.h
>

273 
	g__END_DECLS


	@/usr/include/alloca.h

18 #idef 
_ALLOCA_H


19 
	#_ALLOCA_H
 1

	)

21 
	~<us.h
>

23 
	#__ed_size_t


	)

24 
	~<ddef.h
>

26 
	g__BEGIN_DECLS


29 #unde
lo


32 *
	$lo
 (
size_t
 
__size

__THROW
;

34 #ifdef 
__GNUC__


35 
	#lo
(
size

	`__but_lo
 (size)

	)

38 
__END_DECLS


	@/usr/include/bits/errno.h

19 #ifde
_ERRNO_H


21 #unde
EDOM


22 #unde
EILSEQ


23 #unde
ERANGE


24 
	~<lux/o.h
>

27 
	#ENOTSUP
 
EOPNOTSUPP


	)

30 #ide
ECANCELED


31 
	#ECANCELED
 125

	)

35 #ide
EOWNERDEAD


36 
	#EOWNERDEAD
 130

	)

37 
	#ENOTRECOVERABLE
 131

	)

40 #ide
ERFKILL


41 
	#ERFKILL
 132

	)

44 #ide
EHWPOISON


45 
	#EHWPOISON
 133

	)

48 #ide
__ASSEMBLER__


50 *
	$__o_loti
 (
__THROW
 
	`__ibu__
 ((
__cڡ__
));

52 #i!
defed
 
_LIBC
 || defed 
_LIBC_REENTRANT


54 
	#o
 (*
	`__o_loti
 ())

	)

59 #i!
defed
 
_ERRNO_H
 && defed 
__ed_Emh


63 
	#EDOM
 33

	)

64 
	#EILSEQ
 84

	)

65 
	#ERANGE
 34

	)

	@/usr/include/bits/fcntl.h

19 #ide
_FCNTL_H


23 #ifde
__x86_64__


24 
	#__O_LARGEFILE
 0

	)

27 #ifde
__x86_64__


29 
	#F_GETLK64
 5

	)

30 
	#F_SETLK64
 6

	)

31 
	#F_SETLKW64
 7

	)

35 
	sock


37 
	ml_ty
;

38 
	ml_wh
;

39 #ide
__USE_FILE_OFFSET64


40 
__off_t
 
	ml_t
;

41 
__off_t
 
	ml_n
;

43 
__off64_t
 
	ml_t
;

44 
__off64_t
 
	ml_n
;

46 
__pid_t
 
	ml_pid
;

49 #ifde
__USE_LARGEFILE64


50 
	sock64


52 
	ml_ty
;

53 
	ml_wh
;

54 
__off64_t
 
	ml_t
;

55 
__off64_t
 
	ml_n
;

56 
__pid_t
 
	ml_pid
;

61 
	~<bs/f-lux.h
>

	@/usr/include/bits/fcntl2.h

19 #idef 
_FCNTL_H


25 #ide
__USE_FILE_OFFSET64


26 
	$__ݒ_2
 (cڡ *
__th
, 
__oag

	`__nnu
 ((1));

27 
	`__REDIRECT
 (
__ݒ_s
, (cڡ *
__th
, 
__oag
, ...),

28 
ݒ

	`__nnu
 ((1));

30 
	`__REDIRECT
 (
__ݒ_2
, (cڡ *
__th
, 
__oag
),

31 
__ݒ64_2

	`__nnu
 ((1));

32 
	`__REDIRECT
 (
__ݒ_s
, (cڡ *
__th
, 
__oag
, ...),

33 
ݒ64

	`__nnu
 ((1));

35 
	`__rde
 (
__ݒ_too_my_gs
,

37 
	`__rde
 (
__ݒ_missg_mode
,

40 
__ftify_funi
 

41 
	$ݒ
 (cڡ *
__th
, 
__oag
, ...)

43 i(
	`__va_g_ck_n
 () > 1)

44 
	`__ݒ_too_my_gs
 ();

46 i(
	`__but_cڡt_p
 (
__oag
))

48 i((
__oag
 & 
O_CREAT
!0 && 
	`__va_g_ck_n
 () < 1)

50 
	`__ݒ_missg_mode
 ();

51  
	`__ݒ_2
 (
__th
, 
__oag
);

53  
	`__ݒ_s
 (
__th
, 
__oag
, 
	`__va_g_ck
 ());

56 i(
	`__va_g_ck_n
 () < 1)

57  
	`__ݒ_2
 (
__th
, 
__oag
);

59  
	`__ݒ_s
 (
__th
, 
__oag
, 
	`__va_g_ck
 ());

60 
	}
}

63 #ifde
__USE_LARGEFILE64


64 
	$__ݒ64_2
 (cڡ *
__th
, 
__oag

	`__nnu
 ((1));

65 
	`__REDIRECT
 (
__ݒ64_s
, (cڡ *
__th
, 
__oag
,

66 ...), 
ݒ64

	`__nnu
 ((1));

67 
	`__rde
 (
__ݒ64_too_my_gs
,

69 
	`__rde
 (
__ݒ64_missg_mode
,

72 
__ftify_funi
 

73 
	$ݒ64
 (cڡ *
__th
, 
__oag
, ...)

75 i(
	`__va_g_ck_n
 () > 1)

76 
	`__ݒ64_too_my_gs
 ();

78 i(
	`__but_cڡt_p
 (
__oag
))

80 i((
__oag
 & 
O_CREAT
!0 && 
	`__va_g_ck_n
 () < 1)

82 
	`__ݒ64_missg_mode
 ();

83  
	`__ݒ64_2
 (
__th
, 
__oag
);

85  
	`__ݒ64_s
 (
__th
, 
__oag
, 
	`__va_g_ck
 ());

88 i(
	`__va_g_ck_n
 () < 1)

89  
	`__ݒ64_2
 (
__th
, 
__oag
);

91  
	`__ݒ64_s
 (
__th
, 
__oag
, 
	`__va_g_ck
 ());

92 
	}
}

96 #ifde
__USE_ATFILE


97 #ide
__USE_FILE_OFFSET64


98 
	$__ݒ_2
 (
__fd
, cڡ *
__th
, 
__oag
)

99 
	`__nnu
 ((2));

100 
	`__REDIRECT
 (
__ݒ_s
, (
__fd
, cڡ *
__th
,

101 
__oag
, ...), 
ݒ
)

102 
	`__nnu
 ((2));

104 
	`__REDIRECT
 (
__ݒ_2
, (
__fd
, cڡ *
__th
,

105 
__oag
), 
__ݒ64_2
)

106 
	`__nnu
 ((2));

107 
	`__REDIRECT
 (
__ݒ_s
, (
__fd
, cڡ *
__th
,

108 
__oag
, ...), 
ݒ64
)

109 
	`__nnu
 ((2));

111 
	`__rde
 (
__ݒ_too_my_gs
,

113 
	`__rde
 (
__ݒ_missg_mode
,

116 
__ftify_funi
 

117 
	$ݒ
 (
__fd
, cڡ *
__th
, 
__oag
, ...)

119 i(
	`__va_g_ck_n
 () > 1)

120 
	`__ݒ_too_my_gs
 ();

122 i(
	`__but_cڡt_p
 (
__oag
))

124 i((
__oag
 & 
O_CREAT
!0 && 
	`__va_g_ck_n
 () < 1)

126 
	`__ݒ_missg_mode
 ();

127  
	`__ݒ_2
 (
__fd
, 
__th
, 
__oag
);

129  
	`__ݒ_s
 (
__fd
, 
__th
, 
__oag
, 
	`__va_g_ck
 ());

132 i(
	`__va_g_ck_n
 () < 1)

133  
	`__ݒ_2
 (
__fd
, 
__th
, 
__oag
);

135  
	`__ݒ_s
 (
__fd
, 
__th
, 
__oag
, 
	`__va_g_ck
 ());

136 
	}
}

139 #ifde
__USE_LARGEFILE64


140 
	$__ݒ64_2
 (
__fd
, cڡ *
__th
, 
__oag
)

141 
	`__nnu
 ((2));

142 
	`__REDIRECT
 (
__ݒ64_s
, (
__fd
, cڡ *
__th
,

143 
__oag
, ...), 
ݒ64
)

144 
	`__nnu
 ((2));

145 
	`__rde
 (
__ݒ64_too_my_gs
,

147 
	`__rde
 (
__ݒ64_missg_mode
,

150 
__ftify_funi
 

151 
	$ݒ64
 (
__fd
, cڡ *
__th
, 
__oag
, ...)

153 i(
	`__va_g_ck_n
 () > 1)

154 
	`__ݒ64_too_my_gs
 ();

156 i(
	`__but_cڡt_p
 (
__oag
))

158 i((
__oag
 & 
O_CREAT
!0 && 
	`__va_g_ck_n
 () < 1)

160 
	`__ݒ64_missg_mode
 ();

161  
	`__ݒ64_2
 (
__fd
, 
__th
, 
__oag
);

163  
	`__ݒ64_s
 (
__fd
, 
__th
, 
__oag
, 
	`__va_g_ck
 ());

166 i(
	`__va_g_ck_n
 () < 1)

167  
	`__ݒ64_2
 (
__fd
, 
__th
, 
__oag
);

169  
	`__ݒ64_s
 (
__fd
, 
__th
, 
__oag
, 
	`__va_g_ck
 ());

170 
	}
}

	@/usr/include/bits/pthreadtypes.h

18 #ide
_BITS_PTHREADTYPES_H


19 
	#_BITS_PTHREADTYPES_H
 1

	)

21 
	~<bs/wdsize.h
>

23 #ifde
__x86_64__


24 #i
__WORDSIZE
 == 64

25 
	#__SIZEOF_PTHREAD_ATTR_T
 56

	)

26 
	#__SIZEOF_PTHREAD_MUTEX_T
 40

	)

27 
	#__SIZEOF_PTHREAD_MUTEXATTR_T
 4

	)

28 
	#__SIZEOF_PTHREAD_COND_T
 48

	)

29 
	#__SIZEOF_PTHREAD_CONDATTR_T
 4

	)

30 
	#__SIZEOF_PTHREAD_RWLOCK_T
 56

	)

31 
	#__SIZEOF_PTHREAD_RWLOCKATTR_T
 8

	)

32 
	#__SIZEOF_PTHREAD_BARRIER_T
 32

	)

33 
	#__SIZEOF_PTHREAD_BARRIERATTR_T
 4

	)

35 
	#__SIZEOF_PTHREAD_ATTR_T
 32

	)

36 
	#__SIZEOF_PTHREAD_MUTEX_T
 32

	)

37 
	#__SIZEOF_PTHREAD_MUTEXATTR_T
 4

	)

38 
	#__SIZEOF_PTHREAD_COND_T
 48

	)

39 
	#__SIZEOF_PTHREAD_CONDATTR_T
 4

	)

40 
	#__SIZEOF_PTHREAD_RWLOCK_T
 44

	)

41 
	#__SIZEOF_PTHREAD_RWLOCKATTR_T
 8

	)

42 
	#__SIZEOF_PTHREAD_BARRIER_T
 20

	)

43 
	#__SIZEOF_PTHREAD_BARRIERATTR_T
 4

	)

46 
	#__SIZEOF_PTHREAD_ATTR_T
 36

	)

47 
	#__SIZEOF_PTHREAD_MUTEX_T
 24

	)

48 
	#__SIZEOF_PTHREAD_MUTEXATTR_T
 4

	)

49 
	#__SIZEOF_PTHREAD_COND_T
 48

	)

50 
	#__SIZEOF_PTHREAD_CONDATTR_T
 4

	)

51 
	#__SIZEOF_PTHREAD_RWLOCK_T
 32

	)

52 
	#__SIZEOF_PTHREAD_RWLOCKATTR_T
 8

	)

53 
	#__SIZEOF_PTHREAD_BARRIER_T
 20

	)

54 
	#__SIZEOF_PTHREAD_BARRIERATTR_T
 4

	)

60 
	thad_t
;

63 
	uhad__t


65 
	m__size
[
__SIZEOF_PTHREAD_ATTR_T
];

66 
	m__ign
;

68 #ide
__have_had__t


69 
had__t
 
	thad__t
;

70 
	#__have_had__t
 1

	)

74 #ifde
__x86_64__


75 
	s__had__li


77 
__had__li
 *
	m__ev
;

78 
__had__li
 *
	m__xt
;

79 } 
	t__had_li_t
;

81 
	s__had__i


83 
__had__i
 *
	m__xt
;

84 } 
	t__had_i_t
;

92 
	s__had_mux_s


94 
	m__lock
;

95 
	m__cou
;

96 
	m__owr
;

97 #ifde
__x86_64__


98 
	m__nurs
;

102 
	m__kd
;

103 #ifde
__x86_64__


104 
	m__s
;

105 
	m__isi
;

106 
__had_li_t
 
	m__li
;

107 
	#__PTHREAD_MUTEX_HAVE_PREV
 1

	)

108 
	#__PTHREAD_MUTEX_HAVE_ELISION
 1

	)

110 
	m__nurs
;

111 
__exnsi__
 union

115 
	m__es
;

116 
	m__isi
;

117 
	#__s
 
d
.
__es


	)

118 
	#__isi
 
d
.
__isi


	)

119 
	#__PTHREAD_MUTEX_HAVE_ELISION
 2

	)

120 } 
	md
;

121 
__had_i_t
 
	m__li
;

124 } 
	m__da
;

125 
	m__size
[
__SIZEOF_PTHREAD_MUTEX_T
];

126 
	m__ign
;

127 } 
	thad_mux_t
;

131 
	m__size
[
__SIZEOF_PTHREAD_MUTEXATTR_T
];

132 
	m__ign
;

133 } 
	thad_mux_t
;

142 
	m__lock
;

143 
	m__fux
;

144 
__exnsi__
 
	m__tٮ_q
;

145 
__exnsi__
 
	m__wakeup_q
;

146 
__exnsi__
 
	m__wok_q
;

147 *
	m__mux
;

148 
	m__nwas
;

149 
	m__brd_q
;

150 } 
	m__da
;

151 
	m__size
[
__SIZEOF_PTHREAD_COND_T
];

152 
__exnsi__
 
	m__ign
;

153 } 
	thad_cd_t
;

157 
	m__size
[
__SIZEOF_PTHREAD_CONDATTR_T
];

158 
	m__ign
;

159 } 
	thad_cd_t
;

163 
	thad_key_t
;

167 
	thad__t
;

170 #i
defed
 
__USE_UNIX98
 || defed 
__USE_XOPEN2K


175 #ifde
__x86_64__


178 
	m__lock
;

179 
	m___ads
;

180 
	m__ads_wakeup
;

181 
	m__wr_wakeup
;

182 
	m___ads_queued
;

183 
	m___wrs_queued
;

184 
	m__wr
;

185 
	m__shed
;

186 
	m__d1
;

187 
	m__d2
;

190 
	m__ags
;

191 
	#__PTHREAD_RWLOCK_INT_FLAGS_SHARED
 1

	)

192 } 
	m__da
;

196 
	m__lock
;

197 
	m___ads
;

198 
	m__ads_wakeup
;

199 
	m__wr_wakeup
;

200 
	m___ads_queued
;

201 
	m___wrs_queued
;

204 
	m__ags
;

205 
	m__shed
;

206 
	m__d1
;

207 
	m__d2
;

208 
	m__wr
;

209 } 
	m__da
;

211 
	m__size
[
__SIZEOF_PTHREAD_RWLOCK_T
];

212 
	m__ign
;

213 } 
	thad_rwlock_t
;

217 
	m__size
[
__SIZEOF_PTHREAD_RWLOCKATTR_T
];

218 
	m__ign
;

219 } 
	thad_rwlock_t
;

223 #ifde
__USE_XOPEN2K


225 vީ
	thad_lock_t
;

232 
	m__size
[
__SIZEOF_PTHREAD_BARRIER_T
];

233 
	m__ign
;

234 } 
	thad_brr_t
;

238 
	m__size
[
__SIZEOF_PTHREAD_BARRIERATTR_T
];

239 
	m__ign
;

240 } 
	thad_brr_t
;

244 #ide
__x86_64__


246 
	#__nup_f_ibu
 
	`__ibu__
 ((
	`__grm__
 (1)))

	)

	@/usr/include/bits/stat.h

18 #i!
defed
 
_SYS_STAT_H
 && !defed 
_FCNTL_H


22 #ide
_BITS_STAT_H


23 
	#_BITS_STAT_H
 1

	)

26 #ide
__x86_64__


27 
	#_STAT_VER_LINUX_OLD
 1

	)

28 
	#_STAT_VER_KERNEL
 1

	)

29 
	#_STAT_VER_SVR4
 2

	)

30 
	#_STAT_VER_LINUX
 3

	)

33 
	#_MKNOD_VER_LINUX
 1

	)

34 
	#_MKNOD_VER_SVR4
 2

	)

35 
	#_MKNOD_VER
 
_MKNOD_VER_LINUX


	)

37 
	#_STAT_VER_KERNEL
 0

	)

38 
	#_STAT_VER_LINUX
 1

	)

41 
	#_MKNOD_VER_LINUX
 0

	)

44 
	#_STAT_VER
 
_STAT_VER_LINUX


	)

46 
	s


48 
__dev_t
 
	m_dev
;

49 #ide
__x86_64__


50 
	m__d1
;

52 #i
defed
 
__x86_64__
 || !defed 
__USE_FILE_OFFSET64


53 
__o_t
 
	m_o
;

55 
__o_t
 
	m___o
;

57 #ide
__x86_64__


58 
__mode_t
 
	m_mode
;

59 
__ƚk_t
 
	m_ƚk
;

61 
__ƚk_t
 
	m_ƚk
;

62 
__mode_t
 
	m_mode
;

64 
__uid_t
 
	m_uid
;

65 
__gid_t
 
	m_gid
;

66 #ifde
__x86_64__


67 
	m__d0
;

69 
__dev_t
 
	m_rdev
;

70 #ide
__x86_64__


71 
	m__d2
;

73 #i
defed
 
__x86_64__
 || !defed 
__USE_FILE_OFFSET64


74 
__off_t
 
	m_size
;

76 
__off64_t
 
	m_size
;

78 
__blksize_t
 
	m_blksize
;

79 #i
defed
 
__x86_64__
 || !defed 
__USE_FILE_OFFSET64


80 
__blkt_t
 
	m_blocks
;

82 
__blkt64_t
 
	m_blocks
;

84 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN2K8


91 
timeec
 
	m_im
;

92 
timeec
 
	m_mtim
;

93 
timeec
 
	m_im
;

94 
	#_ime
 
_im
.
tv_c


	)

95 
	#_mtime
 
_mtim
.
tv_c


	)

96 
	#_ime
 
_im
.
tv_c


	)

98 
__time_t
 
	m_ime
;

99 
__sys_ulg_t
 
	m_imc
;

100 
__time_t
 
	m_mtime
;

101 
__sys_ulg_t
 
	m_mtimc
;

102 
__time_t
 
	m_ime
;

103 
__sys_ulg_t
 
	m_imc
;

105 #ifde
__x86_64__


106 
__sys_g_t
 
	m__glibc_rved
[3];

108 #ide
__USE_FILE_OFFSET64


109 
	m__glibc_rved4
;

110 
	m__glibc_rved5
;

112 
__o64_t
 
	m_o
;

117 #ifde
__USE_LARGEFILE64


119 
	s64


121 
__dev_t
 
	m_dev
;

122 #ifde
__x86_64__


123 
__o64_t
 
	m_o
;

124 
__ƚk_t
 
	m_ƚk
;

125 
__mode_t
 
	m_mode
;

127 
	m__d1
;

128 
__o_t
 
	m___o
;

129 
__mode_t
 
	m_mode
;

130 
__ƚk_t
 
	m_ƚk
;

132 
__uid_t
 
	m_uid
;

133 
__gid_t
 
	m_gid
;

134 #ifde
__x86_64__


135 
	m__d0
;

136 
__dev_t
 
	m_rdev
;

137 
__off_t
 
	m_size
;

139 
__dev_t
 
	m_rdev
;

140 
	m__d2
;

141 
__off64_t
 
	m_size
;

143 
__blksize_t
 
	m_blksize
;

144 
__blkt64_t
 
	m_blocks
;

145 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN2K8


152 
timeec
 
	m_im
;

153 
timeec
 
	m_mtim
;

154 
timeec
 
	m_im
;

156 
__time_t
 
	m_ime
;

157 
__sys_ulg_t
 
	m_imc
;

158 
__time_t
 
	m_mtime
;

159 
__sys_ulg_t
 
	m_mtimc
;

160 
__time_t
 
	m_ime
;

161 
__sys_ulg_t
 
	m_imc
;

163 #ifde
__x86_64__


164 
__sys_g_t
 
	m__glibc_rved
[3];

166 
__o64_t
 
	m_o
;

172 
	#_STATBUF_ST_BLKSIZE


	)

173 
	#_STATBUF_ST_RDEV


	)

175 
	#_STATBUF_ST_NSEC


	)

179 
	#__S_IFMT
 0170000

	)

182 
	#__S_IFDIR
 0040000

	)

183 
	#__S_IFCHR
 0020000

	)

184 
	#__S_IFBLK
 0060000

	)

185 
	#__S_IFREG
 0100000

	)

186 
	#__S_IFIFO
 0010000

	)

187 
	#__S_IFLNK
 0120000

	)

188 
	#__S_IFSOCK
 0140000

	)

192 
	#__S_TYPEISMQ
(
buf
((buf)->
_mode
 - (buf)->_mode)

	)

193 
	#__S_TYPEISSEM
(
buf
((buf)->
_mode
 - (buf)->_mode)

	)

194 
	#__S_TYPEISSHM
(
buf
((buf)->
_mode
 - (buf)->_mode)

	)

198 
	#__S_ISUID
 04000

	)

199 
	#__S_ISGID
 02000

	)

200 
	#__S_ISVTX
 01000

	)

201 
	#__S_IREAD
 0400

	)

202 
	#__S_IWRITE
 0200

	)

203 
	#__S_IEXEC
 0100

	)

205 #ifde
__USE_ATFILE


206 
	#UTIME_NOW
 ((1<< 30- 1l)

	)

207 
	#UTIME_OMIT
 ((1<< 30- 2l)

	)

	@/usr/include/bits/stdio-ldbl.h

19 #ide
_STDIO_H


23 
__BEGIN_NAMESPACE_STD


24 
	$__LDBL_REDIR_DECL
 (
rtf
)

25 
	$__LDBL_REDIR_DECL
 (
tf
)

26 
	$__LDBL_REDIR_DECL
 (
rtf
)

27 
	$__LDBL_REDIR_DECL
 (
vrtf
)

28 
	$__LDBL_REDIR_DECL
 (
vtf
)

29 
	$__LDBL_REDIR_DECL
 (
vrtf
)

30 #i
defed
 
__USE_ISOC99
 && !defed 
__USE_GNU
 \

31 && !
defed
 
__REDIRECT
 \

32 && (
defed
 
__STRICT_ANSI__
 || defed 
__USE_XOPEN2K
)

33 
	$__LDBL_REDIR1_DECL
 (
fsnf
, 
__dbl___isoc99_fsnf
)

34 
	$__LDBL_REDIR1_DECL
 (
snf
, 
__dbl___isoc99_snf
)

35 
	$__LDBL_REDIR1_DECL
 (
ssnf
, 
__dbl___isoc99_ssnf
)

37 
	$__LDBL_REDIR_DECL
 (
fsnf
)

38 
	$__LDBL_REDIR_DECL
 (
snf
)

39 
	$__LDBL_REDIR_DECL
 (
ssnf
)

41 
__END_NAMESPACE_STD


43 #i
defed
 
__USE_BSD
 || defed 
__USE_ISOC99
 || defed 
__USE_UNIX98


44 
__BEGIN_NAMESPACE_C99


45 
	$__LDBL_REDIR_DECL
 (
tf
)

46 
	$__LDBL_REDIR_DECL
 (
vtf
)

47 
__END_NAMESPACE_C99


50 #ifdef 
__USE_ISOC99


51 
__BEGIN_NAMESPACE_C99


52 #i!
defed
 
__USE_GNU
 && !defed 
__REDIRECT
 \

53 && (
defed
 
__STRICT_ANSI__
 || defed 
__USE_XOPEN2K
)

54 
	$__LDBL_REDIR1_DECL
 (
vfsnf
, 
__dbl___isoc99_vfsnf
)

55 
	$__LDBL_REDIR1_DECL
 (
vsnf
, 
__dbl___isoc99_vsnf
)

56 
	$__LDBL_REDIR1_DECL
 (
vssnf
, 
__dbl___isoc99_vssnf
)

58 
	$__LDBL_REDIR_DECL
 (
vfsnf
)

59 
	$__LDBL_REDIR_DECL
 (
vssnf
)

60 
	$__LDBL_REDIR_DECL
 (
vsnf
)

62 
__END_NAMESPACE_C99


65 #ifde
__USE_XOPEN2K8


66 
	$__LDBL_REDIR_DECL
 (
vdtf
)

67 
	$__LDBL_REDIR_DECL
 (
dtf
)

70 #ifde
__USE_GNU


71 
	$__LDBL_REDIR_DECL
 (
vartf
)

72 
	$__LDBL_REDIR_DECL
 (
__artf
)

73 
	$__LDBL_REDIR_DECL
 (
artf
)

74 
	$__LDBL_REDIR_DECL
 (
oback_tf
)

75 
	$__LDBL_REDIR_DECL
 (
oback_vtf
)

78 #i
__USE_FORTIFY_LEVEL
 > 0 && 
defed
 
__ftify_funi


79 
	$__LDBL_REDIR_DECL
 (
__rtf_chk
)

80 
	$__LDBL_REDIR_DECL
 (
__vrtf_chk
)

81 #i
defed
 
__USE_BSD
 || defed 
__USE_ISOC99
 || defed 
__USE_UNIX98


82 
	$__LDBL_REDIR_DECL
 (
__tf_chk
)

83 
	$__LDBL_REDIR_DECL
 (
__vtf_chk
)

85 #i
__USE_FORTIFY_LEVEL
 > 1

86 
	$__LDBL_REDIR_DECL
 (
__rtf_chk
)

87 
	$__LDBL_REDIR_DECL
 (
__tf_chk
)

88 
	$__LDBL_REDIR_DECL
 (
__vrtf_chk
)

89 
	$__LDBL_REDIR_DECL
 (
__vtf_chk
)

90 #ifde
__USE_XOPEN2K8


91 
	$__LDBL_REDIR_DECL
 (
__dtf_chk
)

92 
	$__LDBL_REDIR_DECL
 (
__vdtf_chk
)

94 #ifde
__USE_GNU


95 
	$__LDBL_REDIR_DECL
 (
__artf_chk
)

96 
	$__LDBL_REDIR_DECL
 (
__vartf_chk
)

97 
	$__LDBL_REDIR_DECL
 (
__oback_tf_chk
)

98 
	$__LDBL_REDIR_DECL
 (
__oback_vtf_chk
)

	@/usr/include/bits/stdio.h

19 #ide
_STDIO_H


23 #ide
__ex_le


24 
	#__STDIO_INLINE
 
le


	)

26 
	#__STDIO_INLINE
 
__ex_le


	)

30 #ifde
__USE_EXTERN_INLINES


33 #i!(
__USE_FORTIFY_LEVEL
 > 0 && 
defed
 
__ftify_funi
)

35 
__STDIO_INLINE
 

36 
	$vtf
 (cڡ *
__ri
 
__fmt
, 
_G_va_li
 
__g
)

38  
	`vrtf
 (
dout
, 
__fmt
, 
__g
);

39 
	}
}

43 
__STDIO_INLINE
 

44 
	$gch
 ()

46  
	`_IO_gc
 (
d
);

47 
	}
}

50 #ifde
__USE_MISC


52 
__STDIO_INLINE
 

53 
	$fgc_uocked
 (
FILE
 *
__
)

55  
	`_IO_gc_uocked
 (
__
);

56 
	}
}

60 #i
defed
 
__USE_POSIX
 || defed 
__USE_MISC


62 
__STDIO_INLINE
 

63 
	$gc_uocked
 (
FILE
 *
__
)

65  
	`_IO_gc_uocked
 (
__
);

66 
	}
}

69 
__STDIO_INLINE
 

70 
	$gch_uocked
 ()

72  
	`_IO_gc_uocked
 (
d
);

73 
	}
}

78 
__STDIO_INLINE
 

79 
	$putch
 (
__c
)

81  
	`_IO_putc
 (
__c
, 
dout
);

82 
	}
}

85 #ifde
__USE_MISC


87 
__STDIO_INLINE
 

88 
	$utc_uocked
 (
__c
, 
FILE
 *
__am
)

90  
	`_IO_putc_uocked
 (
__c
, 
__am
);

91 
	}
}

95 #i
defed
 
__USE_POSIX
 || defed 
__USE_MISC


97 
__STDIO_INLINE
 

98 
	$putc_uocked
 (
__c
, 
FILE
 *
__am
)

100  
	`_IO_putc_uocked
 (
__c
, 
__am
);

101 
	}
}

104 
__STDIO_INLINE
 

105 
	$putch_uocked
 (
__c
)

107  
	`_IO_putc_uocked
 (
__c
, 
dout
);

108 
	}
}

112 #ifdef 
__USE_GNU


114 
__STDIO_INLINE
 
_IO_ssize_t


115 
	$gle
 (**
__l
, 
size_t
 *
__n
, 
FILE
 *
__am
)

117  
	`__gdim
 (
__l
, 
__n
, '\n', 
__am
);

118 
	}
}

122 #ifde
__USE_MISC


124 
__STDIO_INLINE
 

125 
__NTH
 (
	$of_uocked
 (
FILE
 *
__am
))

127  
	`_IO_of_uocked
 (
__am
);

128 
	}
}

131 
__STDIO_INLINE
 

132 
__NTH
 (
	$_uocked
 (
FILE
 *
__am
))

134  
	`_IO__uocked
 (
__am
);

135 
	}
}

141 #i
defed
 
__USE_MISC
 && defed 
__GNUC__
 && defed 
__OPTIMIZE__
 \

142 && !
defed
 
	g__lulus


144 
	#d_uocked
(
r
, 
size
, 
n
, 
am
) \

145 (
	`__exnsi__
 ((
	`__but_cڡt_p
 (
size
&& __but_cڡt_(
n
) \

146 && (
size_t
(
size
* (size_t(
n
) <= 8 \

147 && (
size_t
(
size
) != 0) \

148 ? ({ *
__r
 = (*(
r
); \

149 
FILE
 *
__am
 = (
am
); \

150 
size_t
 
__t
; \

151 
__t
 = (
size_t
(
size
* (size_t(
n
); \

152 
__t
 > 0; --__cnt) \

154 
__c
 = 
	`_IO_gc_uocked
 (
__am
); \

155 i(
__c
 =
EOF
) \

157 *
__r
++ = 
__c
; \

159 ((
size_t
(
size
* (size_t(
n
- 
__t
) \

160 / (
size_t
(
size
); }) \

161 : (((
	`__but_cڡt_p
 (
size
&& (
size_t
) (size) == 0) \

162 || (
	`__but_cڡt_p
 (
n
&& (
size_t
) (n) == 0)) \

164 ? (((
r
), ((
am
), ((
size
), \

165 ((
n
), (
size_t
) 0) \

166 : 
	`d_uocked
 (
r
, 
size
, 
n
, 
am
))))

	)

168 
	#fwre_uocked
(
r
, 
size
, 
n
, 
am
) \

169 (
	`__exnsi__
 ((
	`__but_cڡt_p
 (
size
&& __but_cڡt_(
n
) \

170 && (
size_t
(
size
* (size_t(
n
) <= 8 \

171 && (
size_t
(
size
) != 0) \

172 ? ({ cڡ *
__r
 = (cڡ *(
r
); \

173 
FILE
 *
__am
 = (
am
); \

174 
size_t
 
__t
; \

175 
__t
 = (
size_t
(
size
* (size_t(
n
); \

176 
__t
 > 0; --__cnt) \

177 i(
	`_IO_putc_uocked
 (*
__r
++, 
__am
=
EOF
) \

179 ((
size_t
(
size
* (size_t(
n
- 
__t
) \

180 / (
size_t
(
size
); }) \

181 : (((
	`__but_cڡt_p
 (
size
&& (
size_t
) (size) == 0) \

182 || (
	`__but_cڡt_p
 (
n
&& (
size_t
) (n) == 0)) \

184 ? (((
r
), ((
am
), ((
size
), \

185 ((
n
), (
size_t
) 0) \

186 : 
	`fwre_uocked
 (
r
, 
size
, 
n
, 
am
))))

	)

190 #unde
__STDIO_INLINE


	@/usr/include/bits/stdio2.h

19 #ide
_STDIO_H


23 
	$__rtf_chk
 (*
__ri
 
__s
, 
__ag
, 
size_t
 
__
,

24 cڡ *
__ri
 
__fm
, ...
__THROW
;

25 
	$__vrtf_chk
 (*
__ri
 
__s
, 
__ag
, 
size_t
 
__
,

26 cڡ *
__ri
 
__fm
,

27 
_G_va_li
 
__

__THROW
;

29 #ifde
__va_g_ck


30 
__ftify_funi
 

31 
	`__NTH
 (
	$rtf
 (*
__ri
 
__s
, cڡ *__ri 
__fmt
, ...))

33  
	`__but___rtf_chk
 (
__s
, 
__USE_FORTIFY_LEVEL
 - 1,

34 
	`__bos
 (
__s
), 
__fmt
, 
	`__va_g_ck
 ());

35 
	}
}

36 #i!
defed
 
__lulus


37 
	#rtf
(
r
, ...) \

38 
	`__but___rtf_chk
 (
r
, 
__USE_FORTIFY_LEVEL
 - 1, 
	`__bos
 (str), \

39 
__VA_ARGS__
)

	)

42 
__ftify_funi
 

43 
__NTH
 (
	$vrtf
 (*
__ri
 
__s
, cڡ *__ri 
__fmt
,

44 
_G_va_li
 
__
))

46  
	`__but___vrtf_chk
 (
__s
, 
__USE_FORTIFY_LEVEL
 - 1,

47 
	`__bos
 (
__s
), 
__fmt
, 
__
);

48 
	}
}

50 #i
defed
 
__USE_BSD
 || defed 
__USE_ISOC99
 || defed 
__USE_UNIX98


52 
	$__tf_chk
 (*
__ri
 
__s
, 
size_t
 
__n
, 
__ag
,

53 
size_t
 
__
, cڡ *
__ri
 
__fm
,

54 ...
__THROW
;

55 
	$__vtf_chk
 (*
__ri
 
__s
, 
size_t
 
__n
, 
__ag
,

56 
size_t
 
__
, cڡ *
__ri
 
__fm
,

57 
_G_va_li
 
__

__THROW
;

59 #ifde
__va_g_ck


60 
__ftify_funi
 

61 
	`__NTH
 (
	$tf
 (*
__ri
 
__s
, 
size_t
 
__n
,

62 cڡ *
__ri
 
__fmt
, ...))

64  
	`__but___tf_chk
 (
__s
, 
__n
, 
__USE_FORTIFY_LEVEL
 - 1,

65 
	`__bos
 (
__s
), 
__fmt
, 
	`__va_g_ck
 ());

66 
	}
}

67 #i!
defed
 
__lulus


68 
	#tf
(
r
, 
n
, ...) \

69 
	`__but___tf_chk
 (
r
, 
n
, 
__USE_FORTIFY_LEVEL
 - 1, 
	`__bos
 (str), \

70 
__VA_ARGS__
)

	)

73 
__ftify_funi
 

74 
__NTH
 (
	$vtf
 (*
__ri
 
__s
, 
size_t
 
__n
,

75 cڡ *
__ri
 
__fmt
, 
_G_va_li
 
__
))

77  
	`__but___vtf_chk
 (
__s
, 
__n
, 
__USE_FORTIFY_LEVEL
 - 1,

78 
	`__bos
 (
__s
), 
__fmt
, 
__
);

79 
	}
}

83 #i
__USE_FORTIFY_LEVEL
 > 1

85 
__rtf_chk
 (
FILE
 *
__ri
 
__am
, 
__ag
,

86 cڡ *
__ri
 
__fm
, ...);

87 
__tf_chk
 (
__ag
, cڡ *
__ri
 
__fm
, ...);

88 
__vrtf_chk
 (
FILE
 *
__ri
 
__am
, 
__ag
,

89 cڡ *
__ri
 
__fm
, 
_G_va_li
 
__
);

90 
__vtf_chk
 (
__ag
, cڡ *
__ri
 
__fm
,

91 
_G_va_li
 
__
);

93 #ifde
__va_g_ck


94 
__ftify_funi
 

95 
	$rtf
 (
FILE
 *
__ri
 
__am
, cڡ *__ri 
__fmt
, ...)

97  
	`__rtf_chk
 (
__am
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
,

98 
	`__va_g_ck
 ());

99 
	}
}

101 
__ftify_funi
 

102 
	$tf
 (cڡ *
__ri
 
__fmt
, ...)

104  
	`__tf_chk
 (
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
, 
	`__va_g_ck
 ());

105 
	}
}

106 #i!
defed
 
__lulus


107 
	#tf
(...) \

108 
	`__tf_chk
 (
__USE_FORTIFY_LEVEL
 - 1, 
__VA_ARGS__
)

	)

109 
	#rtf
(
am
, ...) \

110 
	`__rtf_chk
 (
am
, 
__USE_FORTIFY_LEVEL
 - 1, 
__VA_ARGS__
)

	)

113 
__ftify_funi
 

114 
	$vtf
 (cڡ *
__ri
 
__fmt
, 
_G_va_li
 
__
)

116 #ifde
__USE_EXTERN_INLINES


117  
	`__vrtf_chk
 (
dout
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
, 
__
);

119  
	`__vtf_chk
 (
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
, 
__
);

121 
	}
}

123 
__ftify_funi
 

124 
	$vrtf
 (
FILE
 *
__ri
 
__am
,

125 cڡ *
__ri
 
__fmt
, 
_G_va_li
 
__
)

127  
	`__vrtf_chk
 (
__am
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
, 
__
);

128 
	}
}

130 #ifde
__USE_XOPEN2K8


131 
	$__dtf_chk
 (
__fd
, 
__ag
, cڡ *
__ri
 
__fmt
,

132 ...
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 3, 4)));

133 
	$__vdtf_chk
 (
__fd
, 
__ag
,

134 cڡ *
__ri
 
__fmt
, 
_G_va_li
 
__g
)

135 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 3, 0)));

137 #ifde
__va_g_ck


138 
__ftify_funi
 

139 
	$dtf
 (
__fd
, cڡ *
__ri
 
__fmt
, ...)

141  
	`__dtf_chk
 (
__fd
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
,

142 
	`__va_g_ck
 ());

143 
	}
}

144 #i!
defed
 
__lulus


145 
	#dtf
(
fd
, ...) \

146 
	`__dtf_chk
 (
fd
, 
__USE_FORTIFY_LEVEL
 - 1, 
__VA_ARGS__
)

	)

149 
__ftify_funi
 

150 
	$vdtf
 (
__fd
, cڡ *
__ri
 
__fmt
, 
_G_va_li
 
__
)

152  
	`__vdtf_chk
 (
__fd
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
, 
__
);

153 
	}
}

156 #ifde
__USE_GNU


158 
	$__artf_chk
 (**
__ri
 
__r
, 
__ag
,

159 cڡ *
__ri
 
__fmt
, ...)

160 
__THROW
 
	`__ibu__
 ((
	$__fm__
 (
__tf__
, 3, 4))
__wur
;

161 
	$__vartf_chk
 (**
__ri
 
__r
, 
__ag
,

162 cڡ *
__ri
 
__fmt
, 
_G_va_li
 
__g
)

163 
__THROW
 
	`__ibu__
 ((
	$__fm__
 (
__tf__
, 3, 0))
__wur
;

164 
	$__oback_tf_chk
 (
oback
 *
__ri
 
__oback
,

165 
__ag
, cڡ *
__ri
 
__fm
,

167 
__THROW
 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 3, 4)));

168 
	$__oback_vtf_chk
 (
oback
 *
__ri
 
__oback
,

169 
__ag
,

170 cڡ *
__ri
 
__fm
,

171 
_G_va_li
 
__gs
)

172 
__THROW
 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 3, 0)));

174 #ifde
__va_g_ck


175 
__ftify_funi
 

176 
	`__NTH
 (
	$artf
 (**
__ri
 
__r
, cڡ *__ri 
__fmt
, ...))

178  
	`__artf_chk
 (
__r
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
,

179 
	`__va_g_ck
 ());

180 
	}
}

182 
__ftify_funi
 

183 
__NTH
 (
	$__artf
 (**
__ri
 
__r
, cڡ *__ri 
__fmt
,

186  
	`__artf_chk
 (
__r
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
,

187 
	`__va_g_ck
 ());

188 
	}
}

190 
__ftify_funi
 

191 
__NTH
 (
	$oback_tf
 (
oback
 *
__ri
 
__oback
,

192 cڡ *
__ri
 
__fmt
, ...))

194  
	`__oback_tf_chk
 (
__oback
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
,

195 
	`__va_g_ck
 ());

196 
	}
}

197 #i!
defed
 
__lulus


198 
	#artf
(
r
, ...) \

199 
	`__artf_chk
 (
r
, 
__USE_FORTIFY_LEVEL
 - 1, 
__VA_ARGS__
)

	)

200 
	#__artf
(
r
, ...) \

201 
	`__artf_chk
 (
r
, 
__USE_FORTIFY_LEVEL
 - 1, 
__VA_ARGS__
)

	)

202 
	#oback_tf
(
oback
, ...) \

203 
	`__oback_tf_chk
 (
oback
, 
__USE_FORTIFY_LEVEL
 - 1, 
__VA_ARGS__
)

	)

206 
__ftify_funi
 

207 
__NTH
 (
	$vartf
 (**
__ri
 
__r
, cڡ *__ri 
__fmt
,

208 
_G_va_li
 
__
))

210  
	`__vartf_chk
 (
__r
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
, 
__
);

211 
	}
}

213 
__ftify_funi
 

214 
__NTH
 (
	$oback_vtf
 (
oback
 *
__ri
 
__oback
,

215 cڡ *
__ri
 
__fmt
, 
_G_va_li
 
__
))

217  
	`__oback_vtf_chk
 (
__oback
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
,

218 
__
);

219 
	}
}

225 #i!
defed
 
__USE_ISOC11
 \

226 || (
defed
 
	g__lulus
 && __lulu<201103L && !defed 
__USE_GNU
)

227 *
	$__gs_chk
 (*
__r
, 
size_t

__wur
;

228 *
	`__REDIRECT
 (
__gs_wn
, (*
__r
), 
gs
)

229 
__wur
 
	`__wǉr
 ("please use fgets or getline instead, gets can't "

232 
__ftify_funi
 
__wur
 *

233 
	$gs
 (*
__r
)

235 i(
	`__bos
 (
__r
!(
size_t
) -1)

236  
	`__gs_chk
 (
__r
, 
	`__bos
 (__str));

237  
	`__gs_wn
 (
__r
);

238 
	}
}

241 *
	$__fgs_chk
 (*
__ri
 
__s
, 
size_t
 
__size
, 
__n
,

242 
FILE
 *
__ri
 
__am

__wur
;

243 *
	`__REDIRECT
 (
__fgs_s
,

244 (*
__ri
 
__s
, 
__n
,

245 
FILE
 *
__ri
 
__am
), 
fgs

__wur
;

246 *
	`__REDIRECT
 (
__fgs_chk_wn
,

247 (*
__ri
 
__s
, 
size_t
 
__size
, 
__n
,

248 
FILE
 *
__ri
 
__am
), 
__fgs_chk
)

249 
__wur
 
	`__wǉr
 ("fgets called with bigger sizehanength "

252 
__ftify_funi
 
__wur
 *

253 
	$fgs
 (*
__ri
 
__s
, 
__n
, 
FILE
 *__ri 
__am
)

255 i(
	`__bos
 (
__s
!(
size_t
) -1)

257 i(!
	`__but_cڡt_p
 (
__n
) || __n <= 0)

258  
	`__fgs_chk
 (
__s
, 
	`__bos
 (__s), 
__n
, 
__am
);

260 i((
size_t

__n
 > 
	`__bos
 (
__s
))

261  
	`__fgs_chk_wn
 (
__s
, 
	`__bos
 (__s), 
__n
, 
__am
);

263  
	`__fgs_s
 (
__s
, 
__n
, 
__am
);

264 
	}
}

266 
size_t
 
	$__d_chk
 (*
__ri
 
__r
, 
size_t
 
__
,

267 
size_t
 
__size
, size_
__n
,

268 
FILE
 *
__ri
 
__am

__wur
;

269 
size_t
 
	`__REDIRECT
 (
__d_s
,

270 (*
__ri
 
__r
, 
size_t
 
__size
,

271 
size_t
 
__n
, 
FILE
 *
__ri
 
__am
),

272 
d

__wur
;

273 
size_t
 
	`__REDIRECT
 (
__d_chk_wn
,

274 (*
__ri
 
__r
, 
size_t
 
__
,

275 
size_t
 
__size
, size_
__n
,

276 
FILE
 *
__ri
 
__am
),

277 
__d_chk
)

278 
__wur
 
	`__wǉr
 ("fread called with bigger size *membhanength "

281 
__ftify_funi
 
__wur
 
size_t


282 
	$d
 (*
__ri
 
__r
, 
size_t
 
__size
, size_
__n
,

283 
FILE
 *
__ri
 
__am
)

285 i(
	`__bos0
 (
__r
!(
size_t
) -1)

287 i(!
	`__but_cڡt_p
 (
__size
)

288 || !
	`__but_cڡt_p
 (
__n
)

289 || (
__size
 | 
__n
>(((
size_t
) 1) << (8 *  (size_t) / 2)))

290  
	`__d_chk
 (
__r
, 
	`__bos0
 (__r), 
__size
, 
__n
, 
__am
);

292 i(
__size
 * 
__n
 > 
	`__bos0
 (
__r
))

293  
	`__d_chk_wn
 (
__r
, 
	`__bos0
 (__r), 
__size
, 
__n
, 
__am
);

295  
	`__d_s
 (
__r
, 
__size
, 
__n
, 
__am
);

296 
	}
}

298 #ifde
__USE_GNU


299 *
	$__fgs_uocked_chk
 (*
__ri
 
__s
, 
size_t
 
__size
,

300 
__n
, 
FILE
 *
__ri
 
__am

__wur
;

301 *
	`__REDIRECT
 (
__fgs_uocked_s
,

302 (*
__ri
 
__s
, 
__n
,

303 
FILE
 *
__ri
 
__am
), 
fgs_uocked

__wur
;

304 *
	`__REDIRECT
 (
__fgs_uocked_chk_wn
,

305 (*
__ri
 
__s
, 
size_t
 
__size
, 
__n
,

306 
FILE
 *
__ri
 
__am
), 
__fgs_uocked_chk
)

307 
__wur
 
	`__wǉr
 ("fgets_unlocked called with bigger sizehanength "

310 
__ftify_funi
 
__wur
 *

311 
	$fgs_uocked
 (*
__ri
 
__s
, 
__n
, 
FILE
 *__ri 
__am
)

313 i(
	`__bos
 (
__s
!(
size_t
) -1)

315 i(!
	`__but_cڡt_p
 (
__n
) || __n <= 0)

316  
	`__fgs_uocked_chk
 (
__s
, 
	`__bos
 (__s), 
__n
, 
__am
);

318 i((
size_t

__n
 > 
	`__bos
 (
__s
))

319  
	`__fgs_uocked_chk_wn
 (
__s
, 
	`__bos
 (__s), 
__n
, 
__am
);

321  
	`__fgs_uocked_s
 (
__s
, 
__n
, 
__am
);

322 
	}
}

325 #ifde
__USE_MISC


326 #unde
d_uocked


327 
size_t
 
	$__d_uocked_chk
 (*
__ri
 
__r
, 
size_t
 
__
,

328 
size_t
 
__size
, size_
__n
,

329 
FILE
 *
__ri
 
__am

__wur
;

330 
size_t
 
	`__REDIRECT
 (
__d_uocked_s
,

331 (*
__ri
 
__r
, 
size_t
 
__size
,

332 
size_t
 
__n
, 
FILE
 *
__ri
 
__am
),

333 
d_uocked

__wur
;

334 
size_t
 
	`__REDIRECT
 (
__d_uocked_chk_wn
,

335 (*
__ri
 
__r
, 
size_t
 
__
,

336 
size_t
 
__size
, size_
__n
,

337 
FILE
 *
__ri
 
__am
),

338 
__d_uocked_chk
)

339 
__wur
 
	`__wǉr
 ("fread_unlocked called with bigger size *membhan "

342 
__ftify_funi
 
__wur
 
size_t


343 
	$d_uocked
 (*
__ri
 
__r
, 
size_t
 
__size
, size_
__n
,

344 
FILE
 *
__ri
 
__am
)

346 i(
	`__bos0
 (
__r
!(
size_t
) -1)

348 i(!
	`__but_cڡt_p
 (
__size
)

349 || !
	`__but_cڡt_p
 (
__n
)

350 || (
__size
 | 
__n
>(((
size_t
) 1) << (8 *  (size_t) / 2)))

351  
	`__d_uocked_chk
 (
__r
, 
	`__bos0
 (__r), 
__size
, 
__n
,

352 
__am
);

354 i(
__size
 * 
__n
 > 
	`__bos0
 (
__r
))

355  
	`__d_uocked_chk_wn
 (
__r
, 
	`__bos0
 (__r), 
__size
, 
__n
,

356 
__am
);

359 #ifde
__USE_EXTERN_INLINES


360 i(
	`__but_cڡt_p
 (
__size
)

361 && 
	`__but_cڡt_p
 (
__n
)

362 && (
__size
 | 
__n
< (((
size_t
) 1) << (8 *  (size_t) / 2))

363 && 
__size
 * 
__n
 <= 8)

365 
size_t
 
__t
 = 
__size
 * 
__n
;

366 *
__
 = (*
__r
;

367 i(
__t
 == 0)

370 ; 
__t
 > 0; --__cnt)

372 
__c
 = 
	`_IO_gc_uocked
 (
__am
);

373 i(
__c
 =
EOF
)

375 *
__
++ = 
__c
;

377  (
__
 - (*
__r
/ 
__size
;

380  
	`__d_uocked_s
 (
__r
, 
__size
, 
__n
, 
__am
);

381 
	}
}

	@/usr/include/bits/stdio_lim.h

18 #i!
defed
 
_STDIO_H
 && !defed 
__ed_FOPEN_MAX
 && !defed 
__ed_IOV_MAX


22 #ifde
_STDIO_H


23 
	#L_tmam
 20

	)

24 
	#TMP_MAX
 238328

	)

25 
	#FILENAME_MAX
 4096

	)

27 #ifde
__USE_POSIX


28 
	#L_mid
 9

	)

29 #i!
defed
 
__USE_XOPEN2K
 || defed 
__USE_GNU


30 
	#L_curid
 9

	)

35 #i
defed
 
__ed_FOPEN_MAX
 || defed 
_STDIO_H


36 #unde
FOPEN_MAX


37 
	#FOPEN_MAX
 16

	)

40 #i
defed
 
__ed_IOV_MAX
 && !defed 
IOV_MAX


41 
	#IOV_MAX
 1024

	)

	@/usr/include/bits/stdlib-bsearch.h

19 
__ex_le
 *

20 
	$bch
 (cڡ *
__key
, cڡ *
__ba
, 
size_t
 
__nmemb
, size_
__size
,

21 
__comr__t
 
__comr
)

23 
size_t
 
__l
, 
__u
, 
__idx
;

24 cڡ *
__p
;

25 
__comris
;

27 
__l
 = 0;

28 
__u
 = 
__nmemb
;

29 
__l
 < 
__u
)

31 
__idx
 = (
__l
 + 
__u
) / 2;

32 
__p
 = (*(((cڡ *
__ba
+ (
__idx
 * 
__size
));

33 
__comris
 = (*
__comr
(
__key
, 
__p
);

34 i(
__comris
 < 0)

35 
__u
 = 
__idx
;

36 i(
__comris
 > 0)

37 
__l
 = 
__idx
 + 1;

39  (*
__p
;

42  
NULL
;

43 
	}
}

	@/usr/include/bits/stdlib-float.h

19 #ide
_STDLIB_H


23 #ifde
__USE_EXTERN_INLINES


24 
__BEGIN_NAMESPACE_STD


25 
__ex_le
 

26 
__NTH
 (
	$of
 (cڡ *
__Ō
))

28  
	`od
 (
__Ō
, (**
NULL
);

29 
	}
}

30 
	g__END_NAMESPACE_STD


	@/usr/include/bits/stdlib-ldbl.h

19 #ide
_STDLIB_H


23 #ifdef 
__USE_ISOC99


24 
__BEGIN_NAMESPACE_C99


25 
	$__LDBL_REDIR1_DECL
 (
d
, 
od
)

26 
__END_NAMESPACE_C99


29 #ifde
__USE_GNU


30 
	$__LDBL_REDIR1_DECL
 (
d_l
, 
od_l
)

33 #ifde
__USE_MISC


34 
	$__LDBL_REDIR1_DECL
 (
qecvt
, 
ecvt
)

35 
	$__LDBL_REDIR1_DECL
 (
qfcvt
, 
fcvt
)

36 
	$__LDBL_REDIR1_DECL
 (
qgcvt
, 
gcvt
)

37 
	$__LDBL_REDIR1_DECL
 (
qecvt_r
, 
ecvt_r
)

38 
	$__LDBL_REDIR1_DECL
 (
qfcvt_r
, 
fcvt_r
)

	@/usr/include/bits/stdlib.h

19 #ide
_STDLIB_H


23 *
	$__th_chk
 (cڡ *
__ri
 
__me
,

24 *
__ri
 
__sved
,

25 
size_t
 
__svedn

__THROW
 
__wur
;

26 *
	`__REDIRECT_NTH
 (
__th_s
,

27 (cڡ *
__ri
 
__me
,

28 *
__ri
 
__sved
), 
th

__wur
;

29 *
	`__REDIRECT_NTH
 (
__th_chk_wn
,

30 (cڡ *
__ri
 
__me
,

31 *
__ri
 
__sved
,

32 
size_t
 
__svedn
), 
__th_chk

__wur


33 
	`__wǉr
 ("secondrgument ofealpath must beither NULL ort "

36 
__ftify_funi
 
__wur
 *

37 
	`__NTH
 (
	$th
 (cڡ *
__ri
 
__me
, *__ri 
__sved
))

39 i(
	`__bos
 (
__sved
!(
size_t
) -1)

41 #i
defed
 
_LIBC_LIMITS_H_
 && defed 
PATH_MAX


42 i(
	`__bos
 (
__sved
< 
PATH_MAX
)

43  
	`__th_chk_wn
 (
__me
, 
__sved
, 
	`__bos
 (__resolved));

45  
	`__th_chk
 (
__me
, 
__sved
, 
	`__bos
 (__resolved));

48  
	`__th_s
 (
__me
, 
__sved
);

49 
	}
}

52 
	$__ame_r_chk
 (
__fd
, *
__buf
, 
size_t
 
__bu
,

53 
size_t
 
__ėl

__THROW
 
	`__nnu
 ((2));

54 
	`__REDIRECT_NTH
 (
__ame_r_s
, (
__fd
, *
__buf
,

55 
size_t
 
__bu
), 
ame_r
)

56 
	`__nnu
 ((2));

57 
	`__REDIRECT_NTH
 (
__ame_r_chk_wn
,

58 (
__fd
, *
__buf
, 
size_t
 
__bu
,

59 
size_t
 
__ėl
), 
__ame_r_chk
)

60 
	`__nnu
 ((2)
	`__wǉr
 ("ptsname_r called with buflen biggerhan "

63 
__ftify_funi
 

64 
	`__NTH
 (
	$ame_r
 (
__fd
, *
__buf
, 
size_t
 
__bu
))

66 i(
	`__bos
 (
__buf
!(
size_t
) -1)

68 i(!
	`__but_cڡt_p
 (
__bu
))

69  
	`__ame_r_chk
 (
__fd
, 
__buf
, 
__bu
, 
	`__bos
 (__buf));

70 i(
__bu
 > 
	`__bos
 (
__buf
))

71  
	`__ame_r_chk_wn
 (
__fd
, 
__buf
, 
__bu
, 
	`__bos
 (__buf));

73  
	`__ame_r_s
 (
__fd
, 
__buf
, 
__bu
);

74 
	}
}

77 
	$__womb_chk
 (*
__s
, 
wch_t
 
__wch
, 
size_t
 
__bu
)

78 
__THROW
 
__wur
;

79 
	`__REDIRECT_NTH
 (
__womb_s
, (*
__s
, 
wch_t
 
__wch
),

80 
womb

__wur
;

82 
__ftify_funi
 
__wur
 

83 
	`__NTH
 (
	$womb
 (*
__s
, 
wch_t
 
__wch
))

88 
	#__STDLIB_MB_LEN_MAX
 16

	)

89 #i
defed
 
MB_LEN_MAX
 && MB_LEN_MAX !
__STDLIB_MB_LEN_MAX


92 i(
	`__bos
 (
__s
!(
size_t
-1 && 
__STDLIB_MB_LEN_MAX
 > __bos (__s))

93  
	`__womb_chk
 (
__s
, 
__wch
, 
	`__bos
 (__s));

94  
	`__womb_s
 (
__s
, 
__wch
);

95 
	}
}

98 
size_t
 
	$__mbowcs_chk
 (
wch_t
 *
__ri
 
__d
,

99 cڡ *
__ri
 
__c
,

100 
size_t
 
__n
, size_
__dn

__THROW
;

101 
size_t
 
	`__REDIRECT_NTH
 (
__mbowcs_s
,

102 (
wch_t
 *
__ri
 
__d
,

103 cڡ *
__ri
 
__c
,

104 
size_t
 
__n
), 
mbowcs
);

105 
size_t
 
	`__REDIRECT_NTH
 (
__mbowcs_chk_wn
,

106 (
wch_t
 *
__ri
 
__d
,

107 cڡ *
__ri
 
__c
,

108 
size_t
 
__n
, size_
__dn
), 
__mbowcs_chk
)

109 
	`__wǉr
 ("mbstowcs called with dst buffer smallerhanen "

112 
__ftify_funi
 
size_t


113 
	`__NTH
 (
	$mbowcs
 (
wch_t
 *
__ri
 
__d
, cڡ *__ri 
__c
,

114 
size_t
 
__n
))

116 i(
	`__bos
 (
__d
!(
size_t
) -1)

118 i(!
	`__but_cڡt_p
 (
__n
))

119  
	`__mbowcs_chk
 (
__d
, 
__c
, 
__n
,

120 
	`__bos
 (
__d
/  (
wch_t
));

122 i(
__n
 > 
	`__bos
 (
__d
/  (
wch_t
))

123  
	`__mbowcs_chk_wn
 (
__d
, 
__c
, 
__n
,

124 
	`__bos
 (
__d
/  (
wch_t
));

126  
	`__mbowcs_s
 (
__d
, 
__c
, 
__n
);

127 
	}
}

130 
size_t
 
	$__wcombs_chk
 (*
__ri
 
__d
,

131 cڡ 
wch_t
 *
__ri
 
__c
,

132 
size_t
 
__n
, size_
__dn

__THROW
;

133 
size_t
 
	`__REDIRECT_NTH
 (
__wcombs_s
,

134 (*
__ri
 
__d
,

135 cڡ 
wch_t
 *
__ri
 
__c
,

136 
size_t
 
__n
), 
wcombs
);

137 
size_t
 
	`__REDIRECT_NTH
 (
__wcombs_chk_wn
,

138 (*
__ri
 
__d
,

139 cڡ 
wch_t
 *
__ri
 
__c
,

140 
size_t
 
__n
, size_
__dn
), 
__wcombs_chk
)

141 
	`__wǉr
 ("wcstombs called with dst buffer smallerhanen");

143 
__ftify_funi
 
size_t


144 
	`__NTH
 (
	$wcombs
 (*
__ri
 
__d
, cڡ 
wch_t
 *__ri 
__c
,

145 
size_t
 
__n
))

147 i(
	`__bos
 (
__d
!(
size_t
) -1)

149 i(!
	`__but_cڡt_p
 (
__n
))

150  
	`__wcombs_chk
 (
__d
, 
__c
, 
__n
, 
	`__bos
 (__dst));

151 i(
__n
 > 
	`__bos
 (
__d
))

152  
	`__wcombs_chk_wn
 (
__d
, 
__c
, 
__n
, 
	`__bos
 (__dst));

154  
	`__wcombs_s
 (
__d
, 
__c
, 
__n
);

155 
	}
}

	@/usr/include/bits/sys_errlist.h

19 #ide
_STDIO_H


25 #ifde 
__USE_BSD


26 
sys_ü
;

27 cڡ *cڡ 
sys_i
[];

29 #ifde 
__USE_GNU


30 
_sys_ü
;

31 cڡ *cڡ 
_sys_i
[];

	@/usr/include/bits/types.h

23 #idef 
_BITS_TYPES_H


24 
	#_BITS_TYPES_H
 1

	)

26 
	~<us.h
>

27 
	~<bs/wdsize.h
>

30 
	t__u_ch
;

31 
	t__u_sht
;

32 
	t__u_t
;

33 
	t__u_lg
;

36 sigd 
	t__t8_t
;

37 
	t__ut8_t
;

38 sigd 
	t__t16_t
;

39 
	t__ut16_t
;

40 sigd 
	t__t32_t
;

41 
	t__ut32_t
;

42 #i
__WORDSIZE
 == 64

43 sigd 
	t__t64_t
;

44 
	t__ut64_t
;

46 
__exnsi__
 sigd 
	t__t64_t
;

47 
__exnsi__
 
	t__ut64_t
;

51 #i
__WORDSIZE
 == 64

52 
	t__quad_t
;

53 
	t__u_quad_t
;

55 
__exnsi__
 
	t__quad_t
;

56 
__exnsi__
 
	t__u_quad_t
;

89 
	#__S16_TYPE
 

	)

90 
	#__U16_TYPE
 

	)

91 
	#__S32_TYPE
 

	)

92 
	#__U32_TYPE
 

	)

93 
	#__SLONGWORD_TYPE
 

	)

94 
	#__ULONGWORD_TYPE
 

	)

95 #i
__WORDSIZE
 == 32

96 
	#__SQUAD_TYPE
 
__quad_t


	)

97 
	#__UQUAD_TYPE
 
__u_quad_t


	)

98 
	#__SWORD_TYPE
 

	)

99 
	#__UWORD_TYPE
 

	)

100 
	#__SLONG32_TYPE
 

	)

101 
	#__ULONG32_TYPE
 

	)

102 
	#__S64_TYPE
 
__quad_t


	)

103 
	#__U64_TYPE
 
__u_quad_t


	)

106 
	#__STD_TYPE
 
__exnsi__
 

	)

107 #i
__WORDSIZE
 == 64

108 
	t__SQUAD_TYPE
 

	)

109 
	t__UQUAD_TYPE
 

	)

110 
	t__SWORD_TYPE
 

	)

111 
	t__UWORD_TYPE
 

	)

112 
	t__SLONG32_TYPE
 

	)

113 
	t__ULONG32_TYPE
 

	)

114 
	t__S64_TYPE
 

	)

115 
	t__U64_TYPE
 

	)

117 
	t__STD_TYPE
 

	)

121 
	~<bs/tysizes.h
>

124 
__STD_TYPE
 
	t__DEV_T_TYPE
 
	t__dev_t
;

125 
__STD_TYPE
 
__UID_T_TYPE
 
	g__uid_t
;

126 
__STD_TYPE
 
__GID_T_TYPE
 
	g__gid_t
;

127 
__STD_TYPE
 
__INO_T_TYPE
 
	g__o_t
;

128 
__STD_TYPE
 
__INO64_T_TYPE
 
	g__o64_t
;

129 
__STD_TYPE
 
__MODE_T_TYPE
 
	g__mode_t
;

130 
__STD_TYPE
 
__NLINK_T_TYPE
 
	g__ƚk_t
;

131 
__STD_TYPE
 
__OFF_T_TYPE
 
	g__off_t
;

132 
__STD_TYPE
 
__OFF64_T_TYPE
 
	g__off64_t
;

133 
__STD_TYPE
 
__PID_T_TYPE
 
	g__pid_t
;

134 
__STD_TYPE
 
__FSID_T_TYPE
 
	g__fsid_t
;

135 
__STD_TYPE
 
__CLOCK_T_TYPE
 
	g__ock_t
;

136 
__STD_TYPE
 
__RLIM_T_TYPE
 
	g__im_t
;

137 
__STD_TYPE
 
__RLIM64_T_TYPE
 
	g__im64_t
;

138 
__STD_TYPE
 
__ID_T_TYPE
 
	g__id_t
;

139 
__STD_TYPE
 
__TIME_T_TYPE
 
	g__time_t
;

140 
__STD_TYPE
 
__USECONDS_T_TYPE
 
	g__ucds_t
;

141 
__STD_TYPE
 
__SUSECONDS_T_TYPE
 
	g__sucds_t
;

143 
__STD_TYPE
 
__DADDR_T_TYPE
 
	g__daddr_t
;

144 
__STD_TYPE
 
__KEY_T_TYPE
 
	g__key_t
;

147 
__STD_TYPE
 
__CLOCKID_T_TYPE
 
	g__ockid_t
;

150 
__STD_TYPE
 
__TIMER_T_TYPE
 
	g__tim_t
;

153 
__STD_TYPE
 
__BLKSIZE_T_TYPE
 
	g__blksize_t
;

158 
__STD_TYPE
 
__BLKCNT_T_TYPE
 
	g__blkt_t
;

159 
__STD_TYPE
 
__BLKCNT64_T_TYPE
 
	g__blkt64_t
;

162 
__STD_TYPE
 
__FSBLKCNT_T_TYPE
 
	g__fsblkt_t
;

163 
__STD_TYPE
 
__FSBLKCNT64_T_TYPE
 
	g__fsblkt64_t
;

166 
__STD_TYPE
 
__FSFILCNT_T_TYPE
 
	g__fsft_t
;

167 
__STD_TYPE
 
__FSFILCNT64_T_TYPE
 
	g__fsft64_t
;

170 
__STD_TYPE
 
__FSWORD_T_TYPE
 
	g__fswd_t
;

172 
__STD_TYPE
 
__SSIZE_T_TYPE
 
	g__ssize_t
;

175 
__STD_TYPE
 
__SYSCALL_SLONG_TYPE
 
	g__sys_g_t
;

177 
__STD_TYPE
 
__SYSCALL_ULONG_TYPE
 
	g__sys_ulg_t
;

181 
__off64_t
 
	t__loff_t
;

182 
__quad_t
 *
	t__qaddr_t
;

183 *
	t__ddr_t
;

186 
__STD_TYPE
 
__SWORD_TYPE
 
	g___t
;

189 
__STD_TYPE
 
__U32_TYPE
 
	g__sockn_t
;

192 #unde
__STD_TYPE


	@/usr/include/bits/waitflags.h

19 #i!
defed
 
_SYS_WAIT_H
 && !defed 
_STDLIB_H


25 
	#WNOHANG
 1

	)

26 
	#WUNTRACED
 2

	)

29 
	#WSTOPPED
 2

	)

30 
	#WEXITED
 4

	)

31 
	#WCONTINUED
 8

	)

32 
	#WNOWAIT
 0x01000000

	)

34 
	#__WNOTHREAD
 0x20000000

	)

36 
	#__WALL
 0x40000000

	)

37 
	#__WCLONE
 0x80000000

	)

40 #i
defed
 
__USE_SVID
 || defed 
__USE_XOPEN
 || defed 
__USE_XOPEN2K8


41 #ide
__ENUM_IDTYPE_T


42 
	#__ENUM_IDTYPE_T
 1

	)

46 #unde
P_ALL


47 #unde
P_PID


48 #unde
P_PGID


52 
	mP_ALL
,

53 
	mP_PID
,

54 
	mP_PGID


55 } 
	tidty_t
;

	@/usr/include/bits/waitstatus.h

19 #i!
defed
 
_SYS_WAIT_H
 && !defed 
_STDLIB_H


28 
	#__WEXITSTATUS
(
us
(((us& 0xff00>> 8)

	)

31 
	#__WTERMSIG
(
us
((us& 0x7f)

	)

34 
	#__WSTOPSIG
(
us

	`__WEXITSTATUS
(us)

	)

37 
	#__WIFEXITED
(
us
(
	`__WTERMSIG
(us=0)

	)

40 
	#__WIFSIGNALED
(
us
) \

41 (((sigd (((
us
& 0x7f+ 1>> 1> 0)

	)

44 
	#__WIFSTOPPED
(
us
(((us& 0xff=0x7f)

	)

48 #ifde
WCONTINUED


49 
	#__WIFCONTINUED
(
us
((us=
__W_CONTINUED
)

	)

53 
	#__WCOREDUMP
(
us
((us& 
__WCOREFLAG
)

	)

56 
	#__W_EXITCODE
(
t
, 
sig
(ԑ<< 8 | (sig))

	)

57 
	#__W_STOPCODE
(
sig
((sig<< 8 | 0x7f)

	)

58 
	#__W_CONTINUED
 0xffff

	)

59 
	#__WCOREFLAG
 0x80

	)

62 #ifdef 
__USE_BSD


64 
	~<dn.h
>

66 
	uwa


68 
	mw_us
;

71 #if 
__BYTE_ORDER
 =
__LITTLE_ENDIAN


72 
	m__w_rmsig
:7;

73 
	m__w_cedump
:1;

74 
	m__w_tcode
:8;

77 #if 
__BYTE_ORDER
 =
__BIG_ENDIAN


79 
	m__w_tcode
:8;

80 
	m__w_cedump
:1;

81 
	m__w_rmsig
:7;

83 } 
	m__wa_rmed
;

86 #if 
__BYTE_ORDER
 =
__LITTLE_ENDIAN


87 
	m__w_v
:8;

88 
	m__w_sig
:8;

91 #if 
__BYTE_ORDER
 =
__BIG_ENDIAN


93 
	m__w_sig
:8;

94 
	m__w_v
:8;

96 } 
	m__wa_ݳd
;

99 
	#w_rmsig
 
__wa_rmed
.
__w_rmsig


	)

100 
	#w_cedump
 
__wa_rmed
.
__w_cedump


	)

101 
	#w_tcode
 
__wa_rmed
.
__w_tcode


	)

102 
	#w_sig
 
__wa_ݳd
.
__w_sig


	)

103 
	#w_v
 
__wa_ݳd
.
__w_v


	)

	@/usr/include/endian.h

18 #idef 
_ENDIAN_H


19 
	#_ENDIAN_H
 1

	)

21 
	~<us.h
>

31 
	#__LITTLE_ENDIAN
 1234

	)

32 
	#__BIG_ENDIAN
 4321

	)

33 
	#__PDP_ENDIAN
 3412

	)

36 
	~<bs/dn.h
>

40 #ide
__FLOAT_WORD_ORDER


41 
	#__FLOAT_WORD_ORDER
 
__BYTE_ORDER


	)

44 #ifdef 
__USE_BSD


45 
	#LITTLE_ENDIAN
 
__LITTLE_ENDIAN


	)

46 
	#BIG_ENDIAN
 
__BIG_ENDIAN


	)

47 
	#PDP_ENDIAN
 
__PDP_ENDIAN


	)

48 
	#BYTE_ORDER
 
__BYTE_ORDER


	)

51 #i
__BYTE_ORDER
 =
__LITTLE_ENDIAN


52 
	#__LONG_LONG_PAIR
(
HI
, 
LO
LO, 
	)
HI

53 #i
__BYTE_ORDER
 =
__BIG_ENDIAN


54 
	#__LONG_LONG_PAIR
(
HI
, 
LO
HI, 
	)
LO

58 #i
defed
 
__USE_BSD
 && !defed 
__ASSEMBLER__


60 
	~<bs/bysw.h
>

62 #i
__BYTE_ORDER
 =
__LITTLE_ENDIAN


63 
	#htobe16
(
x

	`__bsw_16
 (x)

	)

64 
	#hte16
(
x
(x)

	)

65 
	#be16toh
(
x

	`__bsw_16
 (x)

	)

66 
	#16toh
(
x
(x)

	)

68 
	#htobe32
(
x

	`__bsw_32
 (x)

	)

69 
	#hte32
(
x
(x)

	)

70 
	#be32toh
(
x

	`__bsw_32
 (x)

	)

71 
	#32toh
(
x
(x)

	)

73 
	#htobe64
(
x

	`__bsw_64
 (x)

	)

74 
	#hte64
(
x
(x)

	)

75 
	#be64toh
(
x

	`__bsw_64
 (x)

	)

76 
	#64toh
(
x
(x)

	)

79 
	#htobe16
(
x
(x)

	)

80 
	#hte16
(
x

	`__bsw_16
 (x)

	)

81 
	#be16toh
(
x
(x)

	)

82 
	#16toh
(
x

	`__bsw_16
 (x)

	)

84 
	#htobe32
(
x
(x)

	)

85 
	#hte32
(
x

	`__bsw_32
 (x)

	)

86 
	#be32toh
(
x
(x)

	)

87 
	#32toh
(
x

	`__bsw_32
 (x)

	)

89 
	#htobe64
(
x
(x)

	)

90 
	#hte64
(
x

	`__bsw_64
 (x)

	)

91 
	#be64toh
(
x
(x)

	)

92 
	#64toh
(
x

	`__bsw_64
 (x)

	)

	@/usr/include/features.h

18 #idef 
_FEATURES_H


19 
	#_FEATURES_H
 1

	)

101 #unde
__USE_ISOC11


102 #unde
__USE_ISOC99


103 #unde
__USE_ISOC95


104 #unde
__USE_ISOCXX11


105 #unde
__USE_POSIX


106 #unde
__USE_POSIX2


107 #unde
__USE_POSIX199309


108 #unde
__USE_POSIX199506


109 #unde
__USE_XOPEN


110 #unde
__USE_XOPEN_EXTENDED


111 #unde
__USE_UNIX98


112 #unde
__USE_XOPEN2K


113 #unde
__USE_XOPEN2KXSI


114 #unde
__USE_XOPEN2K8


115 #unde
__USE_XOPEN2K8XSI


116 #unde
__USE_LARGEFILE


117 #unde
__USE_LARGEFILE64


118 #unde
__USE_FILE_OFFSET64


119 #unde
__USE_BSD


120 #unde
__USE_SVID


121 #unde
__USE_MISC


122 #unde
__USE_ATFILE


123 #unde
__USE_GNU


124 #unde
__USE_REENTRANT


125 #unde
__USE_FORTIFY_LEVEL


126 #unde
__KERNEL_STRICT_NAMES


130 #ide
_LOOSE_KERNEL_NAMES


131 
	#__KERNEL_STRICT_NAMES


	)

141 #i
defed
 
__GNUC__
 && defed 
__GNUC_MINOR__


142 
	#__GNUC_PREREQ
(
maj
, 
m
) \

143 ((
__GNUC__
 << 16+ 
__GNUC_MINOR__
 >((
maj
<< 16+ (
m
))

	)

145 
	#__GNUC_PREREQ
(
maj
, 
m
0

	)

150 #ifde
_GNU_SOURCE


151 #unde
_ISOC95_SOURCE


152 
	#_ISOC95_SOURCE
 1

	)

153 #unde
_ISOC99_SOURCE


154 
	#_ISOC99_SOURCE
 1

	)

155 #unde
_ISOC11_SOURCE


156 
	#_ISOC11_SOURCE
 1

	)

157 #unde
_POSIX_SOURCE


158 
	#_POSIX_SOURCE
 1

	)

159 #unde
_POSIX_C_SOURCE


160 
	#_POSIX_C_SOURCE
 200809L

	)

161 #unde
_XOPEN_SOURCE


162 
	#_XOPEN_SOURCE
 700

	)

163 #unde
_XOPEN_SOURCE_EXTENDED


164 
	#_XOPEN_SOURCE_EXTENDED
 1

	)

165 #unde
_LARGEFILE64_SOURCE


166 
	#_LARGEFILE64_SOURCE
 1

	)

167 #unde
_DEFAULT_SOURCE


168 
	#_DEFAULT_SOURCE
 1

	)

169 #unde
_BSD_SOURCE


170 
	#_BSD_SOURCE
 1

	)

171 #unde
_SVID_SOURCE


172 
	#_SVID_SOURCE
 1

	)

173 #unde
_ATFILE_SOURCE


174 
	#_ATFILE_SOURCE
 1

	)

179 #i(
defed
 
_DEFAULT_SOURCE
 \

180 || (!
defed
 
	g__STRICT_ANSI__
 \

181 && !
defed
 
	g_ISOC99_SOURCE
 \

182 && !
defed
 
	g_POSIX_SOURCE
 && !defed 
	g_POSIX_C_SOURCE
 \

183 && !
defed
 
	g_XOPEN_SOURCE
 \

184 && !
defed
 
	g_BSD_SOURCE
 && !defed 
	g_SVID_SOURCE
))

185 #unde
_DEFAULT_SOURCE


186 
	#_DEFAULT_SOURCE
 1

	)

187 #unde
_BSD_SOURCE


188 
	#_BSD_SOURCE
 1

	)

189 #unde
_SVID_SOURCE


190 
	#_SVID_SOURCE
 1

	)

194 #i(
defed
 
_ISOC11_SOURCE
 \

195 || (
defed
 
	g__STDC_VERSION__
 && __STDC_VERSION__ >= 201112L))

196 
	#__USE_ISOC11
 1

	)

200 #i(
defed
 
_ISOC99_SOURCE
 || defed 
_ISOC11_SOURCE
 \

201 || (
defed
 
__STDC_VERSION__
 && __STDC_VERSION__ >= 199901L))

202 
	#__USE_ISOC99
 1

	)

206 #i(
defed
 
_ISOC99_SOURCE
 || defed 
_ISOC11_SOURCE
 \

207 || (
defed
 
__STDC_VERSION__
 && __STDC_VERSION__ >= 199409L))

208 
	#__USE_ISOC95
 1

	)

215 #i((
defed
 
__lulus
 && __cplusplus >= 201103L) \

216 || 
defed
 
__GXX_EXPERIMENTAL_CXX0X__
)

217 
	#__USE_ISOCXX11
 1

	)

223 #ifde
_DEFAULT_SOURCE


224 #i!
defed
 
_POSIX_SOURCE
 && !defed 
_POSIX_C_SOURCE


225 
	#__USE_POSIX_IMPLICITLY
 1

	)

227 #unde
_POSIX_SOURCE


228 
	#_POSIX_SOURCE
 1

	)

229 #unde
_POSIX_C_SOURCE


230 
	#_POSIX_C_SOURCE
 200809L

	)

232 #i((!
defed
 
__STRICT_ANSI__
 || (
_XOPEN_SOURCE
 - 0) >= 500) && \

233 !
defed
 
_POSIX_SOURCE
 && !defed 
_POSIX_C_SOURCE
)

234 
	#_POSIX_SOURCE
 1

	)

235 #i
defed
 
_XOPEN_SOURCE
 && (_XOPEN_SOURCE - 0) < 500

236 
	#_POSIX_C_SOURCE
 2

	)

237 #i
defed
 
_XOPEN_SOURCE
 && (_XOPEN_SOURCE - 0) < 600

238 
	#_POSIX_C_SOURCE
 199506L

	)

239 #i
defed
 
_XOPEN_SOURCE
 && (_XOPEN_SOURCE - 0) < 700

240 
	#_POSIX_C_SOURCE
 200112L

	)

242 
	#_POSIX_C_SOURCE
 200809L

	)

244 
	#__USE_POSIX_IMPLICITLY
 1

	)

247 #i
defed
 
_POSIX_SOURCE
 || 
_POSIX_C_SOURCE
 >1 || defed 
_XOPEN_SOURCE


248 
	#__USE_POSIX
 1

	)

251 #i
defed
 
_POSIX_C_SOURCE
 && _POSIX_C_SOURCE >2 || defed 
_XOPEN_SOURCE


252 
	#__USE_POSIX2
 1

	)

255 #i(
_POSIX_C_SOURCE
 - 0) >= 199309L

256 
	#__USE_POSIX199309
 1

	)

259 #i(
_POSIX_C_SOURCE
 - 0) >= 199506L

260 
	#__USE_POSIX199506
 1

	)

263 #i(
_POSIX_C_SOURCE
 - 0) >= 200112L

264 
	#__USE_XOPEN2K
 1

	)

265 #unde
__USE_ISOC95


266 
	#__USE_ISOC95
 1

	)

267 #unde
__USE_ISOC99


268 
	#__USE_ISOC99
 1

	)

271 #i(
_POSIX_C_SOURCE
 - 0) >= 200809L

272 
	#__USE_XOPEN2K8
 1

	)

273 #unde
_ATFILE_SOURCE


274 
	#_ATFILE_SOURCE
 1

	)

277 #ifdef 
_XOPEN_SOURCE


278 
	#__USE_XOPEN
 1

	)

279 #i(
_XOPEN_SOURCE
 - 0) >= 500

280 
	#__USE_XOPEN_EXTENDED
 1

	)

281 
	#__USE_UNIX98
 1

	)

282 #unde
_LARGEFILE_SOURCE


283 
	#_LARGEFILE_SOURCE
 1

	)

284 #i(
_XOPEN_SOURCE
 - 0) >= 600

285 #i(
_XOPEN_SOURCE
 - 0) >= 700

286 
	#__USE_XOPEN2K8
 1

	)

287 
	#__USE_XOPEN2K8XSI
 1

	)

289 
	#__USE_XOPEN2K
 1

	)

290 
	#__USE_XOPEN2KXSI
 1

	)

291 #unde
__USE_ISOC95


292 
	#__USE_ISOC95
 1

	)

293 #unde
__USE_ISOC99


294 
	#__USE_ISOC99
 1

	)

297 #ifde
_XOPEN_SOURCE_EXTENDED


298 
	#__USE_XOPEN_EXTENDED
 1

	)

303 #ifde
_LARGEFILE_SOURCE


304 
	#__USE_LARGEFILE
 1

	)

307 #ifde
_LARGEFILE64_SOURCE


308 
	#__USE_LARGEFILE64
 1

	)

311 #i
defed
 
_FILE_OFFSET_BITS
 && _FILE_OFFSET_BITS == 64

312 
	#__USE_FILE_OFFSET64
 1

	)

315 #i
defed
 
_BSD_SOURCE
 || defed 
_SVID_SOURCE


316 
	#__USE_MISC
 1

	)

319 #ifdef 
_BSD_SOURCE


320 
	#__USE_BSD
 1

	)

323 #ifdef 
_SVID_SOURCE


324 
	#__USE_SVID
 1

	)

327 #ifdef 
_ATFILE_SOURCE


328 
	#__USE_ATFILE
 1

	)

331 #ifdef 
_GNU_SOURCE


332 
	#__USE_GNU
 1

	)

335 #i
defed
 
_REENTRANT
 || defed 
_THREAD_SAFE


336 
	#__USE_REENTRANT
 1

	)

339 #i
defed
 
_FORTIFY_SOURCE
 && _FORTIFY_SOURCE > 0 \

340 && 
__GNUC_PREREQ
 (4, 1&& 
defed
 
	g__OPTIMIZE__
 && __OPTIMIZE__ > 0

341 #i
_FORTIFY_SOURCE
 > 1

342 
	#__USE_FORTIFY_LEVEL
 2

	)

344 
	#__USE_FORTIFY_LEVEL
 1

	)

347 
	#__USE_FORTIFY_LEVEL
 0

	)

352 
	~<dc-edef.h
>

360 #unde
__GNU_LIBRARY__


361 
	#__GNU_LIBRARY__
 6

	)

365 
	#__GLIBC__
 2

	)

366 
	#__GLIBC_MINOR__
 19

	)

368 
	#__GLIBC_PREREQ
(
maj
, 
m
) \

369 ((
__GLIBC__
 << 16+ 
__GLIBC_MINOR__
 >((
maj
<< 16+ (
m
))

	)

372 #ide
__ASSEMBLER__


373 #ide
_SYS_CDEFS_H


374 
	~<sys/cdefs.h
>

379 #i
defed
 
__USE_FILE_OFFSET64
 && !defed 
__REDIRECT


380 
	#__USE_LARGEFILE
 1

	)

381 
	#__USE_LARGEFILE64
 1

	)

387 #i
__GNUC_PREREQ
 (2, 7&& 
defed
 
__OPTIMIZE__
 \

388 && !
defed
 
	g__OPTIMIZE_SIZE__
 && !defed 
	g__NO_INLINE__
 \

389 && 
defed
 
	g__ex_le


390 
	#__USE_EXTERN_INLINES
 1

	)

398 
	~<gnu/ubs.h
>

	@/usr/include/getopt.h

19 #ide
_GETOPT_H


21 #ide
__ed_gt


22 
	#_GETOPT_H
 1

	)

32 #i!
defed
 
__GNU_LIBRARY__


33 
	~<y.h
>

36 #ide
__THROW


37 #ide
__GNUC_PREREQ


38 
	#__GNUC_PREREQ
(
maj
, 
m
(0)

	)

40 #i
defed
 
__lulus
 && 
__GNUC_PREREQ
 (2,8)

41 
	#__THROW
 
	`throw
 ()

	)

43 
	#__THROW


	)

47 #ifdef 
__lulus


57 *
ݏrg
;

71 
td
;

76 
݋
;

80 
tt
;

82 #ide
__ed_gt


104 
	sti


106 cڡ *
	gme
;

109 
	ghas_g
;

110 *
	gag
;

111 
	gv
;

116 
	#no_gumt
 0

	)

117 
	#qued_gumt
 1

	)

118 
	#tiڮ_gumt
 2

	)

146 #ifde
__GNU_LIBRARY__


150 
gt
 (
___gc
, *cڡ *
___gv
, cڡ *
__shtts
)

151 
__THROW
;

153 #i
defed
 
__ed_gt
 && defed 
__USE_POSIX2
 \

154 && !
defed
 
	g__USE_POSIX_IMPLICITLY
 && !defed 
	g__USE_GNU


158 #ifde
__REDIRECT


159 
__REDIRECT_NTH
 (
gt
, (
___gc
, *cڡ *
___gv
,

160 cڡ *
__shtts
),

161 
__posix_gt
);

163 
__posix_gt
 (
___gc
, *cڡ *
___gv
,

164 cڡ *
__shtts

__THROW
;

165 
	#gt
 
__posix_gt


	)

169 
gt
 ();

172 #ide
__ed_gt


173 
gt_lg
 (
___gc
, *cڡ *
___gv
,

174 cڡ *
__shtts
,

175 cڡ 
ti
 *
__lgts
, *
__lgd
)

176 
__THROW
;

177 
gt_lg_ly
 (
___gc
, *cڡ *
___gv
,

178 cڡ *
__shtts
,

179 cڡ 
ti
 *
__lgts
, *
__lgd
)

180 
__THROW
;

184 #ifdef 
__lulus


189 #unde
__ed_gt


	@/usr/include/libio.h

28 #ide
_IO_STDIO_H


29 
	#_IO_STDIO_H


	)

31 
	~<_G_cfig.h
>

33 
	#_IO_os_t
 
_G_os_t


	)

34 
	#_IO_os64_t
 
_G_os64_t


	)

35 
	#_IO_size_t
 
size_t


	)

36 
	#_IO_ssize_t
 
__ssize_t


	)

37 
	#_IO_off_t
 
__off_t


	)

38 
	#_IO_off64_t
 
__off64_t


	)

39 
	#_IO_pid_t
 
__pid_t


	)

40 
	#_IO_uid_t
 
__uid_t


	)

41 
	#_IO_icv_t
 
_G_icv_t


	)

42 
	#_IO_HAVE_ST_BLKSIZE
 
_G_HAVE_ST_BLKSIZE


	)

43 
	#_IO_BUFSIZ
 
_G_BUFSIZ


	)

44 
	#_IO_va_li
 
_G_va_li


	)

45 
	#_IO_wt_t
 
wt_t


	)

48 
	#__ed___va_li


	)

49 
	~<dg.h
>

50 #ifde
__GNUC_VA_LIST


51 #unde
_IO_va_li


52 
	#_IO_va_li
 
__gnuc_va_li


	)

55 #ide
__P


56 
	~<sys/cdefs.h
>

59 
	#_IO_UNIFIED_JUMPTABLES
 1

	)

61 #ide
EOF


62 
	#EOF
 (-1)

	)

64 #ide
NULL


65 #i
defed
 
__GNUG__
 && \

66 (
	g__GNUC__
 > 2 || (__GNUC__ =2 && 
__GNUC_MINOR__
 >= 8))

67 
	#NULL
 (
__nu
)

	)

69 #i!
defed
(
__lulus
)

70 
	#NULL
 ((*)0)

	)

72 
	#NULL
 (0)

	)

77 
	#_IOS_INPUT
 1

	)

78 
	#_IOS_OUTPUT
 2

	)

79 
	#_IOS_ATEND
 4

	)

80 
	#_IOS_APPEND
 8

	)

81 
	#_IOS_TRUNC
 16

	)

82 
	#_IOS_NOCREATE
 32

	)

83 
	#_IOS_NOREPLACE
 64

	)

84 
	#_IOS_BIN
 128

	)

92 
	#_IO_MAGIC
 0xFBAD0000

	)

93 
	#_OLD_STDIO_MAGIC
 0xFABC0000

	)

94 
	#_IO_MAGIC_MASK
 0xFFFF0000

	)

95 
	#_IO_USER_BUF
 1

	)

96 
	#_IO_UNBUFFERED
 2

	)

97 
	#_IO_NO_READS
 4

	)

98 
	#_IO_NO_WRITES
 8

	)

99 
	#_IO_EOF_SEEN
 0x10

	)

100 
	#_IO_ERR_SEEN
 0x20

	)

101 
	#_IO_DELETE_DONT_CLOSE
 0x40

	)

102 
	#_IO_LINKED
 0x80

	)

103 
	#_IO_IN_BACKUP
 0x100

	)

104 
	#_IO_LINE_BUF
 0x200

	)

105 
	#_IO_TIED_PUT_GET
 0x400

	)

106 
	#_IO_CURRENTLY_PUTTING
 0x800

	)

107 
	#_IO_IS_APPENDING
 0x1000

	)

108 
	#_IO_IS_FILEBUF
 0x2000

	)

109 
	#_IO_BAD_SEEN
 0x4000

	)

110 
	#_IO_USER_LOCK
 0x8000

	)

112 
	#_IO_FLAGS2_MMAP
 1

	)

113 
	#_IO_FLAGS2_NOTCANCEL
 2

	)

114 #ifde
_LIBC


115 
	#_IO_FLAGS2_FORTIFY
 4

	)

117 
	#_IO_FLAGS2_USER_WBUF
 8

	)

118 #ifde
_LIBC


119 
	#_IO_FLAGS2_SCANF_STD
 16

	)

120 
	#_IO_FLAGS2_NOCLOSE
 32

	)

121 
	#_IO_FLAGS2_CLOEXEC
 64

	)

125 
	#_IO_SKIPWS
 01

	)

126 
	#_IO_LEFT
 02

	)

127 
	#_IO_RIGHT
 04

	)

128 
	#_IO_INTERNAL
 010

	)

129 
	#_IO_DEC
 020

	)

130 
	#_IO_OCT
 040

	)

131 
	#_IO_HEX
 0100

	)

132 
	#_IO_SHOWBASE
 0200

	)

133 
	#_IO_SHOWPOINT
 0400

	)

134 
	#_IO_UPPERCASE
 01000

	)

135 
	#_IO_SHOWPOS
 02000

	)

136 
	#_IO_SCIENTIFIC
 04000

	)

137 
	#_IO_FIXED
 010000

	)

138 
	#_IO_UNITBUF
 020000

	)

139 
	#_IO_STDIO
 040000

	)

140 
	#_IO_DONT_CLOSE
 0100000

	)

141 
	#_IO_BOOLALPHA
 0200000

	)

144 
_IO_jump_t
; 
	g_IO_FILE
;

147 #ifde
_IO_MTSAFE_IO


148 #i
defed
 
__GLIBC__
 && __GLIBC__ >= 2

149 
	~<bs/dio-lock.h
>

154 
	t_IO_lock_t
;

160 
	s_IO_mk
 {

161 
_IO_mk
 *
	m_xt
;

162 
_IO_FILE
 *
	m_sbuf
;

166 
	m_pos
;

168 
t_ampos
(
ampos
 

{ 
	m_os
 = sp; }

169 
t_offt
(
offt
{ 
	m_pos
 = offt; 
	m_os
 = (
ampos
)(-2); }

170 
	mpublic
:

171 
ammk
(
ambuf
 *
sb
);

172 ~
ammk
();

173 
vg
({  
	m_os
 == -2; }

174 
d
(
ammk
&);

175 
d
();

180 
	e__codecvt_su


182 
	m__codecvt_ok
,

183 
	m__codecvt_l
,

184 
	m__codecvt_r
,

185 
	m__codecvt_nocv


188 #i
defed
 
_LIBC
 || defed 
_GLIBCPP_USE_WCHAR_T


191 
	s_IO_codecvt


193 (*
	m__codecvt_der
(
	m_IO_codecvt
 *);

194 
__codecvt_su
 (*
__codecvt_do_out
(
	m_IO_codecvt
 *,

195 
	m__mbe_t
 *,

196 cڡ 
	mwch_t
 *,

197 cڡ 
	mwch_t
 *,

198 cڡ 
	mwch_t
 **, *,

200 
__codecvt_su
 (*
__codecvt_do_unshi
(
	m_IO_codecvt
 *,

201 
	m__mbe_t
 *, *,

203 
__codecvt_su
 (*
__codecvt_do_
(
	m_IO_codecvt
 *,

204 
	m__mbe_t
 *,

206 cڡ **, 
	mwch_t
 *,

207 
	mwch_t
 *, wchar_t **);

208 (*
	m__codecvt_do_codg
(
	m_IO_codecvt
 *);

209 (*
	m__codecvt_do_ways_nocv
(
	m_IO_codecvt
 *);

210 (*
	m__codecvt_do_ngth
(
	m_IO_codecvt
 *, 
	m__mbe_t
 *,

211 cڡ *, cڡ *, 
	m_IO_size_t
);

212 (*
	m__codecvt_do_max_ngth
(
	m_IO_codecvt
 *);

214 
_IO_icv_t
 
	m__cd_
;

215 
_IO_icv_t
 
	m__cd_out
;

219 
	s_IO_wide_da


221 
wch_t
 *
	m_IO_ad_r
;

222 
wch_t
 *
	m_IO_ad_d
;

223 
wch_t
 *
	m_IO_ad_ba
;

224 
wch_t
 *
	m_IO_wre_ba
;

225 
wch_t
 *
	m_IO_wre_r
;

226 
wch_t
 *
	m_IO_wre_d
;

227 
wch_t
 *
	m_IO_buf_ba
;

228 
wch_t
 *
	m_IO_buf_d
;

230 
wch_t
 *
	m_IO_ve_ba
;

231 
wch_t
 *
	m_IO_backup_ba
;

233 
wch_t
 *
	m_IO_ve_d
;

235 
__mbe_t
 
	m_IO_e
;

236 
__mbe_t
 
	m_IO_ϡ_e
;

237 
_IO_codecvt
 
	m_codecvt
;

239 
wch_t
 
	m_shtbuf
[1];

241 cڡ 
_IO_jump_t
 *
	m_wide_vb
;

245 
	s_IO_FILE
 {

246 
	m_ags
;

247 
	#_IO_fe_ags
 
_ags


	)

251 * 
	m_IO_ad_r
;

252 * 
	m_IO_ad_d
;

253 * 
	m_IO_ad_ba
;

254 * 
	m_IO_wre_ba
;

255 * 
	m_IO_wre_r
;

256 * 
	m_IO_wre_d
;

257 * 
	m_IO_buf_ba
;

258 * 
	m_IO_buf_d
;

260 *
	m_IO_ve_ba
;

261 *
	m_IO_backup_ba
;

262 *
	m_IO_ve_d
;

264 
_IO_mk
 *
	m_mks
;

266 
_IO_FILE
 *
	m_cha
;

268 
	m_fo
;

270 
	m_blksize
;

272 
	m_ags2
;

274 
_IO_off_t
 
	m_d_offt
;

276 
	#__HAVE_COLUMN


	)

278 
	m_cur_cumn
;

279 sigd 
	m_vb_offt
;

280 
	m_shtbuf
[1];

284 
_IO_lock_t
 *
	m_lock
;

285 #ifde
_IO_USE_OLD_IO_FILE


288 
	s_IO_FILE_come


290 
_IO_FILE
 
	m_fe
;

292 #i
defed
 
_G_IO_IO_FILE_VERSION
 && _G_IO_IO_FILE_VERSION == 0x20001

293 
_IO_off64_t
 
	m_offt
;

294 #i
defed
 
_LIBC
 || defed 
_GLIBCPP_USE_WCHAR_T


296 
_IO_codecvt
 *
	m_codecvt
;

297 
_IO_wide_da
 *
	m_wide_da
;

298 
_IO_FILE
 *
	m_䓻s_li
;

299 *
	m_䓻s_buf
;

300 
size_t
 
	m_䓻s_size
;

302 *
	m__d1
;

303 *
	m__d2
;

304 *
	m__d3
;

305 *
	m__d4
;

306 
size_t
 
	m__d5
;

308 
	m_mode
;

310 
	m_unud2
[15 *  (- 4 *  (*-  (
size_t
)];

314 #ide
__lulus


315 
_IO_FILE
 
	t_IO_FILE
;

318 
	g_IO_FILE_us
;

320 
_IO_FILE_us
 
_IO_2_1_d_
;

321 
_IO_FILE_us
 
_IO_2_1_dout_
;

322 
_IO_FILE_us
 
_IO_2_1_dr_
;

323 #ide
_LIBC


324 
	#_IO_d
 ((
_IO_FILE
*)(&
_IO_2_1_d_
))

	)

325 
	#_IO_dout
 ((
_IO_FILE
*)(&
_IO_2_1_dout_
))

	)

326 
	#_IO_dr
 ((
_IO_FILE
*)(&
_IO_2_1_dr_
))

	)

328 
_IO_FILE
 *
_IO_d
 
ibu_hidd
;

329 
_IO_FILE
 *
_IO_dout
 
ibu_hidd
;

330 
_IO_FILE
 *
_IO_dr
 
ibu_hidd
;

338 
__ssize_t
 
	t__io_ad_
 (*
	t__cook
, *
	t__buf
, 
	tsize_t
 
	t__nbys
);

346 
__ssize_t
 
	t__io_wre_
 (*
	t__cook
, cڡ *
	t__buf
,

347 
	tsize_t
 
	t__n
);

355 
	t__io_ek_
 (*
	t__cook
, 
	t_IO_off64_t
 *
	t__pos
, 
	t__w
);

358 
	t__io_o_
 (*
	t__cook
);

361 #ifde
_GNU_SOURCE


363 
__io_ad_
 
	tcook_ad_funi_t
;

364 
__io_wre_
 
	tcook_wre_funi_t
;

365 
__io_ek_
 
	tcook_ek_funi_t
;

366 
__io_o_
 
	tcook_o_funi_t
;

371 
__io_ad_
 *
	mad
;

372 
__io_wre_
 *
	mwre
;

373 
__io_ek_
 *
	mek
;

374 
__io_o_
 *
	mo
;

375 } 
	t_IO_cook_io_funis_t
;

376 
_IO_cook_io_funis_t
 
	tcook_io_funis_t
;

378 
	g_IO_cook_fe
;

381 
_IO_cook_
 (
_IO_cook_fe
 *
__cfe
, 
__ad_wre
,

382 *
__cook
, 
_IO_cook_io_funis_t
 
__s
);

386 #ifde
__lulus


390 
__undow
 (
_IO_FILE
 *);

391 
__uow
 (
_IO_FILE
 *);

392 
__ovow
 (
_IO_FILE
 *, );

393 #i
defed
 
_LIBC
 || defed 
_GLIBCPP_USE_WCHAR_T


394 
_IO_wt_t
 
__wundow
 (
_IO_FILE
 *);

395 
_IO_wt_t
 
__wuow
 (
_IO_FILE
 *);

396 
_IO_wt_t
 
__wovow
 (
_IO_FILE
 *, _IO_wint_t);

399 #i 
__GNUC__
 >= 3

400 
	#_IO_BE
(
ex
, 
s

	`__but_ex
 (x),es)

	)

402 
	#_IO_BE
(
ex
, 
s
x)

	)

405 
	#_IO_gc_uocked
(
_
) \

406 (
	`_IO_BE
 ((
_
)->
_IO_ad_r
 >(_)->
_IO_ad_d
, 0) \

407 ? 
	`__uow
 (
_
: *(*(_)->
_IO_ad_r
++)

	)

408 
	#_IO_ekc_uocked
(
_
) \

409 (
	`_IO_BE
 ((
_
)->
_IO_ad_r
 >(_)->
_IO_ad_d
, 0) \

410 && 
	`__undow
 (
_
=
EOF
 ? EOF \

411 : *(*(
_
)->
_IO_ad_r
)

	)

412 
	#_IO_putc_uocked
(
_ch
, 
_
) \

413 (
	`_IO_BE
 ((
_
)->
_IO_wre_r
 >(_)->
_IO_wre_d
, 0) \

414 ? 
	`__ovow
 (
_
, ((
_ch
)) \

415 : ((*(
_
)->
_IO_wre_r
++ = (
_ch
)))

	)

417 #i
defed
 
_LIBC
 || defed 
_GLIBCPP_USE_WCHAR_T


418 
	#_IO_gwc_uocked
(
_
) \

419 (
	`_IO_BE
 ((
_
)->
_wide_da
 =
NULL
 \

420 || ((
_
)->
_wide_da
->
_IO_ad_r
 \

421 >(
_
)->
_wide_da
->
_IO_ad_d
), 0) \

422 ? 
	`__wuow
 (
_
: (
_IO_wt_t
*(_)->
_wide_da
->
_IO_ad_r
++)

	)

423 
	#_IO_putwc_uocked
(
_wch
, 
_
) \

424 (
	`_IO_BE
 ((
_
)->
_wide_da
 =
NULL
 \

425 || ((
_
)->
_wide_da
->
_IO_wre_r
 \

426 >(
_
)->
_wide_da
->
_IO_wre_d
), 0) \

427 ? 
	`__wovow
 (
_
, 
_wch
) \

428 : (
_IO_wt_t
(*(
_
)->
_wide_da
->
_IO_wre_r
++ = (
_wch
)))

	)

431 
	#_IO_of_uocked
(
__
(((__)->
_ags
 & 
_IO_EOF_SEEN
!0)

	)

432 
	#_IO__uocked
(
__
(((__)->
_ags
 & 
_IO_ERR_SEEN
!0)

	)

434 
_IO_gc
 (
_IO_FILE
 *
__
);

435 
_IO_putc
 (
__c
, 
_IO_FILE
 *
__
);

436 
_IO_of
 (
_IO_FILE
 *
__

__THROW
;

437 
_IO_
 (
_IO_FILE
 *
__

__THROW
;

439 
_IO_ekc_locked
 (
_IO_FILE
 *
__
);

442 
	#_IO_PENDING_OUTPUT_COUNT
(
_
) \

443 ((
_
)->
_IO_wre_r
 - (_)->
_IO_wre_ba
)

	)

445 
_IO_ockfe
 (
_IO_FILE
 *
__THROW
;

446 
_IO_fuockfe
 (
_IO_FILE
 *
__THROW
;

447 
_IO_rylockfe
 (
_IO_FILE
 *
__THROW
;

449 #ifde
_IO_MTSAFE_IO


450 
	#_IO_ekc
(
_

	`_IO_ekc_locked
 (_)

	)

451 
	#_IO_ockfe
(
_
) \

452 i(((
_
)->
_ags
 & 
_IO_USER_LOCK
=0
	`_IO_ockfe
 (_)

	)

453 
	#_IO_fuockfe
(
_
) \

454 i(((
_
)->
_ags
 & 
_IO_USER_LOCK
=0
	`_IO_fuockfe
 (_)

	)

456 
	#_IO_ekc
(
_

	`_IO_ekc_uocked
 (_)

	)

457 
	#_IO_ockfe
(
_


	)

458 
	#_IO_fuockfe
(
_


	)

459 
	#_IO_rylockfe
(
_


	)

460 
	#_IO_nup_gi_t
(
_f
, 
_


	)

461 
	#_IO_nup_gi_d
(
_Do


	)

464 
_IO_vfsnf
 (
_IO_FILE
 * 
__ri
, const * __restrict,

465 
_IO_va_li
, *
__ri
);

466 
_IO_vrtf
 (
_IO_FILE
 *
__ri
, const *__restrict,

467 
_IO_va_li
);

468 
_IO_ssize_t
 
_IO_dn
 (
_IO_FILE
 *, , _IO_ssize_t);

469 
_IO_size_t
 
_IO_sgn
 (
_IO_FILE
 *, *, _IO_size_t);

471 
_IO_off64_t
 
_IO_ekoff
 (
_IO_FILE
 *, _IO_off64_t, , );

472 
_IO_off64_t
 
_IO_ekpos
 (
_IO_FILE
 *, _IO_off64_t, );

474 
_IO__backup_
 (
_IO_FILE
 *
__THROW
;

476 #i
defed
 
_LIBC
 || defed 
_GLIBCPP_USE_WCHAR_T


477 
_IO_wt_t
 
_IO_gwc
 (
_IO_FILE
 *
__
);

478 
_IO_wt_t
 
_IO_putwc
 (
wch_t
 
__wc
, 
_IO_FILE
 *
__
);

479 
_IO_fwide
 (
_IO_FILE
 *
__
, 
__mode

__THROW
;

480 #i
__GNUC__
 >= 2

483 #i
defed
 
_LIBC
 && defed 
SHARED


484 
	~<shlib-comt.h
>

485 #i
SHLIB_COMPAT
 (
libc
, 
GLIBC_2_0
, 
GLIBC_2_1
)

486 
	#_IO_fwide_maybe_comtib
 \

487 (
	`__but_ex
 (&
_IO_d_ud
 =
NULL
, 0))

	)

488 cڡ 
_IO_d_ud
;

489 
wk_ex
 (
_IO_d_ud
);

492 #ide
_IO_fwide_maybe_comtib


493 
	#_IO_fwide_maybe_comtib
 (0)

	)

497 
	#_IO_fwide
(
__
, 
__mode
) \

498 ({ 
__su
 = (
__mode
); \

499 i(
__su
 < 0 && ! 
_IO_fwide_maybe_comtib
) \

501 i((
__
)->
_mode
 == 0) \

503 (
__
)->
_mode
 = -1; \

504 
__su
 = (
__
)->
_mode
; \

506 i(
	`__but_cڡt_p
 (
__mode
) && (__mode) == 0) \

507 
__su
 = 
_IO_fwide_maybe_comtib
 ? -1 : (
__
)->
_mode
; \

509 
__su
 = 
	`_IO_fwide
 (
__
, __result); \

510 
__su
; })

	)

513 
_IO_vfwsnf
 (
_IO_FILE
 * 
__ri
, cڡ 
wch_t
 * __restrict,

514 
_IO_va_li
, *
__ri
);

515 
_IO_vfwtf
 (
_IO_FILE
 *
__ri
, cڡ 
wch_t
 *__restrict,

516 
_IO_va_li
);

517 
_IO_ssize_t
 
_IO_wdn
 (
_IO_FILE
 *, 
wt_t
, _IO_ssize_t);

518 
_IO__wbackup_
 (
_IO_FILE
 *
__THROW
;

521 #ifde
__LDBL_COMPAT


522 
	~<bs/libio-ldbl.h
>

525 #ifde
__lulus


	@/usr/include/sys/select.h

21 #ide
_SYS_SELECT_H


22 
	#_SYS_SELECT_H
 1

	)

24 
	~<us.h
>

27 
	~<bs/tys.h
>

30 
	~<bs/.h
>

33 
	~<bs/sigt.h
>

35 #ide
__sigt_t_defed


36 
	#__sigt_t_defed


	)

37 
__sigt_t
 
	tsigt_t
;

41 
	#__ed_time_t


	)

42 
	#__ed_timeec


	)

43 
	~<time.h
>

44 
	#__ed_timev


	)

45 
	~<bs/time.h
>

47 #ide
__sucds_t_defed


48 
__sucds_t
 
	tsucds_t
;

49 
	#__sucds_t_defed


	)

54 
	t__fd_mask
;

57 #unde
__NFDBITS


59 
	#__NFDBITS
 (8 * ( (
__fd_mask
))

	)

60 
	#__FD_ELT
(
d
((d/ 
__NFDBITS
)

	)

61 
	#__FD_MASK
(
d
((
__fd_mask
1 << ((d% 
__NFDBITS
))

	)

68 #ifde
__USE_XOPEN


69 
__fd_mask
 
	mfds_bs
[
__FD_SETSIZE
 / 
__NFDBITS
];

70 
	#__FDS_BITS
(
t
((t)->
fds_bs
)

	)

72 
__fd_mask
 
	m__fds_bs
[
__FD_SETSIZE
 / 
__NFDBITS
];

73 
	#__FDS_BITS
(
t
((t)->
__fds_bs
)

	)

75 } 
	tfd_t
;

78 
	#FD_SETSIZE
 
__FD_SETSIZE


	)

80 #ifde
__USE_MISC


82 
__fd_mask
 
	tfd_mask
;

85 
	#NFDBITS
 
__NFDBITS


	)

90 
	#FD_SET
(
fd
, 
fd

	`__FD_SET
 (fd, fd)

	)

91 
	#FD_CLR
(
fd
, 
fd

	`__FD_CLR
 (fd, fd)

	)

92 
	#FD_ISSET
(
fd
, 
fd

	`__FD_ISSET
 (fd, fd)

	)

93 
	#FD_ZERO
(
fd

	`__FD_ZERO
 (fd)

	)

96 
__BEGIN_DECLS


106 

 (
__nfds
, 
fd_t
 *
__ri
 
__adfds
,

107 
fd_t
 *
__ri
 
__wrefds
,

108 
fd_t
 *
__ri
 
__exfds
,

109 
timev
 *
__ri
 
__timeout
);

111 #ifde
__USE_XOPEN2K


118 
p
 (
__nfds
, 
fd_t
 *
__ri
 
__adfds
,

119 
fd_t
 *
__ri
 
__wrefds
,

120 
fd_t
 *
__ri
 
__exfds
,

121 cڡ 
timeec
 *
__ri
 
__timeout
,

122 cڡ 
__sigt_t
 *
__ri
 
__sigmask
);

127 #i
__USE_FORTIFY_LEVEL
 > 0 && 
defed
 
__GNUC__


128 
	~<bs/2.h
>

131 
	g__END_DECLS


	@/usr/include/sys/sysmacros.h

19 #ide
_SYS_SYSMACROS_H


20 
	#_SYS_SYSMACROS_H
 1

	)

22 
	~<us.h
>

24 
__BEGIN_DECLS


26 
__exnsi__


27 
	$gnu_dev_maj
 (
__dev
)

28 
__THROW
 
__ibu_cڡ__
;

29 
__exnsi__


30 
	$gnu_dev_m
 (
__dev
)

31 
__THROW
 
__ibu_cڡ__
;

32 
__exnsi__


33 
	$gnu_dev_makedev
 (
__maj
,

34 
__m
)

35 
__THROW
 
__ibu_cڡ__
;

37 #ifde
__USE_EXTERN_INLINES


38 
__exnsi__
 
__ex_le
 
__ibu_cڡ__
 

39 
	`__NTH
 (
	$gnu_dev_maj
 (
__dev
))

41  ((
__dev
 >> 8) & 0xfff) | (() (__dev >> 32) & ~0xfff);

42 
	}
}

44 
__exnsi__
 
__ex_le
 
__ibu_cڡ__
 

45 
__NTH
 (
	$gnu_dev_m
 (
__dev
))

47  (
__dev
 & 0xff) | (() (__dev >> 12) & ~0xff);

48 
	}
}

50 
__exnsi__
 
__ex_le
 
__ibu_cڡ__
 

51 
__NTH
 (
	$gnu_dev_makedev
 (
__maj
, 
__m
))

53  ((
__m
 & 0xff| ((
__maj
 & 0xfff) << 8)

54 | ((((
__m
 & ~0xff)) << 12)

55 | ((((
__maj
 & ~0xfff)) << 32));

56 
	}
}

58 
	g__END_DECLS


61 
	#maj
(
dev

	`gnu_dev_maj
 (dev)

	)

62 
	#m
(
dev

	`gnu_dev_m
 (dev)

	)

63 
	#makedev
(
maj
, 
m

	`gnu_dev_makedev
 (maj, m)

	)

	@/usr/include/time.h

22 #idef 
_TIME_H


24 #i(! 
defed
 
__ed_time_t
 && !defed 
__ed_ock_t
 && \

25 ! 
defed
 
	g__ed_timeec
)

26 
	#_TIME_H
 1

	)

27 
	~<us.h
>

29 
	g__BEGIN_DECLS


33 #ifdef 
_TIME_H


35 
	#__ed_size_t


	)

36 
	#__ed_NULL


	)

37 
	~<ddef.h
>

41 
	~<bs/time.h
>

44 #i!
defed
 
__STRICT_ANSI__
 && !defed 
__USE_XOPEN2K


45 #ide
CLK_TCK


46 
	#CLK_TCK
 
CLOCKS_PER_SEC


	)

52 #i!
defed
 
__ock_t_defed
 && (defed 
_TIME_H
 || defed 
__ed_ock_t
)

53 
	#__ock_t_defed
 1

	)

55 
	~<bs/tys.h
>

57 
__BEGIN_NAMESPACE_STD


59 
__ock_t
 
	tock_t
;

60 
	g__END_NAMESPACE_STD


61 #i
defed
 
__USE_XOPEN
 || defed 
__USE_POSIX
 || defed 
__USE_MISC


62 
	$__USING_NAMESPACE_STD
(
ock_t
)

66 #unde
__ed_ock_t


68 #i!
defed
 
__time_t_defed
 && (defed 
_TIME_H
 || defed 
__ed_time_t
)

69 
	#__time_t_defed
 1

	)

71 
	~<bs/tys.h
>

73 
__BEGIN_NAMESPACE_STD


75 
__time_t
 
	ttime_t
;

76 
__END_NAMESPACE_STD


77 #i
defed
 
__USE_POSIX
 || defed 
__USE_MISC
 || defed 
__USE_SVID


78 
	$__USING_NAMESPACE_STD
(
time_t
)

82 #unde
__ed_time_t


84 #i!
defed
 
__ockid_t_defed
 && \

85 ((
defed
 
_TIME_H
 && defed 
__USE_POSIX199309
|| defed 
__ed_ockid_t
)

86 
	#__ockid_t_defed
 1

	)

88 
	~<bs/tys.h
>

91 
__ockid_t
 
	tockid_t
;

94 #unde
__ockid_time_t


96 #i!
defed
 
__tim_t_defed
 && \

97 ((
defed
 
_TIME_H
 && defed 
__USE_POSIX199309
|| defed 
__ed_tim_t
)

98 
	#__tim_t_defed
 1

	)

100 
	~<bs/tys.h
>

103 
__tim_t
 
	ttim_t
;

106 #unde
__ed_tim_t


109 #i(!
defed
 
__timeec_defed
 \

110 && ((
defed
 
_TIME_H
 \

111 && (
defed
 
__USE_POSIX199309
 || defed 
__USE_MISC
 \

112 || 
defed
 
__USE_ISOC11
)) \

113 || 
defed
 
__ed_timeec
))

114 
	#__timeec_defed
 1

	)

116 
	~<bs/tys.h
>

120 
	stimeec


122 
__time_t
 
tv_c
;

123 
__sys_g_t
 
tv_nc
;

127 #unde
__ed_timeec


130 #ifdef 
_TIME_H


131 
__BEGIN_NAMESPACE_STD


133 
	stm


135 
tm_c
;

136 
tm_m
;

137 
tm_hour
;

138 
tm_mday
;

139 
tm_m
;

140 
tm_yr
;

141 
tm_wday
;

142 
tm_yday
;

143 
tm_isd
;

145 #ifdef 
__USE_BSD


146 
tm_gmtoff
;

147 cڡ *
tm_ze
;

149 
__tm_gmtoff
;

150 cڡ *
__tm_ze
;

153 
__END_NAMESPACE_STD


154 #i
defed
 
__USE_XOPEN
 || defed 
__USE_POSIX
 || defed 
__USE_MISC


155 
	$__USING_NAMESPACE_STD
(
tm
)

159 #ifde
__USE_POSIX199309


161 
	simec


163 
timeec
 
_rv
;

164 
timeec
 
_vue
;

168 
sigevt
;

172 #ifde
__USE_XOPEN2K


173 #ide
__pid_t_defed


174 
__pid_t
 
	tpid_t
;

175 
	#__pid_t_defed


	)

180 #ifde
__USE_ISOC11


182 
	#TIME_UTC
 1

	)

186 
__BEGIN_NAMESPACE_STD


189 
ock_t
 
	$ock
 (
__THROW
;

192 
time_t
 
	$time
 (
time_t
 *
__tim

__THROW
;

195 
	$difime
 (
time_t
 
__time1
,ime_
__time0
)

196 
__THROW
 
	`__ibu__
 ((
__cڡ__
));

199 
time_t
 
	$mktime
 (
tm
 *
__

__THROW
;

205 
size_t
 
	$rime
 (*
__ri
 
__s
, 
size_t
 
__maxsize
,

206 cڡ *
__ri
 
__fm
,

207 cڡ 
tm
 *
__ri
 
__

__THROW
;

208 
__END_NAMESPACE_STD


210 #ifde
__USE_XOPEN


213 *
	$time
 (cڡ *
__ri
 
__s
,

214 cڡ *
__ri
 
__fmt
, 
tm
 *
__
)

215 
__THROW
;

218 #ifde
__USE_XOPEN2K8


221 
	~<xlo.h
>

223 
size_t
 
	$rime_l
 (*
__ri
 
__s
, 
size_t
 
__maxsize
,

224 cڡ *
__ri
 
__fm
,

225 cڡ 
tm
 *
__ri
 
__
,

226 
__lo_t
 
__loc

__THROW
;

229 #ifde
__USE_GNU


230 *
	$time_l
 (cڡ *
__ri
 
__s
,

231 cڡ *
__ri
 
__fmt
, 
tm
 *
__
,

232 
__lo_t
 
__loc

__THROW
;

236 
__BEGIN_NAMESPACE_STD


239 
tm
 *
	$gmtime
 (cڡ 
time_t
 *
__tim

__THROW
;

243 
tm
 *
	$loime
 (cڡ 
time_t
 *
__tim

__THROW
;

244 
__END_NAMESPACE_STD


246 #i
defed
 
__USE_POSIX
 || defed 
__USE_MISC


249 
tm
 *
	$gmtime_r
 (cڡ 
time_t
 *
__ri
 
__tim
,

250 
tm
 *
__ri
 
__

__THROW
;

254 
tm
 *
	$loime_r
 (cڡ 
time_t
 *
__ri
 
__tim
,

255 
tm
 *
__ri
 
__

__THROW
;

258 
__BEGIN_NAMESPACE_STD


261 *
	$asime
 (cڡ 
tm
 *
__

__THROW
;

264 *
	$ime
 (cڡ 
time_t
 *
__tim

__THROW
;

265 
__END_NAMESPACE_STD


267 #i
defed
 
__USE_POSIX
 || defed 
__USE_MISC


272 *
	$asime_r
 (cڡ 
tm
 *
__ri
 
__
,

273 *
__ri
 
__buf

__THROW
;

276 *
	$ime_r
 (cڡ 
time_t
 *
__ri
 
__tim
,

277 *
__ri
 
__buf

__THROW
;

282 *
__tzme
[2];

283 
__daylight
;

284 
__timeze
;

287 #ifdef 
__USE_POSIX


289 *
tzme
[2];

293 
	$tzt
 (
__THROW
;

296 #i
defed
 
__USE_SVID
 || defed 
__USE_XOPEN


297 
daylight
;

298 
timeze
;

301 #ifde
__USE_SVID


304 
	$ime
 (cڡ 
time_t
 *
__wh

__THROW
;

310 
	#__ip
(
yr
) \

311 ((
yr
% 4 =0 && ((yr% 100 !0 || (yr% 400 =0))

	)

314 #ifde
__USE_MISC


319 
time_t
 
	$timegm
 (
tm
 *
__

__THROW
;

322 
time_t
 
	$timol
 (
tm
 *
__

__THROW
;

325 
	$dysize
 (
__yr

__THROW
 
	`__ibu__
 ((
__cڡ__
));

329 #ifde
__USE_POSIX199309


334 
	`nop
 (cڡ 
timeec
 *
__queed_time
,

335 
timeec
 *
__mag
);

339 
	$ock_gs
 (
ockid_t
 
__ock_id
, 
timeec
 *
__s

__THROW
;

342 
	$ock_gtime
 (
ockid_t
 
__ock_id
, 
timeec
 *
__

__THROW
;

345 
	$ock_ime
 (
ockid_t
 
__ock_id
, cڡ 
timeec
 *
__
)

346 
__THROW
;

348 #ifde
__USE_XOPEN2K


353 
	`ock_nop
 (
ockid_t
 
__ock_id
, 
__ags
,

354 cڡ 
timeec
 *
__q
,

355 
timeec
 *
__m
);

358 
	$ock_guockid
 (
pid_t
 
__pid
, 
ockid_t
 *
__ock_id

__THROW
;

363 
	$tim_
 (
ockid_t
 
__ock_id
,

364 
sigevt
 *
__ri
 
__evp
,

365 
tim_t
 *
__ri
 
__timid

__THROW
;

368 
	$tim_de
 (
tim_t
 
__timid

__THROW
;

371 
	$tim_ime
 (
tim_t
 
__timid
, 
__ags
,

372 cڡ 
imec
 *
__ri
 
__vue
,

373 
imec
 *
__ri
 
__ovue

__THROW
;

376 
	$tim_gtime
 (
tim_t
 
__timid
, 
imec
 *
__vue
)

377 
__THROW
;

380 
	$tim_govrun
 (
tim_t
 
__timid

__THROW
;

384 #ifde
__USE_ISOC11


386 
	$timeec_g
 (
timeec
 *
__ts
, 
__ba
)

387 
__THROW
 
	`__nnu
 ((1));

391 #ifde
__USE_XOPEN_EXTENDED


403 
gde_r
;

412 
tm
 *
	`gde
 (cڡ *
__rg
);

415 #ifde
__USE_GNU


426 
	`gde_r
 (cڡ *
__ri
 
__rg
,

427 
tm
 *
__ri
 
__sbu
);

430 
__END_DECLS


	@/usr/include/xlocale.h

20 #ide
_XLOCALE_H


21 
	#_XLOCALE_H
 1

	)

27 
	s__lo_ru


30 
__lo_da
 *
	m__los
[13];

33 cڡ *
	m__y_b
;

34 cڡ *
	m__y_tow
;

35 cڡ *
	m__y_tou
;

38 cڡ *
	m__mes
[13];

39 } *
	t__lo_t
;

42 
__lo_t
 
	tlo_t
;

	@/usr/include/_G_config.h

4 #ide
_G_cfig_h


5 
	#_G_cfig_h
 1

	)

9 
	~<bs/tys.h
>

10 
	#__ed_size_t


	)

11 #i
defed
 
_LIBC
 || defed 
_GLIBCPP_USE_WCHAR_T


12 
	#__ed_wch_t


	)

14 
	#__ed_NULL


	)

15 
	~<ddef.h
>

16 
	#__ed_mbe_t


	)

17 #i
defed
 
_LIBC
 || defed 
_GLIBCPP_USE_WCHAR_T


18 
	#__ed_wt_t


	)

20 
	~<wch.h
>

23 
__off_t
 
	m__pos
;

24 
__mbe_t
 
	m__e
;

25 } 
	t_G_os_t
;

28 
__off64_t
 
	m__pos
;

29 
__mbe_t
 
	m__e
;

30 } 
	t_G_os64_t
;

31 #i
defed
 
_LIBC
 || defed 
_GLIBCPP_USE_WCHAR_T


32 
	~<gcv.h
>

35 
__gcv_fo
 
	m__cd
;

38 
__gcv_fo
 
	m__cd
;

39 
__gcv__da
 
	m__da
;

40 } 
	m__combed
;

41 } 
	t_G_icv_t
;

46 
	#_G_va_li
 
__gnuc_va_li


	)

48 
	#_G_HAVE_MMAP
 1

	)

49 
	#_G_HAVE_MREMAP
 1

	)

51 
	#_G_IO_IO_FILE_VERSION
 0x20001

	)

54 
	#_G_HAVE_ST_BLKSIZE
 
	`defed
 (
_STATBUF_ST_BLKSIZE
)

	)

56 
	#_G_BUFSIZ
 8192

	)

	@/usr/include/bits/byteswap.h

19 #i!
defed
 
_BYTESWAP_H
 && !defed 
_NETINET_IN_H
 && !defed 
_ENDIAN_H


23 #ide
_BITS_BYTESWAP_H


24 
	#_BITS_BYTESWAP_H
 1

	)

26 
	~<us.h
>

27 
	~<bs/tys.h
>

28 
	~<bs/wdsize.h
>

31 
	#__bsw_cڡt_16
(
x
) \

32 ((((((
x
>> 8& 0xff| (((x& 0xff<< 8)))

	)

35 
	~<bs/bysw-16.h
>

38 
	#__bsw_cڡt_32
(
x
) \

39 ((((
x
) & 0xff000000) >> 24) | (((x) & 0x00ff0000) >> 8) | \

40 (((
x
& 0x0000ff00<< 8| (((x& 0x000000ff<< 24))

	)

42 #ifde
__GNUC__


43 #i
__GNUC_PREREQ
 (4, 3)

44 
__le
 

45 
	$__bsw_32
 (
__bsx
)

47  
	`__but_bsw32
 (
__bsx
);

48 
	}
}

49 #i
__GNUC__
 >= 2

50 #i
__WORDSIZE
 =64 || (
defed
 
__i486__
 || defed 
__ium__
 \

51 || 
defed
 
	g__iumo__
 || defed 
	g__ium4__
 \

52 || 
defed
 
	g__k8__
 || defed 
	g__hl__
 \

53 || 
defed
 
	g__k6__
 || defed 
	g__noca__
 \

54 || 
defed
 
	g__ce2__
 || defed 
	g__geode__
 \

55 || 
defed
 
	g__amdm10__
)

58 
	#__bsw_32
(
x
) \

59 (
__exnsi__
 \

60 ({ 
__v
, 
__x
 = (
x
); \

61 i(
	`__but_cڡt_p
 (
__x
)) \

62 
__v
 = 
	`__bsw_cڡt_32
 (
__x
); \

64 
	`__asm__
 ("bsw %0" : "" (
__v
: "0" (
__x
)); \

65 
__v
; }))

	)

67 
	#__bsw_32
(
x
) \

68 (
__exnsi__
 \

69 ({ 
__v
, 
__x
 = (
x
); \

70 i(
	`__but_cڡt_p
 (
__x
)) \

71 
__v
 = 
	`__bsw_cڡt_32
 (
__x
); \

73 
	`__asm__
 ("rorw $8, %w0;" \

76 : "" (
__v
) \

77 : "0" (
__x
) \

79 
__v
; }))

	)

82 
	#__bsw_32
(
x
) \

83 (
__exnsi__
 \

84 ({ 
__x
 = (
x
); 
	`__bsw_cڡt_32
 (__x); }))

	)

87 
__le
 

88 
	$__bsw_32
 (
__bsx
)

90  
	`__bsw_cڡt_32
 (
__bsx
);

91 
	}
}

95 #i
__GNUC_PREREQ
 (2, 0)

97 
	#__bsw_cڡt_64
(
x
) \

98 (
	`__exnsi__
 ((((
x
) & 0xff00000000000000ull) >> 56) \

99 | (((
x
) & 0x00ff000000000000ull) >> 40) \

100 | (((
x
) & 0x0000ff0000000000ull) >> 24) \

101 | (((
x
) & 0x000000ff00000000ull) >> 8) \

102 | (((
x
) & 0x00000000ff000000ull) << 8) \

103 | (((
x
) & 0x0000000000ff0000ull) << 24) \

104 | (((
x
) & 0x000000000000ff00ull) << 40) \

105 | (((
x
& 0x00000000000000ffu<< 56)))

	)

107 #i
__GNUC_PREREQ
 (4, 3)

108 
__le
 
__ut64_t


109 
	$__bsw_64
 (
__ut64_t
 
__bsx
)

111  
	`__but_bsw64
 (
__bsx
);

112 
	}
}

113 #i
__WORDSIZE
 == 64

114 
	#__bsw_64
(
x
) \

115 (
__exnsi__
 \

116 ({ 
__ut64_t
 
__v
, 
__x
 = (
x
); \

117 i(
	`__but_cڡt_p
 (
__x
)) \

118 
__v
 = 
	`__bsw_cڡt_64
 (
__x
); \

120 
	`__asm__
 ("bsw %q0" : "" (
__v
: "0" (
__x
)); \

121 
__v
; }))

	)

123 
	#__bsw_64
(
x
) \

124 (
__exnsi__
 \

125 ({ uni { 
__exnsi__
 
__ut64_t
 
__
; \

126 
__l
[2]; } 
__w
, 
__r
; \

127 i(
	`__but_cڡt_p
 (
x
)) \

128 
__r
.
__
 = 
	`__bsw_cڡt_64
 (
x
); \

131 
__w
.
__
 = (
x
); \

132 
__r
.
__l
[0] = 
	`__bsw_32
 (
__w
.__l[1]); \

133 
__r
.
__l
[1] = 
	`__bsw_32
 (
__w
.__l[0]); \

135 
__r
.
__
; }))

	)

138 
	#__bsw_cڡt_64
(
x
) \

139 ((((
x
) & 0xff00000000000000ull) >> 56) \

140 | (((
x
) & 0x00ff000000000000ull) >> 40) \

141 | (((
x
) & 0x0000ff0000000000ull) >> 24) \

142 | (((
x
) & 0x000000ff00000000ull) >> 8) \

143 | (((
x
) & 0x00000000ff000000ull) << 8) \

144 | (((
x
) & 0x0000000000ff0000ull) << 24) \

145 | (((
x
) & 0x000000000000ff00ull) << 40) \

146 | (((
x
& 0x00000000000000ffu<< 56))

	)

148 
__le
 
__ut64_t


149 
	$__bsw_64
 (
__ut64_t
 
__bsx
)

151  
	`__bsw_cڡt_64
 (
__bsx
);

152 
	}
}

	@/usr/include/bits/endian.h

3 #ide
_ENDIAN_H


7 
	#__BYTE_ORDER
 
__LITTLE_ENDIAN


	)

	@/usr/include/bits/fcntl-linux.h

19 #idef 
_FCNTL_H


37 #ifde
__USE_GNU


38 
	~<bs/uio.h
>

42 
	#O_ACCMODE
 0003

	)

43 
	#O_RDONLY
 00

	)

44 
	#O_WRONLY
 01

	)

45 
	#O_RDWR
 02

	)

46 #ide
O_CREAT


47 
	#O_CREAT
 0100

	)

49 #ide
O_EXCL


50 
	#O_EXCL
 0200

	)

52 #ide
O_NOCTTY


53 
	#O_NOCTTY
 0400

	)

55 #ide
O_TRUNC


56 
	#O_TRUNC
 01000

	)

58 #ide
O_APPEND


59 
	#O_APPEND
 02000

	)

61 #ide
O_NONBLOCK


62 
	#O_NONBLOCK
 04000

	)

64 #ide
O_NDELAY


65 
	#O_NDELAY
 
O_NONBLOCK


	)

67 #ide
O_SYNC


68 
	#O_SYNC
 04010000

	)

70 
	#O_FSYNC
 
O_SYNC


	)

71 #ide
O_ASYNC


72 
	#O_ASYNC
 020000

	)

74 #ide
__O_LARGEFILE


75 
	#__O_LARGEFILE
 0100000

	)

78 #ide
__O_DIRECTORY


79 
	#__O_DIRECTORY
 0200000

	)

81 #ide
__O_NOFOLLOW


82 
	#__O_NOFOLLOW
 0400000

	)

84 #ide
__O_CLOEXEC


85 
	#__O_CLOEXEC
 02000000

	)

87 #ide
__O_DIRECT


88 
	#__O_DIRECT
 040000

	)

90 #ide
__O_NOATIME


91 
	#__O_NOATIME
 01000000

	)

93 #ide
__O_PATH


94 
	#__O_PATH
 010000000

	)

96 #ide
__O_DSYNC


97 
	#__O_DSYNC
 010000

	)

99 #ide
__O_TMPFILE


100 
	#__O_TMPFILE
 020200000

	)

103 #ide
F_GETLK


104 #ide
__USE_FILE_OFFSET64


105 
	#F_GETLK
 5

	)

106 
	#F_SETLK
 6

	)

107 
	#F_SETLKW
 7

	)

109 
	#F_GETLK
 
F_GETLK64


	)

110 
	#F_SETLK
 
F_SETLK64


	)

111 
	#F_SETLKW
 
F_SETLKW64


	)

114 #ide
F_GETLK64


115 
	#F_GETLK64
 12

	)

116 
	#F_SETLK64
 13

	)

117 
	#F_SETLKW64
 14

	)

120 #ifde
__USE_LARGEFILE64


121 
	#O_LARGEFILE
 
__O_LARGEFILE


	)

124 #ifde
__USE_XOPEN2K8


125 
	#O_DIRECTORY
 
__O_DIRECTORY


	)

126 
	#O_NOFOLLOW
 
__O_NOFOLLOW


	)

127 
	#O_CLOEXEC
 
__O_CLOEXEC


	)

130 #ifde
__USE_GNU


131 
	#O_DIRECT
 
__O_DIRECT


	)

132 
	#O_NOATIME
 
__O_NOATIME


	)

133 
	#O_PATH
 
__O_PATH


	)

134 
	#O_TMPFILE
 
__O_TMPFILE


	)

140 #i
defed
 
__USE_POSIX199309
 || defed 
__USE_UNIX98


141 
	#O_DSYNC
 
__O_DSYNC


	)

142 #i
defed
 
__O_RSYNC


143 
	#O_RSYNC
 
__O_RSYNC


	)

145 
	#O_RSYNC
 
O_SYNC


	)

150 
	#F_DUPFD
 0

	)

151 
	#F_GETFD
 1

	)

152 
	#F_SETFD
 2

	)

153 
	#F_GETFL
 3

	)

154 
	#F_SETFL
 4

	)

156 #ide
__F_SETOWN


157 
	#__F_SETOWN
 8

	)

158 
	#__F_GETOWN
 9

	)

161 #i
defed
 
__USE_BSD
 || defed 
__USE_UNIX98
 || defed 
__USE_XOPEN2K8


162 
	#F_SETOWN
 
__F_SETOWN


	)

163 
	#F_GETOWN
 
__F_GETOWN


	)

166 #ide
__F_SETSIG


167 
	#__F_SETSIG
 10

	)

168 
	#__F_GETSIG
 11

	)

170 #ide
__F_SETOWN_EX


171 
	#__F_SETOWN_EX
 15

	)

172 
	#__F_GETOWN_EX
 16

	)

175 #ifde
__USE_GNU


176 
	#F_SETSIG
 
__F_SETSIG


	)

177 
	#F_GETSIG
 
__F_GETSIG


	)

178 
	#F_SETOWN_EX
 
__F_SETOWN_EX


	)

179 
	#F_GETOWN_EX
 
__F_GETOWN_EX


	)

182 #ifde
__USE_GNU


183 
	#F_SETLEASE
 1024

	)

184 
	#F_GETLEASE
 1025

	)

185 
	#F_NOTIFY
 1026

	)

186 
	#F_SETPIPE_SZ
 1031

	)

187 
	#F_GETPIPE_SZ
 1032

	)

189 #ifde
__USE_XOPEN2K8


190 
	#F_DUPFD_CLOEXEC
 1030

	)

195 
	#FD_CLOEXEC
 1

	)

197 #ide
F_RDLCK


199 
	#F_RDLCK
 0

	)

200 
	#F_WRLCK
 1

	)

201 
	#F_UNLCK
 2

	)

206 #ide
F_EXLCK


207 
	#F_EXLCK
 4

	)

208 
	#F_SHLCK
 8

	)

211 #ifde
__USE_BSD


213 
	#LOCK_SH
 1

	)

214 
	#LOCK_EX
 2

	)

215 
	#LOCK_NB
 4

	)

217 
	#LOCK_UN
 8

	)

220 #ifde
__USE_GNU


221 
	#LOCK_MAND
 32

	)

222 
	#LOCK_READ
 64

	)

223 
	#LOCK_WRITE
 128

	)

224 
	#LOCK_RW
 192

	)

227 #ifde
__USE_GNU


229 
	#DN_ACCESS
 0x00000001

	)

230 
	#DN_MODIFY
 0x00000002

	)

231 
	#DN_CREATE
 0x00000004

	)

232 
	#DN_DELETE
 0x00000008

	)

233 
	#DN_RENAME
 0x00000010

	)

234 
	#DN_ATTRIB
 0x00000020

	)

235 
	#DN_MULTISHOT
 0x80000000

	)

239 #ifde
__USE_GNU


241 
	e__pid_ty


243 
	mF_OWNER_TID
 = 0,

244 
	mF_OWNER_PID
,

245 
	mF_OWNER_PGRP
,

246 
	mF_OWNER_GID
 = 
F_OWNER_PGRP


250 
	sf_owr_ex


252 
__pid_ty
 
	mty
;

253 
__pid_t
 
	mpid
;

259 #ifdef 
__USE_BSD


260 
	#FAPPEND
 
O_APPEND


	)

261 
	#FFSYNC
 
O_FSYNC


	)

262 
	#FASYNC
 
O_ASYNC


	)

263 
	#FNONBLOCK
 
O_NONBLOCK


	)

264 
	#FNDELAY
 
O_NDELAY


	)

267 #ide
__POSIX_FADV_DONTNEED


268 
	#__POSIX_FADV_DONTNEED
 4

	)

269 
	#__POSIX_FADV_NOREUSE
 5

	)

272 #ifde
__USE_XOPEN2K


273 
	#POSIX_FADV_NORMAL
 0

	)

274 
	#POSIX_FADV_RANDOM
 1

	)

275 
	#POSIX_FADV_SEQUENTIAL
 2

	)

276 
	#POSIX_FADV_WILLNEED
 3

	)

277 
	#POSIX_FADV_DONTNEED
 
__POSIX_FADV_DONTNEED


	)

278 
	#POSIX_FADV_NOREUSE
 
__POSIX_FADV_NOREUSE


	)

282 #ifde
__USE_GNU


284 
	#SYNC_FILE_RANGE_WAIT_BEFORE
 1

	)

287 
	#SYNC_FILE_RANGE_WRITE
 2

	)

290 
	#SYNC_FILE_RANGE_WAIT_AFTER
 4

	)

295 
	#SPLICE_F_MOVE
 1

	)

296 
	#SPLICE_F_NONBLOCK
 2

	)

299 
	#SPLICE_F_MORE
 4

	)

300 
	#SPLICE_F_GIFT
 8

	)

304 
	#FALLOC_FL_KEEP_SIZE
 1

	)

307 
	#FALLOC_FL_PUNCH_HOLE
 2

	)

311 
	sfe_hd


313 
	mhd_bys
;

314 
	mhd_ty
;

316 
	mf_hd
[0];

320 
	#MAX_HANDLE_SZ
 128

	)

324 #ifde
__USE_ATFILE


325 
	#AT_FDCWD
 -100

	)

328 
	#AT_SYMLINK_NOFOLLOW
 0x100

	)

329 
	#AT_REMOVEDIR
 0x200

	)

331 
	#AT_SYMLINK_FOLLOW
 0x400

	)

332 #ifde
__USE_GNU


333 
	#AT_NO_AUTOMOUNT
 0x800

	)

335 
	#AT_EMPTY_PATH
 0x1000

	)

337 
	#AT_EACCESS
 0x200

	)

341 
	g__BEGIN_DECLS


343 #ifde
__USE_GNU


346 
ssize_t
 
	$adahd
 (
__fd
, 
__off64_t
 
__offt
, 
size_t
 
__cou
)

347 
__THROW
;

354 
	`sync_fe_nge
 (
__fd
, 
__off64_t
 
__offt
, __off64_
__cou
,

355 
__ags
);

362 
ssize_t
 
	`vmli
 (
__fdout
, cڡ 
iovec
 *
__iov
,

363 
size_t
 
__cou
, 
__ags
);

369 
ssize_t
 
	`li
 (
__fd
, 
__off64_t
 *
__off
, 
__fdout
,

370 
__off64_t
 *
__offout
, 
size_t
 
__n
,

371 
__ags
);

377 
ssize_t
 
	`e
 (
__fd
, 
__fdout
, 
size_t
 
__n
,

378 
__ags
);

384 #ide
__USE_FILE_OFFSET64


385 
	`o
 (
__fd
, 
__mode
, 
__off_t
 
__offt
, __off_
__n
);

387 #ifde
__REDIRECT


388 
	`__REDIRECT
 (
o
, (
__fd
, 
__mode
, 
__off64_t
 
__offt
,

389 
__off64_t
 
__n
),

390 
o64
);

392 
	#o
 
o64


	)

395 #ifde
__USE_LARGEFILE64


396 
	`o64
 (
__fd
, 
__mode
, 
__off64_t
 
__offt
,

397 
__off64_t
 
__n
);

402 
	$me_to_hd_
 (
__dfd
, cڡ *
__me
,

403 
fe_hd
 *
__hd
, *
__m_id
,

404 
__ags

__THROW
;

410 
	`ݒ_by_hd_
 (
__moudfd
, 
fe_hd
 *
__hd
,

411 
__ags
);

415 
__END_DECLS


	@/usr/include/bits/libio-ldbl.h

19 #ide
_IO_STDIO_H


23 
	$__LDBL_REDIR_DECL
 (
_IO_vfsnf
)

24 
	`__LDBL_REDIR_DECL
 (
_IO_vrtf
)

	@/usr/include/bits/select.h

18 #ide
_SYS_SELECT_H


22 
	~<bs/wdsize.h
>

25 #i
defed
 
__GNUC__
 && __GNUC__ >= 2

27 #i
__WORDSIZE
 == 64

28 
	#__FD_ZERO_STOS
 "osq"

	)

30 
	#__FD_ZERO_STOS
 "o"

	)

33 
	#__FD_ZERO
(
fd
) \

35 
__d0
, 
__d1
; \

36 
__asm__
 
	`__vީe__
 ("d;; " 
__FD_ZERO_STOS
 \

37 : "=c" (
__d0
), "=D" (
__d1
) \

38 : "a" (0), "0" ( (
fd_t
) \

39 /  (
__fd_mask
)), \

40 "1" (&
	`__FDS_BITS
 (
fd
)[0]) \

42 } 0)

	)

48 
	#__FD_ZERO
(
t
) \

50 
__i
; \

51 
fd_t
 *
__r
 = (
t
); \

52 
__i
 = 0; __<  (
fd_t
/  (
__fd_mask
); ++__i) \

53 
	`__FDS_BITS
 (
__r
)[
__i
] = 0; \

54 } 0)

	)

58 
	#__FD_SET
(
d
, 
t
) \

59 (((
	`__FDS_BITS
 (
t
)[
	`__FD_ELT
 (
d
)] |
	`__FD_MASK
 (d)))

	)

60 
	#__FD_CLR
(
d
, 
t
) \

61 (((
	`__FDS_BITS
 (
t
)[
	`__FD_ELT
 (
d
)] &~
	`__FD_MASK
 (d)))

	)

62 
	#__FD_ISSET
(
d
, 
t
) \

63 ((
	`__FDS_BITS
 (
t
)[
	`__FD_ELT
 (
d
)] & 
	`__FD_MASK
 (d)!0)

	)

	@/usr/include/bits/select2.h

19 #ide
_SYS_SELECT_H


24 
__fdt_chk
 (
__d
);

25 
	$__fdt_wn
 (
__d
)

26 
	`__wǉr
 ("bit outside of fd_set selected");

27 #unde
__FD_ELT


28 
	#__FD_ELT
(
d
) \

29 
__exnsi__
 \

30 ({ 
__d
 = (
d
); \

31 (
	`__but_cڡt_p
 (
__d
) \

32 ? (0 <
__d
 && __d < 
__FD_SETSIZE
 \

33 ? (
__d
 / 
__NFDBITS
) \

34 : 
	`__fdt_wn
 (
__d
)) \

35 : 
	`__fdt_chk
 (
__d
)); 
	}
})

	)

	@/usr/include/bits/sigset.h

19 #idef 
_SIGSET_H_tys


20 
	#_SIGSET_H_tys
 1

	)

22 
	t__sig_omic_t
;

26 
	#_SIGSET_NWORDS
 (1024 / (8 *  ()))

	)

29 
	m__v
[
_SIGSET_NWORDS
];

30 } 
	t__sigt_t
;

41 #i!
defed
 
_SIGSET_H_s
 && defed 
_SIGNAL_H


42 
	#_SIGSET_H_s
 1

	)

44 #ide
_EXTERN_INLINE


45 
	#_EXTERN_INLINE
 
__ex_le


	)

49 
	#__sigmask
(
sig
) \

50 (((1<< (((
sig
- 1% (8 *  ())))

	)

53 
	#__sigwd
(
sig
(((sig- 1/ (8 *  ()))

	)

55 #i
defed
 
__GNUC__
 && __GNUC__ >= 2

56 
	#__sigemyt
(
t
) \

57 (
	`__exnsi__
 ({ 
__t
 = 
_SIGSET_NWORDS
; \

58 
sigt_t
 *
__t
 = (
t
); \

59 --
__t
 >0
__t
->
__v
[__cnt] = 0; \

60 0; }))

	)

61 
	#__sigflt
(
t
) \

62 (
	`__exnsi__
 ({ 
__t
 = 
_SIGSET_NWORDS
; \

63 
sigt_t
 *
__t
 = (
t
); \

64 --
__t
 >0
__t
->
__v
[__cnt] = ~0UL; \

65 0; }))

	)

67 #ifde
__USE_GNU


71 
	#__sigimyt
(
t
) \

72 (
	`__exnsi__
 ({ 
__t
 = 
_SIGSET_NWORDS
; \

73 cڡ 
sigt_t
 *
__t
 = (
t
); \

74 
__t
 = 
__t
->
__v
[--
__t
]; \

75 !
__t
 && --
__t
 >= 0) \

76 
__t
 = 
__t
->
__v
[
__t
]; \

77 
__t
 =0; }))

	)

78 
	#__sigdt
(
de
, 

, 
right
) \

79 (
	`__exnsi__
 ({ 
__t
 = 
_SIGSET_NWORDS
; \

80 
sigt_t
 *
__de
 = (
de
); \

81 cڡ 
sigt_t
 *
__
 = (

); \

82 cڡ 
sigt_t
 *
__right
 = (
right
); \

83 --
__t
 >= 0) \

84 
__de
->
__v
[
__t
] = (
__
->__val[__cnt] \

85 & 
__right
->
__v
[
__t
]); \

86 0; }))

	)

87 
	#__sigܣt
(
de
, 

, 
right
) \

88 (
	`__exnsi__
 ({ 
__t
 = 
_SIGSET_NWORDS
; \

89 
sigt_t
 *
__de
 = (
de
); \

90 cڡ 
sigt_t
 *
__
 = (

); \

91 cڡ 
sigt_t
 *
__right
 = (
right
); \

92 --
__t
 >= 0) \

93 
__de
->
__v
[
__t
] = (
__
->__val[__cnt] \

94 | 
__right
->
__v
[
__t
]); \

95 0; }))

	)

102 
__sigismemb
 (cڡ 
__sigt_t
 *, );

103 
__sigaddt
 (
__sigt_t
 *, );

104 
__sigdt
 (
__sigt_t
 *, );

106 #ifde
__USE_EXTERN_INLINES


107 
	#__SIGSETFN
(
NAME
, 
BODY
, 
CONST
) \

108 
_EXTERN_INLINE
 \

109 
	`NAME
 (
CONST
 
__sigt_t
 *
__t
, 
__sig
) \

111 
__mask
 = 
	`__sigmask
 (
__sig
); \

112 
__wd
 = 
	`__sigwd
 (
__sig
); \

113  
BODY
; \

114 }

	)

116 
__SIGSETFN
 (
__sigismemb
, (
__t
->
__v
[
__wd
] & 
__mask
) ? 1 : 0, const)

117 
__SIGSETFN
 (
__sigaddt
, ((
__t
->
__v
[
__wd
] |
__mask
), 0), )

118 
__SIGSETFN
 (
__sigdt
, ((
__t
->
__v
[
__wd
] &~
__mask
), 0), )

120 #unde
__SIGSETFN


	@/usr/include/bits/stdio-lock.h

19 #ide
_BITS_STDIO_LOCK_H


20 
	#_BITS_STDIO_LOCK_H
 1

	)

22 
	~<bs/libc-lock.h
>

23 
	~<lowvlock.h
>

27 
	#_IO_lock_exnsive
 1

	)

29 ru { 
	mlock
; 
	mt
; *
	mowr
; } 
	t_IO_lock_t
;

31 
	#_IO_lock_liz
 { 
LLL_LOCK_INITIALIZER
, 0, 
NULL
 }

	)

33 
	#_IO_lock_
(
_me
) \

34 ((
_me
(
_IO_lock_t

_IO_lock_liz
 , 0)

	)

36 
	#_IO_lock_fi
(
_me
) \

37 ((0)

	)

39 
	#_IO_lock_lock
(
_me
) \

41 *
__lf
 = 
THREAD_SELF
; \

42 i((
_me
).
owr
 !
__lf
) \

44 
	`l_lock
 ((
_me
).
lock
, 
LLL_PRIVATE
); \

45 (
_me
).
owr
 = 
__lf
; \

47 ++(
_me
).
t
; \

48 } 0)

	)

50 
	#_IO_lock_ylock
(
_me
) \

52 
__su
 = 0; \

53 *
__lf
 = 
THREAD_SELF
; \

54 i((
_me
).
owr
 !
__lf
) \

56 i(
	`l_ylock
 ((
_me
).
lock
) == 0) \

58 (
_me
).
owr
 = 
__lf
; \

59 (
_me
).
t
 = 1; \

62 
__su
 = 
EBUSY
; \

65 ++(
_me
).
t
; \

66 
__su
; \

67 })

	)

69 
	#_IO_lock_uock
(
_me
) \

71 i(--(
_me
).
t
 == 0) \

73 (
_me
).
owr
 = 
NULL
; \

74 
	`l_uock
 ((
_me
).
lock
, 
LLL_PRIVATE
); \

76 } 0)

	)

80 
	#_IO_nup_gi_t
(
_f
, 
_
) \

81 
	`__libc_nup_gi_t
 (((
_
)->
_ags
 & 
_IO_USER_LOCK
=0, 
_f
, _)

	)

82 
	#_IO_nup_gi_t_nrg
(
_f
) \

83 
	`__libc_nup_gi_t
 (1, 
_f
, 
NULL
)

	)

84 
	#_IO_nup_gi_d
(
_do
) \

85 
	`__libc_nup_gi_d
 (
_do
)

	)

87 #i
defed
 
_LIBC
 && !defed 
NOT_IN_libc


89 #ifde
__EXCEPTIONS


90 
	#_IO_acque_lock
(
_
) \

92 
_IO_FILE
 *
_IO_acque_lock_fe
 \

93 
	`__ibu__
((
	`nup
 (
_IO_acque_lock_f
))) \

94 (
_
); \

95 
	`_IO_ockfe
 (
_IO_acque_lock_fe
);

	)

96 
	#_IO_acque_lock_r_ags2
(
_
) \

98 
_IO_FILE
 *
_IO_acque_lock_fe
 \

99 
	`__ibu__
((
	`nup
 (
_IO_acque_lock_r_ags2_f
))) \

100 (
_
); \

101 
	`_IO_ockfe
 (
_IO_acque_lock_fe
);

	)

103 
	#_IO_acque_lock
(
_

_IO_acque_lock_eds_exis_abd


	)

104 
	#_IO_acque_lock_r_ags2
(
_

	`_IO_acque_lock
 (_)

	)

106 
	#_IO_a_lock
(
_
; } 0)

	)

	@/usr/include/bits/time.h

23 #i
defed
 
__ed_timev
 || defed 
__USE_GNU


24 #ide
_STRUCT_TIMEVAL


25 
	#_STRUCT_TIMEVAL
 1

	)

26 
	~<bs/tys.h
>

30 
	stimev


32 
__time_t
 
	mtv_c
;

33 
__sucds_t
 
	mtv_uc
;

38 #ide
__ed_timev


39 #ide
_BITS_TIME_H


40 
	#_BITS_TIME_H
 1

	)

48 
	#CLOCKS_PER_SEC
 1000000l

	)

50 #i(!
defed
 
__STRICT_ANSI__
 || defed 
__USE_POSIX
) \

51 && !
defed
 
	g__USE_XOPEN2K


54 
	~<bs/tys.h
>

55 
__syscf
 ();

56 
	#CLK_TCK
 ((
__ock_t

	`__syscf
 (2)

	)

59 #ifde
__USE_POSIX199309


61 
	#CLOCK_REALTIME
 0

	)

63 
	#CLOCK_MONOTONIC
 1

	)

65 
	#CLOCK_PROCESS_CPUTIME_ID
 2

	)

67 
	#CLOCK_THREAD_CPUTIME_ID
 3

	)

69 
	#CLOCK_MONOTONIC_RAW
 4

	)

71 
	#CLOCK_REALTIME_COARSE
 5

	)

73 
	#CLOCK_MONOTONIC_COARSE
 6

	)

75 
	#CLOCK_BOOTTIME
 7

	)

77 
	#CLOCK_REALTIME_ALARM
 8

	)

79 
	#CLOCK_BOOTTIME_ALARM
 9

	)

82 
	#TIMER_ABSTIME
 1

	)

85 #ifde
__USE_GNU


86 
	~<bs/timex.h
>

88 
__BEGIN_DECLS


91 
	$ock_adjtime
 (
__ockid_t
 
__ock_id
, 
timex
 *
__utx

__THROW
;

93 
__END_DECLS


99 #unde
__ed_timev


	@/usr/include/bits/typesizes.h

19 #ide
_BITS_TYPES_H


23 #idef 
_BITS_TYPESIZES_H


24 
	#_BITS_TYPESIZES_H
 1

	)

30 #i
defed
 
__x86_64__
 && defed 
__ILP32__


31 
	#__SYSCALL_SLONG_TYPE
 
__SQUAD_TYPE


	)

32 
	#__SYSCALL_ULONG_TYPE
 
__UQUAD_TYPE


	)

34 
	#__SYSCALL_SLONG_TYPE
 
__SLONGWORD_TYPE


	)

35 
	#__SYSCALL_ULONG_TYPE
 
__ULONGWORD_TYPE


	)

38 
	#__DEV_T_TYPE
 
__UQUAD_TYPE


	)

39 
	#__UID_T_TYPE
 
__U32_TYPE


	)

40 
	#__GID_T_TYPE
 
__U32_TYPE


	)

41 
	#__INO_T_TYPE
 
__SYSCALL_ULONG_TYPE


	)

42 
	#__INO64_T_TYPE
 
__UQUAD_TYPE


	)

43 
	#__MODE_T_TYPE
 
__U32_TYPE


	)

44 #ifde
__x86_64__


45 
	#__NLINK_T_TYPE
 
__SYSCALL_ULONG_TYPE


	)

46 
	#__FSWORD_T_TYPE
 
__SYSCALL_SLONG_TYPE


	)

48 
	#__NLINK_T_TYPE
 
__UWORD_TYPE


	)

49 
	#__FSWORD_T_TYPE
 
__SWORD_TYPE


	)

51 
	#__OFF_T_TYPE
 
__SYSCALL_SLONG_TYPE


	)

52 
	#__OFF64_T_TYPE
 
__SQUAD_TYPE


	)

53 
	#__PID_T_TYPE
 
__S32_TYPE


	)

54 
	#__RLIM_T_TYPE
 
__SYSCALL_ULONG_TYPE


	)

55 
	#__RLIM64_T_TYPE
 
__UQUAD_TYPE


	)

56 
	#__BLKCNT_T_TYPE
 
__SYSCALL_SLONG_TYPE


	)

57 
	#__BLKCNT64_T_TYPE
 
__SQUAD_TYPE


	)

58 
	#__FSBLKCNT_T_TYPE
 
__SYSCALL_ULONG_TYPE


	)

59 
	#__FSBLKCNT64_T_TYPE
 
__UQUAD_TYPE


	)

60 
	#__FSFILCNT_T_TYPE
 
__SYSCALL_ULONG_TYPE


	)

61 
	#__FSFILCNT64_T_TYPE
 
__UQUAD_TYPE


	)

62 
	#__ID_T_TYPE
 
__U32_TYPE


	)

63 
	#__CLOCK_T_TYPE
 
__SYSCALL_SLONG_TYPE


	)

64 
	#__TIME_T_TYPE
 
__SYSCALL_SLONG_TYPE


	)

65 
	#__USECONDS_T_TYPE
 
__U32_TYPE


	)

66 
	#__SUSECONDS_T_TYPE
 
__SYSCALL_SLONG_TYPE


	)

67 
	#__DADDR_T_TYPE
 
__S32_TYPE


	)

68 
	#__KEY_T_TYPE
 
__S32_TYPE


	)

69 
	#__CLOCKID_T_TYPE
 
__S32_TYPE


	)

70 
	#__TIMER_T_TYPE
 *

	)

71 
	#__BLKSIZE_T_TYPE
 
__SYSCALL_SLONG_TYPE


	)

72 
	#__FSID_T_TYPE
 su { 
__v
[2]; }

	)

73 
	#__SSIZE_T_TYPE
 
__SWORD_TYPE


	)

75 #ifde
__x86_64__


79 
	#__OFF_T_MATCHES_OFF64_T
 1

	)

82 
	#__INO_T_MATCHES_INO64_T
 1

	)

86 
	#__FD_SETSIZE
 1024

	)

	@/usr/include/bits/wordsize.h

3 #i
defed
 
__x86_64__
 && !defed 
__ILP32__


4 
	#__WORDSIZE
 64

	)

6 
	#__WORDSIZE
 32

	)

9 #ifde
__x86_64__


10 
	#__WORDSIZE_TIME64_COMPAT32
 1

	)

12 
	#__SYSCALL_WORDSIZE
 64

	)

	@/usr/include/ctype.h

22 #idef 
_CTYPE_H


23 
	#_CTYPE_H
 1

	)

25 
	~<us.h
>

26 
	~<bs/tys.h
>

28 
	g__BEGIN_DECLS


30 #ide
_ISb


39 
	~<dn.h
>

40 #i
__BYTE_ORDER
 =
__BIG_ENDIAN


41 
	#_ISb
(
b
(1 << (b))

	)

43 
	#_ISb
(
b
((b< 8 ? ((1 << (b)<< 8: ((1 << (b)>> 8))

	)

48 
	m_ISu
 = 
_ISb
 (0),

49 
	m_ISlow
 = 
_ISb
 (1),

50 
	m_ISpha
 = 
_ISb
 (2),

51 
	m_ISdig
 = 
_ISb
 (3),

52 
	m_ISxdig
 = 
_ISb
 (4),

53 
	m_ISa
 = 
_ISb
 (5),

54 
	m_ISt
 = 
_ISb
 (6),

55 
	m_ISgph
 = 
_ISb
 (7),

56 
	m_ISbnk
 = 
_ISb
 (8),

57 
	m_ISl
 = 
_ISb
 (9),

58 
	m_ISpun
 = 
_ISb
 (10),

59 
	m_ISnum
 = 
_ISb
 (11)

79 cڡ **
	$__y_b_loc
 ()

80 
__THROW
 
	`__ibu__
 ((
__cڡ__
));

81 cڡ 
__t32_t
 **
	$__y_tow_loc
 ()

82 
__THROW
 
	`__ibu__
 ((
__cڡ__
));

83 cڡ 
__t32_t
 **
	$__y_tou_loc
 ()

84 
__THROW
 
	`__ibu__
 ((
__cڡ__
));

87 #ide
__lulus


88 
	#__isy
(
c
, 
ty
) \

89 ((*
	`__y_b_loc
 ())[((
c
)] & (
ty
)

	)

90 #i
defed
 
__USE_EXTERN_INLINES


91 
	#__isy_f
(
ty
) \

92 
__ex_le
 \

93 
is
##
	`ty
 (
__c

__THROW
 \

95  (*
	`__y_b_loc
 ())[((
__c
)] & (
_IS
##
ty
; \

96 
	}

	)
}

99 
	#__iscii
(
c
(((c& ~0x7f=0

	)

100 
	#__tscii
(
c
((c& 0x7f

	)

102 
	#__exy
(
me

	`me
 (
__THROW


	)

104 
__BEGIN_NAMESPACE_STD


110 
__exy
 (
ium
);

111 
__exy
 (
iha
);

112 
__exy
 (
isl
);

113 
__exy
 (
isdig
);

114 
__exy
 (
iow
);

115 
__exy
 (
isgph
);

116 
__exy
 (
irt
);

117 
__exy
 (
iun
);

118 
__exy
 (
isa
);

119 
__exy
 (
isu
);

120 
__exy
 (
isxdig
);

124 
	$tow
 (
__c

__THROW
;

127 
	$tou
 (
__c

__THROW
;

129 
__END_NAMESPACE_STD


133 #ifdef 
__USE_ISOC99


134 
__BEGIN_NAMESPACE_C99


136 
	`__exy
 (
isbnk
);

138 
__END_NAMESPACE_C99


141 #ifde
__USE_GNU


143 
	$isy
 (
__c
, 
__mask

__THROW
;

146 #i
defed
 
__USE_SVID
 || defed 
__USE_MISC
 || defed 
__USE_XOPEN


150 
	$iscii
 (
__c

__THROW
;

154 
	$tscii
 (
__c

__THROW
;

158 
	`__exy
 (
_tou
);

159 
	`__exy
 (
_tow
);

163 
	#__tobody
(
c
, 
f
, 
a
, 
gs
) \

164 (
__exnsi__
 \

165 ({ 
__s
; \

166 i( (
c
) > 1) \

168 i(
	`__but_cڡt_p
 (
c
)) \

170 
__c
 = (
c
); \

171 
__s
 = 
__c
 < -128 || __> 255 ? __: (
a
)[__c]; \

174 
__s
 = 
f
 
gs
; \

177 
__s
 = (
a
)[((
c
)]; \

178 
__s
; 
	}
}))

	)

180 #i!
defed
 
__NO_CTYPE


181 #ifde
__isy_f


182 
	$__isy_f
 (
num
)

183 
	$__isy_f
 (
pha
)

184 
	$__isy_f
 (
l
)

185 
	$__isy_f
 (
dig
)

186 
	$__isy_f
 (
low
)

187 
	$__isy_f
 (
gph
)

188 
	$__isy_f
 (
t
)

189 
	$__isy_f
 (
pun
)

190 
	$__isy_f
 (
a
)

191 
	$__isy_f
 (
u
)

192 
	$__isy_f
 (
xdig
)

193 #ifde
__USE_ISOC99


194 
	$__isy_f
 (
bnk
)

196 #i
defed
 
__isy


197 
	#ium
(
c

	`__isy
((c), 
_ISnum
)

	)

198 
	#iha
(
c

	`__isy
((c), 
_ISpha
)

	)

199 
	#isl
(
c

	`__isy
((c), 
_ISl
)

	)

200 
	#isdig
(
c

	`__isy
((c), 
_ISdig
)

	)

201 
	#iow
(
c

	`__isy
((c), 
_ISlow
)

	)

202 
	#isgph
(
c

	`__isy
((c), 
_ISgph
)

	)

203 
	#irt
(
c

	`__isy
((c), 
_ISt
)

	)

204 
	#iun
(
c

	`__isy
((c), 
_ISpun
)

	)

205 
	#isa
(
c

	`__isy
((c), 
_ISa
)

	)

206 
	#isu
(
c

	`__isy
((c), 
_ISu
)

	)

207 
	#isxdig
(
c

	`__isy
((c), 
_ISxdig
)

	)

208 #ifde
__USE_ISOC99


209 
	#isbnk
(
c

	`__isy
((c), 
_ISbnk
)

	)

213 #ifde
__USE_EXTERN_INLINES


214 
__ex_le
 

215 
	`__NTH
 (
	$tow
 (
__c
))

217  
__c
 >-128 && __< 256 ? (*
	`__y_tow_loc
 ())[__c] : __c;

218 
	}
}

220 
__ex_le
 

221 
__NTH
 (
	$tou
 (
__c
))

223  
__c
 >-128 && __< 256 ? (*
	`__y_tou_loc
 ())[__c] : __c;

224 
	}
}

227 #i
__GNUC__
 >2 && 
defed
 
__OPTIMIZE__
 && !defed 
__lulus


228 
	#tow
(
c

	`__tobody
 (c, 
tow
, *
	`__y_tow_loc
 (), (c))

	)

229 
	#tou
(
c

	`__tobody
 (c, 
tou
, *
	`__y_tou_loc
 (), (c))

	)

232 #i
defed
 
__USE_SVID
 || defed 
__USE_MISC
 || defed 
__USE_XOPEN


233 
	#iscii
(
c

	`__iscii
 (c)

	)

234 
	#tscii
(
c

	`__tscii
 (c)

	)

236 
	#_tow
(
c
(((*
	`__y_tow_loc
 ())[((c)])

	)

237 
	#_tou
(
c
(((*
	`__y_tou_loc
 ())[((c)])

	)

243 #ifde
__USE_XOPEN2K8


257 
	~<xlo.h
>

261 
	#__isy_l
(
c
, 
ty
, 
lo
) \

262 ((
lo
)->
__y_b
[((
c
)] & (
ty
)

	)

264 
	#__exy_l
(
me
) \

265 
	`me
 (, 
__lo_t

__THROW


	)

271 
__exy_l
 (
ium_l
);

272 
__exy_l
 (
iha_l
);

273 
__exy_l
 (
isl_l
);

274 
__exy_l
 (
isdig_l
);

275 
__exy_l
 (
iow_l
);

276 
__exy_l
 (
isgph_l
);

277 
__exy_l
 (
irt_l
);

278 
__exy_l
 (
iun_l
);

279 
__exy_l
 (
isa_l
);

280 
__exy_l
 (
isu_l
);

281 
__exy_l
 (
isxdig_l
);

283 
__exy_l
 (
isbnk_l
);

287 
	$__tow_l
 (
__c
, 
__lo_t
 
__l

__THROW
;

288 
	$tow_l
 (
__c
, 
__lo_t
 
__l

__THROW
;

291 
	$__tou_l
 (
__c
, 
__lo_t
 
__l

__THROW
;

292 
	$tou_l
 (
__c
, 
__lo_t
 
__l

__THROW
;

294 #i
__GNUC__
 >2 && 
defed
 
__OPTIMIZE__
 && !defed 
__lulus


295 
	#__tow_l
(
c
, 
lo
) \

296 
	`__tobody
 (
c
, 
__tow_l
, (
lo
)->
__y_tow
, (c,o))

	)

297 
	#__tou_l
(
c
, 
lo
) \

298 
	`__tobody
 (
c
, 
__tou_l
, (
lo
)->
__y_tou
, (c,o))

	)

299 
	#tow_l
(
c
, 
lo

	`__tow_l
 ((c), (lo))

	)

300 
	#tou_l
(
c
, 
lo

	`__tou_l
 ((c), (lo))

	)

304 #ide
__NO_CTYPE


305 
	#__ium_l
(
c
,
l

	`__isy_l
((c), 
_ISnum
, (l))

	)

306 
	#__iha_l
(
c
,
l

	`__isy_l
((c), 
_ISpha
, (l))

	)

307 
	#__isl_l
(
c
,
l

	`__isy_l
((c), 
_ISl
, (l))

	)

308 
	#__isdig_l
(
c
,
l

	`__isy_l
((c), 
_ISdig
, (l))

	)

309 
	#__iow_l
(
c
,
l

	`__isy_l
((c), 
_ISlow
, (l))

	)

310 
	#__isgph_l
(
c
,
l

	`__isy_l
((c), 
_ISgph
, (l))

	)

311 
	#__irt_l
(
c
,
l

	`__isy_l
((c), 
_ISt
, (l))

	)

312 
	#__iun_l
(
c
,
l

	`__isy_l
((c), 
_ISpun
, (l))

	)

313 
	#__isa_l
(
c
,
l

	`__isy_l
((c), 
_ISa
, (l))

	)

314 
	#__isu_l
(
c
,
l

	`__isy_l
((c), 
_ISu
, (l))

	)

315 
	#__isxdig_l
(
c
,
l

	`__isy_l
((c), 
_ISxdig
, (l))

	)

317 
	#__isbnk_l
(
c
,
l

	`__isy_l
((c), 
_ISbnk
, (l))

	)

319 #i
defed
 
__USE_SVID
 || defed 
__USE_MISC


320 
	#__iscii_l
(
c
,
l
(), 
	`__iscii
 (c))

	)

321 
	#__tscii_l
(
c
,
l
(), 
	`__tscii
 (c))

	)

324 
	#ium_l
(
c
,
l

	`__ium_l
 ((c), (l))

	)

325 
	#iha_l
(
c
,
l

	`__iha_l
 ((c), (l))

	)

326 
	#isl_l
(
c
,
l

	`__isl_l
 ((c), (l))

	)

327 
	#isdig_l
(
c
,
l

	`__isdig_l
 ((c), (l))

	)

328 
	#iow_l
(
c
,
l

	`__iow_l
 ((c), (l))

	)

329 
	#isgph_l
(
c
,
l

	`__isgph_l
 ((c), (l))

	)

330 
	#irt_l
(
c
,
l

	`__irt_l
 ((c), (l))

	)

331 
	#iun_l
(
c
,
l

	`__iun_l
 ((c), (l))

	)

332 
	#isa_l
(
c
,
l

	`__isa_l
 ((c), (l))

	)

333 
	#isu_l
(
c
,
l

	`__isu_l
 ((c), (l))

	)

334 
	#isxdig_l
(
c
,
l

	`__isxdig_l
 ((c), (l))

	)

336 
	#isbnk_l
(
c
,
l

	`__isbnk_l
 ((c), (l))

	)

338 #i
defed
 
__USE_SVID
 || defed 
__USE_MISC


339 
	#iscii_l
(
c
,
l

	`__iscii_l
 ((c), (l))

	)

340 
	#tscii_l
(
c
,
l

	`__tscii_l
 ((c), (l))

	)

347 
__END_DECLS


	@/usr/include/gnu/stubs.h

6 #i!
defed
 
__x86_64__


7 
	~<gnu/ubs-32.h
>

9 #i
defed
 
__x86_64__
 && defed 
__LP64__


10 
	~<gnu/ubs-64.h
>

12 #i
defed
 
__x86_64__
 && defed 
__ILP32__


13 
	~<gnu/ubs-x32.h
>

	@/usr/include/linux/errno.h

1 
	~<asm/o.h
>

	@/usr/include/stdc-predef.h

18 #idef 
_STDC_PREDEF_H


19 
	#_STDC_PREDEF_H
 1

	)

36 #ifde
__GCC_IEC_559


37 #i
__GCC_IEC_559
 > 0

38 
	#__STDC_IEC_559__
 1

	)

41 
	#__STDC_IEC_559__
 1

	)

44 #ifde
__GCC_IEC_559_COMPLEX


45 #i
__GCC_IEC_559_COMPLEX
 > 0

46 
	#__STDC_IEC_559_COMPLEX__
 1

	)

49 
	#__STDC_IEC_559_COMPLEX__
 1

	)

54 
	#__STDC_ISO_10646__
 201103L

	)

57 
	#__STDC_NO_THREADS__
 1

	)

	@/usr/include/sys/cdefs.h

18 #idef 
_SYS_CDEFS_H


19 
	#_SYS_CDEFS_H
 1

	)

22 #ide
_FEATURES_H


23 
	~<us.h
>

29 #i
defed
 
__GNUC__
 && !defed 
__STDC__


34 #unde
__P


35 #unde
__PMT


37 #ifde
__GNUC__


41 #i
__GNUC_PREREQ
 (4, 6&& !
defed
 
_LIBC


42 
	#__LEAF
 , 
__af__


	)

43 
	#__LEAF_ATTR
 
	`__ibu__
 ((
__af__
))

	)

45 
	#__LEAF


	)

46 
	#__LEAF_ATTR


	)

54 #i!
defed
 
__lulus
 && 
__GNUC_PREREQ
 (3, 3)

55 
	#__THROW
 
	`__ibu__
 ((
__nhrow__
 
__LEAF
))

	)

56 
	#__THROWNL
 
	`__ibu__
 ((
__nhrow__
))

	)

57 
	#__NTH
(
f

	`__ibu__
 ((
__nhrow__
 
__LEAF
)
	)
fct

59 #i
defed
 
__lulus
 && 
__GNUC_PREREQ
 (2,8)

60 
	#__THROW
 
	`throw
 ()

	)

61 
	#__THROWNL
 
	`throw
 ()

	)

62 
	#__NTH
(
f

__LEAF_ATTR
 f 
	`throw
 ()

	)

64 
	#__THROW


	)

65 
	#__THROWNL


	)

66 
	#__NTH
(
f

	)
fct

72 
	#__le


	)

74 
	#__THROW


	)

75 
	#__THROWNL


	)

76 
	#__NTH
(
f

	)
fct

82 
	#__P
(
gs

	)
args

83 
	#__PMT
(
gs

	)
args

88 
	#__CONCAT
(
x
,
y
x ## 
	)
y

89 
	#__STRING
(
x
#x

	)

92 
	#__r_t
 *

	)

93 
	#__lg_doub_t
 

	)

97 #ifdef 
__lulus


98 
	#__BEGIN_DECLS
 "C" {

	)

99 
	#__END_DECLS
 }

	)

101 
	#__BEGIN_DECLS


	)

102 
	#__END_DECLS


	)

111 #i
defed
 
__lulus
 && defed 
_GLIBCPP_USE_NAMESPACES


112 
	#__BEGIN_NAMESPACE_STD
 
mea
 
d
 {

	)

113 
	#__END_NAMESPACE_STD
 }

	)

114 
	#__USING_NAMESPACE_STD
(
me

usg
 
d
::me;

	)

115 
	#__BEGIN_NAMESPACE_C99
 
mea
 
__c99
 {

	)

116 
	#__END_NAMESPACE_C99
 }

	)

117 
	#__USING_NAMESPACE_C99
(
me

usg
 
__c99
::me;

	)

122 
	#__BEGIN_NAMESPACE_STD


	)

123 
	#__END_NAMESPACE_STD


	)

124 
	#__USING_NAMESPACE_STD
(
me
)

	)

125 
	#__BEGIN_NAMESPACE_C99


	)

126 
	#__END_NAMESPACE_C99


	)

127 
	#__USING_NAMESPACE_C99
(
me
)

	)

132 
	#__bos
(
r

	`__but_obje_size
 (r, 
__USE_FORTIFY_LEVEL
 > 1)

	)

133 
	#__bos0
(
r

	`__but_obje_size
 (r, 0)

	)

134 
	#__ftify_funi
 
__ex_ways_le
 
__ibu_tificl__


	)

136 #i
__GNUC_PREREQ
 (4,3)

137 
	#__wnde
(
me
, 
msg
) \

138 
	`me
 (
	`__ibu__
((
	`__wng__
 (
msg
)))

	)

139 
	#__wǉr
(
msg

	`__ibu__
((
	`__wng__
 (msg)))

	)

140 
	#__rde
(
me
, 
msg
) \

141 
	`me
 (
	`__ibu__
((
	`__r__
 (
msg
)))

	)

143 
	#__wnde
(
me
, 
msg

	`me
 ()

	)

144 
	#__wǉr
(
msg
)

	)

145 
	#__rde
(
me
, 
msg

	`me
 ()

	)

149 #i
__GNUC_PREREQ
 (2,97)

151 
	#__exr
 []

	)

153 #ifde
__GNUC__


154 
	#__exr
 [0]

	)

156 #i
defed
 
__STDC_VERSION__
 && __STDC_VERSION__ >= 199901L

157 
	#__exr
 []

	)

160 
	#__exr
 [1]

	)

176 #i
defed
 
__GNUC__
 && __GNUC__ >= 2

178 
	#__REDIRECT
(
me
, 
o
, 
s
m
	`__asm__
 (
	`__ASMNAME
 (#s))

	)

179 #ifde
__lulus


180 
	#__REDIRECT_NTH
(
me
, 
o
, 
s
) \

181 
me
 
o
 
__THROW
 
	`__asm__
 (
	`__ASMNAME
 (#s))

	)

182 
	#__REDIRECT_NTHNL
(
me
, 
o
, 
s
) \

183 
me
 
o
 
__THROWNL
 
	`__asm__
 (
	`__ASMNAME
 (#s))

	)

185 
	#__REDIRECT_NTH
(
me
, 
o
, 
s
) \

186 
me
 
o
 
	`__asm__
 (
	`__ASMNAME
 (#s)
__THROW


	)

187 
	#__REDIRECT_NTHNL
(
me
, 
o
, 
s
) \

188 
me
 
o
 
	`__asm__
 (
	`__ASMNAME
 (#s)
__THROWNL


	)

190 
	#__ASMNAME
(
ame

	`__ASMNAME2
 (
__USER_LABEL_PREFIX__
, cme)

	)

191 
	#__ASMNAME2
(
efix
, 
ame

	`__STRING
 (efix
	)
cname

204 #i!
defed
 
__GNUC__
 || __GNUC__ < 2

205 
	#__ibu__
(
xyz


	)

211 #i
__GNUC_PREREQ
 (2,96)

212 
	#__ibu_mloc__
 
	`__ibu__
 ((
__mloc__
))

	)

214 
	#__ibu_mloc__


	)

219 #i
__GNUC_PREREQ
 (4, 3)

220 
	#__ibu_loc_size__
(
ms
) \

221 
	`__ibu__
 ((
__loc_size__
 
ms
))

	)

223 
	#__ibu_loc_size__
(
ms


	)

229 #i
__GNUC_PREREQ
 (2,96)

230 
	#__ibu_pu__
 
	`__ibu__
 ((
__pu__
))

	)

232 
	#__ibu_pu__


	)

236 #i
__GNUC_PREREQ
 (2,5)

237 
	#__ibu_cڡ__
 
	`__ibu__
 ((
__cڡ__
))

	)

239 
	#__ibu_cڡ__


	)

245 #i
__GNUC_PREREQ
 (3,1)

246 
	#__ibu_ud__
 
	`__ibu__
 ((
__ud__
))

	)

247 
	#__ibu_nole__
 
	`__ibu__
 ((
__nole__
))

	)

249 
	#__ibu_ud__
 
	`__ibu__
 ((
__unud__
))

	)

250 
	#__ibu_nole__


	)

254 #i
__GNUC_PREREQ
 (3,2)

255 
	#__ibu_dd__
 
	`__ibu__
 ((
__dd__
))

	)

257 
	#__ibu_dd__


	)

266 #i
__GNUC_PREREQ
 (2,8)

267 
	#__ibu_fm_g__
(
x

	`__ibu__
 ((
	`__fm_g__
 (x)))

	)

269 
	#__ibu_fm_g__
(
x


	)

276 #i
__GNUC_PREREQ
 (2,97)

277 
	#__ibu_fm_rfm__
(
a
,
b
) \

278 
	`__ibu__
 ((
	`__fm__
 (
__rfm__
, 
a
, 
b
)))

	)

280 
	#__ibu_fm_rfm__
(
a
,
b


	)

285 #i
__GNUC_PREREQ
 (3,3)

286 
	#__nnu
(
ms

	`__ibu__
 ((
__nnu__
ams))

	)

288 
	#__nnu
(
ms
)

	)

293 #i
__GNUC_PREREQ
 (3,4)

294 
	#__ibu_wn_unud_su__
 \

295 
	`__ibu__
 ((
__wn_unud_su__
))

	)

296 #i
__USE_FORTIFY_LEVEL
 > 0

297 
	#__wur
 
__ibu_wn_unud_su__


	)

300 
	#__ibu_wn_unud_su__


	)

302 #ide
__wur


303 
	#__wur


	)

307 #i
__GNUC_PREREQ
 (3,2)

308 
	#__ways_le
 
__le
 
	`__ibu__
 ((
__ways_le__
))

	)

310 
	#__ways_le
 
__le


	)

315 #i
__GNUC_PREREQ
 (4,3)

316 
	#__ibu_tificl__
 
	`__ibu__
 ((
__tificl__
))

	)

318 
	#__ibu_tificl__


	)

321 #ifde
__GNUC__


326 #i
defed
 
__GNUC_STDC_INLINE__
 || defed 
__GNUC_GNU_INLINE__


327 
	#__ex_le
 
__le
 
	`__ibu__
 ((
__gnu_le__
))

	)

328 
	#__ex_ways_le
 \

329 
__ways_le
 
	`__ibu__
 ((
__gnu_le__
))

	)

331 
	#__ex_le
 
__le


	)

332 
	#__ex_ways_le
 
__ways_le


	)

335 
	#__ex_le


	)

336 
	#__ex_ways_le


	)

341 #i
__GNUC_PREREQ
 (4,3)

342 
	#__va_g_ck
(
	`__but_va_g_ck
 ()

	)

343 
	#__va_g_ck_n
(
	`__but_va_g_ck_n
 ()

	)

350 #i!
__GNUC_PREREQ
 (2,8)

351 
	#__exnsi__


	)

355 #i!
__GNUC_PREREQ
 (2,92)

356 
	#__ri


	)

362 #i
__GNUC_PREREQ
 (3,1&& !
defed
 
__GNUG__


363 
	#__ri_r
 
__ri


	)

365 #ifde
__GNUC__


366 
	#__ri_r


	)

368 #i
defed
 
__STDC_VERSION__
 && __STDC_VERSION__ >= 199901L

369 
	#__ri_r
 
ri


	)

372 
	#__ri_r


	)

377 #i
__GNUC__
 >= 3

378 
	#__glibc_uiky
(
cd

	`__but_ex
 ((cd), 0)

	)

379 
	#__glibc_liky
(
cd

	`__but_ex
 ((cd), 1)

	)

381 
	#__glibc_uiky
(
cd
(cd)

	)

382 
	#__glibc_liky
(
cd
(cd)

	)

385 
	~<bs/wdsize.h
>

387 #i
defed
 
__LONG_DOUBLE_MATH_OPTIONAL
 && defed 
__NO_LONG_DOUBLE_MATH


388 
	#__LDBL_COMPAT
 1

	)

389 #ifde
__REDIRECT


390 
	#__LDBL_REDIR1
(
me
, 
o
, 
s

	`__REDIRECT
 (me,ro,ls)

	)

391 
	#__LDBL_REDIR
(
me
, 
o
) \

392 
	`__LDBL_REDIR1
 (
me
, 
o
, 
__dbl_
##me)

	)

393 
	#__LDBL_REDIR1_NTH
(
me
, 
o
, 
s

	`__REDIRECT_NTH
 (me,ro,ls)

	)

394 
	#__LDBL_REDIR_NTH
(
me
, 
o
) \

395 
	`__LDBL_REDIR1_NTH
 (
me
, 
o
, 
__dbl_
##me)

	)

396 
	#__LDBL_REDIR1_DECL
(
me
, 
s
) \

397 
	`__tyof
 (
me
m
	`__asm
 (
	`__ASMNAME
 (#s));

	)

398 
	#__LDBL_REDIR_DECL
(
me
) \

399 
	`__tyof
 (
me
m
	`__asm
 (
	`__ASMNAME
 ("__dbl_" #me));

	)

400 
	#__REDIRECT_LDBL
(
me
, 
o
, 
s
) \

401 
	`__LDBL_REDIR1
 (
me
, 
o
, 
__dbl_
##
s
)

	)

402 
	#__REDIRECT_NTH_LDBL
(
me
, 
o
, 
s
) \

403 
	`__LDBL_REDIR1_NTH
 (
me
, 
o
, 
__dbl_
##
s
)

	)

406 #i!
defed
 
__LDBL_COMPAT
 || !defed 
__REDIRECT


407 
	#__LDBL_REDIR1
(
me
, 
o
, 
s
m
	)
proto

408 
	#__LDBL_REDIR
(
me
, 
o
m
	)
proto

409 
	#__LDBL_REDIR1_NTH
(
me
, 
o
, 
s
m
__THROW


	)

410 
	#__LDBL_REDIR_NTH
(
me
, 
o
m
__THROW


	)

411 
	#__LDBL_REDIR_DECL
(
me
)

	)

412 #ifde
__REDIRECT


413 
	#__REDIRECT_LDBL
(
me
, 
o
, 
s

	`__REDIRECT
 (me,ro,ls)

	)

414 
	#__REDIRECT_NTH_LDBL
(
me
, 
o
, 
s
) \

415 
	`__REDIRECT_NTH
 (
me
, 
o
, 
s
)

	)

	@/usr/include/asm/errno.h

1 
	~<asm-gic/o.h
>

	@/usr/include/bits/byteswap-16.h

19 #ide
_BITS_BYTESWAP_H


23 #ifde
__GNUC__


24 #i
__GNUC__
 >= 2

25 
	#__bsw_16
(
x
) \

26 (
__exnsi__
 \

27 ({ 
__v
, 
__x
 = ((
x
); \

28 i(
	`__but_cڡt_p
 (
__x
)) \

29 
__v
 = 
	`__bsw_cڡt_16
 (
__x
); \

31 
	`__asm__
 ("rorw $8, %w0" \

32 : "" (
__v
) \

33 : "0" (
__x
) \

35 
__v
; }))

	)

38 
	#__bsw_16
(
x
) \

39 (
__exnsi__
 \

40 ({ 
__x
 = ((
x
); \

41 
	`__bsw_cڡt_16
 (
__x
); }))

	)

44 
__le
 

45 
	$__bsw_16
 (
__bsx
)

47  
	`__bsw_cڡt_16
 (
__bsx
);

48 
	}
}

	@/usr/include/bits/libc-lock.h

19 #ide
_BITS_LIBC_LOCK_H


20 
	#_BITS_LIBC_LOCK_H
 1

	)

22 
	~<had.h
>

23 
	#__ed_NULL


	)

24 
	~<ddef.h
>

27 #ifde
_LIBC


28 
	~<lowvlock.h
>

29 
	~<s.h
>

30 
	~<had-funis.h
>

31 
	~<o.h
>

32 
	~<gnu/ti-groups.h
>

36 #i
defed
 
_LIBC
 || defed 
_IO_MTSAFE_IO


37 #i(
defed
 
NOT_IN_libc
 && !defed 
IS_IN_libhad
|| !defed 
_LIBC


38 ru { 
had_mux_t
 
	mmux
; } 
	t__libc_lock_cursive_t
;

40 ru { 
	mlock
; 
	mt
; *
	mowr
; } 
	t__libc_lock_cursive_t
;

43 
__libc_lock_cursive_aque__
 
	t__libc_lock_cursive_t
;

53 
	#__libc_lock_defe_cursive
(
CLASS
,
NAME
) \

54 
CLASS
 
__libc_lock_cursive_t
 
NAME
;

	)

58 #i
defed
 
_LIBC
 && (!defed 
NOT_IN_libc
 || defed 
IS_IN_libhad
)

59 #i
LLL_LOCK_INITIALIZER
 == 0

60 
	#__libc_lock_defe_lized_cursive
(
CLASS
,
NAME
) \

61 
CLASS
 
__libc_lock_cursive_t
 
NAME
;

	)

63 
	#__libc_lock_defe_lized_cursive
(
CLASS
,
NAME
) \

64 
CLASS
 
__libc_lock_cursive_t
 
NAME
 = 
_LIBC_LOCK_RECURSIVE_INITIALIZER
;

	)

66 
	#_LIBC_LOCK_RECURSIVE_INITIALIZER
 \

67 { 
LLL_LOCK_INITIALIZER
, 0, 
NULL
 }

	)

69 
	#__libc_lock_defe_lized_cursive
(
CLASS
,
NAME
) \

70 
CLASS
 
__libc_lock_cursive_t
 
NAME
 = 
_LIBC_LOCK_RECURSIVE_INITIALIZER
;

	)

71 
	#_LIBC_LOCK_RECURSIVE_INITIALIZER
 \

72 {
PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP
}

	)

76 #i
defed
 
_LIBC
 && (!defed 
NOT_IN_libc
 || defed 
IS_IN_libhad
)

77 
	#__libc_lock__cursive
(
NAME
) \

78 ((
NAME
(
__libc_lock_cursive_t

_LIBC_LOCK_RECURSIVE_INITIALIZER
, 0)

	)

80 
	#__libc_lock__cursive
(
NAME
) \

82 i(
__had_mux_
 !
NULL
) \

84 
had_mux_t
 
__
; \

85 
	`__had_mux_
 (&
__
); \

86 
	`__had_mux_y
 (&
__
, 
PTHREAD_MUTEX_RECURSIVE_NP
); \

87 
	`__had_mux_
 (&(
NAME
).
mux
, &
__
); \

88 
	`__had_mux_deroy
 (&
__
); \

90 } 0)

	)

94 #i
defed
 
_LIBC
 && (!defed 
NOT_IN_libc
 || defed 
IS_IN_libhad
)

95 
	#__libc_lock_fi_cursive
(
NAME
((0)

	)

97 
	#__libc_lock_fi_cursive
(
NAME
) \

98 
	`__libc_maybe_
 (
__had_mux_deroy
, (&(
NAME
).
mux
), 0)

	)

102 #i
defed
 
_LIBC
 && (!defed 
NOT_IN_libc
 || defed 
IS_IN_libhad
)

103 #i
__OPTION_EGLIBC_BIG_MACROS
 != 1

107 
__libc_lock_lock_cursive_
 (
__libc_lock_cursive_t
 *);

108 
libc_hidd_o
 (
__libc_lock_lock_cursive_
);

110 #i
__OPTION_EGLIBC_BIG_MACROS


111 
	#__libc_lock_lock_cursive
(
NAME
) \

113 *
lf
 = 
THREAD_SELF
; \

114 i((
NAME
).
owr
 !
lf
) \

116 
	`l_lock
 ((
NAME
).
lock
, 
LLL_PRIVATE
); \

117 (
NAME
).
owr
 = 
lf
; \

119 ++(
NAME
).
t
; \

120 } 0)

	)

122 
	#__libc_lock_lock_cursive
(
NAME
) \

123 
	`__libc_lock_lock_cursive_
 (&(
NAME
))

	)

126 
	#__libc_lock_lock_cursive
(
NAME
) \

127 
	`__libc_maybe_
 (
__had_mux_lock
, (&(
NAME
).
mux
), 0)

	)

131 #i
defed
 
_LIBC
 && (!defed 
NOT_IN_libc
 || defed 
IS_IN_libhad
)

132 #i
__OPTION_EGLIBC_BIG_MACROS
 != 1

136 
__libc_lock_ylock_cursive_
 (
__libc_lock_cursive_t
 *);

137 
libc_hidd_o
 (
__libc_lock_ylock_cursive_
);

139 #i
__OPTION_EGLIBC_BIG_MACROS


140 
	#__libc_lock_ylock_cursive
(
NAME
) \

142 
su
 = 0; \

143 *
lf
 = 
THREAD_SELF
; \

144 i((
NAME
).
owr
 !
lf
) \

146 i(
	`l_ylock
 ((
NAME
).
lock
) == 0) \

148 (
NAME
).
owr
 = 
lf
; \

149 (
NAME
).
t
 = 1; \

152 
su
 = 
EBUSY
; \

155 ++(
NAME
).
t
; \

156 
su
; \

157 })

	)

159 
	#__libc_lock_ylock_cursive
(
NAME
) \

160 
	`__libc_lock_ylock_cursive_
 (&(
NAME
))

	)

163 
	#__libc_lock_ylock_cursive
(
NAME
) \

164 
	`__libc_maybe_
 (
__had_mux_ylock
, (&(
NAME
).
mux
), 0)

	)

168 #i
defed
 
_LIBC
 && (!defed 
NOT_IN_libc
 || defed 
IS_IN_libhad
)

169 #i
__OPTION_EGLIBC_BIG_MACROS
 != 1

173 
__libc_lock_uock_cursive_
 (
__libc_lock_cursive_t
 *);

174 
libc_hidd_o
 (
__libc_lock_uock_cursive_
);

176 #i
__OPTION_EGLIBC_BIG_MACROS


178 
	#__libc_lock_uock_cursive
(
NAME
) \

180 i(--(
NAME
).
t
 == 0) \

182 (
NAME
).
owr
 = 
NULL
; \

183 
	`l_uock
 ((
NAME
).
lock
, 
LLL_PRIVATE
); \

185 } 0)

	)

187 
	#__libc_lock_uock_cursive
(
NAME
) \

188 
	`__libc_lock_uock_cursive_
 (&(
NAME
))

	)

191 
	#__libc_lock_uock_cursive
(
NAME
) \

192 
	`__libc_maybe_
 (
__had_mux_uock
, (&(
NAME
).
mux
), 0)

	)

199 
_had_nup_push_der
 (
_had_nup_bufr
 *
bufr
,

200 (*
route
(*), *
g
);

201 
	`_had_nup_p_e
 (
_had_nup_bufr
 *
bufr
,

202 
execu
);

205 
	#__libc_nup_gi_t
(
DOIT
, 
FCT
, 
ARG
) \

206 { 
_had_nup_bufr
 
_bufr
; \

207 
_ava
; \

208 i(
DOIT
) { \

209 
_ava
 = 
	`PTFAVAIL
 (
_had_nup_push_der
); \

210 i(
_ava
) { \

211 
	`__libc_f__ways
 (
_had_nup_push_der
, (&
_bufr
, 
FCT
, \

212 
ARG
)); \

214 
_bufr
.
__route
 = (
FCT
); \

215 
_bufr
.
__g
 = (
ARG
); \

218 
_ava
 = 0; \

219 }

	)

222 
	#__libc_nup_gi_d
(
DOIT
) \

223 i(
_ava
) { \

224 
	`__libc_f__ways
 (
_had_nup_p_e
, (&
_bufr
, 
DOIT
));\

225 } i(
DOIT
) \

226 
_bufr
.
	`__route
 (_bufr.
__g
); \

227 
	}

	)
}

232 #ifde
_LIBC


233 
	~"libc-lockP.h
"

	@/usr/include/bits/timex.h

18 #idef 
_BITS_TIMEX_H


19 
	#_BITS_TIMEX_H
 1

	)

21 
	~<bs/tys.h
>

25 
	stimex


27 
	mmodes
;

28 
__sys_g_t
 
	mofft
;

29 
__sys_g_t
 
	meq
;

30 
__sys_g_t
 
	mmaxr
;

31 
__sys_g_t
 
	mer
;

32 
	mus
;

33 
__sys_g_t
 
	mcڡt
;

34 
__sys_g_t
 
	mecisi
;

35 
__sys_g_t
 
	mtޔ
;

36 
timev
 
	mtime
;

37 
__sys_g_t
 
	mtick
;

38 
__sys_g_t
 
	mseq
;

39 
__sys_g_t
 
	mjr
;

40 
	mshi
;

41 
__sys_g_t
 
	mab
;

42 
__sys_g_t
 
	mjt
;

43 
__sys_g_t
 
	mlt
;

44 
__sys_g_t
 
	mrt
;

45 
__sys_g_t
 
	mbt
;

47 
	mi
;

56 
	#ADJ_OFFSET
 0x0001

	)

57 
	#ADJ_FREQUENCY
 0x0002

	)

58 
	#ADJ_MAXERROR
 0x0004

	)

59 
	#ADJ_ESTERROR
 0x0008

	)

60 
	#ADJ_STATUS
 0x0010

	)

61 
	#ADJ_TIMECONST
 0x0020

	)

62 
	#ADJ_TAI
 0x0080

	)

63 
	#ADJ_MICRO
 0x1000

	)

64 
	#ADJ_NANO
 0x2000

	)

65 
	#ADJ_TICK
 0x4000

	)

66 
	#ADJ_OFFSET_SINGLESHOT
 0x8001

	)

67 
	#ADJ_OFFSET_SS_READ
 0xa001

	)

70 
	#MOD_OFFSET
 
ADJ_OFFSET


	)

71 
	#MOD_FREQUENCY
 
ADJ_FREQUENCY


	)

72 
	#MOD_MAXERROR
 
ADJ_MAXERROR


	)

73 
	#MOD_ESTERROR
 
ADJ_ESTERROR


	)

74 
	#MOD_STATUS
 
ADJ_STATUS


	)

75 
	#MOD_TIMECONST
 
ADJ_TIMECONST


	)

76 
	#MOD_CLKB
 
ADJ_TICK


	)

77 
	#MOD_CLKA
 
ADJ_OFFSET_SINGLESHOT


	)

78 
	#MOD_TAI
 
ADJ_TAI


	)

79 
	#MOD_MICRO
 
ADJ_MICRO


	)

80 
	#MOD_NANO
 
ADJ_NANO


	)

84 
	#STA_PLL
 0x0001

	)

85 
	#STA_PPSFREQ
 0x0002

	)

86 
	#STA_PPSTIME
 0x0004

	)

87 
	#STA_FLL
 0x0008

	)

89 
	#STA_INS
 0x0010

	)

90 
	#STA_DEL
 0x0020

	)

91 
	#STA_UNSYNC
 0x0040

	)

92 
	#STA_FREQHOLD
 0x0080

	)

94 
	#STA_PPSSIGNAL
 0x0100

	)

95 
	#STA_PPSJITTER
 0x0200

	)

96 
	#STA_PPSWANDER
 0x0400

	)

97 
	#STA_PPSERROR
 0x0800

	)

99 
	#STA_CLOCKERR
 0x1000

	)

100 
	#STA_NANO
 0x2000

	)

101 
	#STA_MODE
 0x4000

	)

102 
	#STA_CLK
 0x8000

	)

105 
	#STA_RONLY
 (
STA_PPSSIGNAL
 | 
STA_PPSJITTER
 | 
STA_PPSWANDER
 | \

106 
STA_PPSERROR
 | 
STA_CLOCKERR
 | 
STA_NANO
 | 
STA_MODE
 | 
STA_CLK
)

	)

	@/usr/include/bits/uio.h

18 #i!
defed
 
_SYS_UIO_H
 && !defed 
_FCNTL_H


22 #ide
_BITS_UIO_H


23 
	#_BITS_UIO_H
 1

	)

25 
	~<sys/tys.h
>

39 
	#UIO_MAXIOV
 1024

	)

43 
	siovec


45 *
	miov_ba
;

46 
size_t
 
	miov_n
;

52 #ifde
__USE_GNU


53 #i
defed
 
_SYS_UIO_H
 && !defed 
_BITS_UIO_H_FOR_SYS_UIO_H


54 
	#_BITS_UIO_H_FOR_SYS_UIO_H
 1

	)

56 
__BEGIN_DECLS


59 
ssize_t
 
	$oss_vm_adv
 (
pid_t
 
__pid
, cڡ 
iovec
 *
__lvec
,

60 
__liovt
,

61 cڡ 
iovec
 *
__rvec
,

62 
__riovt
,

63 
__ags
)

64 
__THROW
;

67 
ssize_t
 
	$oss_vm_wrev
 (
pid_t
 
__pid
, cڡ 
iovec
 *
__lvec
,

68 
__liovt
,

69 cڡ 
iovec
 *
__rvec
,

70 
__riovt
,

71 
__ags
)

72 
__THROW
;

74 
__END_DECLS


	@/usr/include/gconv.h

22 #ide
_GCONV_H


23 
	#_GCONV_H
 1

	)

25 
	~<us.h
>

26 
	#__ed_mbe_t


	)

27 
	#__ed_wt_t


	)

28 
	~<wch.h
>

29 
	#__ed_size_t


	)

30 
	#__ed_wch_t


	)

31 
	~<ddef.h
>

34 
	#__UNKNOWN_10646_CHAR
 ((
wch_t
0xfffd)

	)

39 
	m__GCONV_OK
 = 0,

40 
	m__GCONV_NOCONV
,

41 
	m__GCONV_NODB
,

42 
	m__GCONV_NOMEM
,

44 
	m__GCONV_EMPTY_INPUT
,

45 
	m__GCONV_FULL_OUTPUT
,

46 
	m__GCONV_ILLEGAL_INPUT
,

47 
	m__GCONV_INCOMPLETE_INPUT
,

49 
	m__GCONV_ILLEGAL_DESCRIPTOR
,

50 
	m__GCONV_INTERNAL_ERROR


57 
	m__GCONV_IS_LAST
 = 0x0001,

58 
	m__GCONV_IGNORE_ERRORS
 = 0x0002,

59 
	m__GCONV_SWAP
 = 0x0004

64 
	g__gcv_
;

65 
	g__gcv__da
;

66 
	g__gcv_lded_obje
;

67 
	g__gcv_s_da
;

71 (*
	t__gcv_f
(
	t__gcv_
 *, 
	t__gcv__da
 *,

73 **, 
	tsize_t
 *, , );

76 
	$wt_t
 (*
	t__gcv_btowc_f
(
	t__gcv_
 *, );

79 (*
	t__gcv__f
(
	t__gcv_
 *);

80 (*
	t__gcv_d_f
(
	t__gcv_
 *);

84 (*
	t__gcv_s_f
(
	t__gcv_
 *,

85 
	t__gcv__da
 *, *,

89 
	tsize_t
 *);

92 (*
	t__gcv_s_cڋxt_f
) (*, const *,

97 (*
	t__gcv_s_quy_f
) (const *, const ***,

98 
	tsize_t
 *);

101 (*
	t__gcv_s__f
) (**, const *);

102 (*
	t__gcv_s_d_f
) (*);

104 
	s__gcv_s_da


107 
__gcv_s_f
 
__s_f
;

108 
__gcv_s_cڋxt_f
 
__s_cڋxt_f
;

109 
__gcv_s_d_f
 
__s_d_f
;

110 *
__da
;

111 
__gcv_s_da
 *
__xt
;

116 
	s__gcv_


118 
__gcv_lded_obje
 *
__shlib_hd
;

119 cڡ *
__modme
;

121 
__cou
;

123 *
__om_me
;

124 *
__to_me
;

126 
__gcv_f
 
__f
;

127 
__gcv_btowc_f
 
__btowc_f
;

128 
__gcv__f
 
___f
;

129 
__gcv_d_f
 
__d_f
;

133 
__m_eded_om
;

134 
__max_eded_om
;

135 
__m_eded_to
;

136 
__max_eded_to
;

139 
__eful
;

141 *
__da
;

146 
	s__gcv__da


148 *
__outbuf
;

149 *
__outbund
;

153 
__ags
;

157 
__voti_cou
;

161 
___u
;

163 
__mbe_t
 *
__
;

164 
__mbe_t
 
__e
;

168 
__gcv_s_da
 *
__s
;

173 
	s__gcv_fo


175 
size_t
 
__ns
;

176 
__gcv_
 *
__s
;

177 
__exnsi__
 
__gcv__da
 
__da
 
__exr
;

178 } *
	t__gcv_t
;

	@/usr/include/gnu/stubs-32.h

6 #ifde
_LIBC


7 #r 
Alitis
 
may
 
n
 
defe
 
the
 
mao
 
_LIBC


10 
	#__ub_chags


	)

11 
	#__ub_ach


	)

12 
	#__ub_fchags


	)

13 
	#__ub_fdach


	)

14 
	#__ub_gy


	)

15 
	#__ub_lchmod


	)

16 
	#__ub_voke


	)

17 
	#__ub_og


	)

18 
	#__ub_sigtu


	)

19 
	#__ub_sk


	)

20 
	#__ub_ty


	)

	@/usr/include/gnu/stubs-64.h

6 #ifde
_LIBC


7 #r 
Alitis
 
may
 
n
 
defe
 
the
 
mao
 
_LIBC


10 
	#__ub_bdush


	)

11 
	#__ub_chags


	)

12 
	#__ub_ach


	)

13 
	#__ub_fchags


	)

14 
	#__ub_fdach


	)

15 
	#__ub_gmsg


	)

16 
	#__ub_gy


	)

17 
	#__ub_lchmod


	)

18 
	#__ub_putmsg


	)

19 
	#__ub_voke


	)

20 
	#__ub_og


	)

21 
	#__ub_sigtu


	)

22 
	#__ub_sk


	)

23 
	#__ub_ty


	)

	@/usr/include/gnu/stubs-x32.h

6 #ifde
_LIBC


7 #r 
Alitis
 
may
 
n
 
defe
 
the
 
mao
 
_LIBC


10 
	#__ub_bdush


	)

11 
	#__ub_chags


	)

12 
	#__ub__modu


	)

13 
	#__ub_ach


	)

14 
	#__ub_fchags


	)

15 
	#__ub_fdach


	)

16 
	#__ub_g_kl_syms


	)

17 
	#__ub_gmsg


	)

18 
	#__ub_gy


	)

19 
	#__ub_lchmod


	)

20 
	#__ub_nfsrvl


	)

21 
	#__ub_putmsg


	)

22 
	#__ub_quy_modu


	)

23 
	#__ub_voke


	)

24 
	#__ub_og


	)

25 
	#__ub_sigtu


	)

26 
	#__ub_sk


	)

27 
	#__ub_ty


	)

28 
	#__ub_ulib


	)

	@/usr/include/wchar.h

23 #ide
_WCHAR_H


25 #i!
defed
 
__ed_mbe_t
 && !defed 
__ed_wt_t


26 
	#_WCHAR_H
 1

	)

27 
	~<us.h
>

30 #ifde
_WCHAR_H


32 
	#__ed___FILE


	)

33 #i
defed
 
__USE_UNIX98
 || defed 
__USE_XOPEN2K


34 
	#__ed_FILE


	)

36 
	~<dio.h
>

38 
	#__ed___va_li


	)

39 
	~<dg.h
>

41 
	~<bs/wch.h
>

44 
	#__ed_size_t


	)

45 
	#__ed_wch_t


	)

46 
	#__ed_NULL


	)

48 #i
defed
 
_WCHAR_H
 || defed 
__ed_wt_t
 || !defed 
__WINT_TYPE__


49 #unde
__ed_wt_t


50 
	#__ed_wt_t


	)

51 
	~<ddef.h
>

55 #ide
_WINT_T


60 
	#_WINT_T


	)

61 
	twt_t
;

65 #i
defed
 
__lulus
 && defed 
_GLIBCPP_USE_NAMESPACES
 \

66 && 
defed
 
__WINT_TYPE__


67 
__BEGIN_NAMESPACE_STD


68 
__WINT_TYPE__
 
	twt_t
;

69 
	g__END_NAMESPACE_STD


74 #i
defed
 
__lulus
 && 
__GNUC_PREREQ
 (4, 4)

75 
	#__CORRECT_ISO_CPP_WCHAR_H_PROTO


	)

79 #i(
defed
 
_WCHAR_H
 || defed 
__ed_mbe_t
&& !defed 
____mbe_t_defed


80 
	#____mbe_t_defed
 1

	)

84 
	m__cou
;

87 #ifde
__WINT_TYPE__


88 
__WINT_TYPE__
 
	m__wch
;

90 
wt_t
 
	m__wch
;

92 
	m__wchb
[4];

93 } 
	m__vue
;

94 } 
	t__mbe_t
;

96 #unde
__ed_mbe_t


101 #ifde
_WCHAR_H


103 #ide
__mbe_t_defed


104 
__BEGIN_NAMESPACE_C99


106 
__mbe_t
 
	tmbe_t
;

107 
	g__END_NAMESPACE_C99


108 
	#__mbe_t_defed
 1

	)

111 #ifde
__USE_GNU


112 
	$__USING_NAMESPACE_C99
(
mbe_t
)

115 #ide
WCHAR_MIN


117 
	#WCHAR_MIN
 
__WCHAR_MIN


	)

118 
	#WCHAR_MAX
 
__WCHAR_MAX


	)

121 #ide
WEOF


122 
	#WEOF
 (0xffffffffu)

	)

127 #i
defed
 
__USE_XOPEN
 && !defed 
__USE_UNIX98


128 
	~<wy.h
>

132 
__BEGIN_DECLS


134 
__BEGIN_NAMESPACE_STD


137 
tm
;

138 
__END_NAMESPACE_STD


142 
	$__USING_NAMESPACE_STD
(
tm
)

145 
__BEGIN_NAMESPACE_STD


147 
wch_t
 *
	$wcsy
 (
wch_t
 *
__ri
 
__de
,

148 cڡ 
wch_t
 *
__ri
 
__c

__THROW
;

150 
wch_t
 *
	$wcy
 (
wch_t
 *
__ri
 
__de
,

151 cڡ 
wch_t
 *
__ri
 
__c
, 
size_t
 
__n
)

152 
__THROW
;

155 
wch_t
 *
	$wcst
 (
wch_t
 *
__ri
 
__de
,

156 cڡ 
wch_t
 *
__ri
 
__c

__THROW
;

158 
wch_t
 *
	$wct
 (
wch_t
 *
__ri
 
__de
,

159 cڡ 
wch_t
 *
__ri
 
__c
, 
size_t
 
__n
)

160 
__THROW
;

163 
	$wcscmp
 (cڡ 
wch_t
 *
__s1
, cڡ wch_*
__s2
)

164 
__THROW
 
__ibu_pu__
;

166 
	$wccmp
 (cڡ 
wch_t
 *
__s1
, cڡ wch_*
__s2
, 
size_t
 
__n
)

167 
__THROW
 
__ibu_pu__
;

168 
__END_NAMESPACE_STD


170 #ifde
__USE_XOPEN2K8


172 
	$wcscmp
 (cڡ 
wch_t
 *
__s1
, cڡ wch_*
__s2

__THROW
;

175 
	$wccmp
 (cڡ 
wch_t
 *
__s1
, cڡ wch_*
__s2
,

176 
size_t
 
__n

__THROW
;

180 
	~<xlo.h
>

182 
	$wcscmp_l
 (cڡ 
wch_t
 *
__s1
, cڡ wch_*
__s2
,

183 
__lo_t
 
__loc

__THROW
;

185 
	$wccmp_l
 (cڡ 
wch_t
 *
__s1
, cڡ wch_*
__s2
,

186 
size_t
 
__n
, 
__lo_t
 
__loc

__THROW
;

189 
__BEGIN_NAMESPACE_STD


192 
	$wcscl
 (cڡ 
wch_t
 *
__s1
, cڡ wch_*
__s2

__THROW
;

196 
size_t
 
	$wcsxm
 (
wch_t
 *
__ri
 
__s1
,

197 cڡ 
wch_t
 *
__ri
 
__s2
, 
size_t
 
__n

__THROW
;

198 
__END_NAMESPACE_STD


200 #ifde
__USE_XOPEN2K8


206 
	$wcscl_l
 (cڡ 
wch_t
 *
__s1
, cڡ wch_*
__s2
,

207 
__lo_t
 
__loc

__THROW
;

212 
size_t
 
	$wcsxm_l
 (
wch_t
 *
__s1
, cڡ wch_*
__s2
,

213 
size_t
 
__n
, 
__lo_t
 
__loc

__THROW
;

216 
wch_t
 *
	$wcsdup
 (cڡ 
wch_t
 *
__s

__THROW
 
__ibu_mloc__
;

219 
__BEGIN_NAMESPACE_STD


221 #ifde
__CORRECT_ISO_CPP_WCHAR_H_PROTO


222 "C++" 
wch_t
 *
	$wcschr
 (
wch_t
 *
__wcs
, wch_
__wc
)

223 
__THROW
 
	`__asm
 ("wcschr"
__ibu_pu__
;

224 "C++" cڡ 
wch_t
 *
	$wcschr
 (cڡ 
wch_t
 *
__wcs
, wch_
__wc
)

225 
__THROW
 
	`__asm
 ("wcschr"
__ibu_pu__
;

227 
wch_t
 *
	$wcschr
 (cڡ 
wch_t
 *
__wcs
, wch_
__wc
)

228 
__THROW
 
__ibu_pu__
;

231 #ifde
__CORRECT_ISO_CPP_WCHAR_H_PROTO


232 "C++" 
wch_t
 *
	$wcchr
 (
wch_t
 *
__wcs
, wch_
__wc
)

233 
__THROW
 
	`__asm
 ("wcchr"
__ibu_pu__
;

234 "C++" cڡ 
wch_t
 *
	$wcchr
 (cڡ 
wch_t
 *
__wcs
, wch_
__wc
)

235 
__THROW
 
	`__asm
 ("wcchr"
__ibu_pu__
;

237 
wch_t
 *
	$wcchr
 (cڡ 
wch_t
 *
__wcs
, wch_
__wc
)

238 
__THROW
 
__ibu_pu__
;

240 
__END_NAMESPACE_STD


242 #ifde
__USE_GNU


245 
wch_t
 *
	$wcschul
 (cڡ 
wch_t
 *
__s
, wch_
__wc
)

246 
__THROW
 
__ibu_pu__
;

249 
__BEGIN_NAMESPACE_STD


252 
size_t
 
	$wcscn
 (cڡ 
wch_t
 *
__wcs
, cڡ wch_*
__je
)

253 
__THROW
 
__ibu_pu__
;

256 
size_t
 
	$wcsn
 (cڡ 
wch_t
 *
__wcs
, cڡ wch_*
__ac
)

257 
__THROW
 
__ibu_pu__
;

259 #ifde
__CORRECT_ISO_CPP_WCHAR_H_PROTO


260 "C++" 
wch_t
 *
	$wcbrk
 (
wch_t
 *
__wcs
, cڡ wch_*
__ac
)

261 
__THROW
 
	`__asm
 ("wcbrk"
__ibu_pu__
;

262 "C++" cڡ 
wch_t
 *
	$wcbrk
 (cڡ 
wch_t
 *
__wcs
,

263 cڡ 
wch_t
 *
__ac
)

264 
__THROW
 
	`__asm
 ("wcbrk"
__ibu_pu__
;

266 
wch_t
 *
	$wcbrk
 (cڡ 
wch_t
 *
__wcs
, cڡ wch_*
__ac
)

267 
__THROW
 
__ibu_pu__
;

270 #ifde
__CORRECT_ISO_CPP_WCHAR_H_PROTO


271 "C++" 
wch_t
 *
	$wcsr
 (
wch_t
 *
__hayack
, cڡ wch_*
__ed
)

272 
__THROW
 
	`__asm
 ("wcsr"
__ibu_pu__
;

273 "C++" cڡ 
wch_t
 *
	$wcsr
 (cڡ 
wch_t
 *
__hayack
,

274 cڡ 
wch_t
 *
__ed
)

275 
__THROW
 
	`__asm
 ("wcsr"
__ibu_pu__
;

277 
wch_t
 *
	$wcsr
 (cڡ 
wch_t
 *
__hayack
, cڡ wch_*
__ed
)

278 
__THROW
 
__ibu_pu__
;

282 
wch_t
 *
	$wcok
 (
wch_t
 *
__ri
 
__s
,

283 cڡ 
wch_t
 *
__ri
 
__dim
,

284 
wch_t
 **
__ri
 
__r

__THROW
;

287 
size_t
 
	$wc
 (cڡ 
wch_t
 *
__s

__THROW
 
__ibu_pu__
;

288 
__END_NAMESPACE_STD


290 #ifde
__USE_XOPEN


292 #ifde
__CORRECT_ISO_CPP_WCHAR_H_PROTO


293 "C++" 
wch_t
 *
	$wcswcs
 (
wch_t
 *
__hayack
, cڡ wch_*
__ed
)

294 
__THROW
 
	`__asm
 ("wcswcs"
__ibu_pu__
;

295 "C++" cڡ 
wch_t
 *
	$wcswcs
 (cڡ 
wch_t
 *
__hayack
,

296 cڡ 
wch_t
 *
__ed
)

297 
__THROW
 
	`__asm
 ("wcswcs"
__ibu_pu__
;

299 
wch_t
 *
	$wcswcs
 (cڡ 
wch_t
 *
__hayack
, cڡ wch_*
__ed
)

300 
__THROW
 
__ibu_pu__
;

304 #ifde
__USE_XOPEN2K8


306 
size_t
 
	$wcn
 (cڡ 
wch_t
 *
__s
, 
size_t
 
__maxn
)

307 
__THROW
 
__ibu_pu__
;

311 
__BEGIN_NAMESPACE_STD


313 #ifde
__CORRECT_ISO_CPP_WCHAR_H_PROTO


314 "C++" 
wch_t
 *
	$wmemchr
 (
wch_t
 *
__s
, wch_
__c
, 
size_t
 
__n
)

315 
__THROW
 
	`__asm
 ("wmemchr"
__ibu_pu__
;

316 "C++" cڡ 
wch_t
 *
	$wmemchr
 (cڡ 
wch_t
 *
__s
, wch_
__c
,

317 
size_t
 
__n
)

318 
__THROW
 
	`__asm
 ("wmemchr"
__ibu_pu__
;

320 
wch_t
 *
	$wmemchr
 (cڡ 
wch_t
 *
__s
, wch_
__c
, 
size_t
 
__n
)

321 
__THROW
 
__ibu_pu__
;

325 
	$wmemcmp
 (cڡ 
wch_t
 *
__s1
, cڡ wch_*
__s2
, 
size_t
 
__n
)

326 
__THROW
 
__ibu_pu__
;

329 
wch_t
 *
	$wmemy
 (
wch_t
 *
__ri
 
__s1
,

330 cڡ 
wch_t
 *
__ri
 
__s2
, 
size_t
 
__n

__THROW
;

334 
wch_t
 *
	$wmemmove
 (
wch_t
 *
__s1
, cڡ wch_*
__s2
, 
size_t
 
__n
)

335 
__THROW
;

338 
wch_t
 *
	$wmemt
 (
wch_t
 *
__s
, wch_
__c
, 
size_t
 
__n

__THROW
;

339 
__END_NAMESPACE_STD


341 #ifde
__USE_GNU


344 
wch_t
 *
	$wmempy
 (
wch_t
 *
__ri
 
__s1
,

345 cڡ 
wch_t
 *
__ri
 
__s2
, 
size_t
 
__n
)

346 
__THROW
;

350 
__BEGIN_NAMESPACE_STD


353 
wt_t
 
	$btowc
 (
__c

__THROW
;

357 
	$wob
 (
wt_t
 
__c

__THROW
;

361 
	$mbs
 (cڡ 
mbe_t
 *
__ps

__THROW
 
__ibu_pu__
;

365 
size_t
 
	$mbowc
 (
wch_t
 *
__ri
 
__pwc
,

366 cڡ *
__ri
 
__s
, 
size_t
 
__n
,

367 
mbe_t
 *
__ri
 
__p

__THROW
;

370 
size_t
 
	$wtomb
 (*
__ri
 
__s
, 
wch_t
 
__wc
,

371 
mbe_t
 *
__ri
 
__ps

__THROW
;

374 
size_t
 
	$__mb
 (cڡ *
__ri
 
__s
, 
size_t
 
__n
,

375 
mbe_t
 *
__ri
 
__ps

__THROW
;

376 
size_t
 
	$mb
 (cڡ *
__ri
 
__s
, 
size_t
 
__n
,

377 
mbe_t
 *
__ri
 
__ps

__THROW
;

378 
__END_NAMESPACE_STD


380 #ifde
__USE_EXTERN_INLINES


386 
wt_t
 
	$__btowc_s
 (
__c

	`__asm
 ("btowc");

387 
__ex_le
 
wt_t


388 
	`__NTH
 (
	$btowc
 (
__c
))

389 {  (
	`__but_cڡt_p
 (
__c
) && __c >= '\0' && __c <= '\x7f'

390 ? (
wt_t

__c
 : 
	`__btowc_s
 (__c)); 
	}
}

392 
	$__wob_s
 (
wt_t
 
__c

	`__asm
 ("wctob");

393 
__ex_le
 

394 
	`__NTH
 (
	$wob
 (
wt_t
 
__wc
))

395 {  (
	`__but_cڡt_p
 (
__wc
&& __w>
L
'\0' && __wc <= L'\x7f'

396 ? (
__wc
 : 
	`__wob_s
 (__wc)); 
	}
}

398 
__ex_le
 
size_t


399 
__NTH
 (
	$mb
 (cڡ *
__ri
 
__s
, 
size_t
 
__n
,

400 
mbe_t
 *
__ri
 
__ps
))

401 {  (
__ps
 !
NULL


402 ? 
	`mbowc
 (
NULL
, 
__s
, 
__n
, 
__ps
: 
	`__mb
 (__s, __n, NULL)); 
	}
}

405 
__BEGIN_NAMESPACE_STD


408 
size_t
 
	$mbtowcs
 (
wch_t
 *
__ri
 
__d
,

409 cڡ **
__ri
 
__c
, 
size_t
 
__n
,

410 
mbe_t
 *
__ri
 
__ps

__THROW
;

414 
size_t
 
	$wctombs
 (*
__ri
 
__d
,

415 cڡ 
wch_t
 **
__ri
 
__c
, 
size_t
 
__n
,

416 
mbe_t
 *
__ri
 
__ps

__THROW
;

417 
__END_NAMESPACE_STD


420 #ifdef 
__USE_XOPEN2K8


423 
size_t
 
	$mbowcs
 (
wch_t
 *
__ri
 
__d
,

424 cڡ **
__ri
 
__c
, 
size_t
 
__nmc
,

425 
size_t
 
__n
, 
mbe_t
 *
__ri
 
__ps

__THROW
;

429 
size_t
 
	$wcombs
 (*
__ri
 
__d
,

430 cڡ 
wch_t
 **
__ri
 
__c
,

431 
size_t
 
__nwc
, size_
__n
,

432 
mbe_t
 *
__ri
 
__ps

__THROW
;

437 #ifde
__USE_XOPEN


439 
	$wcwidth
 (
wch_t
 
__c

__THROW
;

443 
	$wcswidth
 (cڡ 
wch_t
 *
__s
, 
size_t
 
__n

__THROW
;

447 
__BEGIN_NAMESPACE_STD


450 
	$wcod
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

451 
wch_t
 **
__ri
 
__dr

__THROW
;

452 
__END_NAMESPACE_STD


454 #ifde
__USE_ISOC99


455 
__BEGIN_NAMESPACE_C99


457 
	$wcof
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

458 
wch_t
 **
__ri
 
__dr

__THROW
;

459 
	$wcd
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

460 
wch_t
 **
__ri
 
__dr

__THROW
;

461 
__END_NAMESPACE_C99


465 
__BEGIN_NAMESPACE_STD


468 
	$wc
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

469 
wch_t
 **
__ri
 
__dr
, 
__ba

__THROW
;

473 
	$wcoul
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

474 
wch_t
 **
__ri
 
__dr
, 
__ba
)

475 
__THROW
;

476 
__END_NAMESPACE_STD


478 #ifde
__USE_ISOC99


479 
__BEGIN_NAMESPACE_C99


482 
__exnsi__


483 
	$wcl
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

484 
wch_t
 **
__ri
 
__dr
, 
__ba
)

485 
__THROW
;

489 
__exnsi__


490 
	$wcou
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

491 
wch_t
 **
__ri
 
__dr
,

492 
__ba

__THROW
;

493 
__END_NAMESPACE_C99


496 #ifde
__USE_GNU


499 
__exnsi__


500 
	$wcoq
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

501 
wch_t
 **
__ri
 
__dr
, 
__ba
)

502 
__THROW
;

506 
__exnsi__


507 
	$wcouq
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

508 
wch_t
 **
__ri
 
__dr
,

509 
__ba

__THROW
;

512 #ifde
__USE_GNU


526 
	~<xlo.h
>

530 
	$wc_l
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

531 
wch_t
 **
__ri
 
__dr
, 
__ba
,

532 
__lo_t
 
__loc

__THROW
;

534 
	$wcoul_l
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

535 
wch_t
 **
__ri
 
__dr
,

536 
__ba
, 
__lo_t
 
__loc

__THROW
;

538 
__exnsi__


539 
	$wcl_l
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

540 
wch_t
 **
__ri
 
__dr
,

541 
__ba
, 
__lo_t
 
__loc

__THROW
;

543 
__exnsi__


544 
	$wcou_l
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

545 
wch_t
 **
__ri
 
__dr
,

546 
__ba
, 
__lo_t
 
__loc
)

547 
__THROW
;

549 
	$wcod_l
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

550 
wch_t
 **
__ri
 
__dr
, 
__lo_t
 
__loc
)

551 
__THROW
;

553 
	$wcof_l
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

554 
wch_t
 **
__ri
 
__dr
, 
__lo_t
 
__loc
)

555 
__THROW
;

557 
	$wcd_l
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

558 
wch_t
 **
__ri
 
__dr
,

559 
__lo_t
 
__loc

__THROW
;

563 #ifde
__USE_XOPEN2K8


566 
wch_t
 *
	$wy
 (
wch_t
 *
__ri
 
__de
,

567 cڡ 
wch_t
 *
__ri
 
__c

__THROW
;

571 
wch_t
 *
	$wny
 (
wch_t
 *
__ri
 
__de
,

572 cڡ 
wch_t
 *
__ri
 
__c
, 
size_t
 
__n
)

573 
__THROW
;

580 
__FILE
 *
	$ݒ_wmemam
 (
wch_t
 **
__buoc
, 
size_t
 *
__sizoc

__THROW
;

583 #i
defed
 
__USE_ISOC95
 || defed 
__USE_UNIX98


584 
__BEGIN_NAMESPACE_STD


587 
	$fwide
 (
__FILE
 *
__
, 
__mode

__THROW
;

594 
	`fwtf
 (
__FILE
 *
__ri
 
__am
,

595 cڡ 
wch_t
 *
__ri
 
__fm
, ...)

601 
	`wtf
 (cڡ 
wch_t
 *
__ri
 
__fm
, ...)

604 
	$swtf
 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__n
,

605 cڡ 
wch_t
 *
__ri
 
__fm
, ...)

606 
__THROW
 ;

612 
	`vfwtf
 (
__FILE
 *
__ri
 
__s
,

613 cڡ 
wch_t
 *
__ri
 
__fm
,

614 
__gnuc_va_li
 
__g
)

620 
	`vwtf
 (cڡ 
wch_t
 *
__ri
 
__fm
,

621 
__gnuc_va_li
 
__g
)

625 
	$vswtf
 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__n
,

626 cڡ 
wch_t
 *
__ri
 
__fm
,

627 
__gnuc_va_li
 
__g
)

628 
__THROW
 ;

635 
	`fwsnf
 (
__FILE
 *
__ri
 
__am
,

636 cڡ 
wch_t
 *
__ri
 
__fm
, ...)

642 
	`wsnf
 (cڡ 
wch_t
 *
__ri
 
__fm
, ...)

645 
	$swsnf
 (cڡ 
wch_t
 *
__ri
 
__s
,

646 cڡ 
wch_t
 *
__ri
 
__fm
, ...)

647 
__THROW
 ;

649 #i
defed
 
__USE_ISOC99
 && !defed 
__USE_GNU
 \

650 && (!
defed
 
__LDBL_COMPAT
 || !defed 
__REDIRECT
) \

651 && (
defed
 
__STRICT_ANSI__
 || defed 
__USE_XOPEN2K
)

652 #ifde
__REDIRECT


656 
	`__REDIRECT
 (
fwsnf
, (
__FILE
 *
__ri
 
__am
,

657 cڡ 
wch_t
 *
__ri
 
__fm
, ...),

658 
__isoc99_fwsnf
)

660 
	`__REDIRECT
 (
wsnf
, (cڡ 
wch_t
 *
__ri
 
__fm
, ...),

661 
__isoc99_wsnf
)

663 
	`__REDIRECT_NTH
 (
swsnf
, (cڡ 
wch_t
 *
__ri
 
__s
,

664 cڡ 
wch_t
 *
__ri
 
__fm
,

665 ...), 
__isoc99_swsnf
)

668 
	`__isoc99_fwsnf
 (
__FILE
 *
__ri
 
__am
,

669 cڡ 
wch_t
 *
__ri
 
__fm
, ...);

670 
	`__isoc99_wsnf
 (cڡ 
wch_t
 *
__ri
 
__fm
, ...);

671 
	$__isoc99_swsnf
 (cڡ 
wch_t
 *
__ri
 
__s
,

672 cڡ 
wch_t
 *
__ri
 
__fm
, ...)

673 
__THROW
;

674 
	#fwsnf
 
__isoc99_fwsnf


	)

675 
	#wsnf
 
__isoc99_wsnf


	)

676 
	#swsnf
 
__isoc99_swsnf


	)

680 
__END_NAMESPACE_STD


683 #ifde
__USE_ISOC99


684 
__BEGIN_NAMESPACE_C99


689 
	`vfwsnf
 (
__FILE
 *
__ri
 
__s
,

690 cڡ 
wch_t
 *
__ri
 
__fm
,

691 
__gnuc_va_li
 
__g
)

697 
	`vwsnf
 (cڡ 
wch_t
 *
__ri
 
__fm
,

698 
__gnuc_va_li
 
__g
)

701 
	$vswsnf
 (cڡ 
wch_t
 *
__ri
 
__s
,

702 cڡ 
wch_t
 *
__ri
 
__fm
,

703 
__gnuc_va_li
 
__g
)

704 
__THROW
 ;

706 #i!
defed
 
__USE_GNU
 \

707 && (!
defed
 
__LDBL_COMPAT
 || !defed 
__REDIRECT
) \

708 && (
defed
 
__STRICT_ANSI__
 || defed 
__USE_XOPEN2K
)

709 #ifde
__REDIRECT


710 
	`__REDIRECT
 (
vfwsnf
, (
__FILE
 *
__ri
 
__s
,

711 cڡ 
wch_t
 *
__ri
 
__fm
,

712 
__gnuc_va_li
 
__g
), 
__isoc99_vfwsnf
)

714 
	`__REDIRECT
 (
vwsnf
, (cڡ 
wch_t
 *
__ri
 
__fm
,

715 
__gnuc_va_li
 
__g
), 
__isoc99_vwsnf
)

717 
	`__REDIRECT_NTH
 (
vswsnf
, (cڡ 
wch_t
 *
__ri
 
__s
,

718 cڡ 
wch_t
 *
__ri
 
__fm
,

719 
__gnuc_va_li
 
__g
), 
__isoc99_vswsnf
)

722 
	`__isoc99_vfwsnf
 (
__FILE
 *
__ri
 
__s
,

723 cڡ 
wch_t
 *
__ri
 
__fm
,

724 
__gnuc_va_li
 
__g
);

725 
	`__isoc99_vwsnf
 (cڡ 
wch_t
 *
__ri
 
__fm
,

726 
__gnuc_va_li
 
__g
);

727 
	$__isoc99_vswsnf
 (cڡ 
wch_t
 *
__ri
 
__s
,

728 cڡ 
wch_t
 *
__ri
 
__fm
,

729 
__gnuc_va_li
 
__g

__THROW
;

730 
	#vfwsnf
 
__isoc99_vfwsnf


	)

731 
	#vwsnf
 
__isoc99_vwsnf


	)

732 
	#vswsnf
 
__isoc99_vswsnf


	)

736 
__END_NAMESPACE_C99


740 
__BEGIN_NAMESPACE_STD


745 
wt_t
 
	`fgwc
 (
__FILE
 *
__am
);

746 
wt_t
 
	`gwc
 (
__FILE
 *
__am
);

752 
wt_t
 
	`gwch
 ();

759 
wt_t
 
	`utwc
 (
wch_t
 
__wc
, 
__FILE
 *
__am
);

760 
wt_t
 
	`putwc
 (
wch_t
 
__wc
, 
__FILE
 *
__am
);

766 
wt_t
 
	`putwch
 (
wch_t
 
__wc
);

774 
wch_t
 *
	`fgws
 (wch_*
__ri
 
__ws
, 
__n
,

775 
__FILE
 *
__ri
 
__am
);

781 
	`utws
 (cڡ 
wch_t
 *
__ri
 
__ws
,

782 
__FILE
 *
__ri
 
__am
);

789 
wt_t
 
	`ungwc
 (wt_
__wc
, 
__FILE
 *
__am
);

790 
__END_NAMESPACE_STD


793 #ifde
__USE_GNU


801 
wt_t
 
	`gwc_uocked
 (
__FILE
 *
__am
);

802 
wt_t
 
	`gwch_uocked
 ();

810 
wt_t
 
	`fgwc_uocked
 (
__FILE
 *
__am
);

818 
wt_t
 
	`utwc_uocked
 (
wch_t
 
__wc
, 
__FILE
 *
__am
);

827 
wt_t
 
	`putwc_uocked
 (
wch_t
 
__wc
, 
__FILE
 *
__am
);

828 
wt_t
 
	`putwch_uocked
 (
wch_t
 
__wc
);

837 
wch_t
 *
	`fgws_uocked
 (wch_*
__ri
 
__ws
, 
__n
,

838 
__FILE
 *
__ri
 
__am
);

846 
	`utws_uocked
 (cڡ 
wch_t
 *
__ri
 
__ws
,

847 
__FILE
 *
__ri
 
__am
);

851 
__BEGIN_NAMESPACE_C99


855 
size_t
 
	$wcsime
 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__maxsize
,

856 cڡ 
wch_t
 *
__ri
 
__fm
,

857 cڡ 
tm
 *
__ri
 
__

__THROW
;

858 
__END_NAMESPACE_C99


860 #ifde
__USE_GNU


861 
	~<xlo.h
>

865 
size_t
 
	$wcsime_l
 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__maxsize
,

866 cڡ 
wch_t
 *
__ri
 
__fm
,

867 cڡ 
tm
 *
__ri
 
__
,

868 
__lo_t
 
__loc

__THROW
;

877 #i
defed
 
__USE_UNIX98
 && !defed 
__USE_GNU


878 
	#__ed_iswxxx


	)

879 
	~<wy.h
>

883 #i
__USE_FORTIFY_LEVEL
 > 0 && 
defed
 
__ftify_funi


884 
	~<bs/wch2.h
>

887 #ifde
__LDBL_COMPAT


888 
	~<bs/wch-ldbl.h
>

891 
__END_DECLS


899 #unde
__ed_mbe_t


900 #unde
__ed_wt_t


	@/usr/include/asm-generic/errno.h

1 #ide
_ASM_GENERIC_ERRNO_H


2 
	#_ASM_GENERIC_ERRNO_H


	)

4 
	~<asm-gic/o-ba.h
>

6 
	#EDEADLK
 35

	)

7 
	#ENAMETOOLONG
 36

	)

8 
	#ENOLCK
 37

	)

9 
	#ENOSYS
 38

	)

10 
	#ENOTEMPTY
 39

	)

11 
	#ELOOP
 40

	)

12 
	#EWOULDBLOCK
 
EAGAIN


	)

13 
	#ENOMSG
 42

	)

14 
	#EIDRM
 43

	)

15 
	#ECHRNG
 44

	)

16 
	#EL2NSYNC
 45

	)

17 
	#EL3HLT
 46

	)

18 
	#EL3RST
 47

	)

19 
	#ELNRNG
 48

	)

20 
	#EUNATCH
 49

	)

21 
	#ENOCSI
 50

	)

22 
	#EL2HLT
 51

	)

23 
	#EBADE
 52

	)

24 
	#EBADR
 53

	)

25 
	#EXFULL
 54

	)

26 
	#ENOANO
 55

	)

27 
	#EBADRQC
 56

	)

28 
	#EBADSLT
 57

	)

30 
	#EDEADLOCK
 
EDEADLK


	)

32 
	#EBFONT
 59

	)

33 
	#ENOSTR
 60

	)

34 
	#ENODATA
 61

	)

35 
	#ETIME
 62

	)

36 
	#ENOSR
 63

	)

37 
	#ENONET
 64

	)

38 
	#ENOPKG
 65

	)

39 
	#EREMOTE
 66

	)

40 
	#ENOLINK
 67

	)

41 
	#EADV
 68

	)

42 
	#ESRMNT
 69

	)

43 
	#ECOMM
 70

	)

44 
	#EPROTO
 71

	)

45 
	#EMULTIHOP
 72

	)

46 
	#EDOTDOT
 73

	)

47 
	#EBADMSG
 74

	)

48 
	#EOVERFLOW
 75

	)

49 
	#ENOTUNIQ
 76

	)

50 
	#EBADFD
 77

	)

51 
	#EREMCHG
 78

	)

52 
	#ELIBACC
 79

	)

53 
	#ELIBBAD
 80

	)

54 
	#ELIBSCN
 81

	)

55 
	#ELIBMAX
 82

	)

56 
	#ELIBEXEC
 83

	)

57 
	#EILSEQ
 84

	)

58 
	#ERESTART
 85

	)

59 
	#ESTRPIPE
 86

	)

60 
	#EUSERS
 87

	)

61 
	#ENOTSOCK
 88

	)

62 
	#EDESTADDRREQ
 89

	)

63 
	#EMSGSIZE
 90

	)

64 
	#EPROTOTYPE
 91

	)

65 
	#ENOPROTOOPT
 92

	)

66 
	#EPROTONOSUPPORT
 93

	)

67 
	#ESOCKTNOSUPPORT
 94

	)

68 
	#EOPNOTSUPP
 95

	)

69 
	#EPFNOSUPPORT
 96

	)

70 
	#EAFNOSUPPORT
 97

	)

71 
	#EADDRINUSE
 98

	)

72 
	#EADDRNOTAVAIL
 99

	)

73 
	#ENETDOWN
 100

	)

74 
	#ENETUNREACH
 101

	)

75 
	#ENETRESET
 102

	)

76 
	#ECONNABORTED
 103

	)

77 
	#ECONNRESET
 104

	)

78 
	#ENOBUFS
 105

	)

79 
	#EISCONN
 106

	)

80 
	#ENOTCONN
 107

	)

81 
	#ESHUTDOWN
 108

	)

82 
	#ETOOMANYREFS
 109

	)

83 
	#ETIMEDOUT
 110

	)

84 
	#ECONNREFUSED
 111

	)

85 
	#EHOSTDOWN
 112

	)

86 
	#EHOSTUNREACH
 113

	)

87 
	#EALREADY
 114

	)

88 
	#EINPROGRESS
 115

	)

89 
	#ESTALE
 116

	)

90 
	#EUCLEAN
 117

	)

91 
	#ENOTNAM
 118

	)

92 
	#ENAVAIL
 119

	)

93 
	#EISNAM
 120

	)

94 
	#EREMOTEIO
 121

	)

95 
	#EDQUOT
 122

	)

97 
	#ENOMEDIUM
 123

	)

98 
	#EMEDIUMTYPE
 124

	)

99 
	#ECANCELED
 125

	)

100 
	#ENOKEY
 126

	)

101 
	#EKEYEXPIRED
 127

	)

102 
	#EKEYREVOKED
 128

	)

103 
	#EKEYREJECTED
 129

	)

106 
	#EOWNERDEAD
 130

	)

107 
	#ENOTRECOVERABLE
 131

	)

109 
	#ERFKILL
 132

	)

111 
	#EHWPOISON
 133

	)

	@/usr/include/bits/wchar-ldbl.h

19 #ide
_WCHAR_H


23 #i
defed
 
__USE_ISOC95
 || defed 
__USE_UNIX98


24 
__BEGIN_NAMESPACE_C99


25 
__LDBL_REDIR_DECL
 (
fwtf
);

26 
__LDBL_REDIR_DECL
 (
wtf
);

27 
__LDBL_REDIR_DECL
 (
swtf
);

28 
__LDBL_REDIR_DECL
 (
vfwtf
);

29 
__LDBL_REDIR_DECL
 (
vwtf
);

30 
__LDBL_REDIR_DECL
 (
vswtf
);

31 #i
defed
 
__USE_ISOC99
 && !defed 
__USE_GNU
 \

32 && !
defed
 
	g__REDIRECT
 \

33 && (
defed
 
	g__STRICT_ANSI__
 || defed 
	g__USE_XOPEN2K
)

34 
	$__LDBL_REDIR1_DECL
 (
fwsnf
, 
__dbl___isoc99_fwsnf
)

35 
	$__LDBL_REDIR1_DECL
 (
wsnf
, 
__dbl___isoc99_wsnf
)

36 
	$__LDBL_REDIR1_DECL
 (
swsnf
, 
__dbl___isoc99_swsnf
)

38 
	`__LDBL_REDIR_DECL
 (
fwsnf
);

39 
	`__LDBL_REDIR_DECL
 (
wsnf
);

40 
	`__LDBL_REDIR_DECL
 (
swsnf
);

42 
__END_NAMESPACE_C99


45 #ifde
__USE_ISOC99


46 
__BEGIN_NAMESPACE_C99


47 
	`__LDBL_REDIR1_DECL
 (
wcd
, 
wcod
);

48 #i!
defed
 
__USE_GNU
 && !defed 
__REDIRECT
 \

49 && (
defed
 
__STRICT_ANSI__
 || defed 
__USE_XOPEN2K
)

50 
	$__LDBL_REDIR1_DECL
 (
vfwsnf
, 
__dbl___isoc99_vfwsnf
)

51 
	$__LDBL_REDIR1_DECL
 (
vwsnf
, 
__dbl___isoc99_vwsnf
)

52 
	$__LDBL_REDIR1_DECL
 (
vswsnf
, 
__dbl___isoc99_vswsnf
)

54 
	`__LDBL_REDIR_DECL
 (
vfwsnf
);

55 
	`__LDBL_REDIR_DECL
 (
vwsnf
);

56 
	`__LDBL_REDIR_DECL
 (
vswsnf
);

58 
__END_NAMESPACE_C99


61 #ifde
__USE_GNU


62 
	`__LDBL_REDIR1_DECL
 (
wcd_l
, 
wcod_l
);

65 #i
__USE_FORTIFY_LEVEL
 > 0 && 
defed
 
__ftify_funi


66 
	$__LDBL_REDIR_DECL
 (
__swtf_chk
)

67 
	$__LDBL_REDIR_DECL
 (
__vswtf_chk
)

68 #i
__USE_FORTIFY_LEVEL
 > 1

69 
	$__LDBL_REDIR_DECL
 (
__fwtf_chk
)

70 
	$__LDBL_REDIR_DECL
 (
__wtf_chk
)

71 
	$__LDBL_REDIR_DECL
 (
__vfwtf_chk
)

72 
	$__LDBL_REDIR_DECL
 (
__vwtf_chk
)

	@/usr/include/bits/wchar.h

19 #ide
_BITS_WCHAR_H


20 
	#_BITS_WCHAR_H
 1

	)

33 #ifde
__WCHAR_MAX__


34 
	#__WCHAR_MAX
 
__WCHAR_MAX__


	)

35 #i
L
'\0' - 1 > 0

36 
	#__WCHAR_MAX
 (0xffffffffu + 
L
'\0')

	)

38 
	#__WCHAR_MAX
 (0x7ffffff+ 
L
'\0')

	)

41 #ifde
__WCHAR_MIN__


42 
	#__WCHAR_MIN
 
__WCHAR_MIN__


	)

43 #i
L
'\0' - 1 > 0

44 
	#__WCHAR_MIN
 (
L
'\0' + 0)

	)

46 
	#__WCHAR_MIN
 (-
__WCHAR_MAX
 - 1)

	)

	@/usr/include/bits/wchar2.h

19 #ide
_WCHAR_H


24 
wch_t
 *
	$__wmemy_chk
 (
wch_t
 *
__ri
 
__s1
,

25 cڡ 
wch_t
 *
__ri
 
__s2
, 
size_t
 
__n
,

26 
size_t
 
__ns1

__THROW
;

27 
wch_t
 *
	`__REDIRECT_NTH
 (
__wmemy_s
,

28 (
wch_t
 *
__ri
 
__s1
,

29 cڡ 
wch_t
 *
__ri
 
__s2
, 
size_t
 
__n
),

30 
wmemy
);

31 
wch_t
 *
	`__REDIRECT_NTH
 (
__wmemy_chk_wn
,

32 (
wch_t
 *
__ri
 
__s1
,

33 cڡ 
wch_t
 *
__ri
 
__s2
, 
size_t
 
__n
,

34 
size_t
 
__ns1
), 
__wmemy_chk
)

35 
	`__wǉr
 ("wmemcpy called withength biggerhan size of destination "

38 
__ftify_funi
 
wch_t
 *

39 
	`__NTH
 (
	$wmemy
 (
wch_t
 *
__ri
 
__s1
, cڡ wch_*__ri 
__s2
,

40 
size_t
 
__n
))

42 i(
	`__bos0
 (
__s1
!(
size_t
) -1)

44 i(!
	`__but_cڡt_p
 (
__n
))

45  
	`__wmemy_chk
 (
__s1
, 
__s2
, 
__n
,

46 
	`__bos0
 (
__s1
/  (
wch_t
));

48 i(
__n
 > 
	`__bos0
 (
__s1
/  (
wch_t
))

49  
	`__wmemy_chk_wn
 (
__s1
, 
__s2
, 
__n
,

50 
	`__bos0
 (
__s1
/  (
wch_t
));

52  
	`__wmemy_s
 (
__s1
, 
__s2
, 
__n
);

53 
	}
}

56 
wch_t
 *
	$__wmemmove_chk
 (
wch_t
 *
__s1
, cڡ wch_*
__s2
,

57 
size_t
 
__n
, size_
__ns1

__THROW
;

58 
wch_t
 *
	`__REDIRECT_NTH
 (
__wmemmove_s
, (wch_*
__s1
,

59 cڡ 
wch_t
 *
__s2
,

60 
size_t
 
__n
), 
wmemmove
);

61 
wch_t
 *
	`__REDIRECT_NTH
 (
__wmemmove_chk_wn
,

62 (
wch_t
 *
__s1
, cڡ wch_*
__s2
,

63 
size_t
 
__n
, size_
__ns1
), 
__wmemmove_chk
)

64 
	`__wǉr
 ("wmemmove called withength biggerhan size of destination "

67 
__ftify_funi
 
wch_t
 *

68 
	`__NTH
 (
	$wmemmove
 (
wch_t
 *
__s1
, cڡ wch_*
__s2
, 
size_t
 
__n
))

70 i(
	`__bos0
 (
__s1
!(
size_t
) -1)

72 i(!
	`__but_cڡt_p
 (
__n
))

73  
	`__wmemmove_chk
 (
__s1
, 
__s2
, 
__n
,

74 
	`__bos0
 (
__s1
/  (
wch_t
));

76 i(
__n
 > 
	`__bos0
 (
__s1
/  (
wch_t
))

77  
	`__wmemmove_chk_wn
 (
__s1
, 
__s2
, 
__n
,

78 
	`__bos0
 (
__s1
/  (
wch_t
));

80  
	`__wmemmove_s
 (
__s1
, 
__s2
, 
__n
);

81 
	}
}

84 #ifde
__USE_GNU


85 
wch_t
 *
	$__wmempy_chk
 (
wch_t
 *
__ri
 
__s1
,

86 cڡ 
wch_t
 *
__ri
 
__s2
, 
size_t
 
__n
,

87 
size_t
 
__ns1

__THROW
;

88 
wch_t
 *
	`__REDIRECT_NTH
 (
__wmempy_s
,

89 (
wch_t
 *
__ri
 
__s1
,

90 cڡ 
wch_t
 *
__ri
 
__s2
,

91 
size_t
 
__n
), 
wmempy
);

92 
wch_t
 *
	`__REDIRECT_NTH
 (
__wmempy_chk_wn
,

93 (
wch_t
 *
__ri
 
__s1
,

94 cڡ 
wch_t
 *
__ri
 
__s2
, 
size_t
 
__n
,

95 
size_t
 
__ns1
), 
__wmempy_chk
)

96 
	`__wǉr
 ("wmempcpy called withength biggerhan size of destination "

99 
__ftify_funi
 
wch_t
 *

100 
	`__NTH
 (
	$wmempy
 (
wch_t
 *
__ri
 
__s1
, cڡ wch_*__ri 
__s2
,

101 
size_t
 
__n
))

103 i(
	`__bos0
 (
__s1
!(
size_t
) -1)

105 i(!
	`__but_cڡt_p
 (
__n
))

106  
	`__wmempy_chk
 (
__s1
, 
__s2
, 
__n
,

107 
	`__bos0
 (
__s1
/  (
wch_t
));

109 i(
__n
 > 
	`__bos0
 (
__s1
/  (
wch_t
))

110  
	`__wmempy_chk_wn
 (
__s1
, 
__s2
, 
__n
,

111 
	`__bos0
 (
__s1
/  (
wch_t
));

113  
	`__wmempy_s
 (
__s1
, 
__s2
, 
__n
);

114 
	}
}

118 
wch_t
 *
	$__wmemt_chk
 (
wch_t
 *
__s
, wch_
__c
, 
size_t
 
__n
,

119 
size_t
 
__ns

__THROW
;

120 
wch_t
 *
	`__REDIRECT_NTH
 (
__wmemt_s
, (wch_*
__s
, wch_
__c
,

121 
size_t
 
__n
), 
wmemt
);

122 
wch_t
 *
	`__REDIRECT_NTH
 (
__wmemt_chk_wn
,

123 (
wch_t
 *
__s
, wch_
__c
, 
size_t
 
__n
,

124 
size_t
 
__ns
), 
__wmemt_chk
)

125 
	`__wǉr
 ("wmemset called withength biggerhan size of destination "

128 
__ftify_funi
 
wch_t
 *

129 
	`__NTH
 (
	$wmemt
 (
wch_t
 *
__s
, wch_
__c
, 
size_t
 
__n
))

131 i(
	`__bos0
 (
__s
!(
size_t
) -1)

133 i(!
	`__but_cڡt_p
 (
__n
))

134  
	`__wmemt_chk
 (
__s
, 
__c
, 
__n
, 
	`__bos0
 (__s/  (
wch_t
));

136 i(
__n
 > 
	`__bos0
 (
__s
/  (
wch_t
))

137  
	`__wmemt_chk_wn
 (
__s
, 
__c
, 
__n
,

138 
	`__bos0
 (
__s
/  (
wch_t
));

140  
	`__wmemt_s
 (
__s
, 
__c
, 
__n
);

141 
	}
}

144 
wch_t
 *
	$__wcsy_chk
 (
wch_t
 *
__ri
 
__de
,

145 cڡ 
wch_t
 *
__ri
 
__c
,

146 
size_t
 
__n

__THROW
;

147 
wch_t
 *
	`__REDIRECT_NTH
 (
__wcsy_s
,

148 (
wch_t
 *
__ri
 
__de
,

149 cڡ 
wch_t
 *
__ri
 
__c
), 
wcsy
);

151 
__ftify_funi
 
wch_t
 *

152 
	`__NTH
 (
	$wcsy
 (
wch_t
 *
__ri
 
__de
, cڡ wch_*__ri 
__c
))

154 i(
	`__bos
 (
__de
!(
size_t
) -1)

155  
	`__wcsy_chk
 (
__de
, 
__c
, 
	`__bos
 (__de/  (
wch_t
));

156  
	`__wcsy_s
 (
__de
, 
__c
);

157 
	}
}

160 
wch_t
 *
	$__wy_chk
 (
wch_t
 *
__ri
 
__de
,

161 cڡ 
wch_t
 *
__ri
 
__c
,

162 
size_t
 
__den

__THROW
;

163 
wch_t
 *
	`__REDIRECT_NTH
 (
__wy_s
,

164 (
wch_t
 *
__ri
 
__de
,

165 cڡ 
wch_t
 *
__ri
 
__c
), 
wy
);

167 
__ftify_funi
 
wch_t
 *

168 
	`__NTH
 (
	$wy
 (
wch_t
 *
__ri
 
__de
, cڡ wch_*__ri 
__c
))

170 i(
	`__bos
 (
__de
!(
size_t
) -1)

171  
	`__wy_chk
 (
__de
, 
__c
, 
	`__bos
 (__de/  (
wch_t
));

172  
	`__wy_s
 (
__de
, 
__c
);

173 
	}
}

176 
wch_t
 *
	$__wcy_chk
 (
wch_t
 *
__ri
 
__de
,

177 cڡ 
wch_t
 *
__ri
 
__c
, 
size_t
 
__n
,

178 
size_t
 
__den

__THROW
;

179 
wch_t
 *
	`__REDIRECT_NTH
 (
__wcy_s
,

180 (
wch_t
 *
__ri
 
__de
,

181 cڡ 
wch_t
 *
__ri
 
__c
,

182 
size_t
 
__n
), 
wcy
);

183 
wch_t
 *
	`__REDIRECT_NTH
 (
__wcy_chk_wn
,

184 (
wch_t
 *
__ri
 
__de
,

185 cڡ 
wch_t
 *
__ri
 
__c
,

186 
size_t
 
__n
, size_
__den
), 
__wcy_chk
)

187 
	`__wǉr
 ("wcsncpy called withength biggerhan size of destination "

190 
__ftify_funi
 
wch_t
 *

191 
	`__NTH
 (
	$wcy
 (
wch_t
 *
__ri
 
__de
, cڡ wch_*__ri 
__c
,

192 
size_t
 
__n
))

194 i(
	`__bos
 (
__de
!(
size_t
) -1)

196 i(!
	`__but_cڡt_p
 (
__n
))

197  
	`__wcy_chk
 (
__de
, 
__c
, 
__n
,

198 
	`__bos
 (
__de
/  (
wch_t
));

199 i(
__n
 > 
	`__bos
 (
__de
/  (
wch_t
))

200  
	`__wcy_chk_wn
 (
__de
, 
__c
, 
__n
,

201 
	`__bos
 (
__de
/  (
wch_t
));

203  
	`__wcy_s
 (
__de
, 
__c
, 
__n
);

204 
	}
}

207 
wch_t
 *
	$__wny_chk
 (
wch_t
 *
__ri
 
__de
,

208 cڡ 
wch_t
 *
__ri
 
__c
, 
size_t
 
__n
,

209 
size_t
 
__den

__THROW
;

210 
wch_t
 *
	`__REDIRECT_NTH
 (
__wny_s
,

211 (
wch_t
 *
__ri
 
__de
,

212 cڡ 
wch_t
 *
__ri
 
__c
,

213 
size_t
 
__n
), 
wny
);

214 
wch_t
 *
	`__REDIRECT_NTH
 (
__wny_chk_wn
,

215 (
wch_t
 *
__ri
 
__de
,

216 cڡ 
wch_t
 *
__ri
 
__c
,

217 
size_t
 
__n
, size_
__den
), 
__wny_chk
)

218 
	`__wǉr
 ("wcpncpy called withength biggerhan size of destination "

221 
__ftify_funi
 
wch_t
 *

222 
	`__NTH
 (
	$wny
 (
wch_t
 *
__ri
 
__de
, cڡ wch_*__ri 
__c
,

223 
size_t
 
__n
))

225 i(
	`__bos
 (
__de
!(
size_t
) -1)

227 i(!
	`__but_cڡt_p
 (
__n
))

228  
	`__wny_chk
 (
__de
, 
__c
, 
__n
,

229 
	`__bos
 (
__de
/  (
wch_t
));

230 i(
__n
 > 
	`__bos
 (
__de
/  (
wch_t
))

231  
	`__wny_chk_wn
 (
__de
, 
__c
, 
__n
,

232 
	`__bos
 (
__de
/  (
wch_t
));

234  
	`__wny_s
 (
__de
, 
__c
, 
__n
);

235 
	}
}

238 
wch_t
 *
	$__wcst_chk
 (
wch_t
 *
__ri
 
__de
,

239 cڡ 
wch_t
 *
__ri
 
__c
,

240 
size_t
 
__den

__THROW
;

241 
wch_t
 *
	`__REDIRECT_NTH
 (
__wcst_s
,

242 (
wch_t
 *
__ri
 
__de
,

243 cڡ 
wch_t
 *
__ri
 
__c
), 
wcst
);

245 
__ftify_funi
 
wch_t
 *

246 
	`__NTH
 (
	$wcst
 (
wch_t
 *
__ri
 
__de
, cڡ wch_*__ri 
__c
))

248 i(
	`__bos
 (
__de
!(
size_t
) -1)

249  
	`__wcst_chk
 (
__de
, 
__c
, 
	`__bos
 (__de/  (
wch_t
));

250  
	`__wcst_s
 (
__de
, 
__c
);

251 
	}
}

254 
wch_t
 *
	$__wct_chk
 (
wch_t
 *
__ri
 
__de
,

255 cڡ 
wch_t
 *
__ri
 
__c
,

256 
size_t
 
__n
, size_
__den

__THROW
;

257 
wch_t
 *
	`__REDIRECT_NTH
 (
__wct_s
,

258 (
wch_t
 *
__ri
 
__de
,

259 cڡ 
wch_t
 *
__ri
 
__c
,

260 
size_t
 
__n
), 
wct
);

262 
__ftify_funi
 
wch_t
 *

263 
	`__NTH
 (
	$wct
 (
wch_t
 *
__ri
 
__de
, cڡ wch_*__ri 
__c
,

264 
size_t
 
__n
))

266 i(
	`__bos
 (
__de
!(
size_t
) -1)

267  
	`__wct_chk
 (
__de
, 
__c
, 
__n
,

268 
	`__bos
 (
__de
/  (
wch_t
));

269  
	`__wct_s
 (
__de
, 
__c
, 
__n
);

270 
	}
}

273 
	$__swtf_chk
 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__n
,

274 
__ag
, 
size_t
 
__s_n
,

275 cڡ 
wch_t
 *
__ri
 
__fm
, ...)

276 
__THROW
 ;

278 
	`__REDIRECT_NTH_LDBL
 (
__swtf_s
,

279 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__n
,

280 cڡ 
wch_t
 *
__ri
 
__fmt
, ...),

281 
swtf
);

283 #ifde
__va_g_ck


284 
__ftify_funi
 

285 
	`__NTH
 (
	$swtf
 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__n
,

286 cڡ 
wch_t
 *
__ri
 
__fmt
, ...))

288 i(
	`__bos
 (
__s
!(
size_t
-1 || 
__USE_FORTIFY_LEVEL
 > 1)

289  
	`__swtf_chk
 (
__s
, 
__n
, 
__USE_FORTIFY_LEVEL
 - 1,

290 
	`__bos
 (
__s
/  (
wch_t
),

291 
__fmt
, 
	`__va_g_ck
 ());

292  
	`__swtf_s
 (
__s
, 
__n
, 
__fmt
, 
	`__va_g_ck
 ());

293 
	}
}

294 #i!
defed
 
__lulus


296 
	#swtf
(
s
, 
n
, ...) \

297 (
	`__bos
 (
s
!(
size_t
-1 || 
__USE_FORTIFY_LEVEL
 > 1 \

298 ? 
	`__swtf_chk
 (
s
, 
n
, 
__USE_FORTIFY_LEVEL
 - 1, \

299 
	`__bos
 (
s
/  (
wch_t
), 
__VA_ARGS__
) \

300 : 
	`swtf
 (
s
, 
n
, 
__VA_ARGS__
))

	)

303 
	$__vswtf_chk
 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__n
,

304 
__ag
, 
size_t
 
__s_n
,

305 cڡ 
wch_t
 *
__ri
 
__fm
,

306 
__gnuc_va_li
 
__g
)

307 
__THROW
 ;

309 
	`__REDIRECT_NTH_LDBL
 (
__vswtf_s
,

310 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__n
,

311 cڡ 
wch_t
 *
__ri
 
__fmt
,

312 
__gnuc_va_li
 
__
), 
vswtf
);

314 
__ftify_funi
 

315 
	`__NTH
 (
	$vswtf
 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__n
,

316 cڡ 
wch_t
 *
__ri
 
__fmt
, 
__gnuc_va_li
 
__
))

318 i(
	`__bos
 (
__s
!(
size_t
-1 || 
__USE_FORTIFY_LEVEL
 > 1)

319  
	`__vswtf_chk
 (
__s
, 
__n
, 
__USE_FORTIFY_LEVEL
 - 1,

320 
	`__bos
 (
__s
/  (
wch_t
), 
__fmt
, 
__
);

321  
	`__vswtf_s
 (
__s
, 
__n
, 
__fmt
, 
__
);

322 
	}
}

325 #i
__USE_FORTIFY_LEVEL
 > 1

327 
__fwtf_chk
 (
__FILE
 *
__ri
 
__am
, 
__ag
,

328 cڡ 
wch_t
 *
__ri
 
__fm
, ...);

329 
__wtf_chk
 (
__ag
, cڡ 
wch_t
 *
__ri
 
__fm
,

331 
__vfwtf_chk
 (
__FILE
 *
__ri
 
__am
, 
__ag
,

332 cڡ 
wch_t
 *
__ri
 
__fm
,

333 
__gnuc_va_li
 
__
);

334 
__vwtf_chk
 (
__ag
, cڡ 
wch_t
 *
__ri
 
__fm
,

335 
__gnuc_va_li
 
__
);

337 #ifde
__va_g_ck


338 
__ftify_funi
 

339 
	$wtf
 (cڡ 
wch_t
 *
__ri
 
__fmt
, ...)

341  
	`__wtf_chk
 (
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
, 
	`__va_g_ck
 ());

342 
	}
}

344 
__ftify_funi
 

345 
	$fwtf
 (
__FILE
 *
__ri
 
__am
, cڡ 
wch_t
 *__ri 
__fmt
, ...)

347  
	`__fwtf_chk
 (
__am
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
,

348 
	`__va_g_ck
 ());

349 
	}
}

350 #i!
defed
 
__lulus


351 
	#wtf
(...) \

352 
	`__wtf_chk
 (
__USE_FORTIFY_LEVEL
 - 1, 
__VA_ARGS__
)

	)

353 
	#fwtf
(
am
, ...) \

354 
	`__fwtf_chk
 (
am
, 
__USE_FORTIFY_LEVEL
 - 1, 
__VA_ARGS__
)

	)

357 
__ftify_funi
 

358 
	$vwtf
 (cڡ 
wch_t
 *
__ri
 
__fmt
, 
__gnuc_va_li
 
__
)

360  
	`__vwtf_chk
 (
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
, 
__
);

361 
	}
}

363 
__ftify_funi
 

364 
	$vfwtf
 (
__FILE
 *
__ri
 
__am
,

365 cڡ 
wch_t
 *
__ri
 
__fmt
, 
__gnuc_va_li
 
__
)

367  
	`__vfwtf_chk
 (
__am
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
, 
__
);

368 
	}
}

372 
wch_t
 *
	$__fgws_chk
 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__size
, 
__n
,

373 
__FILE
 *
__ri
 
__am

__wur
;

374 
wch_t
 *
	`__REDIRECT
 (
__fgws_s
,

375 (
wch_t
 *
__ri
 
__s
, 
__n
,

376 
__FILE
 *
__ri
 
__am
), 
fgws

__wur
;

377 
wch_t
 *
	`__REDIRECT
 (
__fgws_chk_wn
,

378 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__size
, 
__n
,

379 
__FILE
 *
__ri
 
__am
), 
__fgws_chk
)

380 
__wur
 
	`__wǉr
 ("fgetws called with bigger sizehanength "

383 
__ftify_funi
 
__wur
 
wch_t
 *

384 
	$fgws
 (
wch_t
 *
__ri
 
__s
, 
__n
, 
__FILE
 *__ri 
__am
)

386 i(
	`__bos
 (
__s
!(
size_t
) -1)

388 i(!
	`__but_cڡt_p
 (
__n
) || __n <= 0)

389  
	`__fgws_chk
 (
__s
, 
	`__bos
 (__s/  (
wch_t
),

390 
__n
, 
__am
);

392 i((
size_t

__n
 > 
	`__bos
 (
__s
/  (
wch_t
))

393  
	`__fgws_chk_wn
 (
__s
, 
	`__bos
 (__s/  (
wch_t
),

394 
__n
, 
__am
);

396  
	`__fgws_s
 (
__s
, 
__n
, 
__am
);

397 
	}
}

399 #ifde
__USE_GNU


400 
wch_t
 *
	$__fgws_uocked_chk
 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__size
,

401 
__n
, 
__FILE
 *
__ri
 
__am
)

402 
__wur
;

403 
wch_t
 *
	`__REDIRECT
 (
__fgws_uocked_s
,

404 (
wch_t
 *
__ri
 
__s
, 
__n
,

405 
__FILE
 *
__ri
 
__am
), 
fgws_uocked
)

406 
__wur
;

407 
wch_t
 *
	`__REDIRECT
 (
__fgws_uocked_chk_wn
,

408 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__size
, 
__n
,

409 
__FILE
 *
__ri
 
__am
),

410 
__fgws_uocked_chk
)

411 
__wur
 
	`__wǉr
 ("fgetws_unlocked called with bigger sizehanength "

414 
__ftify_funi
 
__wur
 
wch_t
 *

415 
	$fgws_uocked
 (
wch_t
 *
__ri
 
__s
, 
__n
, 
__FILE
 *__ri 
__am
)

417 i(
	`__bos
 (
__s
!(
size_t
) -1)

419 i(!
	`__but_cڡt_p
 (
__n
) || __n <= 0)

420  
	`__fgws_uocked_chk
 (
__s
, 
	`__bos
 (__s/  (
wch_t
),

421 
__n
, 
__am
);

423 i((
size_t

__n
 > 
	`__bos
 (
__s
/  (
wch_t
))

424  
	`__fgws_uocked_chk_wn
 (
__s
, 
	`__bos
 (__s/  (
wch_t
),

425 
__n
, 
__am
);

427  
	`__fgws_uocked_s
 (
__s
, 
__n
, 
__am
);

428 
	}
}

432 
size_t
 
	$__wtomb_chk
 (*
__ri
 
__s
, 
wch_t
 
__wch
,

433 
mbe_t
 *
__ri
 
__p
,

434 
size_t
 
__bu

__THROW
 
__wur
;

435 
size_t
 
	`__REDIRECT_NTH
 (
__wtomb_s
,

436 (*
__ri
 
__s
, 
wch_t
 
__wch
,

437 
mbe_t
 *
__ri
 
__ps
), 
wtomb

__wur
;

439 
__ftify_funi
 
__wur
 
size_t


440 
	`__NTH
 (
	$wtomb
 (*
__ri
 
__s
, 
wch_t
 
__wch
,

441 
mbe_t
 *
__ri
 
__ps
))

446 
	#__WCHAR_MB_LEN_MAX
 16

	)

447 #i
defed
 
MB_LEN_MAX
 && MB_LEN_MAX !
__WCHAR_MB_LEN_MAX


450 i(
	`__bos
 (
__s
!(
size_t
-1 && 
__WCHAR_MB_LEN_MAX
 > __bos (__s))

451  
	`__wtomb_chk
 (
__s
, 
__wch
, 
__ps
, 
	`__bos
 (__s));

452  
	`__wtomb_s
 (
__s
, 
__wch
, 
__ps
);

453 
	}
}

456 
size_t
 
	$__mbtowcs_chk
 (
wch_t
 *
__ri
 
__d
,

457 cڡ **
__ri
 
__c
,

458 
size_t
 
__n
, 
mbe_t
 *
__ri
 
__ps
,

459 
size_t
 
__dn

__THROW
;

460 
size_t
 
	`__REDIRECT_NTH
 (
__mbtowcs_s
,

461 (
wch_t
 *
__ri
 
__d
,

462 cڡ **
__ri
 
__c
,

463 
size_t
 
__n
, 
mbe_t
 *
__ri
 
__ps
),

464 
mbtowcs
);

465 
size_t
 
	`__REDIRECT_NTH
 (
__mbtowcs_chk_wn
,

466 (
wch_t
 *
__ri
 
__d
,

467 cڡ **
__ri
 
__c
,

468 
size_t
 
__n
, 
mbe_t
 *
__ri
 
__ps
,

469 
size_t
 
__dn
), 
__mbtowcs_chk
)

470 
	`__wǉr
 ("mbsrtowcs called with dst buffer smallerhanen "

473 
__ftify_funi
 
size_t


474 
	`__NTH
 (
	$mbtowcs
 (
wch_t
 *
__ri
 
__d
, cڡ **__ri 
__c
,

475 
size_t
 
__n
, 
mbe_t
 *
__ri
 
__ps
))

477 i(
	`__bos
 (
__d
!(
size_t
) -1)

479 i(!
	`__but_cڡt_p
 (
__n
))

480  
	`__mbtowcs_chk
 (
__d
, 
__c
, 
__n
, 
__ps
,

481 
	`__bos
 (
__d
/  (
wch_t
));

483 i(
__n
 > 
	`__bos
 (
__d
/  (
wch_t
))

484  
	`__mbtowcs_chk_wn
 (
__d
, 
__c
, 
__n
, 
__ps
,

485 
	`__bos
 (
__d
/  (
wch_t
));

487  
	`__mbtowcs_s
 (
__d
, 
__c
, 
__n
, 
__ps
);

488 
	}
}

491 
size_t
 
	$__wctombs_chk
 (*
__ri
 
__d
,

492 cڡ 
wch_t
 **
__ri
 
__c
,

493 
size_t
 
__n
, 
mbe_t
 *
__ri
 
__ps
,

494 
size_t
 
__dn

__THROW
;

495 
size_t
 
	`__REDIRECT_NTH
 (
__wctombs_s
,

496 (*
__ri
 
__d
,

497 cڡ 
wch_t
 **
__ri
 
__c
,

498 
size_t
 
__n
, 
mbe_t
 *
__ri
 
__ps
),

499 
wctombs
);

500 
size_t
 
	`__REDIRECT_NTH
 (
__wctombs_chk_wn
,

501 (*
__ri
 
__d
,

502 cڡ 
wch_t
 **
__ri
 
__c
,

503 
size_t
 
__n
, 
mbe_t
 *
__ri
 
__ps
,

504 
size_t
 
__dn
), 
__wctombs_chk
)

505 
	`__wǉr
 ("wcsrtombs called with dst buffer smallerhanen");

507 
__ftify_funi
 
size_t


508 
	`__NTH
 (
	$wctombs
 (*
__ri
 
__d
, cڡ 
wch_t
 **__ri 
__c
,

509 
size_t
 
__n
, 
mbe_t
 *
__ri
 
__ps
))

511 i(
	`__bos
 (
__d
!(
size_t
) -1)

513 i(!
	`__but_cڡt_p
 (
__n
))

514  
	`__wctombs_chk
 (
__d
, 
__c
, 
__n
, 
__ps
, 
	`__bos
 (__dst));

516 i(
__n
 > 
	`__bos
 (
__d
))

517  
	`__wctombs_chk_wn
 (
__d
, 
__c
, 
__n
, 
__ps
, 
	`__bos
 (__dst));

519  
	`__wctombs_s
 (
__d
, 
__c
, 
__n
, 
__ps
);

520 
	}
}

523 #ifde
__USE_GNU


524 
size_t
 
	$__mbowcs_chk
 (
wch_t
 *
__ri
 
__d
,

525 cڡ **
__ri
 
__c
, 
size_t
 
__nmc
,

526 
size_t
 
__n
, 
mbe_t
 *
__ri
 
__ps
,

527 
size_t
 
__dn

__THROW
;

528 
size_t
 
	`__REDIRECT_NTH
 (
__mbowcs_s
,

529 (
wch_t
 *
__ri
 
__d
,

530 cڡ **
__ri
 
__c
, 
size_t
 
__nmc
,

531 
size_t
 
__n
, 
mbe_t
 *
__ri
 
__ps
),

532 
mbowcs
);

533 
size_t
 
	`__REDIRECT_NTH
 (
__mbowcs_chk_wn
,

534 (
wch_t
 *
__ri
 
__d
,

535 cڡ **
__ri
 
__c
, 
size_t
 
__nmc
,

536 
size_t
 
__n
, 
mbe_t
 *
__ri
 
__ps
,

537 
size_t
 
__dn
), 
__mbowcs_chk
)

538 
	`__wǉr
 ("mbsnrtowcs called with dst buffer smallerhanen "

541 
__ftify_funi
 
size_t


542 
	`__NTH
 (
	$mbowcs
 (
wch_t
 *
__ri
 
__d
, cڡ **__ri 
__c
,

543 
size_t
 
__nmc
, size_
__n
, 
mbe_t
 *
__ri
 
__ps
))

545 i(
	`__bos
 (
__d
!(
size_t
) -1)

547 i(!
	`__but_cڡt_p
 (
__n
))

548  
	`__mbowcs_chk
 (
__d
, 
__c
, 
__nmc
, 
__n
, 
__ps
,

549 
	`__bos
 (
__d
/  (
wch_t
));

551 i(
__n
 > 
	`__bos
 (
__d
/  (
wch_t
))

552  
	`__mbowcs_chk_wn
 (
__d
, 
__c
, 
__nmc
, 
__n
, 
__ps
,

553 
	`__bos
 (
__d
/  (
wch_t
));

555  
	`__mbowcs_s
 (
__d
, 
__c
, 
__nmc
, 
__n
, 
__ps
);

556 
	}
}

559 
size_t
 
	$__wcombs_chk
 (*
__ri
 
__d
,

560 cڡ 
wch_t
 **
__ri
 
__c
,

561 
size_t
 
__nwc
, size_
__n
,

562 
mbe_t
 *
__ri
 
__ps
, 
size_t
 
__dn
)

563 
__THROW
;

564 
size_t
 
	`__REDIRECT_NTH
 (
__wcombs_s
,

565 (*
__ri
 
__d
,

566 cڡ 
wch_t
 **
__ri
 
__c
,

567 
size_t
 
__nwc
, size_
__n
,

568 
mbe_t
 *
__ri
 
__ps
), 
wcombs
);

569 
size_t
 
	`__REDIRECT_NTH
 (
__wcombs_chk_wn
,

570 (*
__ri
 
__d
,

571 cڡ 
wch_t
 **
__ri
 
__c
,

572 
size_t
 
__nwc
, size_
__n
,

573 
mbe_t
 *
__ri
 
__ps
,

574 
size_t
 
__dn
), 
__wcombs_chk
)

575 
	`__wǉr
 ("wcsnrtombs called with dst buffer smallerhanen");

577 
__ftify_funi
 
size_t


578 
	`__NTH
 (
	$wcombs
 (*
__ri
 
__d
, cڡ 
wch_t
 **__ri 
__c
,

579 
size_t
 
__nwc
, size_
__n
, 
mbe_t
 *
__ri
 
__ps
))

581 i(
	`__bos
 (
__d
!(
size_t
) -1)

583 i(!
	`__but_cڡt_p
 (
__n
))

584  
	`__wcombs_chk
 (
__d
, 
__c
, 
__nwc
, 
__n
, 
__ps
,

585 
	`__bos
 (
__d
));

587 i(
__n
 > 
	`__bos
 (
__d
))

588  
	`__wcombs_chk_wn
 (
__d
, 
__c
, 
__nwc
, 
__n
, 
__ps
,

589 
	`__bos
 (
__d
));

591  
	`__wcombs_s
 (
__d
, 
__c
, 
__nwc
, 
__n
, 
__ps
);

592 
	}
}

	@/usr/include/gnu/option-groups.h

10 #ide
__GNU_OPTION_GROUPS_H


11 
	#__GNU_OPTION_GROUPS_H


	)

13 
	#__OPTION_EGLIBC_ADVANCED_INET6
 1

	)

14 
	#__OPTION_EGLIBC_BACKTRACE
 1

	)

15 
	#__OPTION_EGLIBC_BIG_MACROS
 1

	)

16 
	#__OPTION_EGLIBC_BSD
 1

	)

17 
	#__OPTION_EGLIBC_CATGETS
 1

	)

18 
	#__OPTION_EGLIBC_CHARSETS
 1

	)

19 
	#__OPTION_EGLIBC_CRYPT
 1

	)

20 
	#__OPTION_EGLIBC_CRYPT_UFC
 1

	)

21 
	#__OPTION_EGLIBC_CXX_TESTS
 1

	)

22 
	#__OPTION_EGLIBC_DB_ALIASES
 1

	)

23 
	#__OPTION_EGLIBC_ENVZ
 1

	)

24 
	#__OPTION_EGLIBC_FCVT
 1

	)

25 
	#__OPTION_EGLIBC_FMTMSG
 1

	)

26 
	#__OPTION_EGLIBC_FSTAB
 1

	)

27 
	#__OPTION_EGLIBC_FTRAVERSE
 1

	)

28 
	#__OPTION_EGLIBC_GETLOGIN
 1

	)

29 
	#__OPTION_EGLIBC_IDN
 1

	)

30 
	#__OPTION_EGLIBC_INET
 1

	)

31 
	#__OPTION_EGLIBC_INET_ANL
 1

	)

32 
	#__OPTION_EGLIBC_LIBM
 1

	)

33 
	#__OPTION_EGLIBC_LOCALES
 1

	)

34 
	#__OPTION_EGLIBC_LOCALE_CODE
 1

	)

35 
	#__OPTION_EGLIBC_MEMUSAGE
 1

	)

36 
	#__OPTION_EGLIBC_NIS
 1

	)

37 
	#__OPTION_EGLIBC_NSSWITCH
 1

	)

38 
	#__OPTION_EGLIBC_RCMD
 1

	)

39 
	#__OPTION_EGLIBC_RTLD_DEBUG
 1

	)

40 
	#__OPTION_EGLIBC_SPAWN
 1

	)

41 
	#__OPTION_EGLIBC_STREAMS
 1

	)

42 
	#__OPTION_EGLIBC_SUNRPC
 1

	)

43 
	#__OPTION_EGLIBC_UTMP
 1

	)

44 
	#__OPTION_EGLIBC_UTMPX
 1

	)

45 
	#__OPTION_EGLIBC_WORDEXP
 1

	)

46 
	#__OPTION_POSIX_C_LANG_WIDE_CHAR
 1

	)

47 
	#__OPTION_POSIX_REGEXP
 1

	)

48 
	#__OPTION_POSIX_REGEXP_GLIBC
 1

	)

49 
	#__OPTION_POSIX_WIDE_CHAR_DEVICE_IO
 1

	)

	@/usr/include/pthread.h

18 #ide
_PTHREAD_H


19 
	#_PTHREAD_H
 1

	)

21 
	~<us.h
>

22 
	~<dn.h
>

23 
	~<sched.h
>

24 
	~<time.h
>

26 
	~<bs/hadtys.h
>

27 
	~<bs/tjmp.h
>

28 
	~<bs/wdsize.h
>

34 
	mPTHREAD_CREATE_JOINABLE
,

35 
	#PTHREAD_CREATE_JOINABLE
 
PTHREAD_CREATE_JOINABLE


	)

36 
	mPTHREAD_CREATE_DETACHED


37 
	#PTHREAD_CREATE_DETACHED
 
PTHREAD_CREATE_DETACHED


	)

44 
	mPTHREAD_MUTEX_TIMED_NP
,

45 
	mPTHREAD_MUTEX_RECURSIVE_NP
,

46 
	mPTHREAD_MUTEX_ERRORCHECK_NP
,

47 
	mPTHREAD_MUTEX_ADAPTIVE_NP


48 #i
defed
 
__USE_UNIX98
 || defed 
__USE_XOPEN2K8


50 
	mPTHREAD_MUTEX_NORMAL
 = 
PTHREAD_MUTEX_TIMED_NP
,

51 
	mPTHREAD_MUTEX_RECURSIVE
 = 
PTHREAD_MUTEX_RECURSIVE_NP
,

52 
	mPTHREAD_MUTEX_ERRORCHECK
 = 
PTHREAD_MUTEX_ERRORCHECK_NP
,

53 
	mPTHREAD_MUTEX_DEFAULT
 = 
PTHREAD_MUTEX_NORMAL


55 #ifde
__USE_GNU


57 , 
	mPTHREAD_MUTEX_FAST_NP
 = 
PTHREAD_MUTEX_TIMED_NP


62 #ifde
__USE_XOPEN2K


66 
	mPTHREAD_MUTEX_STALLED
,

67 
	mPTHREAD_MUTEX_STALLED_NP
 = 
PTHREAD_MUTEX_STALLED
,

68 
	mPTHREAD_MUTEX_ROBUST
,

69 
	mPTHREAD_MUTEX_ROBUST_NP
 = 
PTHREAD_MUTEX_ROBUST


74 #i
defed
 
__USE_POSIX199506
 || defed 
__USE_UNIX98


78 
	mPTHREAD_PRIO_NONE
,

79 
	mPTHREAD_PRIO_INHERIT
,

80 
	mPTHREAD_PRIO_PROTECT


86 #i
__PTHREAD_MUTEX_HAVE_ELISION
 == 1

87 
	#__PTHREAD_SPINS
 0, 0

	)

88 #i
__PTHREAD_MUTEX_HAVE_ELISION
 == 2

89 
	#__PTHREAD_SPINS
 { 0, 0 }

	)

91 
	#__PTHREAD_SPINS
 0

	)

94 #ifde
__PTHREAD_MUTEX_HAVE_PREV


95 
	#PTHREAD_MUTEX_INITIALIZER
 \

96 { { 0, 0, 0, 0, 0, 
__PTHREAD_SPINS
, { 0, 0 } } }

	)

97 #ifde
__USE_GNU


98 
	#PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP
 \

99 { { 0, 0, 0, 0, 
PTHREAD_MUTEX_RECURSIVE_NP
, 
__PTHREAD_SPINS
, { 0, 0 } } }

	)

100 
	#PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP
 \

101 { { 0, 0, 0, 0, 
PTHREAD_MUTEX_ERRORCHECK_NP
, 
__PTHREAD_SPINS
, { 0, 0 } } }

	)

102 
	#PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP
 \

103 { { 0, 0, 0, 0, 
PTHREAD_MUTEX_ADAPTIVE_NP
, 
__PTHREAD_SPINS
, { 0, 0 } } }

	)

104 
	#PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP
 \

105 { { 0, 0, 0, 0, 
PTHREAD_MUTEX_ADAPTIVE_NP
, 
__PTHREAD_SPINS
, { 0, 0 } } }

	)

109 
	#PTHREAD_MUTEX_INITIALIZER
 \

110 { { 0, 0, 0, 0, 0, { 
__PTHREAD_SPINS
 } } }

	)

111 #ifde
__USE_GNU


112 
	#PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP
 \

113 { { 0, 0, 0, 
PTHREAD_MUTEX_RECURSIVE_NP
, 0, { 
__PTHREAD_SPINS
 } } }

	)

114 
	#PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP
 \

115 { { 0, 0, 0, 
PTHREAD_MUTEX_ERRORCHECK_NP
, 0, { 
__PTHREAD_SPINS
 } } }

	)

116 
	#PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP
 \

117 { { 0, 0, 0, 
PTHREAD_MUTEX_ADAPTIVE_NP
, 0, { 
__PTHREAD_SPINS
 } } }

	)

124 #i
defed
 
__USE_UNIX98
 || defed 
__USE_XOPEN2K


127 
	mPTHREAD_RWLOCK_PREFER_READER_NP
,

128 
	mPTHREAD_RWLOCK_PREFER_WRITER_NP
,

129 
	mPTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP
,

130 
	mPTHREAD_RWLOCK_DEFAULT_NP
 = 
PTHREAD_RWLOCK_PREFER_READER_NP


136 #ide
__PTHREAD_RWLOCK_INT_FLAGS_SHARED


137 #i
__WORDSIZE
 == 64

138 
	#__PTHREAD_RWLOCK_INT_FLAGS_SHARED
 1

	)

143 
	#PTHREAD_RWLOCK_INITIALIZER
 \

144 { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }

	)

145 #ifde
__USE_GNU


146 #ifde
__PTHREAD_RWLOCK_INT_FLAGS_SHARED


147 
	#PTHREAD_RWLOCK_WRITER_NONRECURSIVE_INITIALIZER_NP
 \

149 
PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP
 } }

	)

151 #i
__BYTE_ORDER
 =
__LITTLE_ENDIAN


152 
	#PTHREAD_RWLOCK_WRITER_NONRECURSIVE_INITIALIZER_NP
 \

153 { { 0, 0, 0, 0, 0, 0, 
PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP
, \

154 0, 0, 0, 0 } }

	)

156 
	#PTHREAD_RWLOCK_WRITER_NONRECURSIVE_INITIALIZER_NP
 \

157 { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 
PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP
,\

158 0 } }

	)

168 
	mPTHREAD_INHERIT_SCHED
,

169 
	#PTHREAD_INHERIT_SCHED
 
PTHREAD_INHERIT_SCHED


	)

170 
	mPTHREAD_EXPLICIT_SCHED


171 
	#PTHREAD_EXPLICIT_SCHED
 
PTHREAD_EXPLICIT_SCHED


	)

178 
	mPTHREAD_SCOPE_SYSTEM
,

179 
	#PTHREAD_SCOPE_SYSTEM
 
PTHREAD_SCOPE_SYSTEM


	)

180 
	mPTHREAD_SCOPE_PROCESS


181 
	#PTHREAD_SCOPE_PROCESS
 
PTHREAD_SCOPE_PROCESS


	)

188 
	mPTHREAD_PROCESS_PRIVATE
,

189 
	#PTHREAD_PROCESS_PRIVATE
 
PTHREAD_PROCESS_PRIVATE


	)

190 
	mPTHREAD_PROCESS_SHARED


191 
	#PTHREAD_PROCESS_SHARED
 
PTHREAD_PROCESS_SHARED


	)

197 
	#PTHREAD_COND_INITIALIZER
 { { 0, 0, 0, 0, 0, (*0, 0, 0 } }

	)

201 
	s_had_nup_bufr


203 (*
	m__route
) (*);

204 *
	m__g
;

205 
	m__ny
;

206 
_had_nup_bufr
 *
	m__ev
;

212 
	mPTHREAD_CANCEL_ENABLE
,

213 
	#PTHREAD_CANCEL_ENABLE
 
PTHREAD_CANCEL_ENABLE


	)

214 
	mPTHREAD_CANCEL_DISABLE


215 
	#PTHREAD_CANCEL_DISABLE
 
PTHREAD_CANCEL_DISABLE


	)

219 
	mPTHREAD_CANCEL_DEFERRED
,

220 
	#PTHREAD_CANCEL_DEFERRED
 
PTHREAD_CANCEL_DEFERRED


	)

221 
	mPTHREAD_CANCEL_ASYNCHRONOUS


222 
	#PTHREAD_CANCEL_ASYNCHRONOUS
 
PTHREAD_CANCEL_ASYNCHRONOUS


	)

224 
	#PTHREAD_CANCELED
 ((*-1)

	)

228 
	#PTHREAD_ONCE_INIT
 0

	)

231 #ifde
__USE_XOPEN2K


235 
	#PTHREAD_BARRIER_SERIAL_THREAD
 -1

	)

239 
__BEGIN_DECLS


244 
had_
 (
had_t
 *
__ri
 
__wthad
,

245 cڡ 
had__t
 *
__ri
 
__
,

246 *(*
__t_route
) (*),

247 *
__ri
 
__g

__THROWNL
 
__nnu
 ((1, 3));

253 
	$had_ex
 (*
__tv

	`__ibu__
 ((
__nܑu__
));

261 
	`had_jo
 (
had_t
 
__th
, **
__thad_tu
);

263 #ifde
__USE_GNU


266 
	$had_yjo_
 (
had_t
 
__th
, **
__thad_tu

__THROW
;

274 
	`had_timedjo_
 (
had_t
 
__th
, **
__thad_tu
,

275 cڡ 
timeec
 *
__abime
);

282 
	$had_dach
 (
had_t
 
__th

__THROW
;

286 
had_t
 
	$had_lf
 (
__THROW
 
	`__ibu__
 ((
__cڡ__
));

289 
	$had_equ
 (
had_t
 
__thad1
,thad_
__thad2
)

290 
__THROW
 
	`__ibu__
 ((
__cڡ__
));

298 
	$had__
 (
had__t
 *
__

__THROW
 
	`__nnu
 ((1));

301 
	$had__deroy
 (
had__t
 *
__
)

302 
__THROW
 
	`__nnu
 ((1));

305 
	$had__gdache
 (cڡ 
had__t
 *
__
,

306 *
__dache
)

307 
__THROW
 
	`__nnu
 ((1, 2));

310 
	$had__tdache
 (
had__t
 *
__
,

311 
__dache
)

312 
__THROW
 
	`__nnu
 ((1));

316 
	$had__ggudsize
 (cڡ 
had__t
 *
__
,

317 
size_t
 *
__gudsize
)

318 
__THROW
 
	`__nnu
 ((1, 2));

321 
	$had__tgudsize
 (
had__t
 *
__
,

322 
size_t
 
__gudsize
)

323 
__THROW
 
	`__nnu
 ((1));

327 
	$had__gschedm
 (cڡ 
had__t
 *
__ri
 
__
,

328 
sched_m
 *
__ri
 
__m
)

329 
__THROW
 
	`__nnu
 ((1, 2));

332 
	$had__tschedm
 (
had__t
 *
__ri
 
__
,

333 cڡ 
sched_m
 *
__ri


334 
__m

__THROW
 
	`__nnu
 ((1, 2));

337 
	$had__gschedpicy
 (cڡ 
had__t
 *
__ri


338 
__
, *
__ri
 
__picy
)

339 
__THROW
 
	`__nnu
 ((1, 2));

342 
	$had__tschedpicy
 (
had__t
 *
__
, 
__picy
)

343 
__THROW
 
	`__nnu
 ((1));

346 
	$had__ghsched
 (cڡ 
had__t
 *
__ri


347 
__
, *
__ri
 
__h
)

348 
__THROW
 
	`__nnu
 ((1, 2));

351 
	$had__thsched
 (
had__t
 *
__
,

352 
__h
)

353 
__THROW
 
	`__nnu
 ((1));

357 
	$had__gsce
 (cڡ 
had__t
 *
__ri
 
__
,

358 *
__ri
 
__sce
)

359 
__THROW
 
	`__nnu
 ((1, 2));

362 
	$had__tsce
 (
had__t
 *
__
, 
__sce
)

363 
__THROW
 
	`__nnu
 ((1));

366 
	$had__gackaddr
 (cڡ 
had__t
 *
__ri


367 
__
, **
__ri
 
__ackaddr
)

368 
__THROW
 
	`__nnu
 ((1, 2)
__ibu_dd__
;

374 
	$had__tackaddr
 (
had__t
 *
__
,

375 *
__ackaddr
)

376 
__THROW
 
	`__nnu
 ((1)
__ibu_dd__
;

379 
	$had__gacksize
 (cڡ 
had__t
 *
__ri


380 
__
, 
size_t
 *
__ri
 
__acksize
)

381 
__THROW
 
	`__nnu
 ((1, 2));

386 
	$had__tacksize
 (
had__t
 *
__
,

387 
size_t
 
__acksize
)

388 
__THROW
 
	`__nnu
 ((1));

390 #ifde
__USE_XOPEN2K


392 
	$had__gack
 (cڡ 
had__t
 *
__ri
 
__
,

393 **
__ri
 
__ackaddr
,

394 
size_t
 *
__ri
 
__acksize
)

395 
__THROW
 
	`__nnu
 ((1, 2, 3));

400 
	$had__tack
 (
had__t
 *
__
, *
__ackaddr
,

401 
size_t
 
__acksize

__THROW
 
	`__nnu
 ((1));

404 #ifde
__USE_GNU


407 
	$had__ffy_
 (
had__t
 *
__
,

408 
size_t
 
__utsize
,

409 cڡ 
u_t_t
 *
__ut
)

410 
__THROW
 
	`__nnu
 ((1, 3));

414 
	$had__gaffy_
 (cڡ 
had__t
 *
__
,

415 
size_t
 
__utsize
,

416 
u_t_t
 *
__ut
)

417 
__THROW
 
	`__nnu
 ((1, 3));

420 
	$had_g_deu_
 (
had__t
 *
__
)

421 
__THROW
 
	`__nnu
 ((1));

425 
	$had_r_deu_
 (cڡ 
had__t
 *
__
)

426 
__THROW
 
	`__nnu
 ((1));

431 
	$had_g_
 (
had_t
 
__th
, 
had__t
 *
__
)

432 
__THROW
 
	`__nnu
 ((2));

440 
	$had_tschedm
 (
had_t
 
__rg_thad
, 
__picy
,

441 cڡ 
sched_m
 *
__m
)

442 
__THROW
 
	`__nnu
 ((3));

445 
	$had_gschedm
 (
had_t
 
__rg_thad
,

446 *
__ri
 
__picy
,

447 
sched_m
 *
__ri
 
__m
)

448 
__THROW
 
	`__nnu
 ((2, 3));

451 
	$had_tschedio
 (
had_t
 
__rg_thad
, 
__io
)

452 
__THROW
;

455 #ifde
__USE_GNU


457 
	$had_gme_
 (
had_t
 
__rg_thad
, *
__buf
,

458 
size_t
 
__bu
)

459 
__THROW
 
	`__nnu
 ((2));

462 
	$had_ame_
 (
had_t
 
__rg_thad
, cڡ *
__me
)

463 
__THROW
 
	`__nnu
 ((2));

467 #ifde
__USE_UNIX98


469 
	$had_gccucy
 (
__THROW
;

472 
	$had_tccucy
 (
__v

__THROW
;

475 #ifde
__USE_GNU


480 
	$had_yld
 (
__THROW
;

485 
	$had_ffy_
 (
had_t
 
__th
, 
size_t
 
__utsize
,

486 cڡ 
u_t_t
 *
__ut
)

487 
__THROW
 
	`__nnu
 ((3));

490 
	$had_gaffy_
 (
had_t
 
__th
, 
size_t
 
__utsize
,

491 
u_t_t
 *
__ut
)

492 
__THROW
 
	`__nnu
 ((3));

505 
	`had_
 (
had__t
 *
___cڌ
,

506 (*
___route
()
	`__nnu
 ((1, 2));

517 
	`had_tnle
 (
__e
, *
__de
);

521 
	`had_tny
 (
__ty
, *
__dty
);

524 
	`had_nl
 (
had_t
 
__th
);

529 
	`had_nl
 ();

538 
__jmp_buf
 
__nl_jmp_buf
;

539 
__mask_was_ved
;

540 } 
__nl_jmp_buf
[1];

541 *
__d
[4];

542 } 
	t__had_unwd_buf_t
 
	t__ibu__
 ((
	t__igd__
));

545 #ide
__nup_f_ibu


546 
	#__nup_f_ibu


	)

551 
	s__had_nup_ame


553 (*
__nl_route
) (*);

554 *
__nl_g
;

555 
__do_
;

556 
__nl_ty
;

559 #i
defed
 
__GNUC__
 && defed 
__EXCEPTIONS


560 #ifde
__lulus


562 as
	c__had_nup_ass


564 (*
__nl_route
) (*);

565 *
__nl_g
;

566 
__do_
;

567 
__nl_ty
;

569 
public
:

570 
	`__had_nup_ass
 ((*
__f
(*), *
__g
)

571 : 
	`__nl_route
 (
__f
), 
	`__nl_g
 (
__g
), 
	$__do_
 (1) { }

572 ~
	$__had_nup_ass
 ({ i(
__do_

	`__nl_route
 (
__nl_g
); 
	}
}

573 
	$__tdo
 (
__wv
{ 
__do_
 = __wv; 
	}
}

574 
	$__der
 ({ 
	`had_tny
 (
PTHREAD_CANCEL_DEFERRED
,

575 &
__nl_ty
); 
	}
}

576 
	$__e
 (cڡ { 
	`had_tny
 (
__nl_ty
, 0); 
	}
}

586 
	#had_nup_push
(
route
, 
g
) \

588 
__had_nup_ass
 
	`__ame
 (
route
, 
g
)

	)

592 
	#had_nup_p
(
execu
) \

593 
__ame
.
	`__tdo
 (
execu
); \

594 } 0)

	)

596 #ifde
__USE_GNU


600 
	#had_nup_push_der_
(
route
, 
g
) \

602 
__had_nup_ass
 
	`__ame
 (
route
, 
g
); \

603 
__ame
.
	`__der
 ()

	)

608 
	#had_nup_p_e_
(
execu
) \

609 
__ame
.
	`__e
 (); \

610 
__ame
.
	`__tdo
 (
execu
); \

611 } 0)

	)

618 
__ex_le
 

619 
	$__had_nup_route
 (
__had_nup_ame
 *
__ame
)

621 i(
__ame
->
__do_
)

622 
__ame
->
	`__nl_route
 (__ame->
__nl_g
);

623 
	}
}

632 
	#had_nup_push
(
route
, 
g
) \

634 
__had_nup_ame
 
__ame
 \

635 
	`__ibu__
 ((
	`__nup__
 (
__had_nup_route
))) \

636 { .
__nl_route
 = (
route
), .
__nl_g
 = (
g
), \

637 .
__do_
 = 1 };

	)

641 
	#had_nup_p
(
execu
) \

642 
__ame
.
__do_
 = (
execu
); \

643 } 0)

	)

645 #ifde
__USE_GNU


649 
	#had_nup_push_der_
(
route
, 
g
) \

651 
__had_nup_ame
 
__ame
 \

652 
	`__ibu__
 ((
	`__nup__
 (
__had_nup_route
))) \

653 { .
__nl_route
 = (
route
), .
__nl_g
 = (
g
), \

654 .
__do_
 = 1 }; \

655 (
	`had_tny
 (
PTHREAD_CANCEL_DEFERRED
, \

656 &
__ame
.
__nl_ty
)

	)

661 
	#had_nup_p_e_
(
execu
) \

662 (
	`had_tny
 (
__ame
.
__nl_ty
, 
NULL
); \

663 
__ame
.
__do_
 = (
execu
); \

664 } 0)

	)

675 
	#had_nup_push
(
route
, 
g
) \

677 
__had_unwd_buf_t
 
__nl_buf
; \

678 (*
__nl_route
(*(
route
); \

679 *
__nl_g
 = (
g
); \

680 
__n_f_
 = 
	`__sigtjmp
 ((
__jmp_buf_g
 *) (*) \

681 
__nl_buf
.
__nl_jmp_buf
, 0); \

682 i(
	`__glibc_uiky
 (
__n_f_
)) \

684 
	`__nl_route
 (
__nl_g
); \

685 
	`__had_unwd_xt
 (&
__nl_buf
); \

689 
	`__had_gi_nl
 (&
__nl_buf
); \

690 d{

	)

691 
__had_gi_nl
 (
__had_unwd_buf_t
 *
__buf
)

692 
__nup_f_ibu
;

696 
	#had_nup_p
(
execu
) \

699 
	`__had_uegi_nl
 (&
__nl_buf
); \

700 i(
execu
) \

701 
	`__nl_route
 (
__nl_g
); \

702 } 0)

	)

703 
	$__had_uegi_nl
 (
__had_unwd_buf_t
 *
__buf
)

704 
__nup_f_ibu
;

706 #ifde
__USE_GNU


710 
	#had_nup_push_der_
(
route
, 
g
) \

712 
__had_unwd_buf_t
 
__nl_buf
; \

713 (*
__nl_route
(*(
route
); \

714 *
__nl_g
 = (
g
); \

715 
__n_f_
 = 
	`__sigtjmp
 ((
__jmp_buf_g
 *) (*) \

716 
__nl_buf
.
__nl_jmp_buf
, 0); \

717 i(
	`__glibc_uiky
 (
__n_f_
)) \

719 
	`__nl_route
 (
__nl_g
); \

720 
	`__had_unwd_xt
 (&
__nl_buf
); \

724 
	`__had_gi_nl_der
 (&
__nl_buf
); \

725 d{

	)

726 
	`__had_gi_nl_der
 (
__had_unwd_buf_t
 *
__buf
)

727 
__nup_f_ibu
;

732 
	#had_nup_p_e_
(
execu
) \

735 
	`__had_uegi_nl_e
 (&
__nl_buf
); \

736 i(
execu
) \

737 
	`__nl_route
 (
__nl_g
); \

738 
	}
} 0)

	)

739 
	$__had_uegi_nl_e
 (
__had_unwd_buf_t
 *
__buf
)

740 
__nup_f_ibu
;

744 
	$__had_unwd_xt
 (
__had_unwd_buf_t
 *
__buf
)

745 
__nup_f_ibu
 
	`__ibu__
 ((
__nܑu__
))

746 #ide
SHARED


747 
	`__ibu__
 ((
__wk__
))

753 
__jmp_buf_g
;

754 
	$__sigtjmp
 (
__jmp_buf_g
 *
__v
, 
__vemask

__THROWNL
;

760 
	$had_mux_
 (
had_mux_t
 *
__mux
,

761 cڡ 
had_mux_t
 *
__mux
)

762 
__THROW
 
	`__nnu
 ((1));

765 
	$had_mux_deroy
 (
had_mux_t
 *
__mux
)

766 
__THROW
 
	`__nnu
 ((1));

769 
	$had_mux_ylock
 (
had_mux_t
 *
__mux
)

770 
__THROWNL
 
	`__nnu
 ((1));

773 
	$had_mux_lock
 (
had_mux_t
 *
__mux
)

774 
__THROWNL
 
	`__nnu
 ((1));

776 #ifde
__USE_XOPEN2K


778 
	$had_mux_timedlock
 (
had_mux_t
 *
__ri
 
__mux
,

779 cڡ 
timeec
 *
__ri


780 
__abime

__THROWNL
 
	`__nnu
 ((1, 2));

784 
	$had_mux_uock
 (
had_mux_t
 *
__mux
)

785 
__THROWNL
 
	`__nnu
 ((1));

789 
	$had_mux_giog
 (cڡ 
had_mux_t
 *

790 
__ri
 
__mux
,

791 *
__ri
 
__iog
)

792 
__THROW
 
	`__nnu
 ((1, 2));

796 
	$had_mux_riog
 (
had_mux_t
 *
__ri
 
__mux
,

797 
__iog
,

798 *
__ri
 
__d_g
)

799 
__THROW
 
	`__nnu
 ((1, 3));

802 #ifde
__USE_XOPEN2K8


804 
	$had_mux_csit
 (
had_mux_t
 *
__mux
)

805 
__THROW
 
	`__nnu
 ((1));

806 #ifde
__USE_GNU


807 
	$had_mux_csit_
 (
had_mux_t
 *
__mux
)

808 
__THROW
 
	`__nnu
 ((1));

817 
	$had_mux_
 (
had_mux_t
 *
__
)

818 
__THROW
 
	`__nnu
 ((1));

821 
	$had_mux_deroy
 (
had_mux_t
 *
__
)

822 
__THROW
 
	`__nnu
 ((1));

825 
	$had_mux_gpshed
 (cڡ 
had_mux_t
 *

826 
__ri
 
__
,

827 *
__ri
 
__pshed
)

828 
__THROW
 
	`__nnu
 ((1, 2));

831 
	$had_mux_shed
 (
had_mux_t
 *
__
,

832 
__pshed
)

833 
__THROW
 
	`__nnu
 ((1));

835 #i
defed
 
__USE_UNIX98
 || defed 
__USE_XOPEN2K8


837 
	$had_mux_gty
 (cڡ 
had_mux_t
 *
__ri


838 
__
, *
__ri
 
__kd
)

839 
__THROW
 
	`__nnu
 ((1, 2));

844 
	$had_mux_y
 (
had_mux_t
 *
__
, 
__kd
)

845 
__THROW
 
	`__nnu
 ((1));

849 
	$had_mux_goc
 (cڡ 
had_mux_t
 *

850 
__ri
 
__
,

851 *
__ri
 
__oc
)

852 
__THROW
 
	`__nnu
 ((1, 2));

856 
	$had_mux_roc
 (
had_mux_t
 *
__
,

857 
__oc
)

858 
__THROW
 
	`__nnu
 ((1));

861 
	$had_mux_giog
 (cڡ 
had_mux_t
 *

862 
__ri
 
__
,

863 *
__ri
 
__iog
)

864 
__THROW
 
	`__nnu
 ((1, 2));

867 
	$had_mux_riog
 (
had_mux_t
 *
__
,

868 
__iog
)

869 
__THROW
 
	`__nnu
 ((1));

871 #ifde
__USE_XOPEN2K


873 
	$had_mux_grobu
 (cڡ 
had_mux_t
 *
__
,

874 *
__robuss
)

875 
__THROW
 
	`__nnu
 ((1, 2));

876 #ifde
__USE_GNU


877 
	$had_mux_grobu_
 (cڡ 
had_mux_t
 *
__
,

878 *
__robuss
)

879 
__THROW
 
	`__nnu
 ((1, 2));

883 
	$had_mux_obu
 (
had_mux_t
 *
__
,

884 
__robuss
)

885 
__THROW
 
	`__nnu
 ((1));

886 #ifde
__USE_GNU


887 
	$had_mux_obu_
 (
had_mux_t
 *
__
,

888 
__robuss
)

889 
__THROW
 
	`__nnu
 ((1));

894 #i
defed
 
__USE_UNIX98
 || defed 
__USE_XOPEN2K


899 
	$had_rwlock_
 (
had_rwlock_t
 *
__ri
 
__rwlock
,

900 cڡ 
had_rwlock_t
 *
__ri


901 
__

__THROW
 
	`__nnu
 ((1));

904 
	$had_rwlock_deroy
 (
had_rwlock_t
 *
__rwlock
)

905 
__THROW
 
	`__nnu
 ((1));

908 
	$had_rwlock_rdlock
 (
had_rwlock_t
 *
__rwlock
)

909 
__THROWNL
 
	`__nnu
 ((1));

912 
	$had_rwlock_yrdlock
 (
had_rwlock_t
 *
__rwlock
)

913 
__THROWNL
 
	`__nnu
 ((1));

915 #ifde
__USE_XOPEN2K


917 
	$had_rwlock_timedrdlock
 (
had_rwlock_t
 *
__ri
 
__rwlock
,

918 cڡ 
timeec
 *
__ri


919 
__abime

__THROWNL
 
	`__nnu
 ((1, 2));

923 
	$had_rwlock_wock
 (
had_rwlock_t
 *
__rwlock
)

924 
__THROWNL
 
	`__nnu
 ((1));

927 
	$had_rwlock_ywock
 (
had_rwlock_t
 *
__rwlock
)

928 
__THROWNL
 
	`__nnu
 ((1));

930 #ifde
__USE_XOPEN2K


932 
	$had_rwlock_timedwock
 (
had_rwlock_t
 *
__ri
 
__rwlock
,

933 cڡ 
timeec
 *
__ri


934 
__abime

__THROWNL
 
	`__nnu
 ((1, 2));

938 
	$had_rwlock_uock
 (
had_rwlock_t
 *
__rwlock
)

939 
__THROWNL
 
	`__nnu
 ((1));

945 
	$had_rwlock_
 (
had_rwlock_t
 *
__
)

946 
__THROW
 
	`__nnu
 ((1));

949 
	$had_rwlock_deroy
 (
had_rwlock_t
 *
__
)

950 
__THROW
 
	`__nnu
 ((1));

953 
	$had_rwlock_gpshed
 (cڡ 
had_rwlock_t
 *

954 
__ri
 
__
,

955 *
__ri
 
__pshed
)

956 
__THROW
 
	`__nnu
 ((1, 2));

959 
	$had_rwlock_shed
 (
had_rwlock_t
 *
__
,

960 
__pshed
)

961 
__THROW
 
	`__nnu
 ((1));

964 
	$had_rwlock_gkd_
 (cڡ 
had_rwlock_t
 *

965 
__ri
 
__
,

966 *
__ri
 
__ef
)

967 
__THROW
 
	`__nnu
 ((1, 2));

970 
	$had_rwlock_tkd_
 (
had_rwlock_t
 *
__
,

971 
__ef

__THROW
 
	`__nnu
 ((1));

979 
	$had_cd_
 (
had_cd_t
 *
__ri
 
__cd
,

980 cڡ 
had_cd_t
 *
__ri
 
__cd_
)

981 
__THROW
 
	`__nnu
 ((1));

984 
	$had_cd_deroy
 (
had_cd_t
 *
__cd
)

985 
__THROW
 
	`__nnu
 ((1));

988 
	$had_cd_sigl
 (
had_cd_t
 *
__cd
)

989 
__THROWNL
 
	`__nnu
 ((1));

992 
	$had_cd_brd
 (
had_cd_t
 *
__cd
)

993 
__THROWNL
 
	`__nnu
 ((1));

1000 
	$had_cd_wa
 (
had_cd_t
 *
__ri
 
__cd
,

1001 
had_mux_t
 *
__ri
 
__mux
)

1002 
	`__nnu
 ((1, 2));

1011 
	$had_cd_timedwa
 (
had_cd_t
 *
__ri
 
__cd
,

1012 
had_mux_t
 *
__ri
 
__mux
,

1013 cڡ 
timeec
 *
__ri
 
__abime
)

1014 
	`__nnu
 ((1, 2, 3));

1019 
	$had_cd_
 (
had_cd_t
 *
__
)

1020 
__THROW
 
	`__nnu
 ((1));

1023 
	$had_cd_deroy
 (
had_cd_t
 *
__
)

1024 
__THROW
 
	`__nnu
 ((1));

1027 
	$had_cd_gpshed
 (cڡ 
had_cd_t
 *

1028 
__ri
 
__
,

1029 *
__ri
 
__pshed
)

1030 
__THROW
 
	`__nnu
 ((1, 2));

1033 
	$had_cd_shed
 (
had_cd_t
 *
__
,

1034 
__pshed

__THROW
 
	`__nnu
 ((1));

1036 #ifde
__USE_XOPEN2K


1038 
	$had_cd_gock
 (cڡ 
had_cd_t
 *

1039 
__ri
 
__
,

1040 
__ockid_t
 *
__ri
 
__ock_id
)

1041 
__THROW
 
	`__nnu
 ((1, 2));

1044 
	$had_cd_tock
 (
had_cd_t
 *
__
,

1045 
__ockid_t
 
__ock_id
)

1046 
__THROW
 
	`__nnu
 ((1));

1050 #ifde
__USE_XOPEN2K


1055 
	$had__
 (
had_lock_t
 *
__lock
, 
__pshed
)

1056 
__THROW
 
	`__nnu
 ((1));

1059 
	$had__deroy
 (
had_lock_t
 *
__lock
)

1060 
__THROW
 
	`__nnu
 ((1));

1063 
	$had__lock
 (
had_lock_t
 *
__lock
)

1064 
__THROWNL
 
	`__nnu
 ((1));

1067 
	$had__ylock
 (
had_lock_t
 *
__lock
)

1068 
__THROWNL
 
	`__nnu
 ((1));

1071 
	$had__uock
 (
had_lock_t
 *
__lock
)

1072 
__THROWNL
 
	`__nnu
 ((1));

1079 
	$had_brr_
 (
had_brr_t
 *
__ri
 
__brr
,

1080 cڡ 
had_brr_t
 *
__ri


1081 
__
, 
__cou
)

1082 
__THROW
 
	`__nnu
 ((1));

1085 
	$had_brr_deroy
 (
had_brr_t
 *
__brr
)

1086 
__THROW
 
	`__nnu
 ((1));

1089 
	$had_brr_wa
 (
had_brr_t
 *
__brr
)

1090 
__THROWNL
 
	`__nnu
 ((1));

1094 
	$had_brr_
 (
had_brr_t
 *
__
)

1095 
__THROW
 
	`__nnu
 ((1));

1098 
	$had_brr_deroy
 (
had_brr_t
 *
__
)

1099 
__THROW
 
	`__nnu
 ((1));

1102 
	$had_brr_gpshed
 (cڡ 
had_brr_t
 *

1103 
__ri
 
__
,

1104 *
__ri
 
__pshed
)

1105 
__THROW
 
	`__nnu
 ((1, 2));

1108 
	$had_brr_shed
 (
had_brr_t
 *
__
,

1109 
__pshed
)

1110 
__THROW
 
	`__nnu
 ((1));

1122 
	`had_key_
 (
had_key_t
 *
__key
,

1123 (*
__der_funi
) (*))

1124 
__THROW
 
	`__nnu
 ((1));

1127 
	$had_key_de
 (
had_key_t
 
__key

__THROW
;

1130 *
	$had_gecific
 (
had_key_t
 
__key

__THROW
;

1133 
	$had_tecific
 (
had_key_t
 
__key
,

1134 cڡ *
__por

__THROW
 ;

1137 #ifde
__USE_XOPEN2K


1139 
	$had_guockid
 (
had_t
 
__thad_id
,

1140 
__ockid_t
 *
__ock_id
)

1141 
__THROW
 
	`__nnu
 ((2));

1156 
	`had_fk
 ((*
__e
) (),

1157 (*
__
) (),

1158 (*
__chd
()
__THROW
;

1161 #ifde
__USE_EXTERN_INLINES


1163 
__ex_le
 

1164 
	`__NTH
 (
	$had_equ
 (
had_t
 
__thad1
,thad_
__thad2
))

1166  
__thad1
 =
__thad2
;

1167 
	}
}

1170 
	g__END_DECLS


	@/usr/include/wctype.h

23 #ide
_WCTYPE_H


25 
	~<us.h
>

26 
	~<bs/tys.h
>

28 #ide
__ed_iswxxx


29 
	#_WCTYPE_H
 1

	)

32 
	#__ed_wt_t


	)

33 
	~<wch.h
>

37 #ide
WEOF


38 
	#WEOF
 (0xffffffffu)

	)

41 #unde
__ed_iswxxx


46 #ide
__iswxxx_defed


47 
	#__iswxxx_defed
 1

	)

49 
__BEGIN_NAMESPACE_C99


52 
	twy_t
;

53 
	g__END_NAMESPACE_C99


55 #ide
_ISwb


60 
	~<dn.h
>

61 #i
__BYTE_ORDER
 =
__BIG_ENDIAN


62 
	#_ISwb
(
b
(1 << (b))

	)

64 
	#_ISwb
(
b
) \

65 ((
b
) < 8 ? () ((1UL << (bit)) << 24) \

66 : ((
b
) < 16 ? () ((1UL << (bit)) << 8) \

67 : ((
b
) < 24 ? () ((1UL << (bit)) >> 8) \

68 : (((1UL << (
b
)>> 24))))

	)

73 
	m__ISwu
 = 0,

74 
	m__ISwlow
 = 1,

75 
	m__ISwpha
 = 2,

76 
	m__ISwdig
 = 3,

77 
	m__ISwxdig
 = 4,

78 
	m__ISwa
 = 5,

79 
	m__ISwt
 = 6,

80 
	m__ISwgph
 = 7,

81 
	m__ISwbnk
 = 8,

82 
	m__ISwl
 = 9,

83 
	m__ISwpun
 = 10,

84 
	m__ISwnum
 = 11,

86 
	m_ISwu
 = 
_ISwb
 (
__ISwu
),

87 
	m_ISwlow
 = 
_ISwb
 (
__ISwlow
),

88 
	m_ISwpha
 = 
_ISwb
 (
__ISwpha
),

89 
	m_ISwdig
 = 
_ISwb
 (
__ISwdig
),

90 
	m_ISwxdig
 = 
_ISwb
 (
__ISwxdig
),

91 
	m_ISwa
 = 
_ISwb
 (
__ISwa
),

92 
	m_ISwt
 = 
_ISwb
 (
__ISwt
),

93 
	m_ISwgph
 = 
_ISwb
 (
__ISwgph
),

94 
	m_ISwbnk
 = 
_ISwb
 (
__ISwbnk
),

95 
	m_ISwl
 = 
_ISwb
 (
__ISwl
),

96 
	m_ISwpun
 = 
_ISwb
 (
__ISwpun
),

97 
	m_ISwnum
 = 
_ISwb
 (
__ISwnum
)

102 
__BEGIN_DECLS


104 
__BEGIN_NAMESPACE_C99


111 
	$iswnum
 (
wt_t
 
__wc

__THROW
;

117 
	$iswpha
 (
wt_t
 
__wc

__THROW
;

120 
	$iswl
 (
wt_t
 
__wc

__THROW
;

124 
	$iswdig
 (
wt_t
 
__wc

__THROW
;

128 
	$iswgph
 (
wt_t
 
__wc

__THROW
;

133 
	$iswlow
 (
wt_t
 
__wc

__THROW
;

136 
	$iswt
 (
wt_t
 
__wc

__THROW
;

141 
	$iswpun
 (
wt_t
 
__wc

__THROW
;

146 
	$iswa
 (
wt_t
 
__wc

__THROW
;

151 
	$iswu
 (
wt_t
 
__wc

__THROW
;

156 
	$iswxdig
 (
wt_t
 
__wc

__THROW
;

161 #ifde
__USE_ISOC99


162 
	$iswbnk
 (
wt_t
 
__wc

__THROW
;

171 
wy_t
 
	$wy
 (cڡ *
__ݔty

__THROW
;

175 
	$iswy
 (
wt_t
 
__wc
, 
wy_t
 
__desc

__THROW
;

176 
__END_NAMESPACE_C99


183 
__BEGIN_NAMESPACE_C99


186 cڡ 
	t__t32_t
 *
	twns_t
;

187 
__END_NAMESPACE_C99


188 #ifde
__USE_GNU


189 
	$__USING_NAMESPACE_C99
(
wns_t
)

192 
__BEGIN_NAMESPACE_C99


194 
wt_t
 
	$towlow
 (
wt_t
 
__wc

__THROW
;

197 
wt_t
 
	$towu
 (
wt_t
 
__wc

__THROW
;

198 
__END_NAMESPACE_C99


200 
__END_DECLS


207 #ifde
_WCTYPE_H


213 
__BEGIN_DECLS


215 
__BEGIN_NAMESPACE_C99


218 
wns_t
 
	$wns
 (cڡ *
__ݔty

__THROW
;

221 
wt_t
 
	$towns
 (
wt_t
 
__wc
, 
wns_t
 
__desc

__THROW
;

222 
__END_NAMESPACE_C99


224 #ifde
__USE_XOPEN2K8


226 
	~<xlo.h
>

230 
	$iswnum_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

236 
	$iswpha_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

239 
	$iswl_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

243 
	$iswdig_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

247 
	$iswgph_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

252 
	$iswlow_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

255 
	$iswt_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

260 
	$iswpun_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

265 
	$iswa_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

270 
	$iswu_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

275 
	$iswxdig_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

280 
	$iswbnk_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

284 
wy_t
 
	$wy_l
 (cڡ *
__ݔty
, 
__lo_t
 
__lo
)

285 
__THROW
;

289 
	$iswy_l
 (
wt_t
 
__wc
, 
wy_t
 
__desc
, 
__lo_t
 
__lo
)

290 
__THROW
;

298 
wt_t
 
	$towlow_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

301 
wt_t
 
	$towu_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

305 
wns_t
 
	$wns_l
 (cڡ *
__ݔty
, 
__lo_t
 
__lo
)

306 
__THROW
;

309 
wt_t
 
	$towns_l
 (
wt_t
 
__wc
, 
wns_t
 
__desc
,

310 
__lo_t
 
__lo

__THROW
;

314 
__END_DECLS


	@/usr/include/asm-generic/errno-base.h

1 #ide
_ASM_GENERIC_ERRNO_BASE_H


2 
	#_ASM_GENERIC_ERRNO_BASE_H


	)

4 
	#EPERM
 1

	)

5 
	#ENOENT
 2

	)

6 
	#ESRCH
 3

	)

7 
	#EINTR
 4

	)

8 
	#EIO
 5

	)

9 
	#ENXIO
 6

	)

10 
	#E2BIG
 7

	)

11 
	#ENOEXEC
 8

	)

12 
	#EBADF
 9

	)

13 
	#ECHILD
 10

	)

14 
	#EAGAIN
 11

	)

15 
	#ENOMEM
 12

	)

16 
	#EACCES
 13

	)

17 
	#EFAULT
 14

	)

18 
	#ENOTBLK
 15

	)

19 
	#EBUSY
 16

	)

20 
	#EEXIST
 17

	)

21 
	#EXDEV
 18

	)

22 
	#ENODEV
 19

	)

23 
	#ENOTDIR
 20

	)

24 
	#EISDIR
 21

	)

25 
	#EINVAL
 22

	)

26 
	#ENFILE
 23

	)

27 
	#EMFILE
 24

	)

28 
	#ENOTTY
 25

	)

29 
	#ETXTBSY
 26

	)

30 
	#EFBIG
 27

	)

31 
	#ENOSPC
 28

	)

32 
	#ESPIPE
 29

	)

33 
	#EROFS
 30

	)

34 
	#EMLINK
 31

	)

35 
	#EPIPE
 32

	)

36 
	#EDOM
 33

	)

37 
	#ERANGE
 34

	)

	@/usr/include/bits/setjmp.h

19 #ide
_BITS_SETJMP_H


20 
	#_BITS_SETJMP_H
 1

	)

22 #i!
defed
 
_SETJMP_H
 && !defed 
_PTHREAD_H


26 
	~<bs/wdsize.h
>

28 #ide
_ASM


30 #i
__WORDSIZE
 == 64

31 
	t__jmp_buf
[8];

32 #i
defed
 
__x86_64__


33 
__exnsi__
 
	t__jmp_buf
[8];

35 
	t__jmp_buf
[6];

	@/usr/include/sched.h

19 #idef 
_SCHED_H


20 
	#_SCHED_H
 1

	)

22 
	~<us.h
>

25 
	~<bs/tys.h
>

27 
	#__ed_size_t


	)

28 
	~<ddef.h
>

30 
	#__ed_time_t


	)

31 
	#__ed_timeec


	)

32 
	~<time.h
>

34 #ide
__pid_t_defed


35 
__pid_t
 
	tpid_t
;

36 
	#__pid_t_defed


	)

41 
	~<bs/sched.h
>

43 
	#sched_iܙy
 
__sched_iܙy


	)

46 
__BEGIN_DECLS


49 
	$sched_am
 (
__pid_t
 
__pid
, cڡ 
sched_m
 *
__m
)

50 
__THROW
;

53 
	$sched_gm
 (
__pid_t
 
__pid
, 
sched_m
 *
__m

__THROW
;

56 
	$sched_tschedur
 (
__pid_t
 
__pid
, 
__picy
,

57 cڡ 
sched_m
 *
__m

__THROW
;

60 
	$sched_gschedur
 (
__pid_t
 
__pid

__THROW
;

63 
	$sched_yld
 (
__THROW
;

66 
	$sched_g_iܙy_max
 (
__gܙhm

__THROW
;

69 
	$sched_g_iܙy_m
 (
__gܙhm

__THROW
;

72 
	$sched__g_rv
 (
__pid_t
 
__pid
, 
timeec
 *
__t

__THROW
;

75 #ifde
__USE_GNU


77 
	#CPU_SETSIZE
 
__CPU_SETSIZE


	)

78 
	#CPU_SET
(
u
, 
u

	`__CPU_SET_S
 (u,  (
u_t_t
), cpu)

	)

79 
	#CPU_CLR
(
u
, 
u

	`__CPU_CLR_S
 (u,  (
u_t_t
), cpu)

	)

80 
	#CPU_ISSET
(
u
, 
u

	`__CPU_ISSET_S
 (u,  (
u_t_t
), \

81 
u
)

	)

82 
	#CPU_ZERO
(
u

	`__CPU_ZERO_S
 ( (
u_t_t
), cpu)

	)

83 
	#CPU_COUNT
(
u

	`__CPU_COUNT_S
 ( (
u_t_t
), cpu)

	)

85 
	#CPU_SET_S
(
u
, 
tsize
, 
u

	`__CPU_SET_S
 (u, ssize, cpu)

	)

86 
	#CPU_CLR_S
(
u
, 
tsize
, 
u

	`__CPU_CLR_S
 (u, ssize, cpu)

	)

87 
	#CPU_ISSET_S
(
u
, 
tsize
, 
u

	`__CPU_ISSET_S
 (cpu, setsize, \

88 
u
)

	)

89 
	#CPU_ZERO_S
(
tsize
, 
u

	`__CPU_ZERO_S
 (tsize, cpu)

	)

90 
	#CPU_COUNT_S
(
tsize
, 
u

	`__CPU_COUNT_S
 (tsize, cpu)

	)

92 
	#CPU_EQUAL
(
u1
, 
u2
) \

93 
	`__CPU_EQUAL_S
 ( (
u_t_t
), 
u1
, 
u2
)

	)

94 
	#CPU_EQUAL_S
(
tsize
, 
u1
, 
u2
) \

95 
	`__CPU_EQUAL_S
 (
tsize
, 
u1
, 
u2
)

	)

97 
	#CPU_AND
(
det
, 
ct1
, 
ct2
) \

98 
	`__CPU_OP_S
 ( (
u_t_t
), 
det
, 
ct1
, 
ct2
, &)

	)

99 
	#CPU_OR
(
det
, 
ct1
, 
ct2
) \

100 
	`__CPU_OP_S
 ( (
u_t_t
), 
det
, 
ct1
, 
ct2
, |)

	)

101 
	#CPU_XOR
(
det
, 
ct1
, 
ct2
) \

102 
	`__CPU_OP_S
 ( (
u_t_t
), 
det
, 
ct1
, 
ct2
, ^)

	)

103 
	#CPU_AND_S
(
tsize
, 
det
, 
ct1
, 
ct2
) \

104 
	`__CPU_OP_S
 (
tsize
, 
det
, 
ct1
, 
ct2
, &)

	)

105 
	#CPU_OR_S
(
tsize
, 
det
, 
ct1
, 
ct2
) \

106 
	`__CPU_OP_S
 (
tsize
, 
det
, 
ct1
, 
ct2
, |)

	)

107 
	#CPU_XOR_S
(
tsize
, 
det
, 
ct1
, 
ct2
) \

108 
	`__CPU_OP_S
 (
tsize
, 
det
, 
ct1
, 
ct2
, ^)

	)

110 
	#CPU_ALLOC_SIZE
(
cou

	`__CPU_ALLOC_SIZE
 (cou)

	)

111 
	#CPU_ALLOC
(
cou

	`__CPU_ALLOC
 (cou)

	)

112 
	#CPU_FREE
(
ut

	`__CPU_FREE
 (ut)

	)

116 
	$sched_ffy
 (
__pid_t
 
__pid
, 
size_t
 
__utsize
,

117 cڡ 
u_t_t
 *
__ut

__THROW
;

120 
	$sched_gaffy
 (
__pid_t
 
__pid
, 
size_t
 
__utsize
,

121 
u_t_t
 *
__ut

__THROW
;

124 
__END_DECLS


	@/usr/include/bits/sched.h

20 #ide
__ed_schedm


22 #ide
_SCHED_H


28 
	#SCHED_OTHER
 0

	)

29 
	#SCHED_FIFO
 1

	)

30 
	#SCHED_RR
 2

	)

31 #ifde
__USE_GNU


32 
	#SCHED_BATCH
 3

	)

33 
	#SCHED_IDLE
 5

	)

35 
	#SCHED_RESET_ON_FORK
 0x40000000

	)

38 #ifde
__USE_GNU


40 
	#CSIGNAL
 0x000000f

	)

41 
	#CLONE_VM
 0x00000100

	)

42 
	#CLONE_FS
 0x00000200

	)

43 
	#CLONE_FILES
 0x00000400

	)

44 
	#CLONE_SIGHAND
 0x00000800

	)

45 
	#CLONE_PTRACE
 0x00002000

	)

46 
	#CLONE_VFORK
 0x00004000

	)

48 
	#CLONE_PARENT
 0x00008000

	)

50 
	#CLONE_THREAD
 0x00010000

	)

51 
	#CLONE_NEWNS
 0x00020000

	)

52 
	#CLONE_SYSVSEM
 0x00040000

	)

53 
	#CLONE_SETTLS
 0x00080000

	)

54 
	#CLONE_PARENT_SETTID
 0x00100000

	)

56 
	#CLONE_CHILD_CLEARTID
 0x00200000

	)

58 
	#CLONE_DETACHED
 0x00400000

	)

59 
	#CLONE_UNTRACED
 0x00800000

	)

61 
	#CLONE_CHILD_SETTID
 0x01000000

	)

63 
	#CLONE_NEWUTS
 0x04000000

	)

64 
	#CLONE_NEWIPC
 0x08000000

	)

65 
	#CLONE_NEWUSER
 0x10000000

	)

66 
	#CLONE_NEWPID
 0x20000000

	)

67 
	#CLONE_NEWNET
 0x40000000

	)

68 
	#CLONE_IO
 0x80000000

	)

72 
	ssched_m


74 
	m__sched_iܙy
;

77 
	g__BEGIN_DECLS


79 #ifde
__USE_GNU


81 
e
 ((*
__
(*
__g
), *
__chd_ack
,

82 
__ags
, *
__g
, ...
__THROW
;

85 
	$unshe
 (
__ags

__THROW
;

88 
	$sched_gu
 (
__THROW
;

91 
	$s
 (
__fd
, 
__ny

__THROW
;

95 
__END_DECLS


99 #i!
defed
 
__defed_schedm
 \

100 && (
defed
 
__ed_schedm
 || defed 
_SCHED_H
)

101 
	#__defed_schedm
 1

	)

103 
	s__sched_m


105 
__sched_iܙy
;

107 #unde
__ed_schedm


111 #i
defed
 
_SCHED_H
 && !defed 
__u_t_t_defed


112 
	#__u_t_t_defed


	)

114 
	#__CPU_SETSIZE
 1024

	)

115 
	#__NCPUBITS
 (8 *  (
__u_mask
))

	)

118 
	t__u_mask
;

121 
	#__CPUELT
(
u
((u/ 
__NCPUBITS
)

	)

122 
	#__CPUMASK
(
u
((
__u_mask
1 << ((u% 
__NCPUBITS
))

	)

127 
__u_mask
 
__bs
[
__CPU_SETSIZE
 / 
__NCPUBITS
];

128 } 
	tu_t_t
;

131 #i
	`__GNUC_PREREQ
 (2, 91)

132 
	#__CPU_ZERO_S
(
tsize
, 
u
) \

133 d
	`__but_memt
 (
u
, '\0', 
tsize
); 0)

	)

135 
	#__CPU_ZERO_S
(
tsize
, 
u
) \

137 
size_t
 
__i
; \

138 
size_t
 
__imax
 = (
tsize
/  (
__u_mask
); \

139 
__u_mask
 *
__bs
 = (
u
)->__bits; \

140 
__i
 = 0; __< 
__imax
; ++__i) \

141 
__bs
[
__i
] = 0; \

142 
	}
} 0)

	)

144 
	#__CPU_SET_S
(
u
, 
tsize
, 
u
) \

145 (
__exnsi__
 \

146 ({ 
size_t
 
__u
 = (
u
); \

147 
__u
 / 8 < (
tsize
) \

148 ? (((
__u_mask
 *((
u
)->
__bs
))[
	`__CPUELT
 (
__u
)] \

149 |
	`__CPUMASK
 (
__u
)) \

150 : 0; }))

	)

151 
	#__CPU_CLR_S
(
u
, 
tsize
, 
u
) \

152 (
__exnsi__
 \

153 ({ 
size_t
 
__u
 = (
u
); \

154 
__u
 / 8 < (
tsize
) \

155 ? (((
__u_mask
 *((
u
)->
__bs
))[
	`__CPUELT
 (
__u
)] \

156 &~
	`__CPUMASK
 (
__u
)) \

157 : 0; }))

	)

158 
	#__CPU_ISSET_S
(
u
, 
tsize
, 
u
) \

159 (
__exnsi__
 \

160 ({ 
size_t
 
__u
 = (
u
); \

161 
__u
 / 8 < (
tsize
) \

162 ? ((((cڡ 
__u_mask
 *((
u
)->
__bs
))[
	`__CPUELT
 (
__u
)] \

163 & 
	`__CPUMASK
 (
__u
))) != 0 \

164 : 0; }))

	)

166 
	#__CPU_COUNT_S
(
tsize
, 
u
) \

167 
	`__sched_ucou
 (
tsize
, 
u
)

	)

169 #i
__GNUC_PREREQ
 (2, 91)

170 
	#__CPU_EQUAL_S
(
tsize
, 
u1
, 
u2
) \

171 (
	`__but_memcmp
 (
u1
, 
u2
, 
tsize
=0)

	)

173 
	#__CPU_EQUAL_S
(
tsize
, 
u1
, 
u2
) \

174 (
__exnsi__
 \

175 ({ cڡ 
__u_mask
 *
__r1
 = (
u1
)->
__bs
; \

176 cڡ 
__u_mask
 *
__r2
 = (
u2
)->
__bs
; \

177 
size_t
 
__imax
 = (
tsize
/  (
__u_mask
); \

178 
size_t
 
__i
; \

179 
__i
 = 0; __< 
__imax
; ++__i) \

180 i(
__r1
[
__i
] !
__r2
[__i]) \

182 
__i
 =
__imax
; }))

	)

185 
	#__CPU_OP_S
(
tsize
, 
det
, 
ct1
, 
ct2
, 

) \

186 (
__exnsi__
 \

187 ({ 
u_t_t
 *
__de
 = (
det
); \

188 cڡ 
__u_mask
 *
__r1
 = (
ct1
)->
__bs
; \

189 cڡ 
__u_mask
 *
__r2
 = (
ct2
)->
__bs
; \

190 
size_t
 
__imax
 = (
tsize
/  (
__u_mask
); \

191 
size_t
 
__i
; \

192 
__i
 = 0; __< 
__imax
; ++__i) \

193 ((
__u_mask
 *
__de
->
__bs
)[
__i
] = 
__r1
[__i] 

 
__r2
[__i]; \

194 
__de
; }))

	)

196 
	#__CPU_ALLOC_SIZE
(
cou
) \

197 ((((
cou
+ 
__NCPUBITS
 - 1/ __NCPUBITS*  (
__u_mask
))

	)

198 
	#__CPU_ALLOC
(
cou

	`__sched_uloc
 (cou)

	)

199 
	#__CPU_FREE
(
ut

	`__sched_u
 (ut)

	)

201 
__BEGIN_DECLS


203 
	$__sched_ucou
 (
size_t
 
__tsize
, cڡ 
u_t_t
 *
__
)

204 
__THROW
;

205 
u_t_t
 *
	$__sched_uloc
 (
size_t
 
__cou

__THROW
 
__wur
;

206 
	$__sched_u
 (
u_t_t
 *
__t

__THROW
;

208 
__END_DECLS


	@
1
.
1
/usr/include
122
4414
/home/jk/os/MINT64/00.BootLoader/BootLoader.asm
/home/jk/os/MINT64/00.BootLoader/BootLoader2.asm
/home/jk/os/MINT64/01.Kernel32/Source/EntryPoint.s
/home/jk/os/MINT64/01.Kernel32/Source/ModeSwitch.asm
/home/jk/os/MINT64/01.Kernel32/Source/ModeSwitch.h
/home/jk/os/MINT64/01.Kernel32/Source/Page.c
/home/jk/os/MINT64/01.Kernel32/Source/Page.h
/home/jk/os/MINT64/01.Kernel32/Source/Types.h
/home/jk/os/MINT64/01.Kernel32/Source/main.c
/home/jk/os/MINT64/01.Kernel32/VirtualOS.asm
/home/jk/os/MINT64/02.Kernel64/Source/AssemblyUtility.asm
/home/jk/os/MINT64/02.Kernel64/Source/AssemblyUtility.h
/home/jk/os/MINT64/02.Kernel64/Source/Console.c
/home/jk/os/MINT64/02.Kernel64/Source/Console.h
/home/jk/os/MINT64/02.Kernel64/Source/ConsoleShell.c
/home/jk/os/MINT64/02.Kernel64/Source/ConsoleShell.h
/home/jk/os/MINT64/02.Kernel64/Source/Descriptor.c
/home/jk/os/MINT64/02.Kernel64/Source/Descriptor.h
/home/jk/os/MINT64/02.Kernel64/Source/DynamicMemory.c
/home/jk/os/MINT64/02.Kernel64/Source/DynamicMemory.h
/home/jk/os/MINT64/02.Kernel64/Source/EntryPoint.s
/home/jk/os/MINT64/02.Kernel64/Source/FileSystem.c
/home/jk/os/MINT64/02.Kernel64/Source/FileSystem.h
/home/jk/os/MINT64/02.Kernel64/Source/HardDisk.c
/home/jk/os/MINT64/02.Kernel64/Source/HardDisk.h
/home/jk/os/MINT64/02.Kernel64/Source/ISR.asm
/home/jk/os/MINT64/02.Kernel64/Source/ISR.h
/home/jk/os/MINT64/02.Kernel64/Source/InterruptHandler.c
/home/jk/os/MINT64/02.Kernel64/Source/InterruptHandler.h
/home/jk/os/MINT64/02.Kernel64/Source/Keyboard.c
/home/jk/os/MINT64/02.Kernel64/Source/Keyboard.h
/home/jk/os/MINT64/02.Kernel64/Source/List.c
/home/jk/os/MINT64/02.Kernel64/Source/List.h
/home/jk/os/MINT64/02.Kernel64/Source/PIC.c
/home/jk/os/MINT64/02.Kernel64/Source/PIC.h
/home/jk/os/MINT64/02.Kernel64/Source/PIT.c
/home/jk/os/MINT64/02.Kernel64/Source/PIT.h
/home/jk/os/MINT64/02.Kernel64/Source/Queue.c
/home/jk/os/MINT64/02.Kernel64/Source/Queue.h
/home/jk/os/MINT64/02.Kernel64/Source/RTC.c
/home/jk/os/MINT64/02.Kernel64/Source/RTC.h
/home/jk/os/MINT64/02.Kernel64/Source/Synchronization.c
/home/jk/os/MINT64/02.Kernel64/Source/Synchronization.h
/home/jk/os/MINT64/02.Kernel64/Source/Task.c
/home/jk/os/MINT64/02.Kernel64/Source/Task.h
/home/jk/os/MINT64/02.Kernel64/Source/Types.h
/home/jk/os/MINT64/02.Kernel64/Source/Utility.c
/home/jk/os/MINT64/02.Kernel64/Source/Utility.h
/home/jk/os/MINT64/02.Kernel64/Source/main.c
/home/jk/os/MINT64/04.Utility/00.ImageMaker/ImageMaker.c
/home/jk/os/MINT64/testdata.c
/usr/cross/lib/gcc/x86_64-pc-linux/4.8.2/include/stdarg.h
/usr/include/errno.h
/usr/include/fcntl.h
/usr/include/stdio.h
/usr/include/stdlib.h
/usr/include/sys/stat.h
/usr/include/sys/types.h
/usr/include/alloca.h
/usr/include/bits/errno.h
/usr/include/bits/fcntl.h
/usr/include/bits/fcntl2.h
/usr/include/bits/pthreadtypes.h
/usr/include/bits/stat.h
/usr/include/bits/stdio-ldbl.h
/usr/include/bits/stdio.h
/usr/include/bits/stdio2.h
/usr/include/bits/stdio_lim.h
/usr/include/bits/stdlib-bsearch.h
/usr/include/bits/stdlib-float.h
/usr/include/bits/stdlib-ldbl.h
/usr/include/bits/stdlib.h
/usr/include/bits/sys_errlist.h
/usr/include/bits/types.h
/usr/include/bits/waitflags.h
/usr/include/bits/waitstatus.h
/usr/include/endian.h
/usr/include/features.h
/usr/include/getopt.h
/usr/include/libio.h
/usr/include/sys/select.h
/usr/include/sys/sysmacros.h
/usr/include/time.h
/usr/include/xlocale.h
/usr/include/_G_config.h
/usr/include/bits/byteswap.h
/usr/include/bits/endian.h
/usr/include/bits/fcntl-linux.h
/usr/include/bits/libio-ldbl.h
/usr/include/bits/select.h
/usr/include/bits/select2.h
/usr/include/bits/sigset.h
/usr/include/bits/stdio-lock.h
/usr/include/bits/time.h
/usr/include/bits/typesizes.h
/usr/include/bits/wordsize.h
/usr/include/ctype.h
/usr/include/gnu/stubs.h
/usr/include/linux/errno.h
/usr/include/stdc-predef.h
/usr/include/sys/cdefs.h
/usr/include/asm/errno.h
/usr/include/bits/byteswap-16.h
/usr/include/bits/libc-lock.h
/usr/include/bits/timex.h
/usr/include/bits/uio.h
/usr/include/gconv.h
/usr/include/gnu/stubs-32.h
/usr/include/gnu/stubs-64.h
/usr/include/gnu/stubs-x32.h
/usr/include/wchar.h
/usr/include/asm-generic/errno.h
/usr/include/bits/wchar-ldbl.h
/usr/include/bits/wchar.h
/usr/include/bits/wchar2.h
/usr/include/gnu/option-groups.h
/usr/include/pthread.h
/usr/include/wctype.h
/usr/include/asm-generic/errno-base.h
/usr/include/bits/setjmp.h
/usr/include/sched.h
/usr/include/bits/sched.h
