cscope 15 $HOME/os/MINT64               0000956545
	@/home/jk/os/MINT64/00.BootLoader/BootLoader.asm

1 [
ORG
 0x00] ; 코드의 시작 어드레스를 0x00으로 설정

2 [
BITS
 16] ; 이하의 코드는 16비트 코드로 설정

4 
	gSECTION
 .
	gxt
 ;ext 섹션(세그먼트)을 정의

6 
	gjmp
 0x07C0:
START
 ; 
	gCS
 세그먼트 레지스터에 0x07C0을 복사하면서 , 
	gSTART
 레이블로 이동 (CS 세그먼트는 데이터 이동 명령으르 설정불가능하며 점프나 인터럽트 관련 명령으로 변경 가능

10 ; 
MINT64
 
	gOS
에 관련된 환경 설정 값

12 
	gTOTALSECTORCOUNT
: 
dw
 0x02 ; 부트 로더를 제외한 
MINT64
 
	gOS
 이미지의 크기

13 ; 최대 1152 섹터(0x90000b
	gy
)까지 가능 
	gwhy
???? 0xA0000 이후의 메모리는 
gphic
 
	gmode
의 영역이다.

14 
	gKERNEL32SECTORCOUNT
: 
dw
 0x02 ; 보호 모드 커널의 총 섹터 수

15 
	gBOOTSTRAPPROCESSOR
: 
db
 0x01 ; 
Bo١p
 
	gPRoss
인지 여부

19 
	gSTART
:

20 
mov
 
ax
, 0x07C0 ; 부트 로더의 시작 어드레스(0x7C00)를 세그먼트 레지스터 값으로 변환

21 
mov
 
	gds
, 
	gax
 ; 
	gDS
 세그먼트 레지스터에 설정

22 
mov
 
	gax
, 0xB800 ; 비디오 메모리의 시작 어드레스(0xB800)를 세그먼트 레지스터 값으로 변환

23 
mov
 
	ges
, 
	gax
 ; 
	gES
 세그먼트 레지스터에 설정

25 ; 스택을 0x0000:0000~0x0000:
FFFF
 영역에 64
KB
 크기로 생성

26 
mov
 
ax
, 0x0000 ; 스택 세그먼트의 시작 어드레스(0x0000)를 세그먼트 레지스터 값으로 변환

27 
mov
 
	gss
, 
	gax
 ; 
	gSS
 세그먼트 레지스터에 설정

28 
mov
 
	g
, 0xFFFC ; 
	gSP
 레지스터의 어드레스를 0xFFFC로 설정

29 
mov
 
	gbp
, 0xFFFC ; 
	gBP
 레지스터의 어드레스를 0xFFFC로 설정

34 
mov
 
	gsi
, 0 ; 
	gSI
 레지스터 (문자열 원본 인덱스 레지스터)를 초기화

36 .
	gSCREENCLEARLOOP
: ; 화면을 지우는 루프

37 
mov
 
	gby
 [
es
:
si
],0 ; 비디오 메모리의 문자가 위치하는 어드레스에 0을 복사하여 문자를 삭제

38 
mov
 
	gby
 [
es
:
si
+1],0x09 ; 비디오 메모리의 속성이 위치하는 어드레스에 0x09(검은 바탕에 밝은 파랑)을 복사

40 
add
 
	gsi
,2 ; 문자와 속성을 설정했으므로 다음 위치로 이동

42 
cmp
 
	gsi
, 80*25*2 ; 화면의 전체 크기는 80문자*25라인임

43 ; 출력한 문자의 수를 의미하는 
	gSI
 레지스터와 비교

44 
	gjl
 .
	gSCREENCLEARLOOP
 ; 
	gSI
 레지스터가 80*25*2보다 작다면 아직 지우지 못한 영역이 있으므로 .SCREENCLEARLOOP 레이블로 이동

50 
push
 
	gMESSAGE1
 ; 출력 메시지의 어드레스를 스택에 삽입

51 
	gpush
 0 ; 화면 
	gY
 좌표(0)를 스택에 삽입

52 
	gpush
 0 ; 화면 
	gX
 좌표(0)를 스택에 삽입

53 

 
	gPRINTMESSAGE
 ; PRINTMESSAGE 함수 호출

54 
add
 
	g
, 6 ; 삽입한 파라미터 제거

57 ; 
	gos
 이미지를 로딩한다는 메시지 출력

60 
push
 
	gIMAGELOADINGMESSAGE
 ; 출력 메시지의 어드레스를 스택에 삽입

61 
	gpush
 1 ; 화면 
	gY
 좌표(1)를 스택에 삽입

62 
	gpush
 0 ; 화면 
	gX
 좌표(0)를 스택에 삽입

63 

 
	gPRINTMESSAGE
 ; PRINTMESSAGE 함수 호출

64 
add
 
	g
, 6 ; 삽입한 파라미터 제거

67 ; 디스크에서 
	gOS
 이미지를 로딩

73 
	gREADDISK
: ; 디스크를 리셋하는 코드의 시작

75 ; 
BIOS
 
Ret
 
	gFui
 호출

77 ; 서비스 번호 0, 드라이브 번호(0=
Flpy
)

78 
mov
 
ax
, 0

79 
mov
 
	gdl
, 0

82 
jc
 
	gHANDLEDISKERROR


88 ; 디스크의 내용을 메모리로 복사할 어드레스(
	gES
:
BX
)를 0x10000으로 설정

89 
mov
 
si
, 0x1000 ; 
	gOS
 이미지를 복사할 어드레스(0x10000)를 세그먼트 레지스터 값으로 변환

90 
mov
 
	ges
, 
	gsi
 ; 
	gES
 세그먼트 레지스터에 값 설정

91 
mov
 
	gbx
, 0x0000 ; 
	gBX
 레지스터에 0x0000을 설정하여 복사할 어드레스를 0x1000:0000(0x10000)으로 최종 설정

93 
mov
 
di
, 
	gwd
[
TOTALSECTORCOUNT
] ; 복사할 
	gOS
 이미지의 섹터 수를 
	gDI
 레지스터에 설정

95 
	gREADDATA
: ; 디스크를 읽는 코드의 시작

97 
cmp
 
	gdi
, 0 ; 복사할 
	gOS
 이미지의 섹터 수를 0과 비교

98 
je
 
	gREADEND
 ; 복사할 섹터 수가 0이라면 다 복사 했으므로 READEND로 이동

99 
sub
 
	gdi
, 0x01 ; 복사할 섹터 수를 1 감소

103 ; 
BIOS
 
Rd
 
	gFuni
 호출

106 
mov
 
	gah
, 0x02 ; 
	gBIOS
 서비스 번호 2(
Rd
 
	gSe
)

107 
mov
 
	g
, 0x01 ; 읽을 섹터 수는 1

108 
mov
 
	gch
, 
	gby
[
TRACKNUMBER
] ; 읽을 트랙 번호 설정

109 
mov
 
	g
, 
	gby
[
SECTORNUMBER
] ; 읽을 섹터 번호 설정

110 
mov
 
	gdh
, 
	gby
[
HEADNUMBER
] ; 읽을 헤드 번호 설정

111 
mov
 
	gdl
, 0x00 ; 읽을 드라이브 번호(0=
Flpy
) 설정

113 
jc
 
	gHANDLEDISKERROR
 ; 에러가 발생했다면 HANDLEDISKERROR로 이동 
	$jc
 (
jump
 

 
y

CF
=1일때 jump한다.

114 ; 섹터 읽기가 정상적으로 완료가 되면 
FLAGS
의 
CF
비트가 0로 설정된다.

120 
add
 
si
, 0x0020 ; 512(0x200)바이트만큼 읽었으므로, 이를 세그먼트 레지스터 값으로 변환

121 
mov
 
es
, 
si
 ; 
ES
 세그머트 레지스터에 더해서 어드레스를 한 섹터만큼 증가 (
ba
 
addss
를 변경하였네, 
offt
이 아니라)

126 
mov
 

, 
by
[
SECTORNUMBER
] ; 섹터 번호를 
AL
레지스터에 설정

127 
add
 

, 0x01 ; 섹터 번호를 1 증가

128 
mov
 
by
[
SECTORNUMBER
], 

 ; 증가 시킨 섹터 번호는 SECTORNUMBER에 다시 설정

129 
cmp
 

, 19 ; 증가 시킨 섹터 번호를 19와 비교

130 
jl
 
READDATA
 ; 섹터 번호가 19미만이라면 READDATA로 이동

133 
x
 
by
[
HEADNUMBER
], 0x01 ; 헤드 번호를 0x01과 
XOR
하여 토글(0->1,1->0)

134 
mov
 
by
[
SECTORNUMBER
],0x01 ; 섹터 번호를 다시 1로 설정

138 
cmp
 
by
[
HEADNUMBER
], 0x00 ; 헤드 번호를 0x00과 비교

139 
j
 
READDATA
 ; 헤드 번호가 0이 아니면 READDATA로 이동

142 
add
 
by
[
TRACKNUMBER
], 0x01 ; 트랙 번호를 1 증가

143 
jmp
 
READDATA
 ; READDATA로 이동

144 
READEND
:

148 ; 
OS
 이미지가 완료되었다는 메시지를 출력

150 
push
 
LOADINGCOMPLETEMESSAGE
 ; 출력할 메시지의 어드레스를 스택에 삽입

151 
push
 1 ; 화면 
Y
 좌표(1)를 스택에 삽입

152 
push
 20 ; 화면 
X
 좌표(20)를 스택에 삽입

153 

 
PRINTMESSAGE
 ; PRINTMESSAGE 함수 호출

154 
add
 

, 6 ; 삽입한 파라미터 제거

157 ; 로딩한 가상 
OS
 이미지 실행

159 
jmp
 0x1000:0x0000

166 
HANDLEDISKERROR
:

167 
push
 
DISKERRORMESSAGE
 ; 에러 문자열의 어드레스를 스택에 삽입

168 
push
 1 ; 화면 
Y
 좌표(1)를 스택에 삽입

169 
push
 20 ; 화면 
X
 좌표(20)를 스택에 삽입

170 

 
PRINTMESSAGE
 ; PRINTMESSAGE 함수 호출

172 
jmp
 
$
 ; 현재 위치에서 무한 루프 수행

175 ; 
PARAM
: 
x
 좌표, 
y
 좌표, 문자열

176 
PRINTMESSAGE
:

177 
push
 
bp
 ; 베이스 포인터 레지스터(bp)를 스택에 삽입

178 
mov
 
bp
, 

 ; 베이스 포인터 레지스터(bp)에 스택 포인터 레지스터(sp)의 값을 설정

179 ; 베이스 포인터 레지스터(
bp
)를 이용해서 파라미터에 접근할 목적

181 
push
 
es
 ;세그먼트 레지스터부터 
dx
 레지스터까지 스택에 삽입

182 
push
 
si
 ; 함수에서 임시로 사용하는 레지스터로 함수의 마지막 부분에서 스택에 삽입된 값을 꺼내 원래 값으로 복원

183 
push
 
di


184 
push
 
ax


185 
push
 
cx


186 
push
 
dx


188 ; 
es
 세그먼트 레지스터에 비디오 모드 어드레스 설정

190 
mov
 
ax
, 0xB800 ; 비디오 메모리 시작 어드레스(0x0B8000)를 세그먼트 레지스터 값으로 변환

191 
mov
 
es
, 
ax
 ;s 세그먼트 레지스터에 설정

194 ; 
X
, 
Y
의 좌표로 비디오 메모리 어드레스를 계산함

196 ; 
Y
 좌표를 이용해서 먼저 라인 어드레스를 구함

197 
mov
 
ax
, 
wd
[
bp
+6] ; 파라미터 2(화면 좌표 
Y
)를x 레지스터에 설정

198 
mov
 
si
, 160 ; 한 라인의 바이트 수(2*80 컬럼)를 si 레지스터에 설정

199 
mul
 
si
 ; 
ax
 레지스터와 s레지스터를 곱하여 화면 
y
 어드레스 계산

200 
mov
 
di
, 
ax
 ; 계산된 화면 
y
 어드레스를 di 레지스터에 설정

202 ; 
X
 좌표를 이용해서 2를 곱한 후 최종 어드레스를 구함

203 
mov
 
ax
, 
wd
[
bp
+4] ; 파라미터 1(화면 좌표 
X
)를x 레지스터에 설정

204 
mov
 
si
, 2 ; 한 문자를 나타내는 바이트 수(2)를 si 레지스터에 설정

205 
mul
 
si
 ; 
ax
 레지스터와 s레지스터를 곱하여 화면 
x
 어드레스를 계산

206 
add
 
di
, 
ax
 ; 화면 
Y
 어드레스와 계산된 
X
 어드레스를 더해서 실제 비디오 메모리 어드레스를 계산

209 
mov
 
si
, 
wd
[
bp
+8] ; 파라미터 3(출력할 문자열의 어드레스)

211 .
MESSAGELOOP
: ; 메시지를 출력하는 루프

212 
mov
 

,
by
[
si
] ; 
MESSAGE1
의 어드레스를 
SI
레지스터 값만큼 더한 위치의 문자를 
CL
 레지스터에 복사

213 ; 
CL
 레지스터는 
	`CX
(루프 또는 문자열의 카운터로 사용)되는 범용 레지스터의 하위 8비트임

214 ; 문자열은 1바이트면 충분하므로 
CX
 레지스터의 하위 1바이트만 사용

216 
cmp
 

, 0 ; 복사된 문자와 0을 비교

217 
je
 .
MESSAGEEND
 ; 복사한 문자의 값이 0이면 문자열이 종료되었음을 의미하므로 .MESSAGEEND로 이동하여 문자 출력 종료

219 
mov
 
by
[
es
:
di
],

 ; 0이 아니라면 비디오 메모리 어드레스 0xB800:di에 문자를 출력

221 
add
 
si
,1 ; 
SI
 레지스터에 1을 더하여 다음 문자열로 이동

222 
add
 
di
,2 ; 
DI
 레지스터에 2를 더하여 비디오 메모리의 다음 문자 위치로 이동

225 
jmp
 .
MESSAGELOOP
 ; 메시지 출력 루프로 이동하여 다음 문자를 출력

227 .
MESSAGEEND
:

228 
p
 
dx
 ; 함수에서 사용이 끝난 dx 레지스터부터 
es
 레지스터까지를 스택에 삽입된 값을 이용해서 복원

229 
p
 
cx


230 
p
 
ax


231 
p
 
di


232 
p
 
si


233 
p
 
es


234 
p
 
bp


235 
t


243 
MESSAGE1
: 
db
 'MINT64 OS Bo Ld S~!!',0 ; 출력할 메시지 정의 마지막은 0으로 설정하여 .
MESSAGELOOP
에서 문자열이 종료되었음을 알 수 있도록 함

245 
DISKERRORMESSAGE
: 
db
 'DISK Error~!!',0

246 
IMAGELOADINGMESSAGE
: 
db
 'OS Image Loading...',0

247 
LOADINGCOMPLETEMESSAGE
: 
db
 ' Complete~!!', 0

250 
SECTORNUMBER
: 
db
 0x02 ; 
OS
 이미지가 시작하는 섹터 번호를 저장하는 영역 (
MBR
는 부트로더)

251 
HEADNUMBER
: 
db
 0x00 ; 
OS
 이미지가 시작하는 헤드 번호를 지정하는 영역

252 
TRACKNUMBER
: 
db
 0x00 ; 
OS
 이미지가 시작하는 트랙 번호를 저장하는 영역

254 
times
 510 - (
$
-
$$

db
 0x00 ; $ 현재 라인의 어드레스

255 ; 
$$
 현재 섹션(.
xt
)의 시작 어드레스

256 ; 
$
 - 
$$
 현재 섹션을 기준으로 하는 오프셋 ( 0x55, 0xAA를 정확한 위치에 삽입하려고 추가된 부분)

257 ; 510 - (
$
-
$$
) 현재부터 어드레스 510까지

258 ; 
db
 0x00 
	`db
(
defe
 
by
의 약자) 1바이트를 선언하고 값은 0x00

259 ; 
time
 반복 수행

262 
db
 0x55 ; 1바이트를 선언하고 값은 0x55

263 
db
 0xAA ; 1바이트를 선언하고 값은 0xAA

	@/home/jk/os/MINT64/00.BootLoader/BootLoader2.asm

1 [
ORG
 0x00] ; 코드의 시작 어드레스를 0x00으로 설정

2 [
BITS
 16] ; 이하의 코드는 16비트 코드로 설정

4 
	gSECTION
 .
	gxt
 ;ext 섹션(세그먼트)을 정의

6 
	gjmp
 0x07C0:
START
 ; 
	gCS
 세그먼트 레지스터에 0x07C0을 복사하면서 , 
	gSTART
 레이블로 이동 (CS 세그먼트는 데이터 이동 명령으르 설정불가능하며 점프나 인터럽트 관련 명령으로 변경 가능

10 ; 
MINT64
 
	gOS
에 관련된 환경 설정 값

12 
	gTOTALSECTORCOUNT
: 
dw
 1024 ; 부트 로더를 제외한 
MINT64
 
	gOS
 이미지의 크기

13 ; 최대 1152 섹터(0x90000b
	gy
)까지 가능 
	gwhy
???? 0xA0000 이후의 메모리는 
gphic
 
	gmode
의 영역이다.

18 
	gSTART
:

19 
mov
 
ax
, 0x07C0 ; 부트 로더의 시작 어드레스(0x7C00)를 세그먼트 레지스터 값으로 변환

20 
mov
 
	gds
, 
	gax
 ; 
	gDS
 세그먼트 레지스터에 설정

21 
mov
 
	gax
, 0xB800 ; 비디오 메모리의 시작 어드레스(0xB800)를 세그먼트 레지스터 값으로 변환

22 
mov
 
	ges
, 
	gax
 ; 
	gES
 세그먼트 레지스터에 설정

24 ; 스택을 0x0000:0000~0x0000:
FFFF
 영역에 64
KB
 크기로 생성

25 
mov
 
ax
, 0x0000 ; 스택 세그먼트의 시작 어드레스(0x0000)를 세그먼트 레지스터 값으로 변환

26 
mov
 
	gss
, 
	gax
 ; 
	gSS
 세그먼트 레지스터에 설정

27 
mov
 
	g
, 0xFFFE ; 
	gSP
 레지스터의 어드레스를 0xFFFE로 설정

28 
mov
 
	gbp
, 0xFFFE ; 
	gBP
 레지스터의 어드레스를 0xFFFE로 설정

33 
mov
 
	gsi
, 0 ; 
	gSI
 레지스터 (문자열 원본 인덱스 레지스터)를 초기화

35 .
	gSCREENCLEARLOOP
: ; 화면을 지우는 루프

36 
mov
 
	gby
 [
es
:
si
],0 ; 비디오 메모리의 문자가 위치하는 어드레스에 0을 복사하여 문자를 삭제

37 
mov
 
	gby
 [
es
:
si
+1],0x09 ; 비디오 메모리의 속성이 위치하는 어드레스에 0x09(검은 바탕에 밝은 파랑)을 복사

39 
add
 
	gsi
,2 ; 문자와 속성을 설정했으므로 다음 위치로 이동

41 
cmp
 
	gsi
, 80*25*2 ; 화면의 전체 크기는 80문자*25라인임

42 ; 출력한 문자의 수를 의미하는 
	gSI
 레지스터와 비교

43 
	gjl
 .
	gSCREENCLEARLOOP
 ; 
	gSI
 레지스터가 80*25*2보다 작다면 아직 지우지 못한 영역이 있으므로 .SCREENCLEARLOOP 레이블로 이동

49 
push
 
	gMESSAGE1
 ; 출력 메시지의 어드레스를 스택에 삽입

50 
	gpush
 0 ; 화면 
	gY
 좌표(0)를 스택에 삽입

51 
	gpush
 0 ; 화면 
	gX
 좌표(0)를 스택에 삽입

52 

 
	gPRINTMESSAGE
 ; PRINTMESSAGE 함수 호출

53 
add
 
	g
, 6 ; 삽입한 파라미터 제거

56 ; 
	gos
 이미지를 로딩한다는 메시지 출력

59 
push
 
	gIMAGELOADINGMESSAGE
 ; 출력 메시지의 어드레스를 스택에 삽입

60 
	gpush
 1 ; 화면 
	gY
 좌표(1)를 스택에 삽입

61 
	gpush
 0 ; 화면 
	gX
 좌표(0)를 스택에 삽입

62 

 
	gPRINTMESSAGE
 ; PRINTMESSAGE 함수 호출

63 
add
 
	g
, 6 ; 삽입한 파라미터 제거

66 ; 디스크에서 
	gOS
 이미지를 로딩

72 
	gREADDISK
: ; 디스크를 리셋하는 코드의 시작

74 ; 
BIOS
 
Ret
 
	gFui
 호출

76 ; 서비스 번호 0, 드라이브 번호(0=
Flpy
)

77 
mov
 
ax
, 0

78 
mov
 
	gdl
, 0

81 
jc
 
	gHANDLEDISKERROR


87 ; 디스크의 내용을 메모리로 복사할 어드레스(
	gES
:
BX
)를 0x10000으로 설정

88 
mov
 
si
, 0x1000 ; 
	gOS
 이미지를 복사할 어드레스(0x10000)를 세그먼트 레지스터 값으로 변환

89 
mov
 
	ges
, 
	gsi
 ; 
	gES
 세그먼트 레지스터에 값 설정

90 
mov
 
	gbx
, 0x0000 ; 
	gBX
 레지스터에 0x0000을 설정하여 복사할 어드레스를 0x1000:0000(0x10000)으로 최종 설정

92 
mov
 
di
, 
	gwd
[
TOTALSECTORCOUNT
] ; 복사할 
	gOS
 이미지의 섹터 수를 
	gDI
 레지스터에 설정

94 
	gREADDATA
: ; 디스크를 읽는 코드의 시작

96 
cmp
 
	gdi
, 0 ; 복사할 
	gOS
 이미지의 섹터 수를 0과 비교

97 
je
 
	gREADEND
 ; 복사할 섹터 수가 0이라면 다 복사 했으므로 READEND로 이동

98 
sub
 
	gdi
, 0x01 ; 복사할 섹터 수를 1 감소

102 ; 
BIOS
 
Rd
 
	gFuni
 호출

105 
mov
 
	gah
, 0x02 ; 
	gBIOS
 서비스 번호 2(
Rd
 
	gSe
)

106 
mov
 
	g
, 0x01 ; 읽을 섹터 수는 1

107 
mov
 
	gch
, 
	gby
[
TRACKNUMBER
] ; 읽을 트랙 번호 설정

108 
mov
 
	g
, 
	gby
[
SECTORNUMBER
] ; 읽을 섹터 번호 설정

109 
mov
 
	gdh
, 
	gby
[
HEADNUMBER
] ; 읽을 헤드 번호 설정

110 
mov
 
	gdl
, 0x00 ; 읽을 드라이브 번호(0=
Flpy
) 설정

112 
jc
 
	gHANDLEDISKERROR
 ; 에러가 발생했다면 HANDLEDISKERROR로 이동 
	$jc
 (
jump
 

 
y

CF
=1일때 jump한다.

113 ; 섹터 읽기가 정상적으로 완료가 되면 
FLAGS
의 
CF
비트가 0로 설정된다.

119 
add
 
si
, 0x0020 ; 512(0x200)바이트만큼 읽었으므로, 이를 세그먼트 레지스터 값으로 변환

120 
mov
 
es
, 
si
 ; 
ES
 세그머트 레지스터에 더해서 어드레스를 한 섹터만큼 증가 (
ba
 
addss
를 변경하였네, 
offt
이 아니라)

125 
mov
 

, 
by
[
SECTORNUMBER
] ; 섹터 번호를 
AL
레지스터에 설정

126 
add
 

, 0x01 ; 섹터 번호를 1 증가

127 
mov
 
by
[
SECTORNUMBER
], 

 ; 증가 시킨 섹터 번호는 SECTORNUMBER에 다시 설정

128 
cmp
 

, 19 ; 증가 시킨 섹터 번호를 19와 비교

129 
jl
 
READDATA
 ; 섹터 번호가 19미만이라면 READDATA로 이동

132 
x
 
by
[
HEADNUMBER
], 0x01 ; 헤드 번호를 0x01과 
XOR
하여 토글(0->1,1->0)

133 
mov
 
by
[
SECTORNUMBER
],0x01 ; 섹터 번호를 다시 1로 설정

137 
cmp
 
by
[
HEADNUMBER
], 0x00 ; 헤드 번호를 0x00과 비교

138 
j
 
READDATA
 ; 헤드 번호가 0이 아니면 READDATA로 이동

141 
add
 
by
[
TRACKNUMBER
], 0x01 ; 트랙 번호를 1 증가

142 
jmp
 
READDATA
 ; READDATA로 이동

143 
READEND
:

147 ; 
OS
 이미지가 완료되었다는 메시지를 출력

149 
push
 
LOADINGCOMPLETEMESSAGE
 ; 출력할 메시지의 어드레스를 스택에 삽입

150 
push
 1 ; 화면 
Y
 좌표(1)를 스택에 삽입

151 
push
 20 ; 화면 
X
 좌표(20)를 스택에 삽입

152 

 
PRINTMESSAGE
 ; PRINTMESSAGE 함수 호출

153 
add
 

, 6 ; 삽입한 파라미터 제거

156 ; 로딩한 가상 
OS
 이미지 실행

158 
jmp
 0x1000:0x0000

165 
HANDLEDISKERROR
:

166 
push
 
DISKERRORMESSAGE
 ; 에러 문자열의 어드레스를 스택에 삽입

167 
push
 1 ; 화면 
Y
 좌표(1)를 스택에 삽입

168 
push
 20 ; 화면 
X
 좌표(20)를 스택에 삽입

169 

 
PRINTMESSAGE
 ; PRINTMESSAGE 함수 호출

171 
jmp
 
$
 ; 현재 위치에서 무한 루프 수행

174 ; 
PARAM
: 
x
 좌표, 
y
 좌표, 문자열

175 
PRINTMESSAGE
:

176 
push
 
bp
 ; 베이스 포인터 레지스터(bp)를 스택에 삽입

177 
mov
 
bp
, 

 ; 베이스 포인터 레지스터(bp)에 스택 포인터 레지스터(sp)의 값을 설정

178 ; 베이스 포인터 레지스터(
bp
)를 이용해서 파라미터에 접근할 목적

180 
push
 
es
 ;세그먼트 레지스터부터 
dx
 레지스터까지 스택에 삽입

181 
push
 
si
 ; 함수에서 임시로 사용하는 레지스터로 함수의 마지막 부분에서 스택에 삽입된 값을 꺼내 원래 값으로 복원

182 
push
 
di


183 
push
 
ax


184 
push
 
cx


185 
push
 
dx


187 ; 
es
 세그먼트 레지스터에 비디오 모드 어드레스 설정

189 
mov
 
ax
, 0xB800 ; 비디오 메모리 시작 어드레스(0x0B8000)를 세그먼트 레지스터 값으로 변환

190 
mov
 
es
, 
ax
 ;s 세그먼트 레지스터에 설정

193 ; 
X
, 
Y
의 좌표로 비디오 메모리 어드레스를 계산함

195 ; 
Y
 좌표를 이용해서 먼저 라인 어드레스를 구함

196 
mov
 
ax
, 
wd
[
bp
+6] ; 파라미터 2(화면 좌표 
Y
)를x 레지스터에 설정

197 
mov
 
si
, 160 ; 한 라인의 바이트 수(2*80 컬럼)를 si 레지스터에 설정

198 
mul
 
si
 ; 
ax
 레지스터와 s레지스터를 곱하여 화면 
y
 어드레스 계산

199 
mov
 
di
, 
ax
 ; 계산된 화면 
y
 어드레스를 di 레지스터에 설정

201 ; 
X
 좌표를 이용해서 2를 곱한 후 최종 어드레스를 구함

202 
mov
 
ax
, 
wd
[
bp
+4] ; 파라미터 1(화면 좌표 
X
)를x 레지스터에 설정

203 
mov
 
si
, 2 ; 한 문자를 나타내는 바이트 수(2)를 si 레지스터에 설정

204 
mul
 
si
 ; 
ax
 레지스터와 s레지스터를 곱하여 화면 
x
 어드레스를 계산

205 
add
 
di
, 
ax
 ; 화면 
Y
 어드레스와 계산된 
X
 어드레스를 더해서 실제 비디오 메모리 어드레스를 계산

208 
mov
 
si
, 
wd
[
bp
+8] ; 파라미터 3(출력할 문자열의 어드레스)

210 .
MESSAGELOOP
: ; 메시지를 출력하는 루프

211 
mov
 

,
by
[
si
] ; 
MESSAGE1
의 어드레스를 
SI
레지스터 값만큼 더한 위치의 문자를 
CL
 레지스터에 복사

212 ; 
CL
 레지스터는 
	`CX
(루프 또는 문자열의 카운터로 사용)되는 범용 레지스터의 하위 8비트임

213 ; 문자열은 1바이트면 충분하므로 
CX
 레지스터의 하위 1바이트만 사용

215 
cmp
 

, 0 ; 복사된 문자와 0을 비교

216 
je
 .
MESSAGEEND
 ; 복사한 문자의 값이 0이면 문자열이 종료되었음을 의미하므로 .MESSAGEEND로 이동하여 문자 출력 종료

218 
mov
 
by
[
es
:
di
],

 ; 0이 아니라면 비디오 메모리 어드레스 0xB800:di에 문자를 출력

220 
add
 
si
,1 ; 
SI
 레지스터에 1을 더하여 다음 문자열로 이동

221 
add
 
di
,2 ; 
DI
 레지스터에 2를 더하여 비디오 메모리의 다음 문자 위치로 이동

224 
jmp
 .
MESSAGELOOP
 ; 메시지 출력 루프로 이동하여 다음 문자를 출력

226 .
MESSAGEEND
:

227 
p
 
dx
 ; 함수에서 사용이 끝난 dx 레지스터부터 
es
 레지스터까지를 스택에 삽입된 값을 이용해서 복원

228 
p
 
cx


229 
p
 
ax


230 
p
 
di


231 
p
 
si


232 
p
 
es


233 
p
 
bp


234 
t


242 
MESSAGE1
: 
db
 'MINT64 OS Bo Ld S~!!',0 ; 출력할 메시지 정의 마지막은 0으로 설정하여 .
MESSAGELOOP
에서 문자열이 종료되었음을 알 수 있도록 함

244 
DISKERRORMESSAGE
: 
db
 'DISK Error~!!',0

245 
IMAGELOADINGMESSAGE
: 
db
 'OS Image Loading...',0

246 
LOADINGCOMPLETEMESSAGE
: 
db
 ' Complete~!!', 0

249 
SECTORNUMBER
: 
db
 0x02 ; 
OS
 이미지가 시작하는 섹터 번호를 저장하는 영역 (
MBR
는 부트로더)

250 
HEADNUMBER
: 
db
 0x00 ; 
OS
 이미지가 시작하는 헤드 번호를 지정하는 영역

251 
TRACKNUMBER
: 
db
 0x00 ; 
OS
 이미지가 시작하는 트랙 번호를 저장하는 영역

253 
times
 510 - (
$
-
$$

db
 0x00 ; $ 현재 라인의 어드레스

254 ; 
$$
 현재 섹션(.
xt
)의 시작 어드레스

255 ; 
$
 - 
$$
 현재 섹션을 기준으로 하는 오프셋 ( 0x55, 0xAA를 정확한 위치에 삽입하려고 추가된 부분)

256 ; 510 - (
$
-
$$
) 현재부터 어드레스 510까지

257 ; 
db
 0x00 
	`db
(
defe
 
by
의 약자) 1바이트를 선언하고 값은 0x00

258 ; 
time
 반복 수행

261 
db
 0x55 ; 1바이트를 선언하고 값은 0x55

262 
db
 0xAA ; 1바이트를 선언하고 값은 0xAA

	@/home/jk/os/MINT64/01.Kernel32/Source/EntryPoint.s

1 ; 
	gEryPot
.
	gs
 파일은 보호 모드 커널의 가장 앞부분에 위치하는 코드로 보호 모드 전환과 초기화를 수행하여 이후에 위치하는 코드를 위한 환경을 제공합니다.

4 [
ORG
 0x00] ;코드의 시작 어드레스를 0x00으로 설정

5 [
BITS
 16] ; 이하의 코드는 16비트 코드로 설정

7 
glob
 
START


9 
	gSECTION
 .
	gxt
 ;ext 섹션(세그먼트)을 정의

15 
	gSTART
:

17 
mov
 
ax
, 0x1000 ; 보호 모드 엔트리 포인트의 시작 어드레스 (0x10000)를 세그먼트 레지스터 값으로 변환

18 
mov
 
	gds
, 
	gax
 ; 
	gDS
 세그먼트 레지스터에 설정

19 
mov
 
	ges
, 
	gax
 ; 
	gES
 세그먼트 레지스터에 설정

22 ; 
Aliti
 
	gPross
 이면 아래의 고정을 모두 뛰어넘어서 보호 모드 커널로 이동

24 
mov
 
	gax
, 0x0000 ; 
Aliti
 
	gPross
 플래그를 확인하려고

25 
mov
 
	ges
, 
	gax
 ; 
	gES
 세그먼트 레지스터의 시작 어드레스를 0으로 설정

27 
cmp
 
	gby
 [
es
:0x7C09], 0x00 ; 플래그가 0이면 
Aliti
 
	gPross
 이므로

28 
	gje
 .
	gAPPLICATIONPROCESSORSTARTPOINT
 ; 
Aliti
 
	gPross
용 코드로 이동

31 ; 
Bo١p
 
	gPross
만 실행하는 부분

35 ; 
	gA20
 게이트를 활성화

36 ; 
	gBIOS
를 이용한 전환이 실패했을 때 시스템 컨트롤 포트로 전환 시도

38 ; 
	gBIOS
 서비스를 사용해서 
	gA20
 게이트를 활성화

39 
mov
 
	gax
, 0x2401 ; 
	gA20
 게이트 활성화 서비스 설정

40 0x15 ; 
	gBIOS
 인터럽트 서비스 호출

42 
	gjc
 .
	gA20GATEERROR
 ; 
	gA20
 게이트 활성화가 성공했는지 확인

43 
	gjmp
 .
	gA20GATESUCCESS


45 .
	gA20GATEERROR
:

47 

 
	g
, 0x92 ; 시스템 컨트롤 포트(0x92)에서 1바이트를 읽어 
	gAL
 레지스터에 저장

48 

 
	g
, 0x02 ; 읽은 값에 
	gA20
 게이트 비트(비트 1)를 1로 설정

49 
d
 
	g
, 0xFE ; 시스템 리셋 방지를 위해 0xFE와 
	gAND
 연산하여 비트0을 0으로 설정

50 
	gout
 0x92, 
	g
 ; 시스템 컨트롤 포트(0x92)에 변경된 값을 1바이트 설정

54 ; 
Bo١p
 
	gPross
와 
Aliti
 Processor가 공통으로 수행하는 부분

56 .
	gA20GATESUCCESS
:

57 .
APPLICATIONPROCESSORSTARTPOINT
:

58 
i
 ; 인터럽트가 발생하지 못하도록 설정

59 
	glgdt
 [ 
GDTR
 ] ; 
	gGDTR
 자료구조를 프로세서에 설정하여 
	gGDT
 테이블을 로드

64 ; 
Dib
 
	ggg
, Dib 
	gche
, 

 
	gFPU
, 
dib
 
Align
 
	gCheck
, 
Eb
 
	geedMode


66 
mov
 
	gx
, 0x4000003B ; 
	gPG
=0 
CD
=1 
NW
=0 
AM
=0 
WP
=0 
NE
=1 
ET
=1 
TS
=1 
EM
=0 
MP
=1 
PE
=1

67 
mov
 
0
, 
	gx
 ; 
	gCR0
 컨트롤 레지스터에 위에서 저장한 플래그를 설정하여 보호 모드로 전환

69 ; 커널 코드 세그먼트를 0x00을 기준으로 하는 것으로 교체하고 
	gEIP
의 값을 0x00을 기준으로 재설정

70 ; 
	gCS
 세그먼트 셀렉터 : 
EIP


71 
jmp
 
dwd
 0x18: ( 
PROTECTEDMODE
 - 
$$
 + 0x10000 )

77 [
BITS
 32] ; 이하의 코드는 32비트 코드로 설정

78 
	gPROTECTEDMODE
:

79 
mov
 
ax
, 0x20 ; 보호 모드 커널용 데이터 세그먼트 디스크립터를 
	gAX
레지스터에 저장

80 
mov
 
	gds
, 
	gax
 ; 
	gDS
 세그먼트 셀렉터에 설정

81 
mov
 
	ges
, 
	gax
 ; 
	gES
 세그먼트 셀렉터에 설정

82 
mov
 
	gfs
, 
	gax
 ; 
	gFS
 세그먼트 셀렉터에 설정

83 
mov
 
	ggs
, 
	gax
 ; 
	gGS
 세그먼트 셀렉터에 설정

86 ; 스택을 0x00000000~0x0000FFFF 영역에 64 
	gKB
 크기로 설정

88 
mov
 
	gss
, 
	gax
 ; 
	gSS
 세그먼트 셀렉터에 설정

89 
mov
 
	ge
, 0xFFFC ; 
	gESP
 레지스터의 어드레스를 0xFFFC로 설정

90 
mov
 
	gebp
, 0xFFFC ; 
	gEBP
 레지스터의 어드레스를 0xFFFC로 설정

92 ; 
Aliti
 
	gPross
이면 아래의 과정을 모두 뛰어넘어서 
	gC
 언어 커널 엔트리 포인트로 이동

93 
cmp
 
	gby
[0x7C09],0x00

94 
	gje
 .
	gAPPLICATIONPROCESSORSTARTPOINT2


98 
push
 ( 
SWITCHSUCCESSMESSAGE
 - 
$$
 + 0x10000 ) ; 출력할 메시지의 어드레스를 스택에 삽입

99 
	gpush
 2 ; 화면 
	gY
 좌표(2)를 스택에 삽입

100 
	gpush
 0 ; 화면 
	gX
 좌표(0)를 스택에 삽입

101 

 
	gPRINTMESSAGE
 ; PRINTMESSAGE 함수 호출

102 
add
 
	ge
, 12 ; 삽입한 파라미터 제거

104 .
	gAPPLICATIONPROCESSORSTARTPOINT2
:

105 
jmp
 
dwd
 0x18:0x10200 ; 
	gcs
 세그먼트 셀렉터를 커널 코드 디스크립터(0x08)로 변경하면서 0x10200 어드레스(
	gc
언어 커널이 있는 어드레스)로 이동

106 ; 
	gC
 언어 커널이 존재하는 0x10200 어드레스로 이동하여 C 언어 커널 수행

114 ; 스택에 
	gx
 좌표, 
	gy
 좌표, 문자열

116 
	gPRINTMESSAGE
:

117 
push
 
ebp
 ; 베이스 포인터 레지스터(
	gBP
)를 스택에 삽입

118 
mov
 
	gebp
, 
	ge
 ; 베이스 포인터 레지스터(
	gBP
)에 스택 포인터 레지스터(
	gSP
)의 값을 설정

120 
push
 
	gesi
 ; 함수에서 임시로 사용한느 레지스터로 함수의 마지막 부분에서 스택에 삽입되니 값을 꺼내 원래 값으로 복원 기존 리얼 모드에서 비디오 메모리 어드레스를 지정할때 사용하뎐 
	ges
 세그먼트 레지스터가

121 
push
 
	gedi
 ; 없어졌는데 그 이유는 보호 모드로 오면서 32비트 영역으로 확장됨에 따라서 4
	gGB
 영역에 걸친 전 영역을 접근할 수 있기 때문이다.

122 
push
 
x


123 
push
 
ecx


124 
push
 
	gedx


129 ; 
	gX
, 
	gY
의 좌표로 비디오 메모리의 어드레스를 계산함

131 ; 
	gY
 좌표를 이용해서 먼저 라인 어드레스를 구함

132 
mov
 
	gx
, 
	gdwd
 [ 
ebp
 + 12 ] ; 파라미터 2(화면 좌표
	gY
)를 
	gEAX
 레지스터에 설정

133 
mov
 
	gesi
, 160 ; 한 라인의 바이트 수 (2*80 컬럼)를 
	gESI
 레지스터에 설정

134 
mul
 
	gesi
 ; 
	gEAX
 레지스터와 
	gESI
 레지스터를 곱하여 화면 
	gY
 어드레스 계산

135 
mov
 
	gedi
, 
	gx
 ; 계산된 화면 
	gY
 어드레스를 
	gEDI
 레지스터에 설정

137 ; 
	gX
 좌표를 이용해서 2를 곱한 후 최종 어드레스를 구함

138 
mov
 
	gx
, 
	gdwd
 [ 
ebp
 + 8 ] ; 파라미터 1(화면 좌표 
	gX
)를 
	gEAX
레지스터에 설정

139 
mov
 
	gesi
, 2 ; 한 문자를 나타내는 바이트 수(2)를 
	gESI
 레지스터에 설정

140 
mul
 
	gesi
 ; 
	gEAX
 레지스터와 
	gESi
 레지스터를 곱하여 화면 
	gX
 어드레스 계산

141 
add
 
	gedi
, 
	gx
 ; 화면 
	gY
 어드레스와 계산된 
	gX
 어드레스를 더해서 실제 비디오 메모리 어드레스를 계산

145 
mov
 
	gesi
, 
	gdwd
 [ 
ebp
 + 16 ] ; 파라미터 3 (출력할 문자열의 어드레스)

147 .
	gMESSAGELOOP
: ; 메시지를 출력하는 루프

148 
mov
 
	g
, 
	gby
 [ 
esi
 ] ; 
	gESI
 레지스터가 가리키는 문자열 위치에서 한 문자를 
	gCL
 레지스터에 복사

149 ; 
	gCL
 레지스터는 
	gECX
 레지스터의 하위 1바이트를 의미

150 ; 문자열은 1 바이트면 충분하므로 
	gECX
 레지스터의 하위 1 바이트만 사용

152 
cmp
 
	g
, 0 ; 복사된 문자와 0을 비교

153 
	gje
 .
	gMESSAGEEND
 ; 복사한 문자의 값이 0이면 문자열이 종료되었음을 의미하므로 .MESSAGEEND로 이동하여 문자 출력 종료

156 
mov
 
	gby
 [ 
edi
+0xB8000 ], 
	g
 ; 00 아니라면 비디오 메모리 어드레스 0xB8000 + 
	gEDI
에 문자를 출력

158 
add
 
	gesi
, 1 ; 
	gESI
 레지스터에 1을 더하여 다음 문자열로 이동

159 
add
 
	gedi
, 2 ; 
	gEDI
 레지스터에 2를 더하여 비디오 메모리의 다음 문자 위로 이동 비디오 메모리는 (문자,속성)의 쌍으로 구성되므로 문자만 출력하려면 2를 더해야함

161 
	gjmp
 .
	gMESSAGELOOP
 ; 메세지 출력 루프로 이동하여 다음 문자를 출력

163 .
	gMESSAGEEND
:

164 
p
 
edx


165 
p
 
ecx


166 
p
 
x


167 
p
 
edi


168 
p
 
esi


169 
p
 
ebp


170 
t


178 
	gign
 8, 
	gdb
 0

180 ; 
	gGDTR
의 끝을 8b
	gy
로 정렬하기 위해 추가

181 
	gdw
 0x0000

183 ;
	gGDTR
 자료구조 정의

184 
	gGDTR
:

185 
dw
 
GDTEND
-
GDT
-1 ;아래에 위치하는 
	gGDT
 테이블의 전체 크기

186 
dd
 (
GDT
 - 
$$
 + 0x10000 ) ;아래에 위치하는 
	gGDT
 테이블의 시작 어드레스 실제 GDT가 있는 물리주소를 계산하기 위해서 현재 섹션 내의 GDT 오프셋에 세그먼트 기준 주소인 0x10000(부트 로더에 의해 0x10000에 로딩 되었다)을 더함

188 ;
	gGDT
 테이블 정의

189 
	gGDT
:

190 ;널 디스크리터 반드시 0으로 초기화해야함. 
	gGDT
의 맨처음 디스크립터는 널 디스크립터야 된다 (제약 사항)

191 
	gNULLDESCRIPTOR
:

192 
dw
 0x0000

193 
dw
 0x0000

194 
db
 0x00

195 
db
 0x00

196 
db
 0x00

197 
db
 0x00

199 ; 
	gIA
-32e 모드 커널용 코드 세그먼트 디스크립터

200 
	gIA_32eCODEDESCRIPTOR
:

201 
dw
 0xFFFF ; 
	gLim
 [15:0]

202 
dw
 0x0000 ; 
	gBa
 [15:0]

203 
db
 0x00 ; 
	gBa
 [23:16]

204 
db
 0x9A ; 
	gP
=1 
DPL
=0 
Code
 
Segmt
 
Execu
/
Rd


205 
db
 0xAF ; 
	gG
=1 
D
=0 
L
=1 
Lim
 [19:16]

206 
db
 0x00 ; 
	gBa
 [31:24]

208 ; 
	gIA
-32e 모드 커널용 데이터 세그먼트 디스크립터

209 
	gIA_32eDATADESCRIPTOR
:

210 
dw
 0xFFFF ; 
	gLim
 [15:0]

211 
dw
 0x0000 ; 
	gBa
 [15:0]

212 
db
 0x00 ; 
	gBa
 [23:16]

213 
db
 0x92 ; 
	gP
=1 
DPL
=0 
Da
 
Segmt
 
Rd
/
Wre


214 
db
 0xAF ; 
	gG
=1 
D
=0 
L
=1 
Lim
 [19:16]

215 
db
 0x00 ; 
	gBa
 [31:24]

217 
CODEDESCRIPTOR
:

218 
dw
 0xFFFF ; 
	gLim
 [15:0] 세그먼트 크기 4
GB
로 설정 
G
비트가 1로 설정되었을때

219 
dw
 0x0000 ; 
	gba
 [15:0] 기준 주소

220 
db
 0x00 ; 
	gba
 [23:16] 기준 주소

221 
db
 0x9A ; 
	gP
=1 (디스크립터 유효성
DPL
=0 (접근 권한
Code
 
Segmt
 
Execu
/
Rd


222 
db
 0xCF ; 
	gG
=1 ( 세그먼트 크기를 4
GB
로 확장시킴
D
/
B
=1 (1일 경우 32비트용 세그먼트임을 나타낸다.
L
=0 (0으로 설정하면 
IA
-32모드의 32비트 호환모드용 코드 세그먼트임을 나타냄
Lim
[19:16]

223 
db
 0x00 ; 
	gba
 [31:24]

225 
DATADESCRIPTOR
:

226 
dw
 0xFFFF ; 
	gLim
 [15:0] 세그먼트 크기 4
GB
로 설정 
G
비트가 1로 설정되었을때

227 
dw
 0x0000 ; 
	gba
 [15:0] 기준 주소

228 
db
 0x00 ; 
	gba
 [23:16] 기준 주소

229 
db
 0x92 ; 
	gP
=1 (디스크립터 유효성
DPL
=0 (접근 권한
Da
 
Segmt
 
Rd
/
Wre


230 
db
 0xCF ; 
	gG
=1 ( 세그먼트 크기를 4
GB
로 확장시킴
D
/
B
=1 (1일 경우 32비트용 세그먼트임을 나타낸다.
L
=0 (0으로 설정하면 
IA
-32모드의 32비트 호환모드용 코드 세그먼트임을 나타냄
Lim
[19:16]

231 
db
 0x00 ; 
	gba
 [31:24]

232 
GDTEND
:

235 
	gSWITCHSUCCESSMESSAGE
: 
db
 'Switch To Protected Mode Success~!!', 0

237 
	gtimes
 512 - (
	g$
-
	g$$

	gdb
 0x00 ; 512 바이트를 맞추기 위해 남은 부분을 0으로 채움

	@/home/jk/os/MINT64/01.Kernel32/Source/ModeSwitch.asm

1 [
BITS
 32] ; 이하의 코드는 32비트 코드로 설정

3 ; 
	gC
 언어에서 호출할 수 있도록 이름을 노출함(
	gexpt
)

4 
glob
 
	gkRdCPUID
, 
kSwchAndExecu64bKl


6 
	gSECTION
 .
	gxt
 ; .text 섹션(세그먼트)을 정의

8 ; 
	gCPUID
를 반환

9 ; 
	gPARAM
: 
DWORD
 
dwEAX
, DWORD* 
	gpdwEAB
,*
	gpdwEBX
,*
	gpdwECX
,*
pdwEDX


10 
	gkRdCPUID
:

11 
push
 
ebp
 ; 베이스 포인터 레지스터(
	gEBP
)를 스택에 삽입

12 
mov
 
	gebp
, 
	ge
 ; 베이스 포인터 레지스터(
	gEBP
)에 스택 포인터 레지스터(
	gESP
)의 값을 설정

13 
push
 
	gx
 ; 함수에서 임시로 사용하는 레지스터로 함수의 마지막 부분에서 스택에 삽입된 값을 꺼내 원래 값으로 복원

14 
push
 
ebx


15 
push
 
ecx


16 
push
 
edx


17 
push
 
	gesi


22 ; 
	gEAX
 레지스터의 값으로 
	gCPUID
 명령어 실행

25 
mov
 
	gx
, 
	gdwd
[
ebp
+8] ; 파라미터 1(
	gdwEAX
)를 
	gEAX
 레지스터에 저장

26 
	guid
 ; 
	gCPUID
 명령어 실행

32 ; *
pdwEAX


33 
mov
 
	gesi
, 
	gdwd
[
ebp
+12] ; 파라미터 2(
	gpdwEAX
)를 
	gESI
 레지스터에 저장

34 
mov
 
	gdwd
 [
esi
],
	gx
 ; 
	gpdwEAX
가 포인터이므로 포인터가 가리키는 어드레스에 
	gEAX
 레지스터의 값을 저장

36 ; *
pdwEBX


37 
mov
 
	gesi
, 
	gdwd
[
ebp
+16]

38 
mov
 
	gdwd
 [
esi
],
	gebx


40 ; *
pdwECX


41 
mov
 
	gesi
, 
	gdwd
[
ebp
+20]

42 
mov
 
	gdwd
 [
esi
],
	gecx


44 ; *
pdwEBX


45 
mov
 
	gesi
, 
	gdwd
[
ebp
+24]

46 
mov
 
	gdwd
 [
esi
],
edx


48 
p
 
esi


49 
p
 
edx


50 
p
 
ecx


51 
p
 
ebx


52 
p
 
x


53 
p
 
ebp


54 
	gt


56 ; 
	gIA
-32e 모드로 전환하고 64비트 커널을 수행

57 ; 
	gPARAM
: 없음

58 
kSwchAndExecu64bKl
:

60 ; 
	gCR4
 컨트롤 레지스터의 
	gPAE
 비트와 
	gOSXMMEXCPT
 비트, 
	gOXFXSR
 비트를 1로 설정

62 
mov
 
	gx
, 
	g4
 ; 
	gCR4
 컨트롤 레지스터의 값을 
	gEAX
 레지스터에 저장

63 

 
	gx
, 0x620 ; 
	gPAE
 비트(비트5)와 
	gOSXMMEXCPT
 비트(비트10), 
	gOSFXSR
 비트(비트9)를 모두 1로 설정

64 
mov
 
	g4
, 
	gx
 ; 
	gPAE
 비트가 1로 설정된 값을 
	gCR4
 컨트롤 레지스터에 저장

67 ; 
	gCR3
 컨트롤 레지스터에 
	gPML4
 테이블의 어드레스와 캐시 활성화

69 
mov
 
	gx
, 0x100000 ; 
	gEAX
 레지스터에 
	gPML4
 테이블이 존재하는 0x100000(1
	gMB
)를 저장

70 
mov
 
	g3
, 
	gx
 ; 
	gCR3
 컨트롤 레지스터에 0x100000(1
	gMB
)를 저장

73 ; 
	gIA32_EFER
.
	gLME
를 1로 설정하여 
	gIA
-32e 모드를 활성화

75 
mov
 
	gecx
, 0xC0000080 ; 
IA32_EFER
 
	gMSR
 레지스터의 어드레스를 저장

76 
	grdm
 ; 
	gMSR
 레지스터를 읽기

78 

 
	gx
, 0x0100 ; 
	gEAX
 레지스터에 저장된 
IA32_EFER
 
	gMSR
의 하위 32비트에서 
	gLME
비트(비트 9)을 1로 설정

79 
	gwrm
 ; 
	gMSR
 레지스터에 쓰기

83 ; 
	gCR0
 컨트롤 레지스터를 
	gNW
 비트(비트29)=0 
CD
 비트(비트 30)=0 
PG
 비트(비트31)=1로 설정하여 캐시 기능과 페이징 기능을 활성화

84 ; 
	gTS
 비트(비트3=1, 
	gEM
 비트(비트2=0, 
	gMP
 비트(비트1=1로 설정하여 
FPU
를 활성화

86 
mov
 
	gx
, 
	g0
 ; 
	gEAX
 레지스터에 
	gCR0
 컨트롤 레지스터를 저장

87 

 
	gx
, 0xE000000E ; 
	gNW
 비트,
	gCD
 비트,
	gPG
 비트,
	gTS
 비트,
	gEM
 비트,
	gMP
 비트을 모두 1로 설정

88 
x
 
	gx
, 0x60000004 ; 
	gNW
 비트 와 
	gCD
 비트,
	gEm
 비트를 
	gXOR
하여 0으로 설정

89 
mov
 
	g0
, 
	gx
 ; 
	gNW
 비트 = 0, 
	gCD
 비트 = 0, 
	gPG
 비트 = 1, 
	gTS
 비트 = 1, 
	gEM
 비트 = 0, 
	gMP
 비트 = 1로 설정한 값을 다시 
CR0
 컨트롤 레지스터에 저장

91 
jmp
 0x08:0x200000 ; 
	gCS
 세그먼트 셀렉터를 
	gIA_32e
 모드용 코드 세그먼트 디스크립터로 교체하고 0x200000(2
	gMB
) 어드레스로 이동

94 
jmp
 
	g$


	@/home/jk/os/MINT64/01.Kernel32/Source/ModeSwitch.h

1 #ide
__UTILITY_H__


2 
	#__UTILITY_H__


	)

4 
	~"Tys.h
"

6 
kRdCPUID
(
DWORD
 
dwEAX
,DWORD* 
pdwEAX
,DWORD* 
pdwEBX
,DWORD* 
pdwECX
,DWORD* 
pdwEDX
);

7 
kSwchAndExecu64bKl
();

	@/home/jk/os/MINT64/01.Kernel32/Source/Page.c

1 
	~"Page.h
"

4 
	$kInlizePageTabs
()

6 
PML4ENTRY
* 
pPML4Ery
;

7 
PDPTENTRY
* 
pPDPTEry
;

8 
PDENTRY
* 
pPDEry
;

9 
DWORD
 
dwMpgAddss
;

10 
i
;

16 
pPML4Ery
 = (
PML4ENTRY
*)0x100000;

17 
	`kSPageEryDa
(&(
pPML4Ery
[0]),0x00,0x101000,
PAGE_FLAGS_DEFAULT
,0);

18 
i
=1;i<
PAGE_MAXENTRYCOUNT
;i++)

20 
	`kSPageEryDa
(&(
pPML4Ery
[
i
]),0,0,0,0);

28 
pPDPTEry
 =(
PDPTENTRY
*)0x101000;

29 
i
=0;i<64;i++)

31 
	`kSPageEryDa
(&(
pPDPTEry
[
i
]),0,0x102000+(i*
PAGE_TABLESIZE
),
PAGE_FLAGS_DEFAULT
,0);

34 
i
=64;i<
PAGE_MAXENTRYCOUNT
;i++)

36 
	`kSPageEryDa
(&(
pPDPTEry
[
i
]),0,0,0,0);

44 
pPDEry
=(
PDENTRY
*)0x102000;

45 
dwMpgAddss
=0;

48 
i
=0;i<
PAGE_MAXENTRYCOUNT
*64;i++)

51 
	`kSPageEryDa
(&(
pPDEry
[
i
]),(i*(
PAGE_DEFAULTSIZE
>>20))>>12,
dwMpgAddss
,
PAGE_FLAGS_DEFAULT
|
PAGE_FLAGS_PS
,0);

52 
dwMpgAddss
+=
PAGE_DEFAULTSIZE
;

54 
	}
}

58 
	$kSPageEryDa
(
PTENTRY
* 
pEry
,
DWORD
 
dwUBaAddss
,DWORD 
dwLowBaAddss
,DWORD 
dwLowFgs
,DWORD 
dwUFLAGS
)

60 
pEry
->
dwAribuAndLowBaAddss
 = 
dwLowBaAddss
 | 
dwLowFgs
;

61 
pEry
->
dwUBaAddssAndEXB
 =(
dwUBaAddss
&0xFF)|
dwUFLAGS
;

62 
	}
}

	@/home/jk/os/MINT64/01.Kernel32/Source/Page.h

1 #ide
__PAGE_H__


2 
	#__PAGE_H__


	)

4 
	~"Tys.h
"

7 
	#PAGE_FLAGS_P
 0x00000001

8 
	#PAGE_FLAGS_RW
 0x00000002

9 
	#PAGE_FLAGS_US
 0x00000004

10 
	#PAGE_FLAGS_PWT
 0x00000008

11 
	#PAGE_FLAGS_PCD
 0x00000010

12 
	#PAGE_FLAGS_A
 0x00000020

13 
	#PAGE_FLAGS_D
 0x00000040

14 
	#PAGE_FLAGS_PS
 0x00000080

15 
	#PAGE_FLAGS_G
 0x00000100

16 
	#PAGE_FLAGS_PAT
 0x00001000

17 
	#PAGE_FLAGS_EXB
 0x80000000

18 
	#PAGE_FLAGS_DEFAULT
 (
PAGE_FLAGS_P
 | 
PAGE_FLAGS_RW
)

	)

19 
	#PAGE_TABLESIZE
 0x1000

	)

20 
	#PAGE_MAXENTRYCOUNT
 512

	)

21 
	#PAGE_DEFAULTSIZE
 0x200000

	)

25 #agm
ck
 (
push
,1)

27 
	skPageTabErySu


33 
DWORD
 
	mdwAribuAndLowBaAddss
;

35 
DWORD
 
	mdwUBaAddssAndEXB
;

36 } 
	tPML4ENTRY
,
	tPDPTENTRY
,
	tPDENTRY
,
	tPTENTRY
;

38 #agm
ck
 (
p
)

41 
kInlizePageTabs
();

42 
kSPageEryDa
(
PTENTRY
* 
pEry
, 
DWORD
 
dwUBaAddss
, DWORD 
dwLowBaAddess
,DWORD 
dwLowFgs
, DWORD 
dwUFgs
);

	@/home/jk/os/MINT64/01.Kernel32/Source/Types.h

1 #ide
__TYPES_H__


2 
	#__TYPES_H__


	)

4 
	#BYTE
 

	)

5 
	#WORD
 

	)

6 
	#DWORD
 

	)

7 
	#QWORD
 

	)

8 
	#BOOL
 

	)

10 
	#TRUE
 1

	)

11 
	#FALSE
 0

	)

12 
	#NULL
 0

	)

14 #agm
ck
(
push
,1)

16 
	skChaSu


18 
BYTE
 
	mbCha
;

19 
BYTE
 
	mbAribu
;

20 } 
	tCHARACTER
;

22 #agm
ck
(
p
)

	@/home/jk/os/MINT64/01.Kernel32/Source/main.c

1 
	~"Tys.h
"

2 
	~"Page.h
"

3 
	~"ModeSwch.h
"

6 
kPrtSg
(
iX
,
iY
,cڡ * 
pcSg
);

7 
BOOL
 
kInlizeKl64Aa
();

8 
BOOL
 
kIsMemyEnough
();

9 
kCyKl64ImageTo2Mby
();

12 
	#BOOTSTRAPPROCESSOR_FLAGADDRESS
 0x7C09

	)

16 
	$ma
()

18 
DWORD
 
i
;

19 
DWORD
 
dwEAX
, 
dwEBX
, 
dwECX
, 
dwEDX
;

20 
vcVdSg
[13]={0,};

23 if(*((
BYTE
*)
BOOTSTRAPPROCESSOR_FLAGADDRESS
)==0)

25 
	`kSwchAndExecu64bKl
();

33 
	`kPrtSg
(0,3,"Protected Mode C Language kernel start........................[Pass]");

36 
	`kPrtSg
(0,4,"Minimum Memory Size Check...................[ ]");

37 if(
	`kIsMemyEnough
()==
FALSE
)

39 
	`kPrtSg
(45,4,"Fail");

40 
	`kPrtSg
(0,5,"Not Enough Memory~!! MINT64 OS Requires Over 64MByte Memory~!!");

45 
	`kPrtSg
(45,4,"Pass");

50 
	`kPrtSg
(0,5,"IA-32e kernel Area Initialize...............[ ]");

51 if(
	`kInlizeKl64Aa
()==
FALSE
)

53 
	`kPrtSg
(45,4,"Fail");

54 
	`kPrtSg
(0,4,"Kernel Area Initialization Fail~!!");

57 
	`kPrtSg
(45,5,"Pass");

60 
	`kPrtSg
(0,6,"IA-32e Page Tables Initialize...............[ ]");

61 
	`kInlizePageTabs
();

62 
	`kPrtSg
(45,6,"Pass");

65 
	`kRdCPUID
(0x00,&
dwEAX
,&
dwEBX
,&
dwECX
,&
dwEDX
);

66 *(
DWORD
*)
vcVdSg
=
dwEBX
;

67 *((
DWORD
*)
vcVdSg
+1)=
dwEDX
;

68 *((
DWORD
*)
vcVdSg
+2)=
dwECX
;

69 
	`kPrtSg
(0,7,"Processor Vendor String.....................[ ]");

70 
	`kPrtSg
(45,7,
vcVdSg
);

73 
	`kRdCPUID
(0x80000001,&
dwEAX
,&
dwEBX
,&
dwECX
,&
dwEDX
);

74 
	`kPrtSg
(0,8,"64bit Mode Support Check....................[ ]");

75 if(
dwEDX
&(1<<29))

77 
	`kPrtSg
(45,8,"Pass");

81 
	`kPrtSg
(45,8,"Fail");

82 
	`kPrtSg
(0,9,"Thisrocessor doesot support 64bit mode~!!");

87 
	`kPrtSg
(0,9,"Copy IA-32e kernel To 2M Address............[ ]");

88 
	`kCyKl64ImageTo2Mby
();

89 
	`kPrtSg
(45,9,"Pass");

92 
	`kPrtSg
(0,10,"Switch To IA-32e Mode");

93 
	`kSwchAndExecu64bKl
();

97 
	}
}

100 
	$kPrtSg
(
iX
,
iY
,cڡ * 
pcSg
)

102 
CHARACTER
* 
pSn
 =(CHARACTER*)0xB8000;

103 
i
;

106 
pSn
+=(
iY
*80)+
iX
;

109 
i
=0;
pcSg
[i]!=0;i++)

111 
pSn
[
i
].
bCha
=
pcSg
[i];

113 
	}
}

116 
BOOL
 
	$kInlizeKl64Aa
()

118 
DWORD
* 
pdwCutAddss
;

121 
pdwCutAddss
 = (
DWORD
*) 0x100000;

124 (
DWORD
)
pdwCutAddss
<0x600000)

126 *
pdwCutAddss
=0x00;

130 if(*
pdwCutAddss
!=0)

132  
FALSE
;

136 
pdwCutAddss
++;

139  
TRUE
;

140 
	}
}

143 
BOOL
 
	$kIsMemyEnough
()

145 
DWORD
* 
pdwCutAddss
;

148 
pdwCutAddss
=(
DWORD
*)0x100000;

151 (
DWORD
)
pdwCutAddss
<0x4000000)

153 *
pdwCutAddss
=0x12345678;

157 if(*
pdwCutAddss
!=0x12345678)

159  
FALSE
;

163 
pdwCutAddss
 +=(0x1000000/4);

166  
TRUE
;

167 
	}
}

170 
	$kCyKl64ImageTo2Mby
()

172 
WORD
 
wKl32SeCou
, 
wTٮKlSeCou
;

173 
DWORD
* 
pdwSourAddss
,*
pdwDeiAddss
;

174 
i
;

177 
wTٮKlSeCou
 = *((
WORD
*)0x7C05);

178 
wKl32SeCou
 = *((
WORD
*)0x7C07);

180 
pdwSourAddss
 = (
DWORD
*)(0x10000+(
wKl32SeCou
*512));

181 
pdwDeiAddss
=(
DWORD
*)0x200000;

184 
i
=0;i<512*(
wTٮKlSeCou
-
wKl32SeCou
)/4;i++)

186 *
pdwDeiAddss
=*
pdwSourAddss
;

187 
pdwDeiAddss
++;

188 
pdwSourAddss
++;

190 
	}
}

	@/home/jk/os/MINT64/01.Kernel32/VirtualOS.asm

1 [
ORG
 0x00] ; 코드의 시작 어드레스르르 0x00으로 설정

2 [
BITS
 16] ; 이하의 코드는 16비트 코드로 설정

4 
	gSECTION
 .
	gxt
 ;ext 섹션(세그먼트)을 정의

6 
	gjmp
 0x1000:
START
 ; 
	gcs
 세그먼트 레지스터에 0x1000을 복사하면서, 
	gSTART
 레이블로 이동

8 
	gSECTORCOUNT
: 
dw
 0x0000 ; 현재 실행 중인 섹터 번호를 저장

9 
TOTALSECTORCOUNT
 
	gequ
 1024 ; 가상 
	gos
의 총 섹터 수

10 ; 최대 1152섹터 (0x90000b
	gy
)까지 가능

15 
	gSTART
:

16 
mov
 
ax
, 
	gcs
 ; 
	gCS
 세그먼트 레지스터의 값을 
	gax
 레지스터에 설정

17 
mov
 
	gds
, 
	gax
 ;x 레지스터의 값을 ds 세그먼트 레지스터에 설정

18 
mov
 
	gax
, 0xB800 ; 비디오 메모리 어드레스인 0x0B8000을 세그먼트 레지스터 값으로 변환

20 
mov
 
	ges
, 
	gax
 ; 
	gES
 세그먼트 레지스터에 설정

25 %
assign
 
	gi
 0 ; i라는 변수를 지정하고 0으로 초기화

26 %
p
 
	gTOTALSECTORCOUNT
 ; TOTALSECTORCOUNT에 저장된 값만큼 아래 코드를 반복

27 %
assign
 
i
 
	gi
 + 1 ; i에 1 증가

30 
mov
 
	gax
, 2 ; 한 문자를 나타내는 바이트 수(2)를x 레지스터에 설정

32 
mul
 
	gwd
 [ 
SECTORCOUNT
 ] ; 
	gAX
 레지스터와 섹터 수를 곱함

33 
mov
 
	gsi
, 
	gax
 ; 곱한 결과를 si 레지스터에 설정

36 
mov
 
	gby
 [ 
es
: 
si
 + ( 160 * 2 ) ], '0' + ( 
	gi
 % 10 )

37 
add
 
	gwd
 [ 
SECTORCOUNT
 ], 1 ; 섹터 수를 1 증가

41 %
	gi
 =
TOTALSECTORCOUNT
 ; i가 
	gTOTALSECTORCOUNT
와 같다면 즉 마지막 섹터이면 현재 위치에서 무한 루프 수행

43 
jmp
 
	g$


45 
jmp
 ( 0x1000 + 
i
 * 0x20 ): 0x0000 ; 다음 섹터 오프셋으로 이동

46 %
	gdif
 ; 문의 끝

48 
times
 ( 512 - ( 
$
 - 
$$
 ) % 512 ) 
	gdb
 0x00

49 %
	gdp


	@/home/jk/os/MINT64/02.Kernel64/Source/AssemblyUtility.asm

1 [
BITS
 64] ; 이하의 코드는 64비트 코드로 설정

3 
	gSECTION
 .
	gxt
 ;ext 섹션(세그먼트)을 정의

5 ; 
	gc
 언어에서 호출할 수 있도록 이름을 노출함

6 
glob
 
	gkInPtBy
, 
	gkOutPtBy
,
	gkInPtWd
,
kOutPtWd


7 
glob
 
	gkLdGDTR
,
	gkLdTR
,
kLdIDTR


8 
glob
 
	gkEbIru
, 
	gkDibIru
, 
kRdRFLAGS


9 
glob
 
kRdTSC


10 
glob
 
	gkSwchCڋxt
, 
	gkH
, 
kTeAndS


11 
glob
 
	gkInlizeFPU
, 
	gkSaveFPUCڋxt
, 
	gkLdFPUCڋxt
, 
	gkSTS
, 
kCˬTS


12 
glob
 
	gkEbGlobLolAPIC


15 ; 
	gPARAM
 : 포트 번호

16 
kInPtBy
:

17 
push
 
rdx
 ; 함수에서 임시로 사용하는 레지스터를 스택에 저장 함수의 마지막 부분에서 스택에 삽입된 값을 꺼내 복원

19 
mov
 
	grdx
, 
	grdi
 ; 
	gRDX
 레지스터에 파라미터 1(포트 번호)를 저장

20 
mov
 
	gx
, 0 ; 
	gRAX
 레지스터를 초기화

21 

 
	g
, 
	gdx
 ; 
	gDX
 레지스터에 저장된 포트 어드레스에서 한 바이트를 읽어 
	gAL
 레지스터에 저장, AL 레지스터는 함수의 반환 값으로 사용됨

24 
p
 
rdx


25 
	gt


29 ; 
	gPARAM
 : 포트 번호, 데이터

30 
	gkOutPtBy
:

31 
push
 
rdx


32 
push
 
x


34 
mov
 
rdx
, 
	grdi
 ; 
	gRDX
 레지스터에 파라미터 1(포트 번호)를 저장

35 
mov
 
	gx
, 
	grsi
 ; 
	gRAX
 레지스터에 파라미터 2(데이터)를 저장

36 
out
 
	gdx
, 
	g
 ; 
	gDX
 레지스터에 저장된 포트 어드레스에 
	gAL
 레지스터에 저장된 한 바이트를 씀

38 
p
 
x


39 
p
 
rdx


40 
	gt


42 ; 
	gGDTR
 레지스터에 
	gGDT
 테이블을 설정

43 ; 
	gPARAM
: 
GDT
 테이블의 정보를 저장하는 자료구조의 어드레스

44 
kLdGDTR
:

45 
lgdt
 [
rdi
] ; 파라미터 1(
	gGDTR
의 어드레스)를 프로세서에 로드하여 
	gGDT
 테이블을 설정

47 
	gt
 ; 
	gGDT
 테이블을 설정

49 ; 
	gTR
 레지스터에 
	gTSS
 세그먼트 디스크립터 설정

50 ; 
	gPARAM
: 
TSS
 세그먼트 디스크립터의 오프셋

51 
kLdTR
:

52 
r
 
di
 ; 파라미터 1(
	gTSS
 세그먼트 디스크립터의 오프셋)을 프로세서에 설정하여 TSS 세그먼트를 로드

54 
	gt


56 ; 
	gIDTR
 레지스터에 
	gIDT
 테이블을 설정

57 ; 
	gPARAM
: 
IDT
 테이블의 정보를 저장하는 자료구조의 어드레스

58 
kLdIDTR
:

59 
lidt
 [
rdi
] ; 파라미터 1(
	gIDTR
의 어드레스)을 프로세서에 로드하여 
	gIDT
 테이블을 설정

61 
	gt


64 ; 
	gPARAM
: 없음

65 
kEbIru
:

66 
i
 ; 인터럽트를 활성화

67 
	gt


70 ; 
	gPARAM
: 없음

71 
kDibIru
:

72 
i
 ; 인터럽트를 비활성화

73 
	gt


75 ; 
	gRFLAGS
 레지스터를 읽어서 되돌려줌

76 ; 
	gPARAM
: 없음

77 
kRdRFLAGS
:

78 
pushfq
 ; 
	gRFLAGS
 레지스터를 스택에 저장

79 
p
 
	gx
 ; 스택에 저장된 
	gRFLAGS
 레지스터를 
	gRAX
 레지스터에 저장하여 함수의 반환 값으로 설정

81 
	gt


84 ; 
	gPARAM
: 없음

85 
kRdTSC
:

86 
push
 
rdx
 ; 
	gRDX
 레지스터를 스택에 저장

88 
	grdtsc
 ; 타임 스탬프 카운터를 읽어서 
	gRDX
:
RAX
에 저장

90 
shl
 
rdx
,32 ; 
	gRDX
 레지스터에 있는 상위 32비트 
	gTSC
 값과 
	gRAX
 레지스터에 있는 하위 32비트 TSC 갑을 
	gOR
하여 RAX 레지스터에 64비트 TSC 값을 저장

91 

 
	gx
,
rdx


93 
p
 
rdx


94 
	gt


100 %
mao
 
	gKSAVECONTEXT
 0 ; 파라미터를 전달받지 않는 KSAVECONTEXT 매크로 정의

101 ; 
	gRBP
 레지스터부터 
	gGS
 세그먼트 셀렉터까지 모두 스택에 삽입

102 
push
 
rbp


103 
push
 
x


104 
push
 
rbx


105 
push
 
rcx


106 
push
 
rdx


107 
push
 
rdi


108 
push
 
rsi


109 
push
 
r8


110 
push
 
r9


111 
push
 
r10


112 
push
 
r11


113 
push
 
r12


114 
push
 
r13


115 
push
 
r14


116 
push
 
r15


118 
mov
 
	gax
, 
	gds
 ; 
	gDS
 세그먼트 셀렉터와 
	gES
 세그먼트 셀렉터는 스택에 직접 삽입할 수 없으므로, 
	gRAX
 레지스터에 저장한 후 스택에 삽입

119 
push
 
x


120 
mov
 
	gax
, 
es


121 
push
 
x


122 
push
 
fs


123 
push
 
	ggs


124 %
	gdmao
 ; 매크로 끝

128 %
mao
 
	gKLOADCONTEXT
 0 ; 파라미터를 전달받지 않는 KLOADCONTEXT 매크로 정의

129 ; 
	gGS
 세그먼트 셀렉터부터 
	gRBP
 레지스터까지 모두 스택에서 꺼내 복원

130 
p
 
gs


131 
p
 
fs


132 
p
 
x


133 
mov
 
	ges
, 
	gax
 ; 
	gES
 세그먼트 셀렉터와 
	gDS
 세그먼트 셀렉터는 스택에서 직접 꺼내 복원할 수 없으므로 
	gRAX
 레지스터에 저장한 뒤에 복원

134 
p
 
x


135 
mov
 
	gds
, 
ax


137 
p
 
r15


138 
p
 
r14


139 
p
 
r13


140 
p
 
r12


141 
p
 
r11


142 
p
 
r10


143 
p
 
r9


144 
p
 
r8


145 
p
 
rsi


146 
p
 
rdi


147 
p
 
rdx


148 
p
 
rcx


149 
p
 
rbx


150 
p
 
x


151 
p
 
	grbp


152 %
	gdmao
 ; 매크로 끝

154 ; 
Cu
 
	gCڋxt
에 현재 콘텍스트를 저장하고 
Next
 
	gTask
에서 콘텍스트를 복구

155 ; 
	gPARAM
: 
Cut
 
Cڋxt
, 
Next
 Context

156 
	gkSwchCڋxt
:

157 
push
 
rbp
 ; 스택에 
	gRBP
 레지스터를 저장하고 
	gRSP
 레지스터를 RBP에 저장

158 
mov
 
	grbp
, 
	gr


160 ; 
Cut
 
	gCڋxt
가 
	gNULL
이면 콘텍스트를 저장할 필요 없음

161 
	gpushfq
 ; 아래의 
	gcmp
의 결과로 
	gRFLAGS
 레지스터가 변하지 않도록 스택에 저장

162 
cmp
 
	grdi
, 0 ; 
Cut
 
	gCڋxt
가 
	gNULL
이면 콘텍스트 복원으로 바로 이동

163 
	gje
 .
LdCڋxt


164 
	gpfq
 ; 스택에 저장한 
	gRFLAGS
 레지스터를 복원

170 
push
 
	gx
 ; 콘텍스트 영역의 오프셋으로 사용할 
	gRAX
 레지스터를 스택에 저장

172 ; 
	gSS
, 
	gRSP
, 
	gRFLAGS
, 
	gCS
, 
	gRIP
 레지스터 순서대로 삽입

173 
mov
 
	gax
, 
	gss
 ; 
	gSS
 레지스터 저장

174 
mov
 
	gqwd
[
rdi
+(23*8)],
x


176 
mov
 
	gx
, 
	grbp
 ; 
	gRBP
에 저장된 
	gRSP
 레지스터 저장

177 
add
 
	gx
, 16 ; 
	gRSP
 레지스터는 
push
 
	grbp
와 
Ru
 
	gAddss
를 제외한 값으로 저장

178 
mov
 
	gqwd
[
rdi
+(22*8)],
x


180 
	gpushfq
 ; 
	gRFLAGS
 레지스터에 저장

181 
p
 
x


182 
mov
 
	gqwd
[
rdi
+(21*8)],
x


184 
mov
 
	gax
, 
	gcs
 ; 
	gCS
 레지스터 저장

185 
mov
 
	gqwd
[
rdi
+(20*8)],
x


187 
mov
 
	gx
, 
	gqwd
[
rbp
+8] ; 
	gRIP
 레지스터를 
Ru
 
	gAddss
로 설정하여 다음 콘텍스트 복원 시에 이 함수를 호출한 위치로 이동하게 함

188 
mov
 
	gqwd
[
rdi
+(19*8)],
	gx


191 
p
 
x


192 
p
 
	grbp


194 ; 가장 끝부분에 
	gSS
, 
	gRSP
, 
	gRFLAGS
, 
	gCS
, 
	gRIP
 레지스터를 저장했으므로, 이전 영역에 
	gpush
 명령어로 콘텍스트를 저장하기 위해 스택을 변경

195 
add
 
	grdi
,(19*8)

196 
mov
 
	gr
, 
rdi


197 
sub
 
	grdi
,(19*8)

199 ; 나머지 레지스터를 모두 
	gCڋxt
 자료구조에 저장

200 
	gKSAVECONTEXT


207 .
	gLdCڋxt
:

208 
mov
 
r
, 
	grsi


210 ; 
	gCڋxt
 자료구조에서 레지스터를 복원

211 
KLOADCONTEXT


212 
	gq


214 ; 
	gPARAM
: 없음

215 
kH
:

216 
h
 ; 프로세서를 대기 상태로 진입시킴

217 
h


218 
	gt


221 ; 
	gDei
과 
	gCom
를 비교하여 같다면 Dei에 
	gSour
 값을 삽입

222 ; 
	gPARAM
: 값을 저장할 어드레스(
Dei
,
	grdi
), 비교할 값 (
	gCom
,
	grsi
)

223 ; 설정할 값 (
	gSour
,
	grdx
)

224 
	gkTeAndS
:

225 
mov
 
x
, 
	grsi
 ; 두 번째 파라미터인 비교할 값을 
	gRAX
 레지스터에 저장

227 ; 
	gRAX
 레지스터에 저장된 비교할 값과 첫 번째 파라미터(
	grdi
)의 메모리 어드레스의 값을 비교하여

228 ; 두 값이 같다면 세 번째 파라미터(
	gdl
)의 값을 첫 번째 파라미터(
	grdi
)가 가리키는 어드레스에 삽입하고 
	gRFLAGS
의 
	gZF
비트를 1로 설정

229 ; 두 값이 다르면 첫 번째 파라미터(
	grdi
)의 값을 두 번째 파라미터(
	gRAX
)에 삽입하고 
	gRFLAGS
의 
	gZF
 비트를 0로 설정

230 ; 
	gLOCK
 명령어는 어셈블리어 코드에서 전치사로 사용되며, 뒤에 따라오는 명령어를 수행하는 동안

232 
lock
 
cmpxchg
 
	gby
[
rdi
],
dl


233 
	gje
 .
	gSUCCESS


235 .
	gNOTSAME
: ; 
	gDei
과 
	gCom
가 다른 경우

236 
mov
 
	gx
, 0x00

237 
	gt


239 .
	gSUCCESS
:

240 
mov
 
x
, 0x01 ; 
	gDei
과 
	gCom
과 같은 경우

241 
	gt


244 ; 
	gFPU
 관련 어셈블리어 함수

246 ; 
	gFPU
를 초기화

247 ; 
	gPARAM
: 없음

248 
kInlizeFPU
:

249 
f
 ; 
	gFPU
 초기화를 수행

250 
	gt


252 ; 
	gFPU
 관련 레지스터를 콘텍스트 버퍼에 저장

253 ; 
	gPARAM
: 
Bufr
 
Addss


254 
kSaveFPUCڋxt
:

255 
fxve
 [
rdi
] ; 첫 번째 파라미터로 전달된 버퍼에 
	gFPU
 레지스터를 저장

256 
	gt


258 ; 
	gFPU
 관련 레지스터를 콘텍스트 버퍼에서 복원

259 ; 
	gPARAM
: 
Bufr
 
Addss


260 
kLdFPUCڋxt
:

261 
fxr
 [
rdi
] ; 첫 번째 파라미터로 전달된 버퍼에서 
	gFPU
 레지스터를 복원

262 
	gt


264 ; 
	gCR0
 컨트롤 레지스터의 
	gTS
 비트를 1로 설정

265 ; 
	gPARAM
: 없음

266 
kSTS
:

267 
push
 
x
 ; 스택에 
	gRAX
 레지스터의 값을 저장

269 
mov
 
	gx
, 
	g0
 ; 
	gCR0
 컨트롤 레지스터의 값을 
	gRAX
 레지스터로 저장

270 

 
	gx
, 0x08 ; 
	gTS
 비트(비트7)를 1로 설정

271 
mov
 
	g0
, 
	gx
 ; 
	gTS
 비트가 1로 설정된 값을 
	gCR0
 컨트롤 레지스터로 저장

273 
p
 
	gx
 ; 스택에서 
	gRAX
 레지스터의 값을 복원

274 
	gt


276 ; 
	gCR0
 컨트롤 레지스터의 
	gTS
 비트를 0으로 설정

277 ; 
	gPARAM
: 없음

278 
kCˬTS
:

279 
ts
 ; 
	gCR0
 컨트롤 레지스터에서 
	gTS
 비트를 0으로 설정

280 
	gt


283 ; 
	gPARAM
: 포트 번호

284 
kInPtWd
:

285 
push
 
rdx
 ; 함수에서 임시로 사용하는 레지스터를 스택에 저장

288 
mov
 
	grdx
, 
	grdi
 ; 
	gRDX
 레지스터에 파라미터 1(포트 번호)을 저장

289 
mov
 
	gx
, 0 ; 
	gRAX
 레지스터를 초기화

290 

 
	gax
, 
	gdx
 ; 
	gDX
 레지스터에 저장된 포트 어드레스에서 두 바이트를 읽어 
	gAX
 레지스터에 저장

291 ; 
	gAX
 레지스터는 함수의 반환 값으로 사용됨

293 
p
 
	grdx
 ; 함수에서 사용이 끝난 레지스터를 복원

294 
	gt
 ; 함수를 호출한 다음 코드의 위치로 복귀

297 ; 
	gPARAM
: 포트 번호, 데이터

298 
	gkOutPtWd
:

299 
push
 
rdx
 ; 함수에서 임시로 사용하는 레지스터를 스택에 저장

300 
push
 
	gx
 ; 함수의 마지막 부분에서 스택에 삽입된 값을 꺼내 복원

302 
mov
 
	grdx
, 
	grdi
 ; 
	gRDX
 레지스터에 파라미터 1(포트 번호)을 저장

303 
mov
 
	gx
, 
	grsi
 ; 
	gRAX
 레지스터에 파라미터 2(데이터)를 저장

304 
out
 
	gdx
, 
	gax
 ; 
	gDX
 레지스터에 저장된 포트 어드레스에 
	gAX
 레지스터에 저장된 두 바이트를 씀

306 
p
 
	gx
 ; 함수에서 사용이 끝난 레지스터를 복원

307 
p
 
rdx


308 
	gt
 ; 함수를 호출한 다음 코드의 위치로 복귀

310 ; 
IA32_APIC_BASE
 
	gMSR
의 
	gAPIC
 전역 활성화 필드(비트 11)를 1로 설정하여 APIC를 활성화함

311 ; 
	gPARAM
 : 없음

312 
kEbGlobLolAPIC
:

313 
push
 
x
 ; 
	gRDMSR
과 
	gWRMSR
에서 사용하는 레지스터를 모두 스택에 저장

314 
push
 
rcx


315 
push
 
	grdx


317 ; 
IA32_APIC
 
BASE
 
	gMSR
에 설정된 기존 값을 읽어서 전역 
	gAPIC
 비트를 활성화

318 
mov
 
	grcx
,27 ; 
IA32_APIC_BASE
 
	gMSR
은 레지스터 어드레스 27에 위치하여,

319 
	grdm
 ; 
	gMSR
의 상위 32비트와 하위 32비트는 각각 
	gEDX
 레지스터와

320 ; 
	gEAX
 레지스터를 사용함

322 

 
	gx
, 0x0800 ; 
	gAPIC
 전역 활성/비활성 필드는 비트 11에 위치하므로 하위

323 
	gwrm
 ; 32비트를 담당하는 
	gEAX
 레지스터의 비트 11을 1로 설정한 뒤

324 ; 
	gMSR
 레지스터에 값을 덮어씀

326 
p
 
rdx


327 
p
 
rcx


328 
p
 
x


329 
	gt


	@/home/jk/os/MINT64/02.Kernel64/Source/AssemblyUtility.h

1 #ide
__ASSEMBLYUTILITY_H__


2 
	#__ASSEMBLYUTILITY_H__


	)

4 
	~"Tys.h
"

5 
	~"Task.h
"

8 
BYTE
 
kInPtBy
(
WORD
 
wPt
);

9 
kOutPtBy
(
WORD
 
wPt
,
BYTE
 
bDa
);

10 
kLdGDTR
(
QWORD
 
qwGDTRAddss
);

11 
kLdTR
(
WORD
 
wTSSSegmtOfft
);

12 
kLdIDTR
(
QWORD
 
qwIDTRAddss
);

13 
kEbIru
();

14 
kDibIru
();

15 
QWORD
 
kRdRFLAGS
();

16 
QWORD
 
kRdTSC
();

17 
kSwchCڋxt
(
CONTEXT
* 
pCutCڋxt
,CONTEXT* 
pNextCڋxt
);

18 
kH
();

19 
BOOL
 
kTeAndS
(vީ
BYTE
* 
pbDei
,BYTE 
bCom
,BYTE 
bSour
);

20 
kInlizeFPU
();

21 
kSaveFPUCڋxt
(* 
pvFPUCڋxt
);

22 
kLdFPUCڋxt
(* 
pvFPUCڋxt
);

23 
kSTS
();

24 
kCˬTS
();

25 
WORD
 
kInPtWd
(WORD 
wPt
);

26 
WORD
 
kOutPtWd
(WORD 
wPt
,WORD 
wDa
);

27 
kEbGlobLolAPIC
();

	@/home/jk/os/MINT64/02.Kernel64/Source/CacheManager.c

1 
	~"CacheMag.h
"

2 
	~"FeSyem.h
"

3 
	~"DymicMemy.h
"

6 
CACHEMANAGER
 
	ggs_CacheMag
;

9 
kCutDownAcssTime
(
iCacheTabIndex
);

12 
BOOL
 
	$kInlizeCacheMag
()

14 
i
;

17 
	`kMemS
(&
gs_CacheMag
,0,(gs_stCacheManager));

20 
gs_CacheMag
.
vdwAcssTime
[
CACHE_CLUSTERLINKTABLEAREA
]=0;

21 
gs_CacheMag
.
vdwAcssTime
[
CACHE_DATAAREA
]=0;

24 
gs_CacheMag
.
vdwMaxCou
[
CACHE_CLUSTERLINKTABLEAREA
]=
CACHE_MAXCLUSTERLINKTABLEAREACOUNT
;

25 
gs_CacheMag
.
vdwMaxCou
[
CACHE_DATAAREA
]=
CACHE_MAXDATAAREACOUNT
;

28 
gs_CacheMag
.
vpbBufr
[
CACHE_CLUSTERLINKTABLEAREA
]=(
BYTE
*)
	`kAoMemy
(
CACHE_MAXCLUSTERLINKTABLEAREACOUNT
*512);

30 if(
gs_CacheMag
.
vpbBufr
[
CACHE_CLUSTERLINKTABLEAREA
]==
NULL
)

32 
	`kFeMemy
(
gs_CacheMag
.
vpbBufr
[
CACHE_CLUSTERLINKTABLEAREA
]);

33  
FALSE
;

37 
i
=0;i<
CACHE_MAXCLUSTERLINKTABLEAREACOUNT
;i++)

40 
gs_CacheMag
.
vvCacheBufr
[
CACHE_CLUSTERLINKTABLEAREA
][
i
].
pbBufr
=gs_CacheMag.
vpbBufr
[CACHE_CLUSTERLINKTABLEAREA]+(i*512);

43 
gs_CacheMag
.
vvCacheBufr
[
CACHE_CLUSTERLINKTABLEAREA
][
i
].
dwTag
=
CACHE_INVALIDTAG
;

47 
gs_CacheMag
.
vpbBufr
[
CACHE_DATAAREA
] = (
BYTE
*)
	`kAoMemy
(
CACHE_MAXDATAAREACOUNT
*
FILESYSTEM_CLUSTERSIZE
);

49 if(
gs_CacheMag
.
vpbBufr
[
CACHE_DATAAREA
]==
NULL
)

52 
	`kFeMemy
(
gs_CacheMag
.
vpbBufr
[
CACHE_DATAAREA
]);

53  
FALSE
;

57 
i
=0;i<
CACHE_MAXDATAAREACOUNT
;i++)

60 
gs_CacheMag
.
vvCacheBufr
[
CACHE_DATAAREA
][
i
].
pbBufr
=gs_CacheMag.
vpbBufr
[CACHE_DATAAREA]+(i*
FILESYSTEM_CLUSTERSIZE
);

63 
gs_CacheMag
.
vvCacheBufr
[
CACHE_DATAAREA
][
i
].
dwTag
=
CACHE_INVALIDTAG
;

66  
TRUE
;

67 
	}
}

70 
CACHEBUFFER
* 
	$kAoCacheBufr
(
iCacheTabIndex
)

72 
CACHEBUFFER
* 
pCacheBufr
;

73 
i
;

76 if(
iCacheTabIndex
>
CACHE_MAXCACHETABLEINDEX
)

78  
NULL
;

82 
	`kCutDownAcssTime
(
iCacheTabIndex
);

85 
pCacheBufr
 = 
gs_CacheMag
.
vvCacheBufr
[
iCacheTabIndex
];

86 
i
=0;i<
gs_CacheMag
.
vdwMaxCou
[
iCacheTabIndex
];i++)

88 if(
pCacheBufr
[
i
].
dwTag
==
CACHE_INVALIDTAG
)

91 
pCacheBufr
[
i
].
dwTag
 = 
CACHE_INVALIDTAG
-1;

94 
pCacheBufr
[
i
].
dwAcssTime
 = 
gs_CacheMag
.
vdwAcssTime
[
iCacheTabIndex
]++;

96  &(
pCacheBufr
[
i
]);

100  
NULL
;

101 
	}
}

104 
CACHEBUFFER
* 
	$kFdCacheBufr
(
iCacheTabIndex
,
DWORD
 
dwTag
)

106 
CACHEBUFFER
* 
pCacheBufr
;

107 
i
;

110 if(
iCacheTabIndex
>
CACHE_MAXCACHETABLEINDEX
)

112  
NULL
;

116 
	`kCutDownAcssTime
(
iCacheTabIndex
);

119 
pCacheBufr
 = 
gs_CacheMag
.
vvCacheBufr
[
iCacheTabIndex
];

120 
i
=0;i<
gs_CacheMag
.
vdwMaxCou
[
iCacheTabIndex
];i++)

122 if(
pCacheBufr
[
i
].
dwTag
==dwTag)

126 
pCacheBufr
[
i
].
dwAcssTime
=
gs_CacheMag
.
vdwAcssTime
[
iCacheTabIndex
]++;

128  &(
pCacheBufr
[
i
]);

132  
NULL
;

133 
	}
}

136 
	$kCutDownAcssTime
(
iCacheTabIndex
)

138 
CACHEBUFFER
 
Temp
;

139 
CACHEBUFFER
* 
pCacheBufr
;

140 
BOOL
 
bS܋d
;

141 
i
,
j
;

144 if(
iCacheTabIndex
>
CACHE_MAXCACHETABLEINDEX
)

150 if(
gs_CacheMag
.
vdwAcssTime
[
iCacheTabIndex
]<0xfffffffe)

157 
pCacheBufr
 = 
gs_CacheMag
.
vvCacheBufr
[
iCacheTabIndex
];

158 
j
=0;j<
gs_CacheMag
.
vdwMaxCou
[
iCacheTabIndex
]-1;j++)

161 
bS܋d
=
TRUE
;

162 
i
=0;i<
gs_CacheMag
.
vdwMaxCou
[
iCacheTabIndex
]-1-
j
;i++)

165 if(
pCacheBufr
[
i
].
dwAcssTime
>pstCacheBuffer[i+1].dwAccessTime)

168 
bS܋d
 = 
FALSE
;

171 
	`kMemCpy
(&
Temp
,&(
pCacheBufr
[
i
]),(
CACHEBUFFER
));

172 
	`kMemCpy
(&(
pCacheBufr
[
i
]),&աCacheBufr[i+1]),(
CACHEBUFFER
));

173 
	`kMemCpy
(&(
pCacheBufr
[
i
+1]),&
Temp
,(
CACHEBUFFER
));

178 if(
bS܋d
==
TRUE
)

187 
i
=0;i<
gs_CacheMag
.
vdwMaxCou
[
iCacheTabIndex
];i++)

189 
pCacheBufr
[
i
].
dwAcssTime
=i;

193 
gs_CacheMag
.
vdwAcssTime
[
iCacheTabIndex
]=
i
;

194 
	}
}

197 
CACHEBUFFER
* 
	$kGViimInCacheBufr
(
iCacheTabIndex
)

199 
DWORD
 
dwOldTime
;

200 
CACHEBUFFER
* 
pCacheBufr
;

201 
iOldIndex
;

202 
i
;

205 if(
iCacheTabIndex
>
CACHE_MAXCACHETABLEINDEX
)

207  
NULL
;

211 
iOldIndex
 = -1;

212 
dwOldTime
 = 0xFFFFFFFF;

215 
pCacheBufr
 = 
gs_CacheMag
.
vvCacheBufr
[
iCacheTabIndex
];

216 
i
=0;i<
gs_CacheMag
.
vdwMaxCou
[
iCacheTabIndex
];i++)

220 if(
pCacheBufr
[
i
].
dwTag
 =
CACHE_INVALIDTAG
)

222 
iOldIndex
 = 
i
;

227 if(
pCacheBufr
[
i
].
dwAcssTime
<
dwOldTime
)

229 
dwOldTime
 = 
pCacheBufr
[
i
].
dwAcssTime
;

230 
iOldIndex
=
i
;

235 if(
iOldIndex
==-1)

237 
	`kPrtf
("Cache Buffer Find Error\n");

239  
NULL
;

243 
pCacheBufr
[
iOldIndex
].
dwAcssTime
 = 
gs_CacheMag
.
vdwAcssTime
[
iCacheTabIndex
]++;

245  &(
pCacheBufr
[
iOldIndex
]);

246 
	}
}

249 
	$kDisrdACacheBufr
(
iCacheTabIndex
)

251 
CACHEBUFFER
* 
pCacheBufr
;

252 
i
;

255 
pCacheBufr
 = 
gs_CacheMag
.
vvCacheBufr
[
iCacheTabIndex
];

256 
i
=0;i<
gs_CacheMag
.
vdwMaxCou
[
iCacheTabIndex
];i++)

258 
pCacheBufr
[
i
].
dwTag
 = 
CACHE_INVALIDTAG
;

262 
gs_CacheMag
.
vdwAcssTime
[
iCacheTabIndex
]=0;

263 
	}
}

266 
BOOL
 
	$kGCacheBufrAndCou
(
iCacheTabIndex
,
CACHEBUFFER
** 
CacheBufr
,* 
piMaxCou
)

269 if(
iCacheTabIndex
>
CACHE_MAXCACHETABLEINDEX
)

271  
FALSE
;

275 *
CacheBufr
 = 
gs_CacheMag
.
vvCacheBufr
[
iCacheTabIndex
];

276 *
piMaxCou
 = 
gs_CacheMag
.
vdwMaxCou
[
iCacheTabIndex
];

278  
TRUE
;

279 
	}
}

	@/home/jk/os/MINT64/02.Kernel64/Source/CacheManager.h

1 #ide
__CACHEMANAGER_H__


2 
	#__CACHEMANAGER_H__


	)

4 
	~"Tys.h
"

8 
	#CACHE_MAXCLUSTERLINKTABLEAREACOUNT
 16

	)

10 
	#CACHE_MAXDATAAREACOUNT
 32

	)

12 
	#CACHE_INVALIDTAG
 0xFFFFFFFF

	)

15 
	#CACHE_MAXCACHETABLEINDEX
 2

	)

17 
	#CACHE_CLUSTERLINKTABLEAREA
 0

	)

19 
	#CACHE_DATAAREA
 1

	)

23 
	skCacheBufrSu


26 
DWORD
 
	mdwTag
;

29 
DWORD
 
	mdwAcssTime
;

32 
BOOL
 
	mbChged
;

35 
BYTE
 *
	mpbBufr
;

36 } 
	tCACHEBUFFER
;

39 
	skCacheMagSu


42 
DWORD
 
	mvdwAcssTime
[
CACHE_MAXCACHETABLEINDEX
];

45 
BYTE
* 
	mvpbBufr
[
CACHE_MAXCACHETABLEINDEX
];

49 
CACHEBUFFER
 
	mvvCacheBufr
[
CACHE_MAXCACHETABLEINDEX
][
CACHE_MAXDATAAREACOUNT
];

52 
DWORD
 
	mvdwMaxCou
[
CACHE_MAXCACHETABLEINDEX
];

53 } 
	tCACHEMANAGER
;

56 
BOOL
 
kInlizeCacheMag
();

57 
CACHEBUFFER
* 
kAoCacheBufr
(
iCacheTabIndex
);

58 
CACHEBUFFER
* 
kFdCacheBufr
(
iCacheTabIndex
,
DWORD
 
dwTag
);

59 
CACHEBUFFER
* 
kGViimInCacheBufr
(
iCacheTabIndex
);

60 
kDisrdACacheBufr
(
iCacheTabIndex
);

61 
BOOL
 
kGCacheBufrAndCou
(
iCacheTabIndex
,
CACHEBUFFER
** 
CacheBufr
,* 
piMaxCou
);

	@/home/jk/os/MINT64/02.Kernel64/Source/Console.c

1 
	~"/u/oss/lib/gcc/x86_64-pc-lux/4.8.2/ude/dg.h
"

2 
	~"Cse.h
"

3 
	~"Keybrd.h
"

4 
	~"Uty.h
"

5 
	~"AsmblyUty.h
"

6 
	~"Tys.h
"

9 
CONSOLEMANAGER
 
	ggs_CseMag
 = {0,};

12 
	$kInlizeCse
(
iX
,
iY
)

15 
	`kMemS
(&
gs_CseMag
,0,(gs_stConsoleManager));

18 
	`kSCurs
(
iX
,
iY
);

19 
	}
}

23 
	$kSCurs
(
iX
,
iY
)

25 
iLrVue
;

28 
iLrVue
 = 
iY
*
CONSOLE_WIDTH
+
iX
;

31 
	`kOutPtBy
(
VGA_PORT_INDEX
,
VGA_INDEX_UPPERCURSOR
);

33 
	`kOutPtBy
(
VGA_PORT_DATA
,
iLrVue
>>8);

36 
	`kOutPtBy
(
VGA_PORT_INDEX
,
VGA_INDEX_LOWERCURSOR
);

38 
	`kOutPtBy
(
VGA_PORT_DATA
,
iLrVue
&0xFF);

41 
gs_CseMag
.
iCutPrtOfft
=
iLrVue
;

42 
	}
}

45 
	$kGCurs
(* 
piX
,* 
piY
)

48 *
piX
=
gs_CseMag
.
iCutPrtOfft
%
CONSOLE_WIDTH
;

49 *
piY
=
gs_CseMag
.
iCutPrtOfft
/
CONSOLE_WIDTH
;

50 
	}
}

53 
	$kPrtf
(cڡ * 
pcFmSg
,...)

55 
va_li
 

;

56 
vcBufr
[1024];

57 
iNextPrtOfft
;

60 
	`va_t
(

,
pcFmSg
);

61 
	`kVSPrtf
(
vcBufr
,
pcFmSg
,

);

62 
	`va_d
(

);

65 
iNextPrtOfft
=
	`kCsePrtSg
(
vcBufr
);

68 
	`kSCurs
(
iNextPrtOfft
%
CONSOLE_WIDTH
,iNextPrintOffset/CONSOLE_WIDTH);

69 
	}
}

72 
	$kCsePrtSg
(cڡ * 
pcBufr
)

74 
CHARACTER
* 
pSn
 =(CHARACTER*)
CONSOLE_VIDEOMEMORYADDRESS
;

75 
i
,
j
;

76 
iLgth
;

77 
iPrtOfft
;

80 
iPrtOfft
 = 
gs_CseMag
.
iCutPrtOfft
;

83 
iLgth
 = 
	`kSL
(
pcBufr
);

84 
i
=0;i<
iLgth
;i++)

87 if(
pcBufr
[
i
]=='\n')

91 
iPrtOfft
+=(
CONSOLE_WIDTH
-(iPrintOffset%CONSOLE_WIDTH));

95 i(
pcBufr
[
i
]=='\t')

98 
iPrtOfft
+=(8-(iPrintOffset%8));

104 
pSn
[
iPrtOfft
].
bCha
=
pcBufr
[
i
];

105 
pSn
[
iPrtOfft
].
bAribu
=
CONSOLE_DEFAULTTEXTCOLOR
;

106 
iPrtOfft
++;

110 if(
iPrtOfft
>=(
CONSOLE_HEIGHT
*
CONSOLE_WIDTH
))

113 
	`kMemCpy
(
CONSOLE_VIDEOMEMORYADDRESS
,CONSOLE_VIDEOMEMORYADDRESS+
CONSOLE_WIDTH
*(
CHARACTER
),(
CONSOLE_HEIGHT
-1)*CONSOLE_WIDTH*(CHARACTER));

116 
j
=(
CONSOLE_WIDTH
*(
CONSOLE_HEIGHT
-1));j<(CONSOLE_WIDTH*CONSOLE_HEIGHT);j++)

119 
pSn
[
j
].
bCha
=' ';

120 
pSn
[
j
].
bAribu
=
CONSOLE_DEFAULTTEXTCOLOR
;

124 
iPrtOfft
=(
CONSOLE_HEIGHT
-1)*
CONSOLE_WIDTH
;

128  
iPrtOfft
;

129 
	}
}

132 
	$kCˬSn
()

134 
CHARACTER
* 
pSn
=(CHARACTER*)
CONSOLE_VIDEOMEMORYADDRESS
;

135 
i
;

137 
i
=0;i<
CONSOLE_WIDTH
*
CONSOLE_HEIGHT
;i++)

139 
pSn
[
i
].
bCha
=' ';

140 
pSn
[
i
].
bAribu
=
CONSOLE_DEFAULTTEXTCOLOR
;

144 
	`kSCurs
(0,0);

145 
	}
}

148 
BYTE
 
	$kGCh
()

150 
KEYDATA
 
Da
;

156 
	`kGKeyFromKeyQueue
(&
Da
)==
FALSE
)

158 
	`kSchedu
();

163 if(
Da
.
bFgs
&
KEY_FLAGS_DOWN
)

165  
Da
.
bASCIICode
;

168 
	}
}

171 
	$kPrtSgXY
(
iX
,
iY
,cڡ * 
pcSg
)

173 
CHARACTER
* 
pSn
 = (CHARACTER*)
CONSOLE_VIDEOMEMORYADDRESS
;

174 
i
;

177 
pSn
+=(
iY
*80)+
iX
;

180 
i
=0;
pcSg
[i]!=0;i++)

182 
pSn
[
i
].
bCha
=
pcSg
[i];

183 
pSn
[
i
].
bAribu
=
CONSOLE_DEFAULTTEXTCOLOR
;

185 
	}
}

	@/home/jk/os/MINT64/02.Kernel64/Source/Console.h

1 #ide
__CONSOLE_H__


2 
	#__CONSOLE_H__


	)

4 
	~"Tys.h
"

8 
	#CONSOLE_BACKGROUND_BLACK
 0x00

	)

9 
	#CONSOLE_BACKGROUND_BLUE
 0x10

	)

10 
	#CONSOLE_BACKGROUND_GREEN
 0x20

	)

11 
	#CONSOLE_BACKGROUND_CYAN
 0x30

	)

12 
	#CONSOLE_BACKGROUND_RED
 0x40

	)

13 
	#CONSOLE_BACKGROUND_MAGENTA
 0x50

	)

14 
	#CONSOLE_BACKGROUND_BROWN
 0x60

	)

15 
	#CONSOLE_BACKGROUND_WHITE
 0x70

	)

16 
	#CONSOLE_BACKGROUND_BLINK
 0x80

	)

17 
	#CONSOLE_FOREGROUND_DARKBLACK
 0x00

	)

18 
	#CONSOLE_FOREGROUND_DARKBLUE
 0x01

	)

19 
	#CONSOLE_FOREGROUND_DARKGREEN
 0x02

	)

20 
	#CONSOLE_FOREGROUND_DARKCYAN
 0x03

	)

21 
	#CONSOLE_FOREGROUND_DARKRED
 0x04

	)

22 
	#CONSOLE_FOREGROUND_DARKMAGENTA
 0x05

	)

23 
	#CONSOLE_FOREGROUND_DARKBROWN
 0x06

	)

24 
	#CONSOLE_FOREGROUND_DARKWHITE
 0x07

	)

25 
	#CONSOLE_FOREGROUND_BRIGHTBLACK
 0x08

	)

26 
	#CONSOLE_FOREGROUND_BRIGHTBLUE
 0x09

	)

27 
	#CONSOLE_FOREGROUND_BRIGHTGREEN
 0x0A

	)

28 
	#CONSOLE_FOREGROUND_BRIGHTCYAN
 0x0B

	)

29 
	#CONSOLE_FOREGROUND_BRIGHTRED
 0x0C

	)

30 
	#CONSOLE_FOREGROUND_BRIGHTMAGENTA
 0x0D

	)

31 
	#CONSOLE_FOREGROUND_BRIGHTYELLOW
 0x0E

	)

32 
	#CONSOLE_FOREGROUND_BRIGHTWHITE
 0x0F

	)

35 
	#CONSOLE_DEFAULTTEXTCOLOR
 ( 
CONSOLE_BACKGROUND_BLACK
 | \

36 
CONSOLE_FOREGROUND_BRIGHTBLUE
 )

	)

39 
	#CONSOLE_WIDTH
 80

	)

40 
	#CONSOLE_HEIGHT
 25

	)

41 
	#CONSOLE_VIDEOMEMORYADDRESS
 0xB8000

	)

44 
	#VGA_PORT_INDEX
 0x3D4

	)

45 
	#VGA_PORT_DATA
 0x3D5

	)

46 
	#VGA_INDEX_UPPERCURSOR
 0x0E

	)

47 
	#VGA_INDEX_LOWERCURSOR
 0x0F

	)

51 #agm
ck

push
, 1 )

54 
	skCseMagSu


57 
	miCutPrtOfft
;

58 } 
	tCONSOLEMANAGER
;

60 #agm
ck

p
 )

63 
kInlizeCse
(
iX
,
iY
);

64 
kSCurs

iX
, 
iY
 );

65 
kGCurs
*
piX
, *
piY
 );

66 
kPrtf
cڡ * 
pcFmSg
, ... );

67 
kCsePrtSg
cڡ * 
pcBufr
 );

68 
kCˬSn
( );

69 
BYTE
 
kGCh
( );

70 
kPrtSgXY

iX
, 
iY
, cڡ * 
pcSg
 );

	@/home/jk/os/MINT64/02.Kernel64/Source/ConsoleShell.c

1 
	~"CseShl.h
"

2 
	~"Cse.h
"

3 
	~"Keybrd.h
"

4 
	~"Uty.h
"

5 
	~"PIT.h
"

6 
	~"RTC.h
"

7 
	~"AsmblyUty.h
"

8 
	~"Task.h
"

9 
	~"Synchrizi.h
"

10 
	~"DymicMemy.h
"

11 
	~"HdDisk.h
"

12 
	~"FeSyem.h
"

13 
	~"SlPt.h
"

14 
	~"MPCfigutiTab.h
"

15 
	~"LolAPIC.h
"

16 
	~"MuiPross.h
"

19 
MUTEX
 
	ggs_Mux
;

20 vީ
QWORD
 
	ggs_qwAdd
;

24 
kHp
(cڡ * 
pcPamBufr
);

25 
kCls
(cڡ * 
pcPamBufr
);

26 
kShowTٮRAMSize
(cڡ * 
pcPamBufr
);

27 
kSgToDecimHexText
(cڡ * 
pcPamBufr
);

28 
kShutdown
(cڡ * 
pcPamBufr
);

29 
kSTim
(cڡ * 
pcPamBufr
);

30 
kWaUsgPIT
(cڡ * 
pcPamBufr
);

31 
kRdTimeSmpCou
(cڡ * 
pcPamBufr
);

32 
kMsurPssSed
(cڡ * 
pcPamBufr
);

33 
kShowDeAndTime
(cڡ * 
pcPamBufr
);

34 
kCeTeTask
(cڡ * 
pcPamBufr
);

35 
kChgeTaskPriܙy
(cڡ * 
pcPamBufr
);

36 
kShowTaskLi
(cڡ * 
pcPamBufr
);

37 
kKlTask
(cڡ * 
pcPamBufr
);

38 
kCPULd
(cڡ * 
pcPamBufr
);

39 
kTeMux
(cڡ * 
pcPamBufr
);

40 
kTeThad
(cڡ * 
pcPamBufr
);

41 
kShowMrix
(cڡ * 
pcPamBufr
);

42 
kTePIE
(cڡ * 
pcPamBufr
);

43 
kTeSequtlAoti
(cڡ * 
pcPamBufr
);

44 
kTeRdomAoti
(cڡ * 
pcPamBufr
);

45 
kShowDymicMemyInfmi
(cڡ * 
pcPamBufr
);

46 
kShowHDDInfmi
(cڡ * 
pcPamBufr
);

47 
kRdSe
(cڡ * 
pcPamBufr
);

48 
kWreSe
(cڡ * 
pcPamBufr
);

49 
kMouHDD
(cڡ * 
pcPamBufr
);

50 
kFmHDD
(cڡ * 
pcPamBufr
);

51 
kShowFeSyemInfmi
(cڡ * 
pcPamBufr
);

52 
kCeFeInRoDey
(cڡ * 
pcPamBufr
);

53 
kDeFeInRoDey
(cڡ * 
pcPamBufr
);

54 
kShowRoDey
(cڡ * 
pcPamBufr
);

55 
kWreDaToFe
(cڡ * 
pcPamBufr
);

56 
kRdDaFromFe
(cڡ * 
pcPamBufr
);

57 
kTeFeIO
(cڡ * 
pcPamBufr
);

58 
kFlushCache
(cڡ * 
pcPamBufr
);

59 
kDowdFe
(cڡ * 
pcPamBufr
);

60 
kShowMPCfigutiTab
(cڡ * 
pcPamBufr
);

61 
kSAlitiPross
(cڡ * 
pcPamBufr
);

64 
kTeTask1
();

65 
kTeTask2
();

66 
kPrtNumbTask
();

67 
kCeThadTask
();

68 
QWORD
 
kRdom
();

69 
kDrChaThad
();

70 
kMrixPross
();

71 
kFPUTeTask
();

72 
kRdomAotiTask
();

75 
SHELLCOMMANDENTRY
 
	ggs_vCommdTab
[] =

77 {"hp","Show Hp",
kHp
},

78 {"s","Cˬ Sn",
kCls
},

79 {"tٮm","Show TٮRAM Size",
kShowTٮRAMSize
},

80 {"od","SgDecim/Hex cvt,x衹od 1000(decim衹od 0x10(hex)",
kSgToDecimHexText
},

81 {"shutdown","ShutdowAnd Rebo OS",
kShutdown
},

82 {"im","S PIT Cڌ˸Cou0,x)im 10(ms1Քiodiue(1)/l(0))",
kSTim
},

83 {"wa","Wa mUsg PIT,x)wa 100(ms)",
kWaUsgPIT
},

84 {"rdtsc","Rd TimSmCou",
kRdTimeSmpCou
},

85 {"ud","Msu Pross Sed",
kMsurPssSed
},

86 {"de","Show Dd Time",
kShowDeAndTime
},

87 {"sk","CTaskx)sk 1y10(cou)",
kCeTeTask
},

88 {"chgriܙy","ChgTask Priܙy,x)chgriܙy 1(ID2(Priܙy)",
kChgeTaskPriܙy
},

89 {"skli","Show Task Li",
kShowTaskLi
},

90 {"kask","End Task,x)kask 1(ID 0xffffffff(A Task)",
kKlTask
},

91 {"uld","Show Pross Ld",
kCPULd
},

92 {"mux","Te Mux Funi",
kTeMux
},

93 {"thad","Te Thad And ProsFuni",
kTeThad
},

94 {"showmrix","Show Mrix Sn",
kShowMrix
},

95 {"p","Te PIE Ccuti",
kTePIE
},

96 {"dymicmemfo","Show DymiMemy Infmi",
kShowDymicMemyInfmi
},

97 {"qloc","Te SequtAoti & Fe",
kTeSequtlAoti
},

98 {"oc","Te Rdom Aoti & Fe",
kTeRdomAoti
},

99 {"hddfo","Show HDD Infmi",
kShowHDDInfmi
},

100 {"ad","Rd HDD Se܃xd 0(LBA10(cou)",
kRdSe
},

101 {"wre","WrHDD Se܃x)wre 0(LBA10(cou)",
kWreSe
},

102 {"mouhdd","Mou HDD",
kMouHDD
},

103 {"fmhdd","Fm HDD",
kFmHDD
},

104 {"fesyemfo","Show FSyem Infmi",
kShowFeSyemInfmi
},

105 {"fe","CFe,x)fa.txt",
kCeFeInRoDey
},

106 {"defe","DFe,x)defa.txt",
kDeFeInRoDey
},

107 {"d","Show Dey",
kShowRoDey
},

108 {"wrefe","WrDTFe,x)wrefa.txt",
kWreDaToFe
},

109 {"adfe","Rd DFrom Fe,xdfa.txt",
kRdDaFromFe
},

110 {"feio","Te FI/O Funi",
kTeFeIO
},

111 {"ush","Flush FSyem Cache",
kFlushCache
},

112 {"dowd","Dowd DFrom Sex)dowd.txt",
kDowdFe
},

113 {"showmpfo","Show MP Cfiguti Tab Infmi",
kShowMPCfigutiTab
},

114 {"p","S Aliti Pross",
kSAlitiPross
},

118 vީ
QWORD
 
	ggs_qwRdomVue
 = 0;

122 
	$kSCseShl
()

124 
vcCommBufr
[
CONSOLESHELL_MAXCOMMANDBUFFERCOUNT
];

125 
iCommBufrIndex
=0;

126 
BYTE
 
bKey
;

127 
iCursX
, 
iCursY
;

130 
	`kPrtf
(
CONSOLESHELL_PROMPRTMESSAGE
);

135 
bKey
=
	`kGCh
();

137 if(
bKey
==
KEY_BACKSPACE
)

139 if(
iCommBufrIndex
>0)

142 
	`kGCurs
(&
iCursX
,&
iCursY
);

143 
	`kPrtSgXY
(
iCursX
-1,
iCursY
," ");

144 
	`kSCurs
(
iCursX
-1,
iCursY
);

145 
iCommBufrIndex
--;

149 if(
bKey
 =
KEY_ENTER
)

151 
	`kPrtf
("\n");

153 if(
iCommBufrIndex
>0)

156 
vcCommBufr
[
iCommBufrIndex
]='\0';

157 
	`kExecuCommd
(
vcCommBufr
);

161 
	`kPrtf
("%s",
CONSOLESHELL_PROMPRTMESSAGE
);

162 
	`kMemS
(
vcCommBufr
,'\0',
CONSOLESHELL_MAXCOMMANDBUFFERCOUNT
);

163 
iCommBufrIndex
=0;

166 if((
bKey
==
KEY_LSHIFT
)||(bKey==
KEY_RSHIFT
)||(bKey==
KEY_CAPSLOCK
)||(bKey==
KEY_NUMLOCK
)||(bKey==
KEY_SCROLLLOCK
))

173 if(
bKey
==
KEY_TAB
)

175 
bKey
=' ';

179 if(
iCommBufrIndex
<
CONSOLESHELL_MAXCOMMANDBUFFERCOUNT
)

181 
vcCommBufr
[
iCommBufrIndex
++]=
bKey
;

182 
	`kPrtf
("%c",
bKey
);

186 
	}
}

189 
	$kExecuCommd
(cڡ * 
pcCommdBufr
)

191 
i
, 
iSIndex
;

192 
iCommdBufrLgth
,
iCommdLgth
;

193 
iCou
;

196 
iCommdBufrLgth
=
	`kSL
(
pcCommdBufr
);

197 
iSIndex
=0;iSIndex<
iCommdBufrLgth
;iSpaceIndex++)

199 if(
pcCommdBufr
[
iSIndex
]==' ')

206 
iCou
=(
gs_vCommdTab
)/(
SHELLCOMMANDENTRY
);

208 
i
=0;i<
iCou
;i++)

210 
iCommdLgth
=
	`kSL
(
gs_vCommdTab
[
i
].
pcCommd
);

212 if((
iCommdLgth
==
iSIndex
)&&(
	`kMemCmp
(
gs_vCommdTab
[
i
].
pcCommd
,
pcCommdBufr
,iSpaceIndex)==0))

215 
gs_vCommdTab
[
i
].
	`pfFuni
(
pcCommdBufr
+
iSIndex
+1);

221 if(
i
>=
iCou
)

223 
	`kPrtf
("'%s',in found.\n",
pcCommdBufr
);

225 
	}
}

228 
	$kInlizePam
(
PARAMETERLIST
* 
pLi
,cڡ * 
pcPam
)

230 
pLi
->
pcBufr
=
pcPam
;

231 
pLi
->
iLgth
=
	`kSL
(
pcPam
);

232 
pLi
->
iCutPosi
=0;

233 
	}
}

236 
	$kGNextPam
(
PARAMETERLIST
* 
pLi
,* 
pcPam
)

238 
i
;

239 
iLgth
;

242 if(
pLi
->
iLgth
<Li->
iCutPosi
)

248 
i
=
pLi
->
iCutPosi
;i<pLi->
iLgth
;i++)

250 if(
pLi
->
pcBufr
[
i
]==' ')

257 
	`kMemCpy
(
pcPam
,
pLi
->
pcBufr
+pLi->
iCutPosi
,
i
);

258 
iLgth
=
i
-
pLi
->
iCutPosi
;

259 
pcPam
[
iLgth
]='\0';

262 
pLi
->
iCutPosi
+=
iLgth
+1;

263  
iLgth
;

264 
	}
}

268 
	$kHp
(cڡ * 
pcPamBufr
)

270 
i
;

271 
iCou
;

272 
iCursX
,
iCursY
;

273 
iLgth
,
iMaxcommdLgth
=0;

275 
	`kPrtf
("========================================================================\n");

276 
	`kPrtf
(" jk64 Shell Help \n");

277 
	`kPrtf
("========================================================================\n");

279 
iCou
=(
gs_vCommdTab
)/(
SHELLCOMMANDENTRY
);

282 
i
=0;i<
iCou
;i++)

284 
iLgth
=
	`kSL
(
gs_vCommdTab
[
i
].
pcCommd
);

285 if(
iLgth
>
iMaxcommdLgth
)

287 
iMaxcommdLgth
=
iLgth
;

292 
i
=0;i<
iCou
;i++)

294 
	`kPrtf
("%s",
gs_vCommdTab
[
i
].
pcCommd
);

295 
	`kGCurs
(&
iCursX
,&
iCursY
);

296 
	`kSCurs
(
iMaxcommdLgth
,
iCursY
);

297 
	`kPrtf
(" - %s\n",
gs_vCommdTab
[
i
].
pcHp
);

300 if((
i
!=0)&&((i%20)==0))

302 
	`kPrtf
("Preeny Keyo continue... ('q' isxit) :");

303 if(
	`kGCh
()=='q')

305 
	`kPrtf
("\n");

308 
	`kPrtf
("\n");

311 
	}
}

314 
	$kCls
(cڡ * 
pcPamBufr
)

317 
	`kCˬSn
();

318 
	`kSCurs
(0,1);

319 
	}
}

322 
	$kShowTٮRAMSize
(cڡ * 
pcPamBufr
)

324 
	`kPrtf
("Tٮ RAM Size=%d MB\n",
	`kGTٮRAMSize
());

325 
	}
}

328 
	$kSgToDecimHexText
(cڡ * 
pcPamBufr
)

330 
vcPam
[100];

331 
iLgth
;

332 
PARAMETERLIST
 
Li
;

333 
iCou
=0;

334 
iVue
;

337 
	`kInlizePam
(&
Li
,
pcPamBufr
);

342 
iLgth
=
	`kGNextPam
(&
Li
,
vcPam
);

343 if(
iLgth
==0)

349 
	`kPrtf
("Pam %d = '%s', Lgth = %d, ",
iCou
+1,
vcPam
,
iLgth
);

352 if(
	`kMemCmp
(
vcPam
,"0x",2)==0)

355 
iVue
=
	`kAToI
(
vcPam
+2,16);

356 
	`kPrtf
("HEX vu%q\n",
iVue
);

360 
iVue
=
	`kAToI
(
vcPam
,10);

361 
	`kPrtf
("Decim vu%d\n",
iVue
);

364 
iCou
++;

366 
	}
}

369 
	$kShutdown
(cڡ * 
pcPamBufr
)

371 
	`kPrtf
("System Shutdown Start...\n");

374 
	`kPrtf
("Cache Flush... ");

375 if(
	`kFlushFeSyemCache
()==
TRUE
)

377 
	`kPrtf
("Pass\n");

381 
	`kPrtf
("Fail\n");

385 
	`kPrtf
("Press Any Keyo Reboot PC...");

386 
	`kGCh
();

387 
	`kRebo
();

388 
	}
}

391 
	$kSTim
(cڡ * 
pcPamBufr
)

393 
vcPam
[100];

394 
PARAMETERLIST
 
Li
;

395 
lVue
;

396 
BOOL
 
bPiodic
;

399 
	`kInlizePam
(&
Li
,
pcPamBufr
);

402 if(
	`kGNextPam
(&
Li
,
vcPam
)==0)

404 
	`kPrtf
("ex)settimer 10(ms) 1(periodic)\n");

407 
lVue
=
	`kAToI
(
vcPam
,10);

410 if(
	`kGNextPam
(&
Li
,
vcPam
)==0)

412 
	`kPrtf
("ex)settimer 10(ms) 1(periodic)\n");

416 
bPiodic
 = 
	`kAToI
(
vcPam
,10);

418 
	`kInlizePIT
(
	`MSTOCOUNT
(
lVue
),
bPiodic
);

419 
	`kPrtf
("Tim%d ms, Piodi%d ChgCome\n",
lVue
,
bPiodic
);

420 
	}
}

423 
	$kWaUsgPIT
(cڡ * 
pcPamBufr
)

425 
vcPam
[100];

426 
iLgth
;

427 
PARAMETERLIST
 
Li
;

428 
lMicd
;

429 
i
;

432 
	`kInlizePam
(&
Li
,
pcPamBufr
);

433 if(
	`kGNextPam
(&
Li
,
vcPam
)==0)

435 
	`kPrtf
("ex)wait 100(ms)\n");

439 
lMicd
 = 
	`kAToI
(
vcPam
,10);

440 
	`kPrtf
("%d mS˕ S...\n",
lMicd
);

443 
	`kDibIru
();

444 
i
=0;i<
lMicd
/30;i++)

446 
	`kWaUsgDePIT
(
	`MSTOCOUNT
(30));

448 
	`kWaUsgDePIT
(
	`MSTOCOUNT
(
lMicd
%30));

449 
	`kEbIru
();

450 
	`kPrtf
("%d mS˕ Come\n",
lMicd
);

453 
	`kInlizePIT
(
	`MSTOCOUNT
(1),
TRUE
);

454 
	}
}

457 
	$kRdTimeSmpCou
(cڡ * 
pcPamBufr
)

459 
QWORD
 
qwTSC
;

461 
qwTSC
 = 
	`kRdTSC
();

462 
	`kPrtf
("TimSmCou = %q\n",
qwTSC
);

463 
	}
}

466 
	$kMsurPssSed
(cڡ * 
pcPamBufr
)

468 
i
;

469 
QWORD
 
qwLaTSC
, 
qwTٮTSC
=0;

471 
	`kPrtf
("Now Measuring");

474 
	`kDibIru
();

475 
i
=0;i<200;i++)

477 
qwLaTSC
=
	`kRdTSC
();

478 
	`kWaUsgDePIT
(
	`MSTOCOUNT
(50));

479 
qwTٮTSC
+=
	`kRdTSC
()-
qwLaTSC
;

481 
	`kPrtf
(".");

485 
	`kInlizePIT
(
	`MSTOCOUNT
(1),
TRUE
);

486 
	`kEbIru
();

488 
	`kPrtf
("\nCPU Sed = %d MHz\n",
qwTٮTSC
/10/1000/1000);

489 
	}
}

492 
	$kShowDeAndTime
(cڡ * 
pcPamBufr
)

494 
BYTE
 
bSecd
, 
bMu
,
bHour
;

495 
BYTE
 
bDayOFWk
,
bDayOfMth
,
bMth
;

496 
WORD
 
wYr
;

499 
	`kRdRTCTime
(&
bHour
,&
bMu
,&
bSecd
);

500 
	`kRdRTCDa
(&
wYr
,&
bMth
,&
bDayOfMth
,&
bDayOFWk
);

502 
	`kPrtf
("D: %d/%d/%d %s",
wYr
,
bMth
,
bDayOfMth
,
	`kCvtDayOfWkToSg
(
bDayOFWk
));

503 
	`kPrtf
("Tim: %d:%d:%d\n",
bHour
,
bMu
,
bSecd
);

504 
	}
}

509 
	$kTeTask1
()

511 
BYTE
 
bDa
;

512 
i
=0,
iX
=0,
iY
=0,
iMg
,
j
;

513 
CHARACTER
* 
pSn
 = (CHARACTER*
CONSOLE_VIDEOMEMORYADDRESS
;

514 
TCB
* 
pRugTask
;

518 
pRugTask
 = 
	`kGRugTask
();

519 
iMg
 = (
pRugTask
->
Lk
.
qwID
&0xFFFFFFFF)%10+1;

522 
j
=0;j<20000;j++)

524 
i
)

527 
iX
++;

528 if(
iX
>=(
CONSOLE_WIDTH
-
iMg
))

530 
i
=1;

535 
iY
++;

536 if(
iY
>=(
CONSOLE_HEIGHT
-
iMg
))

538 
i
=2;

543 
iX
--;

544 if(
iX
<
iMg
)

546 
i
=3;

551 
iY
--;

552 if(
iY
<
iMg
)

554 
i
=0;

561 
pSn
[
iY
*
CONSOLE_WIDTH
+
iX
].
bCha
=
bDa
;

562 
pSn
[
iY
*
CONSOLE_WIDTH
+
iX
].
bAribu
=
bDa
&0x0F;

563 
bDa
++;

570 
	`kExTask
();

572 
	}
}

576 
	$kTeTask2
()

578 
i
=0,
iOfft
;

579 
CHARACTER
* 
pSn
 = (CHARACTER*)
CONSOLE_VIDEOMEMORYADDRESS
;

580 
TCB
* 
pRugTask
;

581 
vcDa
[4]={'-','\\','|','/'};

584 
pRugTask
 = 
	`kGRugTask
();

585 
iOfft
 = (
pRugTask
->
Lk
.
qwID
&0xFFFFFFFF)*2;

586 
iOfft
 = 
CONSOLE_WIDTH
*
CONSOLE_HEIGHT
-(iOffset%(CONSOLE_WIDTH*CONSOLE_HEIGHT));

591 
pSn
[
iOfft
].
bCha
 = 
vcDa
[
i
%4];

593 
pSn
[
iOfft
].
bAribu
 = (iOffset%15)+1;

594 
i
++;

599 
	}
}

602 
	$kCeTeTask
(cڡ * 
pcPamBufr
)

604 
PARAMETERLIST
 
Li
;

605 
vcTy
[30];

606 
vcCou
[30];

607 
i
;

610 
	`kInlizePam
(&
Li
,
pcPamBufr
);

611 
	`kGNextPam
(&
Li
,
vcTy
);

612 
	`kGNextPam
(&
Li
,
vcCou
);

614 
	`kAToI
(
vcTy
,10))

618 
i
=0;i<
	`kAToI
(
vcCou
,10);i++)

620 if(
	`kCeTask
(
TASK_FLAGS_LOW
|
TASK_FLAGS_THREAD
,0,0,(
QWORD
)
kTeTask1
)==
NULL
)

626 
	`kPrtf
("Task1 %d Ced\n",
i
);

631 
i
=0;i<
	`kAToI
(
vcCou
,10);i++)

633 if(
	`kCeTask
(
TASK_FLAGS_LOW
|
TASK_FLAGS_THREAD
,0,0,(
QWORD
)
kTeTask2
)==
NULL
)

639 
	`kPrtf
("Task2 %d ced\n",
i
);

643 
	}
}

646 
	$kChgeTaskPriܙy
(cڡ * 
pcPamBufr
)

648 
PARAMETERLIST
 
Li
;

649 
vcID
[30];

650 
vcPriܙy
[30];

651 
QWORD
 
qwID
;

652 
BYTE
 
bPriܙy
;

655 
	`kInlizePam
(&
Li
,
pcPamBufr
);

656 
	`kGNextPam
(&
Li
,
vcID
);

657 
	`kGNextPam
(&
Li
,
vcPriܙy
);

660 if(
	`kMemCmp
(
vcID
,"0x",2)==0)

662 
qwID
 = 
	`kAToI
(
vcID
+2,16);

666 
qwID
 = 
	`kAToI
(
vcID
,10);

669 
bPriܙy
 = 
	`kAToI
(
vcPriܙy
,10);

671 
	`kPrtf
("ChgTask Priܙy ID [0x%q] Priܙy[%d]",
qwID
,
bPriܙy
);

672 if(
	`kChgePriܙy
(
qwID
,
bPriܙy
)==
TRUE
)

674 
	`kPrtf
("Success\n");

678 
	`kPrtf
("Fail\n");

680 
	}
}

683 
	$kShowTaskLi
(cڡ * 
pcPamBufr
)

685 
i
;

686 
TCB
* 
pTCB
;

687 
iCou
=0;

689 
	`kPrtf
("============Task Tٮ Cou [%d] ===========\n",
	`kGTaskCou
());

690 
i
=0;i<
TASK_MAXCOUNT
;i++)

693 
pTCB
 = 
	`kGTCBInTCBPo
(
i
);

694 if((
pTCB
->
Lk
.
qwID
>>32)!=0)

697 if((
iCou
!=0)&&((iCount%10)==0))

699 
	`kPrtf
("Pressny keyo continue... ('q' isxit) : ");

700 if(
	`kGCh
()=='q')

702 
	`kPrtf
("\n");

705 
	`kPrtf
("\n");

708 
	`kPrtf
("[%d] Task ID[0x%Q], Priܙy[%d], Fgs[0x%Q], Thad[%d]\n",1+
iCou
++,
pTCB
->
Lk
.
qwID
,
	`GETPRIORITY
աTCB->
qwFgs
),pTCB->qwFgs,
	`kGLiCou
(&աTCB->
ChdThadLi
)));

709 
	`kPrtf
(" PPID[0x%Q], Memy Addss[0x%Q], Size[0x%Q]\n",
pTCB
->
qwPtProssID
,pTCB->
pvMemyAddss
,pTCB->
qwMemySize
);

714 
	}
}

717 
	$kKlTask
(cڡ * 
pcPamBufr
)

719 
PARAMETERLIST
 
Li
;

720 
vcID
[30];

721 
QWORD
 
qwID
;

722 
TCB
* 
pTCB
;

723 
i
;

726 
	`kInlizePam
(&
Li
,
pcPamBufr
);

727 
	`kGNextPam
(&
Li
,
vcID
);

730 if(
	`kMemCmp
(
vcID
,"0x",2)==0)

732 
qwID
 = 
	`kAToI
(
vcID
+2,16);

736 
qwID
 = 
	`kAToI
(
vcID
,10);

740 if(
qwID
!=0xFFFFFFFF)

742 
pTCB
 = 
	`kGTCBInTCBPo
(
	`GETTCBOFFSET
(
qwID
));

743 
qwID
 = 
pTCB
->
Lk
.qwID;

746 if(((
qwID
>>32)!=0)&&((
pTCB
->
qwFgs
&
TASK_FLAGS_SYSTEM
)==0x00))

748 
	`kPrtf
("KTask ID [0x%q]",
qwID
);

749 if(
	`kEndTask
(
qwID
)==
TRUE
)

751 
	`kPrtf
("Success\n");

755 
	`kPrtf
("Fail\n");

760 
	`kPrtf
("Task doesotxist orask is systemask\n");

767 
i
=0;i<
TASK_MAXCOUNT
;i++)

769 
pTCB
 = 
	`kGTCBInTCBPo
(
i
);

770 
qwID
 = 
pTCB
->
Lk
.qwID;

773 if(((
qwID
>>32)!=0)&&((
pTCB
->
qwFgs
&
TASK_FLAGS_SYSTEM
)==0x00))

775 
	`kPrtf
("KTask ID [0x%q]",
qwID
);

776 if(
	`kEndTask
(
qwID
)==
TRUE
)

778 
	`kPrtf
("Success\n");

782 
	`kPrtf
("Fail\n");

787 
	}
}

790 
	$kCPULd
(cڡ * 
pcPamBufr
)

792 
	`kPrtf
("Pross Ld : %d%%\n",
	`kGProssLd
());

794 
	}
}

798 
	$kPrtNumbTask
()

800 
i
;

801 
j
;

802 
QWORD
 
qwTickCou
;

806 
qwTickCou
 = 
	`kGTickCou
();

807 (
	`kGTickCou
()-
qwTickCou
)<50)

809 
	`kSchedu
();

813 
i
=0;i<5;i++)

815 
	`kLock
(&(
gs_Mux
));

816 
	`kPrtf
("Task ID [0x%Q] Vue[%d]\n",
	`kGRugTask
()->
Lk
.
qwID
,
gs_qwAdd
);

817 
gs_qwAdd
+=1;

818 
	`kUock
(&(
gs_Mux
));

821 
j
=0;j<30000;j++);

825 
qwTickCou
 = 
	`kGTickCou
();

826 (
	`kGTickCou
()-
qwTickCou
)<1000)

828 
	`kSchedu
();

832 
	`kExTask
();

833 
	}
}

836 
	$kTeMux
(cڡ * 
pcPamBufr
)

838 
i
;

840 
gs_qwAdd
=1;

843 
	`kInlizeMux
(&(
gs_Mux
));

845 
i
=0;i<3;i++)

848 
	`kCeTask
(
TASK_FLAGS_LOW
|
TASK_FLAGS_THREAD
,0,0,(
QWORD
)
kPrtNumbTask
);

850 
	`kPrtf
("Wa Ut %d Task End...\n",
i
);

851 
	`kGCh
();

852 
	}
}

855 
	$kCeThadTask
()

857 
i
;

859 
i
=0;i<3;i++)

861 
	`kCeTask
(
TASK_FLAGS_LOW
|
TASK_FLAGS_THREAD
,0,0,(
QWORD
)
kTeTask2
);

866 
	`kS˕
(1);

868 
	}
}

871 
	$kTeThad
(cڡ * 
pcPamBufr
)

873 
TCB
* 
pPross
;

875 
pPross
 = 
	`kCeTask
(
TASK_FLAGS_LOW
|
TASK_FLAGS_PROCESS
,(*)0xEEEEEEEE,0x1000,(
QWORD
)
kCeThadTask
);

877 if(
pPross
!=
NULL
)

879 
	`kPrtf
("Pros[0x%Q] CSucss\n",
pPross
->
Lk
.
qwID
);

883 
	`kPrtf
("Process Create Fail\n");

885 
	}
}

888 
QWORD
 
	$kRdom
()

890 
gs_qwRdomVue
 = (gs_qwRandomValue*412153 + 5571031)>>16;

891  
gs_qwRdomVue
;

892 
	}
}

895 
	$kDrChaThad
()

897 
iX
;

898 
i
;

899 
vcText
[2] = {0,};

901 
iX
 = 
	`kRdom
()%
CONSOLE_WIDTH
;

906 
	`kS˕
(
	`kRdom
()%20);

908 if((
	`kRdom
()%20)<15)

910 
vcText
[0]=' ';

911 
i
=0;i<
CONSOLE_HEIGHT
-1;i++)

913 
	`kPrtSgXY
(
iX
,
i
,
vcText
);

914 
	`kS˕
(50);

919 
i
=0;i<
CONSOLE_HEIGHT
-1;i++)

921 
vcText
[0]=
i
+
	`kRdom
();

922 
	`kPrtSgXY
(
iX
,
i
,
vcText
);

923 
	`kS˕
(50);

927 
	}
}

930 
	$kMrixPross
()

932 
i
;

934 
i
=0;i<300;i++)

936 if(
	`kCeTask
(
TASK_FLAGS_THREAD
|
TASK_FLAGS_LOW
,0,0,(
QWORD
)
kDrChaThad
)==
NULL
)

941 
	`kS˕
(
	`kRdom
()%5+5);

944 
	`kPrtf
("%d Thad id\n",
i
);

947 
	`kGCh
();

948 
	}
}

951 
	$kShowMrix
(cڡ * 
pcPamBufr
)

953 
TCB
* 
pPross
;

955 
pPross
 = 
	`kCeTask
(
TASK_FLAGS_PROCESS
|
TASK_FLAGS_LOW
,(*)0xE00000,0xE00000,(
QWORD
)
kMrixPross
);

957 if(
pPross
!=
NULL
)

959 
	`kPrtf
("Mrix Pros[0x%Q] CeSucss\n",
pPross
->
Lk
.
qwID
);

962 (
pPross
->
Lk
.
qwID
>>32)!=0)

964 
	`kS˕
(100);

969 
	`kPrtf
("Matrix Process Create Fail\n");

971 
	}
}

973 
	$kFPUTeTask
()

975 
dVue1
;

976 
dVue2
;

977 
TCB
* 
pRugTask
;

978 
QWORD
 
qwCou
=0;

979 
QWORD
 
qwRdomVue
;

980 
i
;

981 
iOfft
;

982 
vcDa
[4]={'-','\\','|','/'};

983 
CHARACTER
* 
pSn
 = (CHARACTER*)
CONSOLE_VIDEOMEMORYADDRESS
;

985 
pRugTask
 = 
	`kGRugTask
();

988 
iOfft
 = (
pRugTask
->
Lk
.
qwID
&0xFFFFFFFF)*2;

989 
iOfft
 = 
CONSOLE_WIDTH
*
CONSOLE_HEIGHT
-(iOffset%(CONSOLE_WIDTH*CONSOLE_HEIGHT));

994 
dVue1
=1;

995 
dVue2
=1;

998 
i
=0;i<10;i++)

1000 
qwRdomVue
 = 
	`kRdom
();

1001 
dVue1
*=()
qwRdomVue
;

1002 
dVue2
*=()
qwRdomVue
;

1004 
	`kS˕
(1);

1006 
qwRdomVue
=
	`kRdom
();

1007 
dVue1
/=()
qwRdomVue
;

1008 
dVue2
/=()
qwRdomVue
;

1011 if(
dVue1
!=
dVue2
)

1013 
	`kPrtf
("Vuin same~!!! [%f] ![%f]\n",
dVue1
,
dVue2
);

1017 
qwCou
++;

1020 
pSn
[
iOfft
].
bCha
 = 
vcDa
[
qwCou
%4];

1023 
pSn
[
iOfft
].
bAribu
 = (iOffset%15)+1;

1025 
	}
}

1028 
	$kTePIE
(cڡ * 
pcPamBufr
)

1030 
dResu
;

1031 
i
;

1033 
	`kPrtf
("PIE Calculation Test\n");

1034 
	`kPrtf
("Result:355/133=");

1035 
dResu
 =()355/133;

1036 
	`kPrtf
("%d%d%d\n",(
QWORD
)
dResu
,((QWORD)(dResult*10)%10),((QWORD)(dResult*100)%10));

1039 
i
=0;i<100;i++)

1041 
	`kCeTask
(
TASK_FLAGS_LOW
|
TASK_FLAGS_THREAD
,0,0,(
QWORD
)
kFPUTeTask
);

1043 
	}
}

1046 
	$kShowDymicMemyInfmi
(cڡ * 
pcPamBufr
)

1048 
QWORD
 
qwSAddss
,
qwTٮSize
,
qwMaSize
,
qwUdSize
;

1050 
	`kGDymicMemyInfmi
(&
qwSAddss
,&
qwTٮSize
,&
qwMaSize
,&
qwUdSize
);

1052 
	`kPrtf
("================ Dynamic Memory Information =============\n");

1053 
	`kPrtf
("S Adds: [0x%Q]\n",
qwSAddss
);

1054 
	`kPrtf
("Tٮ Siz: [0x%Q]by, [%d]MB\n",
qwTٮSize
,qwTotalSize/1024/1024);

1055 
	`kPrtf
("MSize: [0x%Q]by, [%d]KB\n",
qwMaSize
,qwMetaSize/1024);

1056 
	`kPrtf
("Ud Size: [0x%Q]by, [%d]KB\n",
qwUdSize
,qwUsedSize/1024);

1057 
	}
}

1060 
	$kTeSequtlAoti
(cڡ * 
pcPamBufr
)

1062 
DYNAMICMEMORY
* 
pMemy
;

1063 
i
,
j
,
k
;

1064 
QWORD
* 
pqwBufr
;

1066 
	`kPrtf
("=============== Dynamic Memory Test =================\n");

1067 
pMemy
 = 
	`kGDymicMemyMag
();

1069 
i
=0;i<
pMemy
->
iMaxLevCou
;i++)

1071 
	`kPrtf
("Block Li [%d] Te S\n",
i
);

1072 
	`kPrtf
("Allocation And Compare: ");

1075 
j
=0;j<(
pMemy
->
iBlockCouOfSmˡBlock
>>
i
);j++)

1077 
pqwBufr
 = 
	`kAoMemy
(
DYNAMICMEMORY_MIN_SIZE
<<
i
);

1078 if(
pqwBufr
==
NULL
)

1080 
	`kPrtf
("\nAllocation Fail\n");

1085 
k
=0;k<(
DYNAMICMEMORY_MIN_SIZE
<<
i
)/8;k++)

1087 
pqwBufr
[
k
]=k;

1090 
k
=0;k<(
DYNAMICMEMORY_MIN_SIZE
<<
i
)/8;k++)

1092 if(
pqwBufr
[
k
]!=k)

1094 
	`kPrtf
("\nCompare Fail\n");

1100 
	`kPrtf
(".");

1103 
	`kPrtf
("\nFree: ");

1105 
j
=0;j<(
pMemy
->
iBlockCouOfSmˡBlock
>>
i
);j++)

1107 if(
	`kFeMemy
((*)(
pMemy
->
qwSAddss
+(
DYNAMICMEMORY_MIN_SIZE
<<
i
)*
j
))==
FALSE
)

1109 
	`kPrtf
("\n Free Fail\n");

1114 
	`kPrtf
(".");

1116 
	`kPrtf
("\n");

1118 
	}
}

1121 
	$kRdomAotiTask
()

1123 
TCB
* 
pTask
;

1124 
QWORD
 
qwMemySize
;

1125 
vcBufr
[200];

1126 
BYTE
* 
pbAotiBufr
;

1127 
i
,
j
;

1128 
iY
;

1130 
pTask
 = 
	`kGRugTask
();

1131 
iY
 = (
pTask
->
Lk
.
qwID
)%15+9;

1133 
j
=0;j<10;j++)

1138 
qwMemySize
 = ((
	`kRdom
()%(32*1024))+1)*1024;

1139 
pbAotiBufr
 = 
	`kAoMemy
(
qwMemySize
);

1143 if(
pbAotiBufr
==0)

1145 
	`kS˕
(1);

1147 } 
pbAotiBufr
==0);

1149 
	`kSPrtf
(
vcBufr
,"|Addss: [0x%Q] Size: [0x%Q] Aoti Sucss",
pbAotiBufr
,
qwMemySize
);

1151 
	`kPrtSgXY
(20,
iY
,
vcBufr
);

1152 
	`kS˕
(200);

1155 
	`kSPrtf
(
vcBufr
,"|Addss: [0x%Q] Size: [0x%Q] DWre...",
pbAotiBufr
,
qwMemySize
);

1156 
	`kPrtSgXY
(20,
iY
,
vcBufr
);

1157 
i
=0;i<
qwMemySize
/2;i++)

1159 
pbAotiBufr
[
i
] = 
	`kRdom
()&0xFF;

1160 
pbAotiBufr
[
i
+(
qwMemySize
/2)]=pbAllocationBuffer[i];

1163 
	`kS˕
(200);

1166 
	`kSPrtf
(
vcBufr
,"|Addss: [0x%Q] Size: [0x%Q] DVify...",
pbAotiBufr
,
qwMemySize
);

1167 
	`kPrtSgXY
(20,
iY
,
vcBufr
);

1168 
i
=0;i<
qwMemySize
/2;i++)

1170 if(
pbAotiBufr
[
i
]!bAotiBufr[i+(
qwMemySize
/2)])

1172 
	`kPrtf
("Task ID[0x%Q] Vify Fa\n",
pTask
->
Lk
.
qwID
);

1173 
	`kExTask
();

1176 
	`kFeMemy
(
pbAotiBufr
);

1177 
	`kS˕
(200);

1180 
	`kExTask
();

1181 
	}
}

1184 
	$kTeRdomAoti
(cڡ * 
pcPamBufr
)

1186 
i
;

1188 
i
=0;i<100;i++)

1190 
	`kCeTask
(
TASK_FLAGS_LOWEST
|
TASK_FLAGS_THREAD
,0,0,(
QWORD
)
kRdomAotiTask
);

1192 
	}
}

1195 
	$kShowHDDInfmi
(cڡ * 
pcPamBufr
)

1197 
HDDINFORMATION
 
HDD
;

1198 
vcBufr
[100];

1201 if(
	`kGHDDInfmi
(&
HDD
)==
FALSE
)

1203 
	`kPrtf
("HDD Information Read Fail\n");

1207 
	`kPrtf
("===================== Primary Master HDD Information ====================\n");

1210 
	`kMemCpy
(
vcBufr
,
HDD
.
vwModNumb
,(stHDD.vwModelNumber));

1211 
vcBufr
[(
HDD
.
vwModNumb
)-1]='\0';

1212 
	`kPrtf
("Mod Numb:\%s\n",
vcBufr
);

1215 
	`kMemCpy
(
vcBufr
,
HDD
.
vwSlNumb
,(stHDD.vwSerialNumber));

1216 
vcBufr
[(
HDD
.
vwSlNumb
)-1]='\0';

1217 
	`kPrtf
("SNumb:\%s\n",
vcBufr
);

1220 
	`kPrtf
("Hd Cou:\%d\n",
HDD
.
wNumbOfHd
);

1221 
	`kPrtf
("Cyld Cou:\%d\n",
HDD
.
wNumbOfCyld
);

1222 
	`kPrtf
("Se Cou:\%d\n",
HDD
.
wNumbOfSePCyld
);

1225 
	`kPrtf
("Tٮ Se:\%d Se, %dMB\n",
HDD
.
dwTٮSes
,stHDD.dwTotalSectors/2/1024);

1226 
	}
}

1229 
	$kRdSe
(cڡ * 
pcPamBufr
)

1231 
PARAMETERLIST
 
Li
;

1232 
vcLBA
[50],
vcSeCou
[50];

1233 
DWORD
 
dwLBA
;

1234 
iSeCou
;

1235 * 
pcBufr
;

1236 
i
,
j
;

1237 
BYTE
 
bDa
;

1238 
BOOL
 
bEx
=
FALSE
;

1241 
	`kInlizePam
(&
Li
,
pcPamBufr
);

1242 if((
	`kGNextPam
(&
Li
,
vcLBA
)==0)||(kGNextPam(&Li,
vcSeCou
)==0))

1244 
	`kPrtf
("ex)readsector 0(LBA) 10(count)\n");

1247 
dwLBA
 = 
	`kAToI
(
vcLBA
,10);

1248 
iSeCou
 = 
	`kAToI
(
vcSeCou
,10);

1251 
pcBufr
 = 
	`kAoMemy
(
iSeCou
*512);

1252 if(
	`kRdHDDSe
(
TRUE
,TRUE,
dwLBA
,
iSeCou
,
pcBufr
)==iSectorCount)

1254 
	`kPrtf
("LBA [%d] [%d] Se Rd Sucss~!!",
dwLBA
,
iSeCou
);

1256 
j
=0;j<
iSeCou
;j++)

1258 
i
=0;i<512;i++)

1260 if(!((
j
==0)&&(
i
==0))&&((i%256)==0))

1262 
	`kPrtf
("\nPressny keyo continue... ('q' isxit) : ");

1263 if(
	`kGCh
()=='q')

1265 
bEx
=
TRUE
;

1270 if((
i
%16)==0)

1272 
	`kPrtf
("\n[LBA:%d, Offt:%d]\t| ",
dwLBA
+
j
,
i
);

1276 
bDa
 = 
pcBufr
[
j
*512+
i
]&0xFF;

1277 if(
bDa
<16)

1279 
	`kPrtf
("0");

1281 
	`kPrtf
("%X ",
bDa
);

1284 if(
bEx
==
TRUE
)

1290 
	`kPrtf
("\n");

1294 
	`kPrtf
("Read Fail\n");

1297 
	`kFeMemy
(
pcBufr
);

1298 
	}
}

1301 
	$kWreSe
(cڡ * 
pcPamBufr
)

1303 
PARAMETERLIST
 
Li
;

1304 
vcLBA
[50],
vcSeCou
[50];

1305 
DWORD
 
dwLBA
;

1306 
iSeCou
;

1307 * 
pcBufr
;

1308 
i
,
j
;

1309 
BOOL
 
bEx
=
FALSE
;

1310 
BYTE
 
bDa
;

1311 
DWORD
 
s_dwWreCou
=0;

1314 
	`kInlizePam
(&
Li
,
pcPamBufr
);

1315 if((
	`kGNextPam
(&
Li
,
vcLBA
)==0)||(kGNextPam(&Li,
vcSeCou
)==0))

1317 
	`kPrtf
("ex)writesector 0(LBA) 10(count)\n");

1321 
dwLBA
 = 
	`kAToI
(
vcLBA
,10);

1322 
iSeCou
 = 
	`kAToI
(
vcSeCou
,10);

1324 
s_dwWreCou
++;

1327 
pcBufr
 = 
	`kAoMemy
(
iSeCou
*512);

1328 
j
=0;j<
iSeCou
;j++)

1330 
i
=0;i<512;i+=8)

1332 *(
DWORD
*)&(
pcBufr
[
j
*512+
i
])=
dwLBA
+j;

1333 *(
DWORD
*)&(
pcBufr
[
j
*512+
i
+4])=
s_dwWreCou
;

1338 if(
	`kWreHDDSe
(
TRUE
,TRUE,
dwLBA
,
iSeCou
,
pcBufr
)!=iSectorCount)

1340 
	`kPrtf
("Write Fail\n");

1343 
	`kPrtf
("LBA [%d], [%d] Se WrSucss~!!",
dwLBA
,
iSeCou
);

1346 
j
=0;j<
iSeCou
;j++)

1348 
i
=0;i<512;i++)

1350 if(!((
j
==0)&&(
i
==0))&&((i%256)==0))

1352 
	`kPrtf
("\nPressny keyo continue... ('q' isxit) : ");

1353 if(
	`kGCh
()=='q')

1355 
bEx
=
TRUE
;

1360 if((
i
%16)==0)

1362 
	`kPrtf
("\n[LBA:%d, Offt:%d]\t| ",
dwLBA
+
j
,
i
);

1366 
bDa
 = 
pcBufr
[
j
*512+
i
]&0xFF;

1367 if(
bDa
<16)

1369 
	`kPrtf
("0");

1371 
	`kPrtf
("%X ",
bDa
);

1374 if(
bEx
==
TRUE
)

1380 
	`kPrtf
("\n");

1381 
	`kFeMemy
(
pcBufr
);

1382 
	}
}

1385 
	$kMouHDD
(cڡ * 
pcPamBufr
)

1387 if(
	`kMou
()==
FALSE
)

1389 
	`kPrtf
("HDD Mount Fail\n");

1392 
	`kPrtf
("Hdd Mount Success\n");

1393 
	}
}

1396 
	$kFmHDD
(cڡ * 
pcPamBufr
)

1398 if(
	`kFm
()==
FALSE
)

1400 
	`kPrtf
("HDD Format Fail\n");

1404 
	`kPrtf
("HDD Format Success\n");

1405 
	}
}

1408 
	$kShowFeSyemInfmi
(cڡ * 
pcPamBufr
)

1410 
FILESYSTEMMANAGER
 
Mag
;

1412 
	`kGFeSyemInfmi
(&
Mag
);

1414 
	`kPrtf
("==================================== File System Information =================================\n");

1415 
	`kPrtf
("Moued:\t\t\t\t\%d\n",
Mag
.
bMoued
);

1416 
	`kPrtf
("Rerved Se Cou:\t\t\%d Se\n",
Mag
.
dwRervedSeCou
);

1417 
	`kPrtf
("Clu Lk Tab S Addss:\%d Se\n",
Mag
.
dwCluLkAaSAddss
);

1418 
	`kPrtf
("Clu Lk Tab Size:\t\%d Se\n",
Mag
.
dwCluLkAaSize
);

1419 
	`kPrtf
("DAS Addss:\t\%d Se\n",
Mag
.
dwDaAaSAddss
);

1420 
	`kPrtf
("Tٮ Clu Cou:\t\t\%d Clu\n",
Mag
.
dwTٮCluCou
);

1421 
	}
}

1424 
	$kCeFeInRoDey
(cڡ * 
pcPamBufr
)

1426 
PARAMETERLIST
 
Li
;

1427 
vcFeName
[50];

1428 
iLgth
;

1429 
DWORD
 
dwClu
;

1430 
DIRECTORYENTRY
 
Ery
;

1431 
i
;

1432 
FILE
* 
pFe
;

1435 
	`kInlizePam
(&
Li
,
pcPamBufr
);

1436 
iLgth
 = 
	`kGNextPam
(&
Li
,
vcFeName
);

1437 
vcFeName
[
iLgth
]='\0';

1438 if((
iLgth
>((
Ery
.
vcFeName
)-1))||(iLength==0))

1440 
	`kPrtf
("Tooong or Too short File Name\n");

1444 
pFe
 = 
	`fݒ
(
vcFeName
,"w");

1445 if(
pFe
==
NULL
)

1447 
	`kPrtf
("File Create Fail\n");

1450 
	`fo
(
pFe
);

1451 
	`kPrtf
("File Create Success\n");

1452 
	}
}

1455 
	$kDeFeInRoDey
(cڡ * 
pcPamBufr
)

1457 
PARAMETERLIST
 
Li
;

1458 
vcFeName
[50];

1459 
iLgth
;

1460 
DIRECTORYENTRY
 
Ery
;

1461 
iOfft
;

1464 
	`kInlizePam
(&
Li
,
pcPamBufr
);

1465 
iLgth
 = 
	`kGNextPam
(&
Li
,
vcFeName
);

1466 
vcFeName
[
iLgth
]='\0';

1468 if((
iLgth
>(
FILESYSTEM_MAXFILENAMELENGTH
-1))||(iLength==0))

1470 
	`kPrtf
("Too Long or Too Short File Name\n");

1474 if(
	`move
(
vcFeName
)!=0)

1476 
	`kPrtf
("File Not Found or File Opened\n");

1480 
	`kPrtf
("File Delete Success\n");

1481 
	}
}

1484 
	$kShowRoDey
(cڡ * 
pcPamBufr
)

1486 
DIR
* 
pDey
;

1487 
i
,
iTٮCou
,
iCou
;

1488 
dt
* 
pEry
;

1489 
vcBufr
[400];

1490 
vcTempVue
[50];

1491 
DWORD
 
dwTٮBy
;

1492 
DWORD
 
dwUdCluCou
;

1493 
FILESYSTEMMANAGER
 
Mag
;

1496 
	`kGFeSyemInfmi
(&
Mag
);

1499 
pDey
 = 
	`ݒd
("/");

1500 if(
pDey
==
NULL
)

1502 
	`kPrtf
("Root Directory Open Fail\n");

1507 
iTٮCou
=0;

1508 
dwTٮBy
=0;

1509 
dwUdCluCou
=0;

1514 
pEry
 = 
	`add
(
pDey
);

1516 if(
pEry
==
NULL
)

1520 
iTٮCou
++;

1521 
dwTٮBy
+=
pEry
->
dwFeSize
;

1524 if(
pEry
->
dwFeSize
==0)

1527 
dwUdCluCou
++;

1532 
dwUdCluCou
 +=(
pEry
->
dwFeSize
+
FILESYSTEM_CLUSTERSIZE
-1)/FILESYSTEM_CLUSTERSIZE;

1537 
	`wdd
(
pDey
);

1538 
iCou
=0;

1542 
pEry
 = 
	`add
(
pDey
);

1544 if(
pEry
==
NULL
)

1550 
	`kMemS
(
vcBufr
,' ',(vcBuffer)-1);

1551 
vcBufr
[(vcBuffer)-1]='\0';

1554 
	`kMemCpy
(
vcBufr
,
pEry
->
d_me
,
	`kSL
(pstEntry->d_name));

1557 
	`kSPrtf
(
vcTempVue
,"%d By",
pEry
->
dwFeSize
);

1558 
	`kMemCpy
(
vcBufr
+30,
vcTempVue
,
	`kSL
(vcTempValue));

1561 
	`kSPrtf
(
vcBufr
+55,"0x%X Clu",
pEry
->
dwSCluIndex
);

1562 
	`kPrtf
(" %s\n",
vcBufr
);

1564 if((
iCou
!=0)&&((iCount%20)==0))

1566 
	`kPrtf
("Preeny keyo continue... ('q' isxit) : ");

1567 if(
	`kGCh
()=='q')

1569 
	`kPrtf
("\n");

1573 
iCou
++;

1577 
	`kPrtf
("\t\tTٮ FCou: %d\n",
iTٮCou
);

1578 
	`kPrtf
("\t\tTٮ FSize: %d KBy (%d Clu)\n",
dwTٮBy
/1024,
dwUdCluCou
);

1581 
	`kPrtf
("\t\tFS: %d KBy (%d Clu)\n",(
Mag
.
dwTٮCluCou
-
dwUdCluCou
)*
FILESYSTEM_CLUSTERSIZE
/1024,stManager.dwTotalClusterCount-dwUsedClusterCount);

1584 
	`od
(
pDey
);

1585 
	}
}

1588 
	$kWreDaToFe
(cڡ * 
pcPamBufr
)

1590 
PARAMETERLIST
 
Li
;

1591 
vcFeName
[50];

1592 
iLgth
;

1593 
FILE
* 

;

1594 
iECou
;

1595 
BYTE
 
bKey
;

1598 
	`kInlizePam
(&
Li
,
pcPamBufr
);

1599 
iLgth
 = 
	`kGNextPam
(&
Li
,
vcFeName
);

1600 
vcFeName
[
iLgth
]='\0';

1601 if((
iLgth
>(
FILESYSTEM_MAXFILENAMELENGTH
-1))||(iLength==0))

1603 
	`kPrtf
("Too Long or Too Short File Name\n");

1608 

 = 
	`fݒ
(
vcFeName
,"w");

1609 if(

==
NULL
)

1611 
	`kPrtf
("%FOFa\n",
vcFeName
);

1616 
iECou
=0;

1619 
bKey
 = 
	`kGCh
();

1621 if(
bKey
==
KEY_ENTER
)

1623 
iECou
++;

1624 if(
iECou
>=3)

1632 
iECou
=0;

1635 
	`kPrtf
("%c",
bKey
);

1636 if(
	`fwre
(&
bKey
,1,1,

)!=1)

1638 
	`kPrtf
("File Write Fail\n");

1643 
	`kPrtf
("File Create Success\n");

1644 
	`fo
(

);

1645 
	}
}

1648 
	$kRdDaFromFe
(cڡ * 
pcPamBufr
)

1650 
PARAMETERLIST
 
Li
;

1651 
vcFeName
[50];

1652 
iLgth
;

1653 
FILE
* 

;

1654 
iECou
;

1655 
BYTE
 
bKey
;

1658 
	`kInlizePam
(&
Li
,
pcPamBufr
);

1659 
iLgth
 = 
	`kGNextPam
(&
Li
,
vcFeName
);

1660 
vcFeName
[
iLgth
]='\0';

1661 if((
iLgth
>(
FILESYSTEM_MAXFILENAMELENGTH
-1))||(iLength==0))

1663 
	`kPrtf
("Too Long or Too Short File Name\n");

1668 

 = 
	`fݒ
(
vcFeName
,"r");

1669 if(

==
NULL
)

1671 
	`kPrtf
("%FOFa\n",
vcFeName
);

1676 
iECou
=0;

1680 if(
	`d
(&
bKey
,1,1,

)!=1)

1685 
	`kPrtf
("%c",
bKey
);

1688 if(
bKey
==
KEY_ENTER
)

1690 
iECou
++;

1692 if((
iECou
!=0)&&((iEnterCount%20)==0))

1694 
	`kPrtf
("Pressny keto continue... ('q' isxit) :");

1695 if(
	`kGCh
()=='q')

1697 
	`kPrtf
("\n");

1700 
	`kPrtf
("\n");

1701 
iECou
=0;

1706 
	`fo
(

);

1707 
	}
}

1710 
	$kTeFeIO
(cڡ * 
pcPamBufr
)

1712 
FILE
* 
pFe
;

1713 
BYTE
* 
pbBufr
;

1714 
i
;

1715 
j
;

1716 
DWORD
 
dwRdomOfft
;

1717 
DWORD
 
dwByCou
;

1718 
BYTE
 
vbTempBufr
[1024];

1719 
DWORD
 
dwMaxFeSize
;

1721 
	`kPrtf
("============================== File I/O Function Test ===============================\n");

1724 
dwMaxFeSize
 = 4*1024*1024;

1725 
pbBufr
 = 
	`kAoMemy
(
dwMaxFeSize
);

1726 if(
pbBufr
==
NULL
)

1728 
	`kPrtf
("Memory Allocation Fail\n");

1733 
	`move
("testfileio.bin");

1738 
	`kPrtf
("1. File Open Fail Test...");

1740 
pFe
 = 
	`fݒ
("testfileio.bin","r");

1741 if(
pFe
==
NULL
)

1743 
	`kPrtf
("[Pass]\n");

1747 
	`kPrtf
("[Fail]\n");

1748 
	`fo
(
pFe
);

1754 
	`kPrtf
("2. File Create Test...");

1756 
pFe
 = 
	`fݒ
("testfileio.bin","w");

1757 if(
pFe
!=
NULL
)

1759 
	`kPrtf
("[Pass]\n");

1760 
	`kPrtf
(" FHd [0x%Q]\n",
pFe
);

1764 
	`kPrtf
("[Fail]\n");

1770 
	`kPrtf
("3. Sequential Write Test(Cluster Size)...");

1772 
i
=0;i<100;i++)

1774 
	`kMemS
(
pbBufr
,
i
,
FILESYSTEM_CLUSTERSIZE
);

1775 if(
	`fwre
(
pbBufr
,1,
FILESYSTEM_CLUSTERSIZE
,
pFe
)!=FILESYSTEM_CLUSTERSIZE)

1777 
	`kPrtf
("[Fail]\n");

1778 
	`kPrtf
(" %d Clu E\n",
i
);

1784 if(
i
>=100)

1786 
	`kPrtf
("[Pass]\n");

1792 
	`kPrtf
("4. Sequential Read And Verify Test(Cluster Size)...");

1794 
	`fek
(
pFe
,-100*
FILESYSTEM_CLUSTERSIZE
,
SEEK_END
);

1797 
i
=0;i<100;i++)

1800 if(
	`d
(
pbBufr
,1,
FILESYSTEM_CLUSTERSIZE
,
pFe
)!=FILESYSTEM_CLUSTERSIZE)

1802 
	`kPrtf
("[Fail]\n");

1807 
j
=0;j<
FILESYSTEM_CLUSTERSIZE
;j++)

1809 if(
pbBufr
[
j
]!=(
BYTE
)
i
)

1811 
	`kPrtf
("[Fail]\n");

1812 
	`kPrtf
(" %d Clu E. [%X] ![%X]\n",
i
,
pbBufr
[
j
],(
BYTE
)i);

1818 if(
i
>=100)

1820 
	`kPrtf
("[Pass]\n");

1826 
	`kPrtf
("5. Random Write Test...\n");

1829 
	`kMemS
(
pbBufr
,0,
dwMaxFeSize
);

1832 
	`fek
(
pFe
,-100*
FILESYSTEM_CLUSTERSIZE
,
SEEK_CUR
);

1833 
	`d
(
pbBufr
,1,
dwMaxFeSize
,
pFe
);

1836 
i
=0;i<100;i++)

1838 
dwByCou
 = (
	`kRdom
()%((
vbTempBufr
)-1))+1;

1839 
dwRdomOfft
 = 
	`kRdom
()%(
dwMaxFeSize
-
dwByCou
);

1841 
	`kPrtf
(" [%d] Off[%d] By [%d]...",
i
,
dwRdomOfft
,
dwByCou
);

1844 
	`fek
(
pFe
,
dwRdomOfft
,
SEEK_SET
);

1845 
	`kMemS
(
vbTempBufr
,
i
,
dwByCou
);

1848 if(
	`fwre
(
vbTempBufr
,1,
dwByCou
,
pFe
)!=dwByteCount)

1850 
	`kPrtf
("[Fail]\n");

1855 
	`kPrtf
("[Pass]\n");

1858 
	`kMemS
(
pbBufr
+
dwRdomOfft
,
i
,
dwByCou
);

1862 
	`fek
(
pFe
,
dwMaxFeSize
-1,
SEEK_SET
);

1863 
	`fwre
(&
i
,1,1,
pFe
);

1864 
pbBufr
[
dwMaxFeSize
-1]=(
BYTE
)
i
;

1870 
	`kPrtf
("6. Random Read And Verify Test...\n");

1872 
i
=0;i<100;i++)

1874 
dwByCou
 = (
	`kRdom
()%((
vbTempBufr
)-1))+1;

1875 
dwRdomOfft
 = 
	`kRdom
()%((
dwMaxFeSize
)-
dwByCou
);

1877 
	`kPrtf
(" [%d] Off[%d] By [%d]...",
i
,
dwRdomOfft
,
dwByCou
);

1880 
	`fek
(
pFe
,
dwRdomOfft
,
SEEK_SET
);

1883 if(
	`d
(
vbTempBufr
,1,
dwByCou
,
pFe
)!=dwByteCount)

1885 
	`kPrtf
("[Fail]\n");

1886 
	`kPrtf
(" Rd Fa\n",
dwRdomOfft
);

1891 if(
	`kMemCmp
(
pbBufr
+
dwRdomOfft
,
vbTempBufr
,
dwByCou
)!=0)

1893 
	`kPrtf
("[Fail]\n");

1894 
	`kPrtf
(" Com Fa\n",
dwRdomOfft
);

1898 
	`kPrtf
("[Pass]\n");

1904 
	`kPrtf
("7. Sequential Write, Read And Verify Test(1024 Byte)...\n");

1906 
	`fek
(
pFe
,-
dwMaxFeSize
,
SEEK_CUR
);

1909 
i
=0;i<(2*1024*1024/1024);i++)

1911 
	`kPrtf
(" [%d] Off[%d] By [%d] Wre...",
i
,i*1024,1024);

1914 if(
	`fwre
(
pbBufr
+(
i
*1024),1,1024,
pFe
)!=1024)

1916 
	`kPrtf
("[Fail]\n");

1921 
	`kPrtf
("[Pass]\n");

1926 
	`fek
(
pFe
,-
dwMaxFeSize
,
SEEK_SET
);

1930 
i
=0;i<(
dwMaxFeSize
/1024);i++)

1933 
	`kPrtf
(" [%d] Off[%d] By [%d] Rd And Vify...",
i
,i*1024,1024);

1936 if(
	`d
(
vbTempBufr
,1,1024,
pFe
)!=1024)

1938 
	`kPrtf
("[Fail]\n");

1942 if(
	`kMemCmp
(
pbBufr
+(
i
*1024),
vbTempBufr
,1024)!=0)

1944 
	`kPrtf
("[Fail]\n");

1949 
	`kPrtf
("[Pass]\n");

1956 
	`kPrtf
("8. File Delete Fail Test...");

1958 if(
	`move
("testfileio.bin")!=0)

1960 
	`kPrtf
("[Pass]\n");

1964 
	`kPrtf
("[Fail]\n");

1970 
	`kPrtf
("9. File Close Test...");

1972 if(
	`fo
(
pFe
)==0)

1974 
	`kPrtf
("[Pass]\n");

1978 
	`kPrtf
("[Fail]\n");

1984 
	`kPrtf
("10. File Delete Test...");

1986 if(
	`move
("testfileio.bin")==0)

1988 
	`kPrtf
("[Pass]\n");

1992 
	`kPrtf
("[Fail[\n");

1996 
	`kFeMemy
(
pbBufr
);

1997 
	}
}

2000 
	$kFlushCache
(cڡ * 
pcPamBufr
)

2002 
QWORD
 
qwTickCou
;

2004 
qwTickCou
 = 
	`kGTickCou
();

2005 
	`kPrtf
("Cache Flush...");

2006 if(
	`kFlushFeSyemCache
()==
TRUE
)

2008 
	`kPrtf
("pass\n");

2012 
	`kPrtf
("Fail\n");

2014 
	`kPrtf
("Tٮ Tim%d ms\n",
kGTickCou
-
qwTickCou
);

2015 
	}
}

2018 
	$kDowdFe
(cڡ * 
pcPamBufr
)

2020 
PARAMETERLIST
 
Li
;

2021 
vcFeName
[50];

2022 
iFeNameLgth
;

2023 
DWORD
 
dwDaLgth
;

2024 
FILE
* 

;

2025 
DWORD
 
dwReivedSize
;

2026 
DWORD
 
dwTempSize
;

2027 
BYTE
 
vbDaBufr
[
SERIAL_FIFOMAXSIZE
];

2028 
QWORD
 
qwLaReivedTickCou
;

2031 
	`kInlizePam
(&
Li
,
pcPamBufr
);

2032 
iFeNameLgth
 = 
	`kGNextPam
(&
Li
,
vcFeName
);

2033 
vcFeName
[
iFeNameLgth
]='\0';

2034 if((
iFeNameLgth
>(
FILESYSTEM_MAXFILENAMELENGTH
-1))||(iFileNameLength==0))

2036 
	`kPrtf
("Too Long or Too Short File Name\n");

2037 
	`kPrtf
("ex)download.txt\n");

2042 
	`kCˬSlFIFO
();

2047 
	`kPrtf
("Waiting For Data Length.....");

2048 
dwReivedSize
=0;

2049 
qwLaReivedTickCou
 = 
	`kGTickCou
();

2051 
dwReivedSize
<4)

2054 
dwTempSize
 = 
	`kReiveSlDa
(((
BYTE
*)&
dwDaLgth
)+
dwReivedSize
,4-dwReceivedSize);

2055 
dwReivedSize
 +
dwTempSize
;

2058 if(
dwTempSize
==0)

2060 
	`kS˕
(0);

2063 if((
	`kGTickCou
()-
qwLaReivedTickCou
)>30000)

2065 
	`kPrtf
("Time Out Occur~!!\n");

2071 
qwLaReivedTickCou
 = 
	`kGTickCou
();

2076 
	`kPrtf
("[%d] By\n",
dwDaLgth
);

2079 
	`kSdSlDa
("A",1);

2085 

 = 
	`fݒ
(
vcFeName
,"w");

2086 if(

==
NULL
)

2088 
	`kPrtf
("%FOFa\n",
vcFeName
);

2093 
	`kPrtf
("Data Receive Start: ");

2094 
dwReivedSize
=0;

2095 
qwLaReivedTickCou
 = 
	`kGTickCou
();

2096 
dwReivedSize
!=
dwDaLgth
)

2099 
dwTempSize
 = 
	`kReiveSlDa
(
vbDaBufr
,
SERIAL_FIFOMAXSIZE
);

2100 
dwReivedSize
+=
dwTempSize
;

2103 if(
dwTempSize
!=0)

2107 if(((
dwReivedSize
%
SERIAL_FIFOMAXSIZE
)==0)||((dwReivedSize==
dwDaLgth
)))

2109 
	`kSdSlDa
("A",1);

2110 
	`kPrtf
("#");

2114 if(
	`fwre
(
vbDaBufr
,1,
dwTempSize
,

)!=dwTempSize)

2116 
	`kPrtf
("File Write Error Occur\n");

2121 
qwLaReivedTickCou
 = 
	`kGTickCou
();

2126 
	`kS˕
(0);

2129 if((
	`kGTickCou
()-
qwLaReivedTickCou
)>10000)

2131 
	`kPrtf
("Time Out Occur~!!\n");

2143 if(
dwReivedSize
!=
dwDaLgth
)

2145 
	`kPrtf
("\E Occur. Tٮ Siz[%d] Reived Siz[%d]\n",
dwReivedSize
,
dwDaLgth
);

2149 
	`kPrtf
("\ReivCome. Tٮ Siz[%d] By\n",
dwReivedSize
);

2153 
	`fo
(

);

2154 
	`kFlushFeSyemCache
();

2155 
	}
}

2158 
	$kShowMPCfigutiTab
(cڡ * 
pcPamBufr
)

2160 
	`kPrtMPCfigutiTab
();

2161 
	}
}

2164 
	$kSAlitiPross
(cڡ * 
pcPamBufr
)

2167 if(
	`kSUpAlitiPross
()==
FALSE
)

2169 
	`kPrtf
("Application Processor Start Fail\n");

2173 
	`kPrtf
("Applicaton Processor Start Success\n");

2176 
	`kPrtf
("Bo١Pross[APIC ID: %d] S Aliti Pross\n",
	`kGAPICID
());

2177 
	}
}

	@/home/jk/os/MINT64/02.Kernel64/Source/ConsoleShell.h

1 #ide
__CONSOLESHELL_H__


2 
	#__CONSOLESHELL_H__


	)

4 
	~"Tys.h
"

7 
	#CONSOLESHELL_MAXCOMMANDBUFFERCOUNT
 300

	)

8 
	#CONSOLESHELL_PROMPRTMESSAGE
 "jk64>"

	)

11 (*
	tCommdFuni
)(cڡ * 
	tpcPam
);

15 #agm
	`ck
(
push
,1)

18 
	skShlCommdEryru


21 * 
pcCommd
;

23 * 
pcHp
;

25 
CommdFuni
 
pfFuni
;

26 } 
	tSHELLCOMMANDENTRY
;

29 
	skPamLiSu


32 cڡ * 
pcBufr
;

34 
iLgth
;

36 
iCutPosi
;

37 } 
	tPARAMETERLIST
;

39 #agm
	`ck
(
p
)

43 
	`kSCseShl
();

44 
	`kExecuCommd
(cڡ * 
pcCommdBufr
);

45 
	`kInlizePam
(
PARAMETERLIST
* 
pLi
,cڡ * 
pcPam
);

46 
	`kGNextPam
(
PARAMETERLIST
* 
pLi
,* 
pcPam
);

	@/home/jk/os/MINT64/02.Kernel64/Source/Descriptor.c

1 
	~"Dest.h
"

2 
	~"Uty.h
"

3 
	~"ISR.h
"

4 
	~"MuiPross.h
"

11 
	$kInlizeGDTTabAndTSS
 ()

13 
GDTR
* 
pGDTR
;

14 
GDTENTRY8
* 
pEry
;

15 
TSSSEGMENT
* 
pTSS
;

16 
i
;

19 
pGDTR
 = (
GDTR
*)
GDTR_STARTADDRESS
;

20 
pEry
 = (
GDTENTRY8
*)(
GDTR_STARTADDRESS
+(
GDTR
));

21 
pGDTR
->
wLim
 = 
GDT_TABLESIZE
-1;

22 
pGDTR
->
qwBaAddss
 = (
QWORD
)
pEry
;

25 
pTSS
 = (
TSSSEGMENT
*)((
QWORD
)
pEry
+
GDT_TABLESIZE
);

28 
	`kSGDTEry8
(&(
pEry
[0]),0,0,0,0,0);

29 
	`kSGDTEry8
(&(
pEry
[1]),0,0xFFFFF,
GDT_FLAGS_UPPER_CODE
,
GDT_FLAGS_LOWER_KERNELCODE
,
GDT_TYPE_CODE
);

30 
	`kSGDTEry8
(&(
pEry
[2]),0,0xFFFFF,
GDT_FLAGS_UPPER_DATA
,
GDT_FLAGS_LOWER_KERNELDATA
,
GDT_TYPE_DATA
);

33 
i
=0;i<
MAXPROCESSORCOUNT
;i++)

37 
	`kSGDTEry16
((
GDTENTRY16
*)&(
pEry
[
GDT_MAXENTRY8COUNT
+(
i
*2)]),(
QWORD
)
pTSS
+(i*(
TSSSEGMENT
)),(TSSSEGMENT)-1,
GDT_FLAGS_UPPER_TSS
,
GDT_FLAGS_LOWER_TSS
,
GDT_TYPE_TSS
);

42 
	`kInlizeTSSSegmt
(
pTSS
);

43 
	}
}

47 
	$kSGDTEry8
(
GDTENTRY8
* 
pEry
,
DWORD
 
dwBaAddss
,DWORD 
dwLim
,
BYTE
 
bUFgs
,BYTE 
bLowFgs
,BYTE 
bTy
)

49 
pEry
->
wLowLim
=
dwLim
&0xFFFF;

50 
pEry
->
wLowBaAddss
 = 
dwBaAddss
&0xFFFF;

51 
pEry
->
bUBaAddss1
 = (
dwBaAddss
>>16)&0xFF;

52 
pEry
->
bTyAndLowFg
 = 
bLowFgs
 | 
bTy
;

53 
pEry
->
bULimAndUFg
 = ((
dwLim
>>16)&0xFF)|
bUFgs
;

54 
pEry
->
bUBaAddss2
 = (
dwBaAddss
>>24)&0xFF;

55 
	}
}

59 
	$kSGDTEry16
(
GDTENTRY16
* 
pEry
,
QWORD
 
qwBaAddss
,
DWORD
 
dwLim
,
BYTE
 
bUFgs
,BYTE 
bLowFgs
,BYTE 
bTy
)

61 
pEry
->
wLowLim
 = 
dwLim
&0xFFFF;

62 
pEry
->
wLowBaAddss
 = 
qwBaAddss
&0xFFFF;

63 
pEry
->
bMiddBaAddss1
 = (
qwBaAddss
>>16)&0xFF;

64 
pEry
->
bTyAndLowFg
 = 
bLowFgs
 | 
bTy
;

65 
pEry
->
bULimAndUFg
 = ((
dwLim
>>16)&&0xFF)|
bUFgs
;

66 
pEry
->
bMiddBaAddss2
 = (
qwBaAddss
>>24)&0xFF;

67 
pEry
->
dwUBaAddss
 = 
qwBaAddss
 >> 32;

68 
pEry
->
dwRerved
=0;

69 
	}
}

72 
	$kInlizeTSSSegmt
(
TSSSEGMENT
* 
pTSS
)

74 
i
;

77 
i
=0;i<
MAXPROCESSORCOUNT
;i++)

80 
	`kMemS
(
pTSS
,0,(
TSSSEGMENT
));

83 
pTSS
->
qwIST
[0] = 
IST_STARTADDRESS
 + 
IST_SIZE
 - (IST_SIZE/
MAXPROCESSORCOUNT
*
i
);

87 
pTSS
->
wIOMBaAddss
 = 0xFFFF;

90 
pTSS
++;

93 
	}
}

100 
	$kInlizeIDTTabs
()

102 
IDTR
* 
pIDTR
;

103 
IDTENTRY
* 
pEry
;

104 
i
;

107 
pIDTR
 = (
IDTR
*)
IDTR_STARTADDRESS
;

109 
pEry
 = (
IDTENTRY
*)(
IDTR_STARTADDRESS
+(
IDTR
));

110 
pIDTR
->
qwBaAddss
 = (
QWORD
)
pEry
;

111 
pIDTR
->
wLim
 = 
IDT_TABLESIZE
-1;

116 
	`kSIDTEry
&
pEry
[ 0 ] ), 
kISRDivideE
, 0x08, 
IDT_FLAGS_IST1
,

117 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

118 
	`kSIDTEry
&
pEry
[ 1 ] ), 
kISRDebug
, 0x08, 
IDT_FLAGS_IST1
,

119 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

120 
	`kSIDTEry
&
pEry
[ 2 ] ), 
kISRNMI
, 0x08, 
IDT_FLAGS_IST1
,

121 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

122 
	`kSIDTEry
&
pEry
[ 3 ] ), 
kISRBakPot
, 0x08, 
IDT_FLAGS_IST1
,

123 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

124 
	`kSIDTEry
&
pEry
[ 4 ] ), 
kISROvow
, 0x08, 
IDT_FLAGS_IST1
,

125 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

126 
	`kSIDTEry
&
pEry
[ 5 ] ), 
kISRBoundRgeExeded
, 0x08, 
IDT_FLAGS_IST1
,

127 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

128 
	`kSIDTEry
&
pEry
[ 6 ] ), 
kISRInvidOpcode
, 0x08, 
IDT_FLAGS_IST1
,

129 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

130 
	`kSIDTEry
&
pEry
[ 7 ] ), 
kISRDeviNAvaab
, 0x08, 
IDT_FLAGS_IST1
,

131 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

132 
	`kSIDTEry
&
pEry
[ 8 ] ), 
kISRDoubFau
, 0x08, 
IDT_FLAGS_IST1
,

133 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

134 
	`kSIDTEry
&
pEry
[ 9 ] ), 
kISRCrossSegmtOvrun
, 0x08, 
IDT_FLAGS_IST1
,

135 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

136 
	`kSIDTEry
&
pEry
[ 10 ] ), 
kISRInvidTSS
, 0x08, 
IDT_FLAGS_IST1
,

137 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

138 
	`kSIDTEry
&
pEry
[ 11 ] ), 
kISRSegmtNP
, 0x08, 
IDT_FLAGS_IST1
,

139 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

140 
	`kSIDTEry
&
pEry
[ 12 ] ), 
kISRSckSegmtFau
, 0x08, 
IDT_FLAGS_IST1
,

141 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

142 
	`kSIDTEry
&
pEry
[ 13 ] ), 
kISRGPrei
, 0x08, 
IDT_FLAGS_IST1
,

143 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

144 
	`kSIDTEry
&
pEry
[ 14 ] ), 
kISRPageFau
, 0x08, 
IDT_FLAGS_IST1
,

145 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

146 
	`kSIDTEry
&
pEry
[ 15 ] ), 
kISR15
, 0x08, 
IDT_FLAGS_IST1
,

147 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

148 
	`kSIDTEry
&
pEry
[ 16 ] ), 
kISRFPUE
, 0x08, 
IDT_FLAGS_IST1
,

149 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

150 
	`kSIDTEry
&
pEry
[ 17 ] ), 
kISRAlignmtCheck
, 0x08, 
IDT_FLAGS_IST1
,

151 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

152 
	`kSIDTEry
&
pEry
[ 18 ] ), 
kISRMacheCheck
, 0x08, 
IDT_FLAGS_IST1
,

153 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

154 
	`kSIDTEry
&
pEry
[ 19 ] ), 
kISRSIMDE
, 0x08, 
IDT_FLAGS_IST1
,

155 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

156 
	`kSIDTEry
&
pEry
[ 20 ] ), 
kISRETCExi
, 0x08, 
IDT_FLAGS_IST1
,

157 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

159  
i
 = 21 ; i < 32 ; i++ )

161 
	`kSIDTEry
&
pEry
[ 
i
 ] ), 
kISRETCExi
, 0x08, 
IDT_FLAGS_IST1
,

162 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

167 
	`kSIDTEry
&
pEry
[ 32 ] ), 
kISRTim
, 0x08, 
IDT_FLAGS_IST1
,

168 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

169 
	`kSIDTEry
&
pEry
[ 33 ] ), 
kISRKeybrd
, 0x08, 
IDT_FLAGS_IST1
,

170 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

171 
	`kSIDTEry
&
pEry
[ 34 ] ), 
kISRSvePIC
, 0x08, 
IDT_FLAGS_IST1
,

172 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

173 
	`kSIDTEry
&
pEry
[ 35 ] ), 
kISRSl2
, 0x08, 
IDT_FLAGS_IST1
,

174 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

175 
	`kSIDTEry
&
pEry
[ 36 ] ), 
kISRSl1
, 0x08, 
IDT_FLAGS_IST1
,

176 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

177 
	`kSIDTEry
&
pEry
[ 37 ] ), 
kISRPl2
, 0x08, 
IDT_FLAGS_IST1
,

178 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

179 
	`kSIDTEry
&
pEry
[ 38 ] ), 
kISRFlpy
, 0x08, 
IDT_FLAGS_IST1
,

180 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

181 
	`kSIDTEry
&
pEry
[ 39 ] ), 
kISRPl1
, 0x08, 
IDT_FLAGS_IST1
,

182 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

183 
	`kSIDTEry
&
pEry
[ 40 ] ), 
kISRRTC
, 0x08, 
IDT_FLAGS_IST1
,

184 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

185 
	`kSIDTEry
&
pEry
[ 41 ] ), 
kISRRerved
, 0x08, 
IDT_FLAGS_IST1
,

186 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

187 
	`kSIDTEry
&
pEry
[ 42 ] ), 
kISRNUd1
, 0x08, 
IDT_FLAGS_IST1
,

188 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

189 
	`kSIDTEry
&
pEry
[ 43 ] ), 
kISRNUd2
, 0x08, 
IDT_FLAGS_IST1
,

190 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

191 
	`kSIDTEry
&
pEry
[ 44 ] ), 
kISRMou
, 0x08, 
IDT_FLAGS_IST1
,

192 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

193 
	`kSIDTEry
&
pEry
[ 45 ] ), 
kISRCross
, 0x08, 
IDT_FLAGS_IST1
,

194 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

195 
	`kSIDTEry
&
pEry
[ 46 ] ), 
kISRHDD1
, 0x08, 
IDT_FLAGS_IST1
,

196 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

197 
	`kSIDTEry
&
pEry
[ 47 ] ), 
kISRHDD2
, 0x08, 
IDT_FLAGS_IST1
,

198 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

200  
i
 = 48 ; i < 
IDT_MAXENTRYCOUNT
 ; i++ )

202 
	`kSIDTEry
&
pEry
[ 
i
 ] ), 
kISRETCIru
, 0x08, 
IDT_FLAGS_IST1
,

203 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

206 
	}
}

209 
	$kSIDTEry
(
IDTENTRY
* 
pEry
,* 
pvHdr
,
WORD
 
wSe
,
BYTE
 
bIST
,BYTE 
bFgs
,BYTE 
bTy
)

211 
pEry
->
wLowBaAddss
 = (
QWORD
)
pvHdr
&0xFFFF;

212 
pEry
->
wSegmtSe
 = 
wSe
;

213 
pEry
->
bIST
 = bIST&0x3;

214 
pEry
->
bTyAndFgs
 = 
bTy
|
bFgs
;

215 
pEry
->
wMiddBaAddss
=((
QWORD
)
pvHdr
>>16)&0xFFFF;

216 
pEry
->
dwUBaAddss
=(
QWORD
)
pvHdr
>>32;

217 
pEry
->
dwRerved
=0;

218 
	}
}

	@/home/jk/os/MINT64/02.Kernel64/Source/Descriptor.h

1 #ide
__DESCRIPTOR_H__


2 
	#__DESCRIPTOR_H__


	)

4 
	~"Tys.h
"

5 
	~"MuiPross.h
"

12 
	#GDT_TYPE_CODE
 0x0A

	)

13 
	#GDT_TYPE_DATA
 0x02

	)

14 
	#GDT_TYPE_TSS
 0x09

	)

15 
	#GDT_FLAGS_LOWER_S
 0x10

	)

16 
	#GDT_FLAGS_LOWER_DPL0
 0x00

	)

17 
	#GDT_FLAGS_LOWER_DPL1
 0x20

	)

18 
	#GDT_FLAGS_LOWER_DPL2
 0x40

	)

19 
	#GDT_FLAGS_LOWER_DPL3
 0x60

	)

20 
	#GDT_FLAGS_LOWER_P
 0x80

	)

21 
	#GDT_FLAGS_UPPER_L
 0x20

	)

22 
	#GDT_FLAGS_UPPER_DB
 0x40

	)

23 
	#GDT_FLAGS_UPPER_G
 0x80

	)

27 
	#GDT_FLAGS_LOWER_KERNELCODE
 (
GDT_TYPE_CODE
 | 
GDT_FLAGS_LOWER_S
 | 
GDT_FLAGS_LOWER_DPL0
 | 
GDT_FLAGS_LOWER_P
)

	)

28 
	#GDT_FLAGS_LOWER_KERNELDATA
 (
GDT_TYPE_DATA
 | 
GDT_FLAGS_LOWER_S
 | 
GDT_FLAGS_LOWER_DPL0
 | 
GDT_FLAGS_LOWER_P
)

	)

29 
	#GDT_FLAGS_LOWER_TSS
 (
GDT_FLAGS_LOWER_DPL0
 | 
GDT_FLAGS_LOWER_P
)

	)

30 
	#GDT_FLAGS_LOWER_USERCODE
 (
GDT_TYPE_CODE
 | 
GDT_FLAGS_LOWER_S
 | 
GDT_FLAGS_LOWER_DPL3
 | 
GDT_FLAGS_LOWER_P
)

	)

31 
	#GDT_FLAGS_LOWER_USERDATA
 (
GDT_TYPE_DATA
 | 
GDT_FLAGS_LOWER_S
 | 
GDT_FLAGS_LOWER_DPL3
 | 
GDT_FLAGS_LOWER_P
)

	)

34 
	#GDT_FLAGS_UPPER_CODE
 (
GDT_FLAGS_UPPER_G
 | 
GDT_FLAGS_UPPER_L
)

	)

35 
	#GDT_FLAGS_UPPER_DATA
 (
GDT_FLAGS_UPPER_G
 | 
GDT_FLAGS_UPPER_L
)

	)

36 
	#GDT_FLAGS_UPPER_TSS
 (
GDT_FLAGS_UPPER_G
)

	)

39 
	#GDT_KERNELCODESEGMENT
 0x08

	)

40 
	#GDT_KERNELDATASEGMENT
 0x10

	)

41 
	#GDT_TSSSEGMENT
 0x18

	)

45 
	#GDTR_STARTADDRESS
 0x142000

	)

47 
	#GDT_MAXENTRY8COUNT
 3

	)

49 
	#GDT_MAXENTRY16COUNT
 (
MAXPROCESSORCOUNT
)

	)

51 
	#GDT_TABLESIZE
 (((
GDTENTRY8
)*
GDT_MAXENTRY8COUNT
+ ((
GDTENTRY16
)*
GDT_MAXENTRY16COUNT
))

	)

52 
	#TSS_SEGMENTSIZE
 ((
TSSSEGMENT
)*
MAXPROCESSORCOUNT
)

	)

59 
	#IDT_TYPE_INTERRUPT
 0x0E

	)

60 
	#IDT_TYPE_TRAP
 0x0F

	)

61 
	#IDT_FLAGS_DPL0
 0x00

	)

62 
	#IDT_FLAGS_DPL1
 0x20

	)

63 
	#IDT_FLAGS_DPL2
 0x40

	)

64 
	#IDT_FLAGS_DPL3
 0x60

	)

65 
	#IDT_FLAGS_P
 0x80

	)

66 
	#IDT_FLAGS_IST0
 0

	)

67 
	#IDT_FLAGS_IST1
 1

	)

71 
	#IDT_FLAGS_KERNEL
 (
IDT_FLAGS_DPL0
 | 
IDT_FLAGS_P
)

	)

72 
	#IDT_FLAGS_USER
 (
IDT_FLAGS_DPL3
 | 
IDT_FLAGS_P
)

	)

76 
	#IDT_MAXENTRYCOUNT
 100

	)

78 
	#IDTR_STARTADDRESS
 (
GDTR_STARTADDRESS
+(
GDTR
)+
GDT_TABLESIZE
+
TSS_SEGMENTSIZE
)

	)

80 
	#IDT_STARTADDRESS
 (
IDTR_STARTADDRESS
+(
IDTR
))

	)

82 
	#IDT_TABLESIZE
 (
IDT_MAXENTRYCOUNT
*(
IDTENTRY
))

	)

86 
	#IST_STARTADDRESS
 0x700000

	)

88 
	#IST_SIZE
 0x100000

	)

92 #agm
ck
(
push
,1)

95 
	skGDTRSu


97 
WORD
 
	mwLim
;

98 
QWORD
 
	mqwBaAddss
;

100 
WORD
 
	mwPadg
;

101 
DWORD
 
	mdwPadg
;

102 } 
	tGDTR
,
	tIDTR
;

105 
	skGDTEry8Su


107 
WORD
 
	mwLowLim
;

108 
WORD
 
	mwLowBaAddss
;

109 
BYTE
 
	mbUBaAddss1
;

111 
BYTE
 
	mbTyAndLowFg
;

113 
BYTE
 
	mbULimAndUFg
;

114 
BYTE
 
	mbUBaAddss2
;

115 } 
	tGDTENTRY8
;

118 
	skGDTEry16ru


120 
WORD
 
	mwLowLim
;

121 
WORD
 
	mwLowBaAddss
;

122 
BYTE
 
	mbMiddBaAddss1
;

124 
BYTE
 
	mbTyAndLowFg
;

126 
BYTE
 
	mbULimAndUFg
;

127 
BYTE
 
	mbMiddBaAddss2
;

128 
DWORD
 
	mdwUBaAddss
;

129 
DWORD
 
	mdwRerved
;

130 } 
	tGDTENTRY16
;

133 
	skTSSDaSu


135 
DWORD
 
	mdwRerved1
;

136 
QWORD
 
	mqwR
[3];

137 
QWORD
 
	mqwRerved2
;

138 
QWORD
 
	mqwIST
[7];

139 
QWORD
 
	mqwRerved3
;

140 
WORD
 
	mwRerved
;

141 
WORD
 
	mwIOMBaAddss
;

142 } 
	tTSSSEGMENT
;

145 
	skIDTErySu


147 
WORD
 
	mwLowBaAddss
;

148 
WORD
 
	mwSegmtSe
;

150 
BYTE
 
	mbIST
;

152 
BYTE
 
	mbTyAndFgs
;

153 
WORD
 
	mwMiddBaAddss
;

154 
DWORD
 
	mdwUBaAddss
;

155 
DWORD
 
	mdwRerved
;

156 } 
	tIDTENTRY
;

158 #agm
ck
(
p
)

161 
kInlizeGDTTabAndTSS
 ();

162 
kSGDTEry8
 (
GDTENTRY8
* 
pEry
,
DWORD
 
dwBaAddss
,DWORD 
dwLim
,
BYTE
 
bUFgs
,BYTE 
bLowFgs
,BYTE 
bTy
);

163 
kSGDTEry16
 (
GDTENTRY16
* 
pEry
,
QWORD
 
qwBaAddss
,
DWORD
 
dwLim
,
BYTE
 
bUFgs
,BYTE 
bLowFgs
,BYTE 
bTy
);

164 
kInlizeTSSSegmt
 (
TSSSEGMENT
* 
pTSS
);

166 
kInlizeIDTTabs
 ();

167 
kSIDTEry
(
IDTENTRY
* 
pEry
,* 
pvHdr
,
WORD
 
wSe
,
BYTE
 
bIST
,BYTE 
bFgs
,BYTE 
bTy
);

168 
kDummyHdr
 ();

	@/home/jk/os/MINT64/02.Kernel64/Source/DynamicMemory.c

1 
	~"DymicMemy.h
"

2 
	~"Uty.h
"

3 
	~"Task.h
"

5 
DYNAMICMEMORY
 
	ggs_DymicMemy
;

8 
QWORD
 
kCcuϋDymicMemySize
();

9 
kCcuϋMaBlockCou
(
QWORD
 
qwDymicRAMSize
);

10 
kAotiBuddyBlock
(
QWORD
 
qwAligdSize
);

11 
QWORD
 
kGBuddyBlockSize
(QWORD 
qwSize
);

12 
kGBlockLiIndexOfMchSize
(
QWORD
 
qwAligdSize
);

13 
kFdFeBlockInBm
(
iBlockLiIndex
);

14 
kSFgInBm
(
iBlockLiIndex
,
iOfft
,
BYTE
 
bFg
);

15 
BOOL
 
kFeBuddyBlock
(
iBlockLiIndex
,
iBlockOfft
);

16 
BYTE
 
kGFgInBm
(
iBlockLiIndex
,
iOfft
);

23 
	$kInlizeDymicMemy
()

25 
QWORD
 
qwDymicMemySize
;

26 
i
,
j
;

27 
BYTE
* 
pbCutBmPosi
;

28 
iBlockCouOfLev
, 
iMaBlockCoou
;

32 
qwDymicMemySize
 = 
	`kCcuϋDymicMemySize
();

33 
iMaBlockCoou
 = 
	`kCcuϋMaBlockCou
(
qwDymicMemySize
);

37 
gs_DymicMemy
.
iBlockCouOfSmˡBlock
 = (
qwDymicMemySize
/
DYNAMICMEMORY_MIN_SIZE
)-
iMaBlockCoou
;

40 
i
=0;(
gs_DymicMemy
.
iBlockCouOfSmˡBlock
>>i)>0;i++)

44 
gs_DymicMemy
.
iMaxLevCou
=
i
;

47 
gs_DymicMemy
.
pbAodBlockLiIndex
 = (
BYTE
*)
DYNAMICMEMORY_START_ADDRESS
;

48 
i
=0;i<
gs_DymicMemy
.
iBlockCouOfSmˡBlock
;i++)

50 
gs_DymicMemy
.
pbAodBlockLiIndex
[
i
]=0xFF;

54 
gs_DymicMemy
.
pBmOfLev
 = (
BITMAP
*)(
DYNAMICMEMORY_START_ADDRESS
+((
BYTE
)*gs_DymicMemy.
iBlockCouOfSmˡBlock
));

56 
pbCutBmPosi
 = ((
BYTE
*)
gs_DymicMemy
.
pBmOfLev
)+((
BITMAP
)*gs_DymicMemy.
iMaxLevCou
);

60 
j
=0;j<
gs_DymicMemy
.
iMaxLevCou
;j++)

62 
gs_DymicMemy
.
pBmOfLev
[
j
].
pbBm
 = 
pbCutBmPosi
;

63 
gs_DymicMemy
.
pBmOfLev
[
j
].
qwExiBCou
 = 0;

64 
iBlockCouOfLev
 = 
gs_DymicMemy
.
iBlockCouOfSmˡBlock
>>
j
;

68 
i
=0;i<
iBlockCouOfLev
/8;i++)

70 *
pbCutBmPosi
 = 0x00;

71 
pbCutBmPosi
++;

75 if((
iBlockCouOfLev
%8)!=0)

77 *
pbCutBmPosi
=0x00;

80 
i
 = 
iBlockCouOfLev
%8;

81 if((
i
%2)==1)

83 *
pbCutBmPosi
 |=(
DYNAMICMEMORY_EXIST
<<(
i
-1));

84 
gs_DymicMemy
.
pBmOfLev
[
j
].
qwExiBCou
=1;

86 
pbCutBmPosi
++;

91 
gs_DymicMemy
.
qwSAddss
 = 
DYNAMICMEMORY_START_ADDRESS
+
iMaBlockCoou
*
DYNAMICMEMORY_MIN_SIZE
;

92 
gs_DymicMemy
.
qwEndAddss
 = 
	`kCcuϋDymicMemySize
()+
DYNAMICMEMORY_START_ADDRESS
;

93 
gs_DymicMemy
.
qwUdSize
=0;

94 
	}
}

97 
QWORD
 
	$kCcuϋDymicMemySize
()

99 
QWORD
 
qwRAMSize
;

102 
qwRAMSize
 = (
	`kGTٮRAMSize
()*1024*1024);

103 if(
qwRAMSize
>(
QWORD
)3*1024*1024*1024)

105 
qwRAMSize
 = (
QWORD
)3*1024*1024*1024;

108  
qwRAMSize
 - 
DYNAMICMEMORY_START_ADDRESS
;

109 
	}
}

113 
	$kCcuϋMaBlockCou
(
QWORD
 
qwDymicRAMSize
)

115 
lBlockCouOfSmˡBlock
;

116 
DWORD
 
dwSizeOfAodBlockLiIndex
;

117 
DWORD
 
dwSizeOfBm
;

118 
i
;

121 
lBlockCouOfSmˡBlock
 = 
qwDymicRAMSize
/
DYNAMICMEMORY_MIN_SIZE
;

123 
dwSizeOfAodBlockLiIndex
 = 
lBlockCouOfSmˡBlock
*(
BYTE
);

126 
dwSizeOfBm
=0;

127 
i
=0;(
lBlockCouOfSmˡBlock
>>i)>0;i++)

130 
dwSizeOfBm
 +=(
BITMAP
);

132 
dwSizeOfBm
 +=((
lBlockCouOfSmˡBlock
>>
i
)+7)/8;

136  (
dwSizeOfAodBlockLiIndex
+
dwSizeOfBm
+
DYNAMICMEMORY_MIN_SIZE
-1)/DYNAMICMEMORY_MIN_SIZE;

137 
	}
}

140 * 
	$kAoMemy
(
QWORD
 
qwSize
)

142 
QWORD
 
qwAligdSize
;

143 
QWORD
 
qwRiveAddss
;

144 
lOfft
;

145 
iSizeAayOfft
;

146 
iIndexOfBlockLi
;

149 
qwAligdSize
 = 
	`kGBuddyBlockSize
(
qwSize
);

150 if(
qwAligdSize
 == 0)

153  
NULL
;

157 if(
gs_DymicMemy
.
qwSAddss
+gs_DymicMemy.
qwUdSize
+
qwAligdSize
>gs_DymicMemy.
qwEndAddss
)

160  
NULL
;

164 
lOfft
 = 
	`kAotiBuddyBlock
(
qwAligdSize
);

165 if(
lOfft
==-1)

168  
NULL
;

171 
iIndexOfBlockLi
 = 
	`kGBlockLiIndexOfMchSize
(
qwAligdSize
);

175 
qwRiveAddss
 = 
qwAligdSize
*
lOfft
;

176 
iSizeAayOfft
 = 
qwRiveAddss
/
DYNAMICMEMORY_MIN_SIZE
;

177 
gs_DymicMemy
.
pbAodBlockLiIndex
[
iSizeAayOfft
] = (
BYTE
)
iIndexOfBlockLi
;

178 
gs_DymicMemy
.
qwUdSize
 +=
qwAligdSize
;

180  (*)(
qwRiveAddss
+
gs_DymicMemy
.
qwSAddss
);

181 
	}
}

184 
QWORD
 
	$kGBuddyBlockSize
(
QWORD
 
qwSize
)

186 
i
;

188 
i
=0;i<
gs_DymicMemy
.
iMaxLevCou
;i++)

190 if(
qwSize
<=(
DYNAMICMEMORY_MIN_SIZE
<<
i
))

192  (
DYNAMICMEMORY_MIN_SIZE
<<
i
);

197 
	}
}

201 
	$kAotiBuddyBlock
(
QWORD
 
qwAligdSize
)

203 
iBlockLiIndex
,
iFeOfft
;

204 
i
;

205 
BOOL
 
bPviousIruFg
;

208 
iBlockLiIndex
 = 
	`kGBlockLiIndexOfMchSize
(
qwAligdSize
);

209 if(
iBlockLiIndex
==-1)

216 
bPviousIruFg
 = 
	`kLockFSyemDa
();

219 
i
=
iBlockLiIndex
;i<
gs_DymicMemy
.
iMaxLevCou
;i++)

222 
iFeOfft
 = 
	`kFdFeBlockInBm
(
i
);

223 if(
iFeOfft
!=-1)

230 if(
iFeOfft
==-1)

233 
	`kUockFSyemDa
(
bPviousIruFg
);

238 
	`kSFgInBm
(
i
,
iFeOfft
,
DYNAMICMEMORY_EMPTY
);

241 if(
i
>
iBlockLiIndex
)

245 
i
=i-1;i>=
iBlockLiIndex
;i--)

248 
	`kSFgInBm
(
i
,
iFeOfft
*2,
DYNAMICMEMORY_EMPTY
);

250 
	`kSFgInBm
(
i
,
iFeOfft
*2+1,
DYNAMICMEMORY_EXIST
);

252 
iFeOfft
 = iFreeOffset*2;

255 
	`kUockFSyemDa
(
bPviousIruFg
);

257  
iFeOfft
;

258 
	}
}

261 
	$kGBlockLiIndexOfMchSize
(
QWORD
 
qwAligdSize
)

263 
i
;

265 
i
=0;i<
gs_DymicMemy
.
iMaxLevCou
;i++)

267 if(
qwAligdSize
<=(
DYNAMICMEMORY_MIN_SIZE
<<
i
))

269  
i
;

273 
	}
}

276 
	$kFdFeBlockInBm
(
iBlockLiIndex
)

278 
i
,
iMaxCou
;

279 
BYTE
* 
pbBm
;

280 
QWORD
* 
pqwBm
;

283 if(
gs_DymicMemy
.
pBmOfLev
[
iBlockLiIndex
].
qwExiBCou
==0)

289 
iMaxCou
 = 
gs_DymicMemy
.
iBlockCouOfSmˡBlock
>>
iBlockLiIndex
;

290 
pbBm
 = 
gs_DymicMemy
.
pBmOfLev
[
iBlockLiIndex
].pbBitmap;

291 
i
=0;i<
iMaxCou
;)

294 if(((
iMaxCou
-
i
)/64)>0)

296 
pqwBm
 =(
QWORD
*)&(
pbBm
[
i
/8]);

298 if(*
pqwBm
==0)

300 
i
+=64;

305 if((
pbBm
[
i
/8]&(
DYNAMICMEMORY_EXIST
<<(i%8)))!=0)

307  
i
;

309 
i
++;

313 
	}
}

316 
	$kSFgInBm
(
iBlockLiIndex
,
iOfft
,
BYTE
 
bFg
)

318 
BYTE
* 
pbBm
;

319 
pbBm
 = 
gs_DymicMemy
.
pBmOfLev
[
iBlockLiIndex
].pbBitmap;

321 if(
bFg
==
DYNAMICMEMORY_EXIST
)

324 if((
pbBm
[
iOfft
/8]&(0x01<<(iOffset%8)))==0)

326 
gs_DymicMemy
.
pBmOfLev
[
iBlockLiIndex
].
qwExiBCou
++;

328 
pbBm
[
iOfft
/8]|=(0x01<<(iOffset%8));

333 if((
pbBm
[
iOfft
/8]&(0x01<<(iOffset%8)))!=0)

335 
gs_DymicMemy
.
pBmOfLev
[
iBlockLiIndex
].
qwExiBCou
--;

337 
pbBm
[
iOfft
/8]&=~(0x01<<(iOffset%8));

339 
	}
}

342 
BOOL
 
	$kFeMemy
(* 
pvAddss
)

344 
QWORD
 
qwRiveAddss
;

345 
iSizeAayOfft
;

346 
QWORD
 
qwBlockSize
;

347 
iBlockLiIndex
;

348 
iBmOfft
;

350 if(
pvAddss
==
NULL
)

352  
FALSE
;

356 
qwRiveAddss
 = ((
QWORD
)
pvAddss
)-
gs_DymicMemy
.
qwSAddss
;

357 
iSizeAayOfft
 = 
qwRiveAddss
/
DYNAMICMEMORY_MIN_SIZE
;

360 if(
gs_DymicMemy
.
pbAodBlockLiIndex
[
iSizeAayOfft
]==0xFF)

362  
FALSE
;

367 
iBlockLiIndex
 = ()
gs_DymicMemy
.
pbAodBlockLiIndex
[
iSizeAayOfft
];

368 
gs_DymicMemy
.
pbAodBlockLiIndex
[
iSizeAayOfft
]=0xFF;

370 
qwBlockSize
 = 
DYNAMICMEMORY_MIN_SIZE
<<
iBlockLiIndex
;

373 
iBmOfft
 = 
qwRiveAddss
/
qwBlockSize
;

374 if(
	`kFeBuddyBlock
(
iBlockLiIndex
,
iBmOfft
)==
TRUE
)

376 
gs_DymicMemy
.
qwUdSize
 -
qwBlockSize
;

377  
TRUE
;

380  
FALSE
;

381 
	}
}

384 
BOOL
 
	$kFeBuddyBlock
(
iBlockLiIndex
,
iBlockOfft
)

386 
iBuddyBlockOfft
;

387 
i
;

388 
BOOL
 
bFg
;

389 
BOOL
 
bPviousIruFg
;

392 
bPviousIruFg
 = 
	`kLockFSyemDa
();

395 
i
=
iBlockLiIndex
;i<
gs_DymicMemy
.
iMaxLevCou
;i++)

398 
	`kSFgInBm
(
i
,
iBlockOfft
,
DYNAMICMEMORY_EXIST
);

402 if((
iBlockOfft
%2)==0)

404 
iBuddyBlockOfft
 = 
iBlockOfft
+1;

408 
iBuddyBlockOfft
 = 
iBlockOfft
-1;

411 
bFg
 = 
	`kGFgInBm
(
i
,
iBuddyBlockOfft
);

414 if(
bFg
 =
DYNAMICMEMORY_EMPTY
)

421 
	`kSFgInBm
(
i
,
iBuddyBlockOfft
,
DYNAMICMEMORY_EMPTY
);

422 
	`kSFgInBm
(
i
,
iBlockOfft
,
DYNAMICMEMORY_EMPTY
);

425 
iBlockOfft
 = iBlockOffset/2;

428 
	`kUockFSyemDa
(
bPviousIruFg
);

429  
TRUE
;

430 
	}
}

433 
BYTE
 
	$kGFgInBm
(
iBlockLiIndex
,
iOfft
)

435 
BYTE
* 
pbBm
;

437 
pbBm
 = 
gs_DymicMemy
.
pBmOfLev
[
iBlockLiIndex
].pbBitmap;

438 if((
pbBm
[
iOfft
/8]&(0x01<<(iOffset%8)))!=0x00)

440  
DYNAMICMEMORY_EXIST
;

443  
DYNAMICMEMORY_EMPTY
;

444 
	}
}

447 
	$kGDymicMemyInfmi
(
QWORD
* 
pqwDymicMemySAddss
,QWORD* 
pqwDymicMemyTٮSize
,QWORD* 
pqwMaDaSize
,QWORD* 
pqwUdMemySize
)

449 *
pqwDymicMemySAddss
 = 
DYNAMICMEMORY_START_ADDRESS
;

450 *
pqwDymicMemyTٮSize
 = 
	`kCcuϋDymicMemySize
();

451 *
pqwMaDaSize
 = 
	`kCcuϋMaBlockCou
(*
pqwDymicMemyTٮSize
)*
DYNAMICMEMORY_MIN_SIZE
;

452 *
pqwUdMemySize
 = 
gs_DymicMemy
.
qwUdSize
;

453 
	}
}

456 
DYNAMICMEMORY
* 
	$kGDymicMemyMag
()

458  &
gs_DymicMemy
;

459 
	}
}

	@/home/jk/os/MINT64/02.Kernel64/Source/DynamicMemory.h

1 #ide
__DYNAMICMEMORY_H__


2 
	#__DYNAMICMEMORY_H__


	)

4 
	~"Tys.h
"

8 
	#DYNAMICMEMORY_START_ADDRESS
 ((
TASK_STACKPOOLADDRESS
+(
TASK_STACKSIZE
*
TASK_MAXCOUNT
)+0xfffff)&0xfffffffffff00000)

	)

12 
	#DYNAMICMEMORY_MIN_SIZE
 (1*1024)

	)

15 
	#DYNAMICMEMORY_EXIST
 0x01

	)

16 
	#DYNAMICMEMORY_EMPTY
 0x00

	)

20 
	skBmSu


22 
BYTE
* 
	mpbBm
;

23 
QWORD
 
	mqwExiBCou
;

24 } 
	tBITMAP
;

27 
	skDymicMemyMagSu


30 
	miMaxLevCou
;

31 
	miBlockCouOfSmˡBlock
;

32 
QWORD
 
	mqwUdSize
;

35 
QWORD
 
	mqwSAddss
;

36 
QWORD
 
	mqwEndAddss
;

39 
BYTE
* 
	mpbAodBlockLiIndex
;

40 
BITMAP
* 
	mpBmOfLev
;

41 } 
	tDYNAMICMEMORY
;

44 
kInlizeDymicMemy
();

45 * 
kAoMemy
(
QWORD
 
qwSize
);

46 
BOOL
 
kFeMemy
(* 
pvAddss
);

47 
kGDymicMemyInfmi
(
QWORD
* 
pqwDymicMemySAddss
,QWORD* 
pqwDymicMemyTٮSize
,QWORD* 
pqwMaDaSize
,QWORD* 
pqwUdMemySize
);

48 
DYNAMICMEMORY
* 
kGDymicMemyMag
();

	@/home/jk/os/MINT64/02.Kernel64/Source/EntryPoint.s

1 [
BITS
 64] ; 이하의 코드는 64비트 코드로 설정

3 
	gSECTION
 .
	gxt
 ; .text 섹션(세그먼트)을 정의

5 ; 외부에서 정의된 함수를 쓸 수 있도록 선언함(
	gimpt
)

6 
ma


7 ; 
APIC
 
	gID
 레지스터의 어드레스와 깨어난 코어의 개수

8 
g_qwAPICIDAddss
, 
g_iWakeUpAlitiProssCou


14 
	gSTART
:

15 
mov
 
ax
, 0x10 ; 
	gIA
-32모드 커널용 데이터 세그먼트 디스크립터를 
	gAX
 레지스터에 저장

16 
mov
 
	gds
, 
	gax
 ; 
	gDS
 세그먼트 셀렉터에 설정

17 
mov
 
	ges
, 
	gax
 ; 
	gES
 세그먼트 셀렉터에 설정

18 
mov
 
	gfs
, 
	gax
 ; 
	gFS
 세그먼트 셀렉터에 설정

19 
mov
 
	ggs
, 
	gax
 ; 
	gGS
 세그먼트 셀렉터에 설정

21 ; 스택을 0x600000 ~ 0x6FFFFFF 영역에 1
	gMB
 크기로 생성

22 
mov
 
	gss
, 
	gax
 ; ss 세그먼트 셀렉터에 설정

23 
mov
 
	gr
, 0x6FFFF8 ; 
	gRSP
 레지스터의 어드레스를 0x6FFFF8로 설정

24 
mov
 
	grbp
, 0x6FFFF8 ; 
	gRBP
 레지스터의 어드레스를 0x6FFFF8로 설정

26 ; 부트 로더 영역의 
Bo١p
 
	gPross
 플래그를 확인하여, Bootstrap Processor이면

27 ; 바로 
	gma
 함수로 이동

28 
cmp
 
	gby
[0x7C09],0x01

29 
	gje
 .
	gBOOTSTRAPPROCESSORSTARTPOINT


32 ; 
Aliti
 
	gPross
만 실행하는 영역

34 ; 스택의 꼭대기(
	gT
)는 
APIC
 
	gID
를 이용해서 0x700000 이하로 이동

35 ; 최대 16개의 코어까지 지원 가능하므로 스택 영역인 1
	gM
를 16으로 나눈 값인

36 ; 64
Kby
(0x10000)만큼식 아래로 이동하면서 설정

37 ; 로컬 
	gAPIC
의 
APIC
 
	gID
 레지스터에서 ID를 추출, ID는 
	gB
 24-31에 위치함

38 
mov
 
	gx
,0 ; 
	gRAX
 레지스터 초기화

39 
mov
 
	grbx
, 
	gqwd
[
g_qwAPICIDAddss
] ; 
APIC
 
	gID
 레지스터의 어드레스를 읽음

40 
mov
 
	gx
, 
	gdwd
[
rbx
] ; 
APIC
 
	gID
 레지스터에서 APIC ID를 읽음 (비트 24-31)

41 
shr
 
	gx
, 24 ; 비트 24-31에 존재하는 
APIC
 
	gID
를 시프트 시켜서 비트 0-7로 이동

43 ; 추출한 
APIC
 
	gID
에 64
Kby
(0x10000)을 곱하여 스택의 꼭대기에 이동시킬 거리를 계산

44 
mov
 
	grbx
, 0x10000 ; 
	gRBX
 레지스터에 스택의 크기(64
	gKby
)를 저장

45 
mul
 
	grbx
 ; 
	gRAX
 레지스터에 저장된 
APIC
 
	gID
와 
	gRBX
 레지스터의 스택 값을 곱함

47 
sub
 
	gr
, 
	gx
 ; 
	gRSP
와 
	gRBP
 레지스터에서 
	gRAX
 레지스터에 저장된 값(스택의 꼭대기를 이동시킬 거리)을

48 
sub
 
	grbp
, 
	gx
 ; 빼서 각 코어 별 스택을 할당해줌

50 ; 깨어난 
Aliti
 
	gPross
 수를 1 증가시킴, 
	glock
 명령어를 사용하여 변수에

51 ; 배타적(
	gexusive
) 접근이 가능하도록 함

52 
lock
 
c
 
	gdwd
 [
g_iWakeUpAlitiProssCou
]

55 ; 
Bo١p
 
	gPross
와 
Aliti
 Processor가 공통으로 실행하는 영역

57 .
	gBOOTSTRAPPROCESSORSTARTPOINT
:

58 

 
ma
 ; 
	gC
 언어 엔트리 포인트 함수(
	gma
) 호출

60 
jmp
 
	g$


	@/home/jk/os/MINT64/02.Kernel64/Source/FileSystem.c

1 
	~"FeSyem.h
"

2 
	~"HdDisk.h
"

3 
	~"DymicMemy.h
"

4 
	~"Task.h
"

5 
	~"Uty.h
"

6 
	~"CacheMag.h
"

7 
	~"RAMDisk.h
"

10 
FILESYSTEMMANAGER
 
	ggs_FeSyemMag
;

12 
BYTE
 
	ggs_vbTempBufr
[
FILESYSTEM_SECTORPERCLUSTER
*512];

15 
fRdHDDInfmi
 
	ggs_pfRdHDDInfmi
 = 
NULL
;

16 
fRdHDDSe
 
	ggs_pfRdHDDSe
 =
NULL
;

17 
fWreHDDSe
 
	ggs_pfWreHDDSe
 =
NULL
;

20 
BOOL
 
kRdCluLkTab
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
);

21 
BOOL
 
kWreCluLkTab
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
);

22 
BOOL
 
kRdClu
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
);

23 
BOOL
 
kWreClu
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
);

24 
DWORD
 
kFdFeClu
();

25 
BOOL
 
kSCluLkDa
(
DWORD
 
dwCluIndex
,DWORD 
dwDa
);

26 
BOOL
 
kGCluLkDa
(
DWORD
 
dwCluIndex
,DWORD* 
pdwDa
);

27 
kFdFeDeyEry
();

28 
BOOL
 
kSDeyEryDa
(
iIndex
,
DIRECTORYENTRY
* 
pEry
);

29 
BOOL
 
kGDeyEryDa
(
iIndex
,
DIRECTORYENTRY
* 
pEry
);

30 
kFdDeyEry
(cڡ * 
pcFeName
,
DIRECTORYENTRY
* 
pEry
);

33 * 
kAoFeDeyHd
();

34 
kFeFeDeyHd
(
FILE
* 
pFe
);

35 
BOOL
 
kCeFe
(cڡ * 
pcFeName
,
DIRECTORYENTRY
* 
pEry
,* 
piDeyEryIndex
);

36 
BOOL
 
kFeCluUtEnd
(
DWORD
 
dwCluIndex
);

37 
BOOL
 
kUpdeDeyEry
(
FILEHANDLE
* 
pFeHd
);

40 
BOOL
 
kIlRdCluLkTabWhoutCache
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
);

41 
BOOL
 
kIlRdCluLkTabWhCache
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
);

42 
BOOL
 
kIlWreCluLkTabWhoutCache
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
);

43 
BOOL
 
kIlWreCluLkTabWhCache
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
);

44 
BOOL
 
kIlRdCluWhoutCache
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
);

45 
BOOL
 
kIlRdCluWhCache
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
);

46 
BOOL
 
kIlWreCluWhoutCache
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
);

47 
BOOL
 
kIlWreCluWhCache
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
);

49 
CACHEBUFFER
* 
kAoCacheBufrWhFlush
(
iCacheTabIndex
);

52 
BOOL
 
	$kInlizeFeSyem
()

54 
BOOL
 
bCacheEb
 = 
FALSE
;

57 
	`kMemS
(&
gs_FeSyemMag
,0,(gs_stFileSystemManager));

58 
	`kInlizeMux
(&(
gs_FeSyemMag
.
Mux
));

72  if(
	`kInlizeRDD
(
RDD_TOTALSECTORCOUNT
)==
TRUE
)

75 
gs_pfRdHDDInfmi
 = 
kRdRDDInfmi
;

76 
gs_pfRdHDDSe
 = 
kRdRDDSe
;

77 
gs_pfWreHDDSe
 = 
kWreRDDSe
;

80 if(
	`kFm
(=
FALSE
)

82  
FALSE
;

87  
FALSE
;

91 if(
	`kMou
()==
FALSE
)

93  
FALSE
;

97 
gs_FeSyemMag
.
pHdPo
 = (
FILE
*
	`kAoMemy
(
FILESYSTEM_HANDLE_MAXCOUNT
*(FILE));

100 if(
gs_FeSyemMag
.
pHdPo
 =
NULL
)

102 
gs_FeSyemMag
.
bMoued
 = 
FALSE
;

103  
FALSE
;

107 
	`kMemS
(
gs_FeSyemMag
.
pHdPo
,0,
FILESYSTEM_HANDLE_MAXCOUNT
*(
FILE
));

109 if(
bCacheEb
==
TRUE
)

111 
gs_FeSyemMag
.
bCacheEb
=
	`kInlizeCacheMag
();

114  
TRUE
;

115 
	}
}

122 
BOOL
 
	$kMou
()

124 
MBR
* 
pMBR
;

127 
	`kLock
(&(
gs_FeSyemMag
.
Mux
));

130 if(
	`gs_pfRdHDDSe
(
TRUE
,TRUE,0,1,
gs_vbTempBufr
)==
FALSE
)

133 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

134  
FALSE
;

138 
pMBR
 = (
MBR
*)
gs_vbTempBufr
;

140 if(
pMBR
->
dwSigtu
 !
FILESYSTEM_SIGNATUR
)

143 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

144  
FALSE
;

148 
gs_FeSyemMag
.
bMoued
 = 
TRUE
;

151 
gs_FeSyemMag
.
dwRervedSeCou
 = 
pMBR
->dwReservedSectorCount;

152 
gs_FeSyemMag
.
dwCluLkAaSAddss
 = 
pMBR
->
dwRervedSeCou
+1;

153 
gs_FeSyemMag
.
dwCluLkAaSize
 = 
pMBR
->
dwCluLkSeCou
;

154 
gs_FeSyemMag
.
dwDaAaSAddss
 = 
pMBR
->
dwRervedSeCou
 +MBR->
dwCluLkSeCou
+1;

155 
gs_FeSyemMag
.
dwTٮCluCou
 = 
pMBR
->dwTotalClusterCount;

158 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

159  
TRUE
;

160 
	}
}

163 
BOOL
 
	$kFm
()

165 
HDDINFORMATION
* 
pHDD
;

166 
MBR
* 
pMBR
;

167 
DWORD
 
dwTٮSeCou
,
dwRemaSeCou
;

168 
DWORD
 
dwMaxCluCou
,
dwCluCou
;

169 
DWORD
 
dwCluLkSeCou
;

170 
DWORD
 
i
;

173 
	`kLock
(&(
gs_FeSyemMag
.
Mux
));

178 
pHDD
 = (
HDDINFORMATION
*)
gs_vbTempBufr
;

179 if(
	`gs_pfRdHDDInfmi
(
TRUE
,TRUE,
pHDD
)==
FALSE
)

182 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

183  
FALSE
;

186 
dwTٮSeCou
 = 
pHDD
->
dwTٮSes
;

189 
dwMaxCluCou
 = 
dwTٮSeCou
 / 
FILESYSTEM_SECTORPERCLUSTER
;

194 
dwCluLkSeCou
 = (
dwMaxCluCou
+127)/128;

199 
dwRemaSeCou
 = 
dwTٮSeCou
 - 
dwCluLkSeCou
 -1;

200 
dwCluCou
 = 
dwRemaSeCou
/
FILESYSTEM_SECTORPERCLUSTER
;

203 
dwCluLkSeCou
 = (
dwCluCou
+127)/128;

210 if(
	`gs_pfRdHDDSe
(
TRUE
,TRUE,0,1,
gs_vbTempBufr
)==
FALSE
)

213 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

214  
FALSE
;

218 
pMBR
 = (
MBR
*)
gs_vbTempBufr
;

219 
	`kMemS
(
pMBR
->
vPt
,0,(pstMBR->vstPartiton));

220 
pMBR
->
dwSigtu
 = 
FILESYSTEM_SIGNATUR
;

221 
pMBR
->
dwRervedSeCou
 = 0;

222 
pMBR
->
dwCluLkSeCou
 = dwClusterLinkSectorCount;

223 
pMBR
->
dwTٮCluCou
 = 
dwCluCou
;

226 if(
	`gs_pfWreHDDSe
(
TRUE
,TRUE,0,1,
gs_vbTempBufr
)==
FALSE
)

229 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

230  
FALSE
;

234 
	`kMemS
(
gs_vbTempBufr
,0,512);

235 
i
=0;i<(
dwCluLkSeCou
+
FILESYSTEM_SECTORPERCLUSTER
);i++)

238 if(
i
==0)

240 ((
DWORD
*)(
gs_vbTempBufr
))[0]=
FILESYSTEM_LASTCLUSTER
;

244 ((
DWORD
*)(
gs_vbTempBufr
))[0]=
FILESYSTEM_FREECLUSTER
;

248 if(
	`gs_pfWreHDDSe
(
TRUE
,TRUE,
i
+1,1,
gs_vbTempBufr
)==
FALSE
)

251 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

252  
FALSE
;

257 if(
gs_FeSyemMag
.
bCacheEb
==
TRUE
)

259 
	`kDisrdACacheBufr
(
CACHE_CLUSTERLINKTABLEAREA
);

260 
	`kDisrdACacheBufr
(
CACHE_DATAAREA
);

264 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

265  
TRUE
;

266 
	}
}

269 
BOOL
 
	$kGHDDInfmi
(
HDDINFORMATION
* 
pInfmi
)

271 
BOOL
 
bResu
;

274 
	`kLock
(&(
gs_FeSyemMag
.
Mux
));

276 
bResu
 = 
	`gs_pfRdHDDInfmi
(
TRUE
,TRUE,
pInfmi
);

279 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

281  
bResu
;

282 
	}
}

285 
BOOL
 
	$kRdCluLkTab
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
)

288 if(
gs_FeSyemMag
.
bCacheEb
==
FALSE
)

290 
	`kIlRdCluLkTabWhoutCache
(
dwOfft
,
pbBufr
);

294 
	`kIlRdCluLkTabWhCache
(
dwOfft
,
pbBufr
);

296 
	}
}

300 
BOOL
 
	$kIlRdCluLkTabWhoutCache
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
)

303  
	`gs_pfRdHDDSe
(
TRUE
,TRUE,
dwOfft
+
gs_FeSyemMag
.
dwCluLkAaSAddss
,1,
pbBufr
);

304 
	}
}

308 
BOOL
 
	$kIlRdCluLkTabWhCache
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
)

310 
CACHEBUFFER
* 
pCacheBufr
;

313 
pCacheBufr
 = 
	`kFdCacheBufr
(
CACHE_CLUSTERLINKTABLEAREA
,
dwOfft
);

316 if(
pCacheBufr
!=
NULL
)

318 
	`kMemCpy
(
pbBufr
,
pCacheBufr
->pbBuffer,512);

319  
TRUE
;

323 if(
	`kIlRdCluLkTabWhoutCache
(
dwOfft
,
pbBufr
)==
FALSE
)

325  
FALSE
;

329 
pCacheBufr
 = 
	`kAoCacheBufrWhFlush
(
CACHE_CLUSTERLINKTABLEAREA
);

330 if(
pCacheBufr
==
NULL
)

332  
FALSE
;

336 
	`kMemCpy
(
pCacheBufr
->
pbBufr
,pbBuffer,512);

337 
pCacheBufr
->
dwTag
 = 
dwOfft
;

340 
pCacheBufr
->
bChged
 = 
FALSE
;

341  
TRUE
;

342 
	}
}

346 
CACHEBUFFER
* 
	$kAoCacheBufrWhFlush
(
iCacheTabIndex
)

348 
CACHEBUFFER
* 
pCacheBufr
;

351 
pCacheBufr
 = 
	`kAoCacheBufr
(
iCacheTabIndex
);

353 if(
pCacheBufr
 =
NULL
)

355 
pCacheBufr
 = 
	`kGViimInCacheBufr
(
iCacheTabIndex
);

357 if(
pCacheBufr
==
NULL
)

359 
	`kPrtf
("Cache Allocate Fail~!!!!\n");

360  
NULL
;

364 if(
pCacheBufr
->
bChged
 ==
TRUE
)

366 
iCacheTabIndex
)

369 
CACHE_CLUSTERLINKTABLEAREA
:

371 if(
	`kIlWreCluLkTabWhoutCache
(
pCacheBufr
->
dwTag
,pCacheBufr->
pbBufr
)==
FALSE
)

373 
	`kPrtf
("Cache Buffer Write Fail~!!!!\n");

374  
NULL
;

379 
CACHE_DATAAREA
:

381 if(
	`kIlWreCluWhoutCache
(
pCacheBufr
->
dwTag
,pCacheBufr->
pbBufr
)==
FALSE
)

383 
	`kPrtf
("Cache Buffer Write Fail~!!!!\n");

384  
NULL
;

390 
	`kPrtf
("kAllocateCacheBufferWithFlush Fail\n");

391  
NULL
;

397  
pCacheBufr
;

398 
	}
}

402 
BOOL
 
	$kWreCluLkTab
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
)

405 if(
gs_FeSyemMag
.
bCacheEb
==
FALSE
)

407  
	`kIlWreCluLkTabWhoutCache
(
dwOfft
,
pbBufr
);

411  
	`kIlWreCluLkTabWhCache
(
dwOfft
,
pbBufr
);

413 
	}
}

417 
BOOL
 
	$kIlWreCluLkTabWhoutCache
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
)

420  
	`gs_pfWreHDDSe
(
TRUE
,TRUE,
dwOfft
+
gs_FeSyemMag
.
dwCluLkAaSAddss
,1,
pbBufr
);

421 
	}
}

425 
BOOL
 
	$kIlWreCluLkTabWhCache
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
)

427 
CACHEBUFFER
* 
pCacheBufr
;

430 
pCacheBufr
 = 
	`kFdCacheBufr
(
CACHE_CLUSTERLINKTABLEAREA
,
dwOfft
);

433 if(
pCacheBufr
!=
NULL
)

435 
	`kMemCpy
(
pCacheBufr
->
pbBufr
,pbBuffer,512);

438 
pCacheBufr
->
bChged
 = 
TRUE
;

439  
TRUE
;

443 
pCacheBufr
 = 
	`kAoCacheBufrWhFlush
(
CACHE_CLUSTERLINKTABLEAREA
);

444 if(
pCacheBufr
==
NULL
)

446  
FALSE
;

450 
	`kMemCpy
(
pCacheBufr
->
pbBufr
,pbBuffer,512);

451 
pCacheBufr
->
dwTag
 = 
dwOfft
;

454 
pCacheBufr
->
bChged
 = 
TRUE
;

456  
TRUE
;

457 
	}
}

460 
BOOL
 
	$kRdClu
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
)

463 if(
gs_FeSyemMag
.
bCacheEb
==
FALSE
)

465 
	`kIlRdCluWhoutCache
(
dwOfft
,
pbBufr
);

469 
	`kIlRdCluWhCache
(
dwOfft
,
pbBufr
);

471 
	}
}

475 
BOOL
 
	$kIlRdCluWhoutCache
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
)

478  
	`gs_pfRdHDDSe
(
TRUE
,TRUE,(
dwOfft
*
FILESYSTEM_SECTORPERCLUSTER
)+
gs_FeSyemMag
.
dwDaAaSAddss
,FILESYSTEM_SECTORPERCLUSTER,
pbBufr
);

479 
	}
}

483 
BOOL
 
	$kIlRdCluWhCache
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
)

485 
CACHEBUFFER
* 
pCacheBufr
;

488 
pCacheBufr
 = 
	`kFdCacheBufr
(
CACHE_DATAAREA
,
dwOfft
);

491 if(
pCacheBufr
!=
NULL
)

493 
	`kMemCpy
(
pbBufr
,
pCacheBufr
->pbBufr,
FILESYSTEM_CLUSTERSIZE
);

494  
TRUE
;

498 if(
	`kIlRdCluWhoutCache
(
dwOfft
,
pbBufr
)==
FALSE
)

500  
FALSE
;

504 
pCacheBufr
 = 
	`kAoCacheBufrWhFlush
(
CACHE_DATAAREA
);

505 if(
pCacheBufr
==
NULL
)

507  
FALSE
;

511 
	`kMemCpy
(
pCacheBufr
->
pbBufr
,pbBufr,
FILESYSTEM_CLUSTERSIZE
);

512 
pCacheBufr
->
dwTag
 = 
dwOfft
;

515 
pCacheBufr
->
bChged
 = 
FALSE
;

516  
TRUE
;

517 
	}
}

520 
BOOL
 
	$kWreClu
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
)

523 if(
gs_FeSyemMag
.
bCacheEb
==
FALSE
)

525 
	`kIlWreCluWhoutCache
(
dwOfft
,
pbBufr
);

529 
	`kIlWreCluWhCache
(
dwOfft
,
pbBufr
);

531 
	}
}

535 
BOOL
 
	$kIlWreCluWhoutCache
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
)

538  
	`gs_pfWreHDDSe
(
TRUE
,TRUE,(
dwOfft
*
FILESYSTEM_SECTORPERCLUSTER
)+
gs_FeSyemMag
.
dwDaAaSAddss
,FILESYSTEM_SECTORPERCLUSTER,
pbBufr
);

539 
	}
}

543 
BOOL
 
	$kIlWreCluWhCache
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
)

545 
CACHEBUFFER
* 
pCacheBufr
;

548 
pCacheBufr
 = 
	`kFdCacheBufr
(
CACHE_DATAAREA
,
dwOfft
);

551 if(
pCacheBufr
!=
NULL
)

553 
	`kMemCpy
(
pCacheBufr
->
pbBufr
,pbBufr,
FILESYSTEM_CLUSTERSIZE
);

556 
pCacheBufr
->
bChged
 = 
TRUE
;

558  
TRUE
;

562 
pCacheBufr
 = 
	`kAoCacheBufrWhFlush
(
CACHE_DATAAREA
);

563 if(
pCacheBufr
==
NULL
)

565  
FALSE
;

569 
	`kMemCpy
(
pCacheBufr
->
pbBufr
,pbBufr,
FILESYSTEM_CLUSTERSIZE
);

570 
pCacheBufr
->
dwTag
 = 
dwOfft
;

573 
pCacheBufr
->
bChged
 = 
TRUE
;

575  
TRUE
;

576 
	}
}

579 
DWORD
 
	$kFdFeClu
()

581 
DWORD
 
dwLkCouInSe
;

582 
DWORD
 
dwLaSeOfft
,
dwCutSeOfft
;

583 
DWORD
 
i
,
j
;

586 if(
gs_FeSyemMag
.
bMoued
==
FALSE
)

588  
FILESYSTEM_LASTCLUSTER
;

592 
dwLaSeOfft
 = 
gs_FeSyemMag
.
dwLaAoduLkSeOfft
;

595 
i
=0;i<
gs_FeSyemMag
.
dwCluLkAaSize
;i++)

599 if((
dwLaSeOfft
+
i
)==(
gs_FeSyemMag
.
dwCluLkAaSize
-1))

601 
dwLkCouInSe
 = 
gs_FeSyemMag
.
dwTٮCluCou
%128;

605 
dwLkCouInSe
 = 128;

609 
dwCutSeOfft
 = (
dwLaSeOfft
+
i
)%
gs_FeSyemMag
.
dwCluLkAaSize
;

610 if(
	`kRdCluLkTab
(
dwCutSeOfft
,
gs_vbTempBufr
)==
FALSE
)

612  
FILESYSTEM_LASTCLUSTER
;

616 
j
=0;j<
dwLkCouInSe
;j++)

618 if(((
DWORD
*)
gs_vbTempBufr
)[
j
]==
FILESYSTEM_FREECLUSTER
)

625 if(
j
!=
dwLkCouInSe
)

628 
gs_FeSyemMag
.
dwLaAoduLkSeOfft
 = 
dwCutSeOfft
;

631  (
dwCutSeOfft
*128)+
j
;

635  
FILESYSTEM_LASTCLUSTER
;

636 
	}
}

639 
BOOL
 
	$kSCluLkDa
(
DWORD
 
dwCluIndex
,DWORD 
dwDa
)

641 
DWORD
 
dwSeOfft
;

644 if(
gs_FeSyemMag
.
bMoued
==
FALSE
)

646 
	`kPrtf
("FileSystemot mounted\n");

647  
FALSE
;

651 
dwSeOfft
 = 
dwCluIndex
/128;

654 if(
	`kRdCluLkTab
(
dwSeOfft
,
gs_vbTempBufr
)==
FALSE
)

656 
	`kPrtf
("kReadClusterLinkTablerror\n");

657  
FALSE
;

660 ((
DWORD
*)
gs_vbTempBufr
)[
dwCluIndex
%128]=
dwDa
;

662 if(
	`kWreCluLkTab
(
dwSeOfft
,
gs_vbTempBufr
)==
FALSE
)

664 
	`kPrtf
("kWriteClusterLinkTablerror\n");

665  
FALSE
;

668  
TRUE
;

669 
	}
}

672 
BOOL
 
	$kGCluLkDa
(
DWORD
 
dwCluIndex
,DWORD* 
pdwDa
)

674 
DWORD
 
dwSeOfft
;

677 if(
gs_FeSyemMag
.
bMoued
==
FALSE
)

679  
FALSE
;

683 
dwSeOfft
 = 
dwCluIndex
/128;

685 if(
dwSeOfft
>
gs_FeSyemMag
.
dwCluLkAaSize
)

687  
FALSE
;

691 if(
	`kRdCluLkTab
(
dwSeOfft
,
gs_vbTempBufr
)==
FALSE
)

693  
FALSE
;

696 *
pdwDa
 = ((
DWORD
*)
gs_vbTempBufr
)[
dwCluIndex
%128];

697  
TRUE
;

698 
	}
}

701 
	$kFdFeDeyEry
()

703 
DIRECTORYENTRY
* 
pEry
;

704 
i
;

707 if(
gs_FeSyemMag
.
bMoued
==
FALSE
)

713 if(
	`kRdClu
(0,
gs_vbTempBufr
)==
FALSE
)

719 
pEry
 = (
DIRECTORYENTRY
*)
gs_vbTempBufr
;

720 
i
=0;i<
FILESYSTEM_MAXDIRECTORYENTRYCOUNT
;i++)

722 if(
pEry
[
i
].
dwSCluIndex
==0)

724  
i
;

729 
	}
}

732 
BOOL
 
	$kSDeyEryDa
(
iIndex
,
DIRECTORYENTRY
* 
pEry
)

734 
DIRECTORYENTRY
* 
pRoEry
;

737 if((
gs_FeSyemMag
.
bMoued
==
FALSE
)||(
iIndex
<0)||(iIndex>=
FILESYSTEM_MAXDIRECTORYENTRYCOUNT
))

739 
	`kPrtf
("FeSyem moued (Index=%d)\n",
iIndex
);

740  
FALSE
;

744 if(
	`kRdClu
(0,
gs_vbTempBufr
)==
FALSE
)

746 
	`kPrtf
("kReadClusterrror\n");

747  
FALSE
;

751 
pRoEry
 = (
DIRECTORYENTRY
*)
gs_vbTempBufr
;

752 
	`kMemCpy
(
pRoEry
+
iIndex
,
pEry
,(
DIRECTORYENTRY
));

755 if(
	`kWreClu
(0,
gs_vbTempBufr
)==
FALSE
)

757 
	`kPrtf
("kWriteClusterrror\n");

758  
FALSE
;

761  
TRUE
;

762 
	}
}

765 
BOOL
 
	$kGDeyEryDa
(
iIndex
,
DIRECTORYENTRY
* 
pEry
)

767 
DIRECTORYENTRY
* 
pRoEry
;

770 if((
gs_FeSyemMag
.
bMoued
==
FALSE
)||(
iIndex
<0)||(iIndex>=
FILESYSTEM_MAXDIRECTORYENTRYCOUNT
))

772  
FALSE
;

776 if(
	`kRdClu
(0,
gs_vbTempBufr
)==
FALSE
)

778  
FALSE
;

782 
pRoEry
 = (
DIRECTORYENTRY
*)
gs_vbTempBufr
;

783 
	`kMemCpy
(
pEry
,
pRoEry
+
iIndex
,(
DIRECTORYENTRY
));

784  
TRUE
;

785 
	}
}

788 
	$kFdDeyEry
(cڡ * 
pcFeName
,
DIRECTORYENTRY
* 
pEry
)

790 
DIRECTORYENTRY
* 
pRoEry
;

791 
i
;

792 
iLgth
;

795 if(
gs_FeSyemMag
.
bMoued
==
FALSE
)

801 if(
	`kRdClu
(0,
gs_vbTempBufr
)==
FALSE
)

806 
iLgth
 = 
	`kSL
(
pcFeName
);

808 
pRoEry
 = (
DIRECTORYENTRY
*)
gs_vbTempBufr
;

809 
i
=0;i<
FILESYSTEM_MAXDIRECTORYENTRYCOUNT
;i++)

811 if(
	`kMemCmp
(
pRoEry
[
i
].
vcFeName
,
pcFeName
,
iLgth
)==0)

813 
	`kMemCpy
(
pEry
,
pRoEry
+
i
,(
DIRECTORYENTRY
));

814  
i
;

819 
	}
}

822 
	$kGFeSyemInfmi
(
FILESYSTEMMANAGER
* 
pMag
)

824 
	`kMemCpy
(
pMag
,&
gs_FeSyemMag
,(gs_stFileSystemManager));

825 
	}
}

831 * 
	$kAoFeDeyHd
()

833 
i
;

834 
FILE
* 
pFe
;

837 
pFe
 = 
gs_FeSyemMag
.
pHdPo
;

838 
i
=0;i<
FILESYSTEM_HANDLE_MAXCOUNT
;i++)

841 if(
pFe
->
bTy
 =
FILESYSTEM_TYPE_FREE
)

843 
pFe
->
bTy
 = 
FILESYSTEM_TYPE_FILE
;

844  
pFe
;

848 
pFe
++;

851  
NULL
;

852 
	}
}

855 
	$kFeFeDeyHd
(
FILE
* 
pFe
)

858 
	`kMemS
(
pFe
,0,(
FILE
));

861 
pFe
->
bTy
 = 
FILESYSTEM_TYPE_FREE
;

862 
	}
}

865 
BOOL
 
	$kCeFe
(cڡ * 
pcFeName
,
DIRECTORYENTRY
* 
pEry
,* 
piDeyEryIndex
)

867 
DWORD
 
dwClu
;

870 
dwClu
 = 
	`kFdFeClu
();

871 if((
dwClu
==
FILESYSTEM_LASTCLUSTER
)||(
	`kSCluLkDa
(dwClu,FILESYSTEM_LASTCLUSTER)==
FALSE
))

873  
FALSE
;

877 *
piDeyEryIndex
 = 
	`kFdFeDeyEry
();

878 if(*
piDeyEryIndex
==-1)

881 
	`kSCluLkDa
(
dwClu
,
FILESYSTEM_FREECLUSTER
);

882  
FALSE
;

886 
	`kMemCpy
(
pEry
->
vcFeName
,
pcFeName
,
	`kSL
(pcFileName)+1);

887 
pEry
->
dwSCluIndex
 = 
dwClu
;

888 
pEry
->
dwFeSize
 = 0;

891 if(
	`kSDeyEryDa
(*
piDeyEryIndex
,
pEry
)==
FALSE
)

894 
	`kSCluLkDa
(
dwClu
,
FILESYSTEM_FREECLUSTER
);

895  
FALSE
;

898  
TRUE
;

899 
	}
}

902 
BOOL
 
	$kFeCluUtEnd
(
DWORD
 
dwCluIndex
)

904 
DWORD
 
dwCutCluIndex
;

905 
DWORD
 
dwNextCluIndex
;

908 
dwCutCluIndex
 = 
dwCluIndex
;

910 
dwCutCluIndex
!=
FILESYSTEM_LASTCLUSTER
)

913 if(
	`kGCluLkDa
(
dwCutCluIndex
,&
dwNextCluIndex
)==
FALSE
)

915  
FALSE
;

919 if(
	`kSCluLkDa
(
dwCutCluIndex
,
FILESYSTEM_FREECLUSTER
)==
FALSE
)

921  
FALSE
;

925 
dwCutCluIndex
 = 
dwNextCluIndex
;

928  
TRUE
;

929 
	}
}

932 
FILE
* 
	$kOnFe
(cڡ * 
pcFeName
,cڡ * 
pcMode
)

934 
DIRECTORYENTRY
 
Ery
;

935 
iDeyEryOfft
;

936 
iFeNameLgth
;

937 
DWORD
 
dwSecdClu
;

938 
FILE
* 
pFe
;

941 
iFeNameLgth
 = 
	`kSL
(
pcFeName
);

942 if((
iFeNameLgth
>((
Ery
.
vcFeName
)-1))||(iFileNameLength==0))

944  
NULL
;

948 
	`kLock
(&(
gs_FeSyemMag
.
Mux
));

953 
iDeyEryOfft
 = 
	`kFdDeyEry
(
pcFeName
,&
Ery
);

954 if(
iDeyEryOfft
==-1)

957 if(
pcMode
[0]=='r')

960 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

961  
NULL
;

965 if(
	`kCeFe
(
pcFeName
,&
Ery
,&
iDeyEryOfft
)==
FALSE
)

968 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

969  
NULL
;

975 if(
pcMode
[0]=='w')

978 if(
	`kGCluLkDa
(
Ery
.
dwSCluIndex
,&
dwSecdClu
)==
FALSE
)

981 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

982  
NULL
;

986 if(
	`kSCluLkDa
(
Ery
.
dwSCluIndex
,
FILESYSTEM_LASTCLUSTER
)==
FALSE
)

989 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

990  
NULL
;

994 if(
	`kFeCluUtEnd
(
dwSecdClu
)==
FALSE
)

997 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

998  
NULL
;

1002 
Ery
.
dwFeSize
 = 0;

1003 if(
	`kSDeyEryDa
(
iDeyEryOfft
,&
Ery
)==
FALSE
)

1006 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1007  
NULL
;

1015 
pFe
 = 
	`kAoFeDeyHd
();

1016 if(
pFe
==
NULL
)

1019 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1020  
NULL
;

1024 
pFe
->
bTy
 = 
FILESYSTEM_TYPE_FILE
;

1025 
pFe
->
FeHd
.
iDeyEryOfft
 = iDirectoryEntryOffset;

1026 
pFe
->
FeHd
.
dwFeSize
 = 
Ery
.dwFileSize;

1027 
pFe
->
FeHd
.
dwSCluIndex
 = 
Ery
.dwStartClusterIndex;

1028 
pFe
->
FeHd
.
dwCutCluIndex
 = 
Ery
.
dwSCluIndex
;

1029 
pFe
->
FeHd
.
dwPviousCluIndex

Ery
.
dwSCluIndex
;

1030 
pFe
->
FeHd
.
dwCutOfft
 =0;

1033 if(
pcMode
[0]=='a')

1035 
	`kSkFe
(
pFe
,0,
FILESYSTEM_SEEK_END
);

1039 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1040  
pFe
;

1041 
	}
}

1044 
DWORD
 
	$kRdFe
(* 
pvBufr
,
DWORD
 
dwSize
,DWORD 
dwCou
,
FILE
* 
pFe
)

1046 
DWORD
 
dwTٮCou
;

1047 
DWORD
 
dwRdCou
;

1048 
DWORD
 
dwOfftInClu
;

1049 
DWORD
 
dwCySize
;

1050 
FILEHANDLE
* 
pFeHd
;

1051 
DWORD
 
dwNextCluIndex
;

1054 if((
pFe
==
NULL
)||աFe->
bTy
!=
FILESYSTEM_TYPE_FILE
))

1059 
pFeHd
 = &(
pFe
->
FeHd
);

1062 if((
pFeHd
->
dwCutOfft
=FeHd->
dwFeSize
)||աFeHd->
dwCutCluIndex
==
FILESYSTEM_LASTCLUSTER
))

1068 
dwTٮCou
 = 
	`MIN
(
dwSize
*
dwCou
,
pFeHd
->
dwFeSize
-pFeHd->
dwCutOfft
);

1071 
	`kLock
(&(
gs_FeSyemMag
.
Mux
));

1074 
dwRdCou
=0;

1075 
dwRdCou
!=
dwTٮCou
)

1081 if(
	`kRdClu
(
pFeHd
->
dwCutCluIndex
,
gs_vbTempBufr
)==
FALSE
)

1087 
dwOfftInClu
 = 
pFeHd
->
dwCutOfft
%
FILESYSTEM_CLUSTERSIZE
;

1090 
dwCySize
 = 
	`MIN
(
FILESYSTEM_CLUSTERSIZE
-
dwOfftInClu
,
dwTٮCou
-
dwRdCou
);

1092 
	`kMemCpy
((*)
pvBufr
+
dwRdCou
,
gs_vbTempBufr
+
dwOfftInClu
,
dwCySize
);

1095 
dwRdCou
 +=
dwCySize
;

1096 
pFeHd
->
dwCutOfft
 +=
dwCySize
;

1101 if((
pFeHd
->
dwCutOfft
%
FILESYSTEM_CLUSTERSIZE
)==0)

1104 if(
	`kGCluLkDa
(
pFeHd
->
dwCutCluIndex
,&
dwNextCluIndex
)==
FALSE
)

1110 
pFeHd
->
dwPviousCluIndex
FeHd->
dwCutCluIndex
;

1111 
pFeHd
->
dwCutCluIndex
=
dwNextCluIndex
;

1116 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1119  
dwRdCou
;

1120 
	}
}

1123 
BOOL
 
	$kUpdeDeyEry
(
FILEHANDLE
* 
pFeHd
)

1125 
DIRECTORYENTRY
 
Ery
;

1128 if((
pFeHd
==
NULL
)||(
	`kGDeyEryDa
աFeHd->
iDeyEryOfft
,&
Ery
)==
FALSE
))

1130  
FALSE
;

1134 
Ery
.
dwFeSize
 = 
pFeHd
->dwFileSize;

1135 
Ery
.
dwSCluIndex
 = 
pFeHd
->dwStartClusterIndex;

1138 if(
	`kSDeyEryDa
(
pFeHd
->
iDeyEryOfft
,&
Ery
)==
FALSE
)

1140  
FALSE
;

1143  
TRUE
;

1144 
	}
}

1147 
DWORD
 
	$kWreFe
(cڡ * 
pvBufr
,
DWORD
 
dwSize
,DWORD 
dwCou
,
FILE
* 
pFe
)

1149 
DWORD
 
dwWreCou
;

1150 
DWORD
 
dwTٮCou
;

1151 
DWORD
 
dwOfftInClu
;

1152 
DWORD
 
dwCySize
;

1153 
DWORD
 
dwAodCluIndex
;

1154 
DWORD
 
dwNextCluIndex
;

1155 
DWORD
 
dwUFeSize
;

1156 
FILEHANDLE
* 
pFeHd
;

1159 if((
pFe
==
NULL
)||աFe->
bTy
!=
FILESYSTEM_TYPE_FILE
))

1164 
pFeHd
 = &(
pFe
->
FeHd
);

1167 
dwUFeSize
 = ((
pFeHd
->
dwFeSize
+
FILESYSTEM_CLUSTERSIZE
)/FILESYSTEM_CLUSTERSIZE)*FILESYSTEM_CLUSTERSIZE;

1170 
dwTٮCou
 = 
dwSize
*
dwCou
;

1173 
	`kLock
(&(
gs_FeSyemMag
.
Mux
));

1176 
dwWreCou
=0;

1177 
dwWreCou
!=
dwTٮCou
)

1181 
dwOfftInClu
 = 
pFeHd
->
dwCutOfft
%
FILESYSTEM_CLUSTERSIZE
;

1182 
dwCySize
 = 
	`MIN
(
FILESYSTEM_CLUSTERSIZE
-
dwOfftInClu
,
dwTٮCou
-
dwWreCou
);

1185 
dwAodCluIndex
=-1;

1188 if(
dwUFeSize
<=(
pFeHd
->
dwCutOfft
+
dwCySize
))

1191 
dwAodCluIndex
 = 
	`kFdFeClu
();

1192 if(
dwAodCluIndex
==
FILESYSTEM_LASTCLUSTER
)

1198 if(
	`kSCluLkDa
(
dwAodCluIndex
,
FILESYSTEM_LASTCLUSTER
)==
FALSE
)

1205 if(
pFeHd
->
dwCutOfft
%
FILESYSTEM_CLUSTERSIZE
!=0)

1207 if(
pFeHd
->
dwCutCluIndex
==
FILESYSTEM_LASTCLUSTER
)

1209 if(
	`kRdClu
(
pFeHd
->
dwPviousCluIndex
,
gs_vbTempBufr
)==
FALSE
)

1218 if(
	`kRdClu
(
pFeHd
->
dwCutCluIndex
,
gs_vbTempBufr
)==
FALSE
)

1228 
	`kMemCpy
(
gs_vbTempBufr
+
dwOfftInClu
,(*)
pvBufr
+
dwWreCou
,
dwCySize
);

1231 if(
pFeHd
->
dwCutCluIndex
==
FILESYSTEM_LASTCLUSTER
)

1233 if(
	`kWreClu
(
pFeHd
->
dwPviousCluIndex
,
gs_vbTempBufr
)==
FALSE
)

1240 if(
	`kWreClu
(
pFeHd
->
dwCutCluIndex
,
gs_vbTempBufr
)==
FALSE
)

1248 
dwWreCou
+=
dwCySize
;

1249 
pFeHd
->
dwCutOfft
+=
dwCySize
;

1252 if(
dwOfftInClu
+
dwCySize
==
FILESYSTEM_CLUSTERSIZE
)

1254 if(
dwAodCluIndex
!=-1)

1256 if(
	`kSCluLkDa
(
pFeHd
->
dwCutCluIndex
,
dwAodCluIndex
)==
FALSE
)

1261 
pFeHd
->
dwPviousCluIndex
 =FeHd->
dwCutCluIndex
;

1262 
pFeHd
->
dwCutCluIndex
 = 
dwAodCluIndex
;

1267 if(
	`kGCluLkDa
(
pFeHd
->
dwCutCluIndex
,&
dwNextCluIndex
)==
FALSE
)

1273 
pFeHd
->
dwPviousCluIndex
 =FeHd->
dwCutCluIndex
;

1274 
pFeHd
->
dwCutCluIndex
 = 
dwNextCluIndex
;

1286 if(
pFeHd
->
dwFeSize
<pFeHd->
dwCutOfft
)

1288 
pFeHd
->
dwFeSize
FeHd->
dwCutOfft
;

1289 
	`kUpdeDeyEry
(
pFeHd
);

1293 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1294  
dwWreCou
;

1295 
	}
}

1298 
BOOL
 
	$kWreZo
(
FILE
* 
pFe
,
DWORD
 
dwCou
)

1300 
BYTE
* 
pbBufr
;

1301 
DWORD
 
dwRemaCou
;

1302 
DWORD
 
dwWreCou
;

1305 if(
pFe
==
NULL
)

1307  
FALSE
;

1311 
pbBufr
 = (
BYTE
*)
	`kAoMemy
(
FILESYSTEM_CLUSTERSIZE
);

1312 if(
pbBufr
==
NULL
)

1314  
FALSE
;

1318 
	`kMemS
(
pbBufr
,0,
FILESYSTEM_CLUSTERSIZE
);

1319 
dwRemaCou
 = 
dwCou
;

1322 
dwRemaCou
!=0)

1324 
dwWreCou
 = 
	`MIN
(
dwRemaCou
,
FILESYSTEM_CLUSTERSIZE
);

1325 if(
	`kWreFe
(
pbBufr
,1,
dwWreCou
,
pFe
)!=dwWriteCount)

1327 
	`kFeMemy
(
pbBufr
);

1328  
FALSE
;

1331 
dwRemaCou
 ==
dwWreCou
;

1334 
	`kFeMemy
(
pbBufr
);

1335  
TRUE
;

1336 
	}
}

1339 
	$kSkFe
(
FILE
* 
pFe
,
iOfft
,
iOrig
)

1341 
DWORD
 
dwRlOfft
;

1342 
DWORD
 
dwCluOfftToMove
;

1343 
DWORD
 
dwCutCluOfft
;

1344 
DWORD
 
dwLaCluOfft
;

1345 
DWORD
 
dwMoveCou
;

1346 
DWORD
 
i
;

1347 
DWORD
 
dwSCluIndex
;

1348 
DWORD
 
dwPviousCluIndex
;

1349 
DWORD
 
dwCutCluIndex
;

1350 
FILEHANDLE
* 
pFeHd
;

1353 if((
pFe
==
NULL
)||աFe->
bTy
!=
FILESYSTEM_TYPE_FILE
))

1358 
pFeHd
 = &(
pFe
->
FeHd
);

1365 
iOrig
)

1368 
FILESYSTEM_SEEK_SET
:

1370 if(
iOfft
<=0)

1372 
dwRlOfft
=0;

1376 
dwRlOfft
=
iOfft
;

1381 
FILESYSTEM_SEEK_CUR
:

1384 if((
iOfft
<=0)&&(
pFeHd
->
dwCutOfft
<=(
DWORD
)-iOffset))

1386 
dwRlOfft
=0;

1390 
dwRlOfft
 = 
pFeHd
->
dwCutOfft
+
iOfft
;

1395 
FILESYSTEM_SEEK_END
:

1398 if((
iOfft
<0)&&(
pFeHd
->
dwFeSize
<=(
DWORD
)-iOffset))

1400 
dwRlOfft
=0;

1404 
dwRlOfft
 = 
pFeHd
->
dwFeSize
+
iOfft
;

1414 
dwLaCluOfft
 = 
pFeHd
->
dwFeSize
/
FILESYSTEM_CLUSTERSIZE
;

1416 
dwCluOfftToMove
 = 
dwRlOfft
/
FILESYSTEM_CLUSTERSIZE
;

1418 
dwCutCluOfft
 = 
pFeHd
->
dwCutOfft
/
FILESYSTEM_CLUSTERSIZE
;

1422 if(
dwLaCluOfft
<
dwCluOfftToMove
)

1424 
dwMoveCou
 = 
dwLaCluOfft
-
dwCutCluOfft
;

1425 
dwSCluIndex
 = 
pFeHd
->
dwCutCluIndex
;

1429 if(
dwCutCluOfft
<=
dwCluOfftToMove
)

1431 
dwMoveCou
 = 
dwCluOfftToMove
-
dwCutCluOfft
;

1432 
dwSCluIndex
 = 
pFeHd
->
dwCutCluIndex
;

1437 
dwMoveCou
 = 
dwCluOfftToMove
;

1438 
dwSCluIndex
 = 
pFeHd
->dwStartClusterIndex;

1442 
	`kLock
(&(
gs_FeSyemMag
.
Mux
));

1445 
dwCutCluIndex
 = 
dwSCluIndex
;

1446 
i
=0;i<
dwMoveCou
;i++)

1449 
dwPviousCluIndex
 = 
dwCutCluIndex
;

1452 if(
	`kGCluLkDa
(
dwPviousCluIndex
,&
dwCutCluIndex
)==
FALSE
)

1455 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1461 if(
dwMoveCou
>0)

1463 
pFeHd
->
dwPviousCluIndex
 = dwPreviousClusterIndex;

1464 
pFeHd
->
dwCutCluIndex
 = dwCurrentClusterIndex;

1467 if(
dwSCluIndex
==
pFeHd
->dwStartClusterIndex)

1469 
pFeHd
->
dwPviousCluIndex
 =FeHd->
dwSCluIndex
;

1470 
pFeHd
->
dwCutCluIndex
 =FeHd->
dwSCluIndex
;

1478 if(
dwLaCluOfft
<
dwCluOfftToMove
)

1480 
pFeHd
->
dwCutOfft
 =FeHd->
dwFeSize
;

1482 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1485 if(
	`kWreZo
(
pFe
,
dwRlOfft
-
pFeHd
->
dwFeSize
)==
FALSE
)

1491 
pFeHd
->
dwCutOfft
 = 
dwRlOfft
;

1494 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1497 
	}
}

1500 
	$kCloFe
(
FILE
* 
pFe
)

1503 if((
pFe
==
NULL
)||աFe->
bTy
!=
FILESYSTEM_TYPE_FILE
))

1509 
	`kFeFeDeyHd
(
pFe
);

1511 
	}
}

1514 
BOOL
 
	$kIsFeOd
(cڡ 
DIRECTORYENTRY
* 
pEry
)

1516 
i
;

1517 
FILE
* 
pFe
;

1520 
pFe
 = 
gs_FeSyemMag
.
pHdPo
;

1521 
i
=0;i<
FILESYSTEM_HANDLE_MAXCOUNT
;i++)

1524 if((
pFe
[
i
].
bTy
==
FILESYSTEM_TYPE_FILE
)&&աFe[i].
FeHd
.
dwSCluIndex
==
pEry
->dwStartClusterIndex))

1526  
TRUE
;

1530  
FALSE
;

1531 
	}
}

1534 
	$kRemoveFe
(cڡ * 
pcFeName
)

1536 
DIRECTORYENTRY
 
Ery
;

1537 
iDeyEryOfft
;

1538 
iFeNameLgth
;

1541 
iFeNameLgth
 = 
	`kSL
(
pcFeName
);

1542 if((
iFeNameLgth
>((
Ery
.
vcFeName
)-1))||(iFileNameLength==0))

1544  
NULL
;

1548 
	`kLock
(&(
gs_FeSyemMag
.
Mux
));

1551 
iDeyEryOfft
 = 
	`kFdDeyEry
(
pcFeName
,&
Ery
);

1552 if(
iDeyEryOfft
==-1)

1555 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1560 if(
	`kIsFeOd
(&
Ery
)==
TRUE
)

1563 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1568 if(
	`kFeCluUtEnd
(
Ery
.
dwSCluIndex
)==
FALSE
)

1571 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1576 
	`kMemS
(&
Ery
,0,(stEntry));

1577 if(
	`kSDeyEryDa
(
iDeyEryOfft
,&
Ery
)==
FALSE
)

1580 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1585 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1587 
	}
}

1590 
DIR
* 
	$kOnDey
(cڡ * 
pcDeyName
)

1592 
DIR
* 
pDey
;

1593 
DIRECTORYENTRY
* 
pDeyBufr
;

1596 
	`kLock
(&(
gs_FeSyemMag
.
Mux
));

1599 
pDey
 = 
	`kAoFeDeyHd
();

1600 if(
pDey
==
NULL
)

1603 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1604  
NULL
;

1608 
pDeyBufr
 = (
DIRECTORYENTRY
*)
	`kAoMemy
(
FILESYSTEM_CLUSTERSIZE
);

1609 if(
pDeyBufr
==
NULL
)

1612 
	`kFeFeDeyHd
(
pDey
);

1614 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1615  
NULL
;

1619 if(
	`kRdClu
(0,(
BYTE
*)
pDeyBufr
)==
FALSE
)

1622 
	`kFeFeDeyHd
(
pDey
);

1623 
	`kFeMemy
(
pDeyBufr
);

1626 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1627  
NULL
;

1631 
pDey
->
bTy
 = 
FILESYSTEM_TYPE_DIRECTORY
;

1632 
pDey
->
DeyHd
.
iCutOfft
 = 0;

1633 
pDey
->
DeyHd
.
pDeyBufr
 =stDirectoryBuffer;

1636 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1637  
pDey
;

1638 
	}
}

1641 
kDeyErySu
* 
	$kRdDey
(
DIR
* 
pDey
)

1643 
DIRECTORYHANDLE
* 
pDeyHd
;

1644 
DIRECTORYENTRY
* 
pEry
;

1647 if((
pDey
==
NULL
)||աDey->
bTy
!=
FILESYSTEM_TYPE_DIRECTORY
))

1649  
NULL
;

1652 
pDeyHd
 = &(
pDey
->
DeyHd
);

1655 if((
pDeyHd
->
iCutOfft
<0)||աDeyHd->iCutOfft>=
FILESYSTEM_MAXDIRECTORYENTRYCOUNT
))

1657  
NULL
;

1661 
	`kLock
(&(
gs_FeSyemMag
.
Mux
));

1664 
pEry
 = 
pDeyHd
->
pDeyBufr
;

1665 
pDeyHd
->
iCutOfft
<
FILESYSTEM_MAXDIRECTORYENTRYCOUNT
)

1668 if(
pEry
[
pDeyHd
->
iCutOfft
].
dwSCluIndex
!=0)

1671 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1672  &(
pEry
[
pDeyHd
->
iCutOfft
++]);

1675 
pDeyHd
->
iCutOfft
++;

1679 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1680  
NULL
;

1681 
	}
}

1684 
	$kRewdDey
(
DIR
* 
pDey
)

1686 
DIRECTORYHANDLE
* 
pDeyHd
;

1689 if((
pDey
==
NULL
)||աDey->
bTy
!=
FILESYSTEM_TYPE_DIRECTORY
))

1694 
pDeyHd
=&(
pDey
->
DeyHd
);

1697 
	`kLock
(&(
gs_FeSyemMag
.
Mux
));

1700 
pDeyHd
->
iCutOfft
=0;

1703 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1704 
	}
}

1707 
	$kCloDey
(
DIR
* 
pDey
)

1709 
DIRECTORYHANDLE
* 
pDeyHd
;

1712 if((
pDey
==
NULL
)||աDey->
bTy
!=
FILESYSTEM_TYPE_DIRECTORY
))

1717 
pDeyHd
 = &(
pDey
->
DeyHd
);

1720 
	`kLock
(&(
gs_FeSyemMag
.
Mux
));

1723 
	`kFeMemy
(
pDeyHd
->
pDeyBufr
);

1724 
	`kFeFeDeyHd
(
pDey
);

1727 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1730 
	}
}

1733 
BOOL
 
	$kFlushFeSyemCache
()

1735 
CACHEBUFFER
* 
pCacheBufr
;

1736 
iCacheCou
;

1737 
i
;

1740 if(
gs_FeSyemMag
.
bCacheEb
==
FALSE
)

1742  
TRUE
;

1746 
	`kLock
(&(
gs_FeSyemMag
.
Mux
));

1749 
	`kGCacheBufrAndCou
(
CACHE_CLUSTERLINKTABLEAREA
,&
pCacheBufr
,&
iCacheCou
);

1751 
i
=0;i<
iCacheCou
;i++)

1754 if(
pCacheBufr
[
i
].
bChged
==
TRUE
)

1756 if(
	`kIlWreCluLkTabWhoutCache
(
pCacheBufr
[
i
].
dwTag
,pCacheBufr[i].
pbBufr
)==
FALSE
)

1758  
FALSE
;

1762 
pCacheBufr
[
i
].
bChged
 = 
FALSE
;

1767 
	`kGCacheBufrAndCou
(
CACHE_DATAAREA
,&
pCacheBufr
,&
iCacheCou
);

1768 
i
=0;i<
iCacheCou
;i++)

1771 if(
pCacheBufr
[
i
].
bChged
==
TRUE
)

1773 if(
	`kIlWreCluWhoutCache
(
pCacheBufr
[
i
].
dwTag
,pCacheBufr[i].
pbBufr
)==
FALSE
)

1775  
FALSE
;

1779 
pCacheBufr
[
i
].
bChged
 = 
FALSE
;

1784 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1785  
TRUE
;

1786 
	}
}

	@/home/jk/os/MINT64/02.Kernel64/Source/FileSystem.h

1 #ide
__FILESYSTEM_H__


2 
	#__FILESYSTEM_H__


	)

4 
	~"Tys.h
"

5 
	~"Synchrizi.h
"

6 
	~"HdDisk.h
"

7 
	~"CacheMag.h
"

11 
	#FILESYSTEM_SIGNATUR
 0x7E38CF10

	)

13 
	#FILESYSTEM_SECTORPERCLUSTER
 8

	)

15 
	#FILESYSTEM_LASTCLUSTER
 0xFFFFFFFF

	)

17 
	#FILESYSTEM_FREECLUSTER
 0x00

	)

19 
	#FILESYSTEM_MAXDIRECTORYENTRYCOUNT
 ((
FILESYSTEM_SECTORPERCLUSTER
*512)/(
DIRECTORYENTRY
))

	)

21 
	#FILESYSTEM_CLUSTERSIZE
 (
FILESYSTEM_SECTORPERCLUSTER
*512)

	)

24 
	#FILESYSTEM_HANDLE_MAXCOUNT
 (
TASK_MAXCOUNT
*3)

	)

27 
	#FILESYSTEM_MAXFILENAMELENGTH
 24

	)

30 
	#FILESYSTEM_TYPE_FREE
 0

	)

31 
	#FILESYSTEM_TYPE_FILE
 1

	)

32 
	#FILESYSTEM_TYPE_DIRECTORY
 2

	)

35 
	#FILESYSTEM_SEEK_SET
 0

	)

36 
	#FILESYSTEM_SEEK_CUR
 1

	)

37 
	#FILESYSTEM_SEEK_END
 2

	)

40 
	$BOOL
 (*
	tfRdHDDInfmi
(
	tBOOL
 
	tbPrimy
,BOOL 
	tbMa
,
	tHDDINFORMATION
* 
	tpHDDInfmi
);

41 (*
	tfRdHDDSe
(
	tBOOL
 
	tbPrimy
,BOOL 
	tbMa
,
	tDWORD
 
	tdwLBA
,
	tiSeCou
,* 
	tpcBufr
);

42 (*
	tfWreHDDSe
(
	tBOOL
 
	tbPrimy
,BOOL 
	tbMa
,
	tDWORD
 
	tdwLBA
,
	tiSeCou
,* 
	tpcBufr
);

45 
	#fݒ
 
kOnFe


	)

46 
	#d
 
kRdFe


	)

47 
	#fwre
 
kWreFe


	)

48 
	#fek
 
kSkFe


	)

49 
	#fo
 
kCloFe


	)

50 
	#move
 
kRemoveFe


	)

51 
	#ݒd
 
kOnDey


	)

52 
	#add
 
kRdDey


	)

53 
	#wdd
 
kRewdDey


	)

54 
	#od
 
kCloDey


	)

57 
	#SEEK_SET
 
FILESYSTEM_SEEK_SET


	)

58 
	#SEEK_CUR
 
FILESYSTEM_SEEK_CUR


	)

59 
	#SEEK_END
 
FILESYSTEM_SEEK_END


	)

62 
	#size_t
 
DWORD


	)

63 
	#dt
 
kDeyErySu


	)

64 
	#d_me
 
vcFeName


	)

68 #agm
	`ck
(
push
,1)

71 
	skPtiSu


74 
BYTE
 
bBoabFg
;

76 
BYTE
 
vbSgCHSAddss
[3];

78 
BYTE
 
bPtiTy
;

80 
BYTE
 
vbEndgCHSAddss
[3];

82 
DWORD
 
dwSgLBAAddss
;

84 
DWORD
 
dwSizeInSe
;

85 } 
	tPARTITION
;

88 
	skMBRSu


91 
BYTE
 
vbBoCode
[430];

94 
DWORD
 
dwSigtu
;

96 
DWORD
 
dwRervedSeCou
;

98 
DWORD
 
dwCluLkSeCou
;

100 
DWORD
 
dwTٮCluCou
;

103 
PARTITION
 
vPt
[4];

106 
BYTE
 
vbBoLdSigtu
[2];

107 } 
	tMBR
;

110 
	skDeyErySu


113 
vcFeName
[
FILESYSTEM_MAXFILENAMELENGTH
];

115 
DWORD
 
dwFeSize
;

117 
DWORD
 
dwSCluIndex
;

118 } 
	tDIRECTORYENTRY
;

121 
	skFeHdSu


124 
iDeyEryOfft
;

126 
DWORD
 
dwFeSize
;

128 
DWORD
 
dwSCluIndex
;

130 
DWORD
 
dwCutCluIndex
;

132 
DWORD
 
dwPviousCluIndex
;

134 
DWORD
 
dwCutOfft
;

135 } 
	tFILEHANDLE
;

138 
	skDeyHdSu


141 
DIRECTORYENTRY
* 
pDeyBufr
;

144 
iCutOfft
;

145 } 
	tDIRECTORYHANDLE
;

148 
	skFeDeyHdSu


151 
BYTE
 
bTy
;

157 
FILEHANDLE
 
FeHd
;

159 
DIRECTORYHANDLE
 
DeyHd
;

161 } 
	tFILE
, 
	tDIR
;

165 
	skFeSyemMagSu


168 
BOOL
 
bMoued
;

171 
DWORD
 
dwRervedSeCou
;

172 
DWORD
 
dwCluLkAaSAddss
;

173 
DWORD
 
dwCluLkAaSize
;

174 
DWORD
 
dwDaAaSAddss
;

176 
DWORD
 
dwTٮCluCou
;

179 
DWORD
 
dwLaAoduLkSeOfft
;

182 
MUTEX
 
Mux
;

185 
FILE
* 
pHdPo
;

188 
BOOL
 
bCacheEb
;

189 } 
	tFILESYSTEMMANAGER
;

191 #agm
	`ck
(
p
)

194 
BOOL
 
	`kInlizeFeSyem
();

195 
BOOL
 
	`kFm
();

196 
BOOL
 
	`kMou
();

197 
BOOL
 
	`kGHDDInfmi
(
HDDINFORMATION
* 
pInfmi
);

200 
	`kGFeSyemInfmi
(
FILESYSTEMMANAGER
* 
pMag
);

203 
FILE
* 
	`kOnFe
(cڡ * 
pcFeName
,cڡ * 
pcMode
);

204 
DWORD
 
	`kRdFe
(* 
pvBufr
,DWORD 
dwSize
,DWORD 
dwCou
,
FILE
* 
pFe
);

205 
DWORD
 
	`kWreFe
(cڡ * 
pvBufr
,DWORD 
dwSize
,DWORD 
dwCou
,
FILE
* 
pFe
);

206 
	`kSkFe
(
FILE
* 
pFe
,
iOfft
,
iOrig
);

207 
	`kCloFe
(
FILE
* 
pFe
);

208 
	`kRemoveFe
(cڡ * 
pcFeName
);

209 
DIR
* 
	`kOnDey
(cڡ * 
pcDeyName
);

210 
kDeyErySu
* 
	`kRdDey
(
DIR
* 
pDey
);

211 
	`kRewdDey
(
DIR
* 
pDey
);

212 
	`kCloDey
(
DIR
* 
pDey
);

213 
BOOL
 
	`kWreZo
(
FILE
* 
pFe
,
DWORD
 
dwCou
);

214 
BOOL
 
	`kIsFeOd
(cڡ 
DIRECTORYENTRY
* 
pEry
);

217 
BOOL
 
	`kFlushFeSyemCache
();

	@/home/jk/os/MINT64/02.Kernel64/Source/HardDisk.c

1 
	~"HdDisk.h
"

4 
HDDMANAGER
 
	ggs_HDDMag
;

7 
kSwByInWd
(
WORD
* 
pwDa
,
iWdCou
);

8 
BYTE
 
kRdHDDStus
(
BOOL
 
bPrimy
);

9 
BOOL
 
kIsHDDBusy
(BOOL 
bPrimy
);

10 
BOOL
 
kISHDDRdy
(BOOL 
bPrimy
);

11 
BOOL
 
kWaFHDDNoBusy
(BOOL 
bPrimy
);

12 
BOOL
 
kWaFHDDIru
(BOOL 
bPrimy
);

15 
BOOL
 
	$kInlizeHDD
()

18 
	`kInlizeMux
(&(
gs_HDDMag
.
Mux
));

21 
gs_HDDMag
.
bPrimyIruOccur
 = 
FALSE
;

22 
gs_HDDMag
.
bSecdyIruOccur
 = 
FALSE
;

26 
	`kOutPtBy
(
HDD_PORT_PRIMARYBASE
+
HDD_PORT_INDEX_DIGITALOUTPUT
,0);

27 
	`kOutPtBy
(
HDD_PORT_SECONDARYBASE
+
HDD_PORT_INDEX_DIGITALOUTPUT
,0);

30 if(
	`kRdHDDInfmi
(
TRUE
,TRUE,&(
gs_HDDMag
.
HDDInfmi
))==
FALSE
)

32 
gs_HDDMag
.
bHDDDeed
 = 
FALSE
;

33 
gs_HDDMag
.
bCWre
 = 
FALSE
;

34  
FALSE
;

38 
gs_HDDMag
.
bHDDDeed
 = 
TRUE
;

39 if(
	`kMemCmp
(
gs_HDDMag
.
HDDInfmi
.
vwModNumb
,"QEMU",4)==0)

41 
gs_HDDMag
.
bCWre
 = 
TRUE
;

45 
gs_HDDMag
.
bCWre
 = 
FALSE
;

48  
TRUE
;

49 
	}
}

52 
BYTE
 
	$kRdHDDStus
(
BOOL
 
bPrimy
)

54 if(
bPrimy
 =
TRUE
)

57  
	`kInPtBy
(
HDD_PORT_PRIMARYBASE
+
HDD_PORT_INDEX_STATUS
);

60  
	`kInPtBy
(
HDD_PORT_SECONDARYBASE
+
HDD_PORT_INDEX_STATUS
);

61 
	}
}

64 
BOOL
 
	$kWaFHDDNoBusy
(
BOOL
 
bPrimy
)

66 
QWORD
 
qwSTickCou
;

67 
BYTE
 
bStus
;

70 
qwSTickCou
 = 
	`kGTickCou
();

73 (
	`kGTickCou
()-
qwSTickCou
)<=
HDD_WAITTIME
)

76 
bStus
 = 
	`kRdHDDStus
(
bPrimy
);

79 if((
bStus
&
HDD_STATUS_BUSY
)!=HDD_STATUS_BUSY)

81  
TRUE
;

84 
	`kS˕
(1);

87  
FALSE
;

88 
	}
}

91 
BOOL
 
	$kWaFHDDRdy
(
BOOL
 
bPrimy
)

93 
QWORD
 
qwSTickCou
;

94 
BYTE
 
bStus
;

97 
qwSTickCou
 = 
	`kGTickCou
();

100 (
	`kGTickCou
()-
qwSTickCou
)<=
HDD_WAITTIME
)

103 
bStus
 = 
	`kRdHDDStus
(
bPrimy
);

106 if((
bStus
&
HDD_STATUS_READY
)==HDD_STATUS_READY)

108  
TRUE
;

111 
	`kS˕
(1);

114  
FALSE
;

115 
	}
}

118 
	$kSHDDIruFg
(
BOOL
 
bPrimy
,BOOL 
bFg
)

120 if(
bPrimy
==
TRUE
)

122 
gs_HDDMag
.
bPrimyIruOccur
 = 
bFg
;

126 
gs_HDDMag
.
bSecdyIruOccur
 = 
bFg
;

128 
	}
}

131 
BOOL
 
	$kWaFHDDIru
(
BOOL
 
bPrimy
)

133 
QWORD
 
qwTickCou
;

136 
qwTickCou
 = 
	`kGTickCou
();

139 (
	`kGTickCou
()-
qwTickCou
)<=
HDD_WAITTIME
)

142 if((
bPrimy
==
TRUE
)&&(
gs_HDDMag
.
bPrimyIruOccur
==TRUE))

144  
TRUE
;

146 if((
bPrimy
==
FALSE
)&&(
gs_HDDMag
.
bSecdyIruOccur
==
TRUE
))

148  
TRUE
;

153  
FALSE
;

154 
	}
}

157 
BOOL
 
	$kRdHDDInfmi
(
BOOL
 
bPrimy
,BOOL 
bMa
,
HDDINFORMATION
* 
pHDDInfmi
)

159 
WORD
 
wPtBa
;

160 
QWORD
 
qwLaTickCou
;

161 
BYTE
 
bStus
;

162 
BYTE
 
bDriveFg
;

163 
i
;

164 
WORD
 
wTemp
;

165 
BOOL
 
bWaResu
;

168 if(
bPrimy
==
TRUE
)

171 
wPtBa
 = 
HDD_PORT_PRIMARYBASE
;

176 
wPtBa
 = 
HDD_PORT_SECONDARYBASE
;

180 
	`kLock
(&(
gs_HDDMag
.
Mux
));

183 if(
	`kWaFHDDNoBusy
(
bPrimy
)==
FALSE
)

186 
	`kUock
(&(
gs_HDDMag
.
Mux
));

187  
FALSE
;

195 if(
bMa
==
TRUE
)

198 
bDriveFg
 = 
HDD_DRIVEANDHEAD_LBA
;

203 
bDriveFg
 = 
HDD_DRIVEANDHEAD_LBA
 | 
HDD_DRIVEANDHEAD_SLAVE
;

207 
	`kOutPtBy
(
wPtBa
+
HDD_PORT_INDEX_DRIVEANDHEAD
,
bDriveFg
);

213 if(
	`kWaFHDDRdy
(
bPrimy
)==
FALSE
)

216 
	`kUock
(&(
gs_HDDMag
.
Mux
));

217  
FALSE
;

221 
	`kSHDDIruFg
(
bPrimy
,
FALSE
);

224 
	`kOutPtBy
(
wPtBa
+
HDD_PORT_INDEX_COMMAND
,
HDD_COMMAND_IDENTIFY
);

227 
bWaResu
 = 
	`kWaFHDDIru
(
bPrimy
);

229 
bStus
 = 
	`kRdHDDStus
(
bPrimy
);

230 if((
bWaResu
==
FALSE
)||((
bStus
&
HDD_STATUS_ERROR
)==HDD_STATUS_ERROR))

233 
	`kUock
(&(
gs_HDDMag
.
Mux
));

234  
FALSE
;

241 
i
=0;i<512/2;i++)

243 ((
WORD
*)
pHDDInfmi
)[
i
]=
	`kInPtWd
(
wPtBa
+
HDD_PORT_INDEX_DATA
);

247 
	`kSwByInWd
(
pHDDInfmi
->
vwModNumb
,(pstHDDInformation->vwModelNumber)/2);

248 
	`kSwByInWd
(
pHDDInfmi
->
vwSlNumb
,(pstHDDInformation->vwSerialNumber)/2);

251 
	`kUock
(&(
gs_HDDMag
.
Mux
));

252  
TRUE
;

253 
	}
}

256 
	$kSwByInWd
(
WORD
* 
pwDa
,
iWdCou
)

258 
i
;

259 
WORD
 
wTemp
;

261 
i
=0;i<
iWdCou
;i++)

263 
wTemp
 = 
pwDa
[
i
];

264 
pwDa
[
i
]=(
wTemp
>>8)|(wTemp<<8);

266 
	}
}

271 
	$kRdHDDSe
(
BOOL
 
bPrimy
,BOOL 
bMa
,
DWORD
 
dwLBA
,
iSeCou
,* 
pcBufr
)

273 
WORD
 
wPtBa
;

274 
i
,
j
;

275 
BYTE
 
bDriveFg
;

276 
BYTE
 
bStus
;

277 
lRdCou
=0;

278 
BOOL
 
bWaResu
;

281 if((
gs_HDDMag
.
bHDDDeed
==
FALSE
)||(
iSeCou
<=0)||(256<iSeCou)||((
dwLBA
+iSeCou)>=gs_HDDMag.
HDDInfmi
.
dwTٮSes
))

287 if(
bPrimy
==
TRUE
)

290 
wPtBa
 = 
HDD_PORT_PRIMARYBASE
;

295 
wPtBa
 = 
HDD_PORT_SECONDARYBASE
;

299 
	`kLock
(&(
gs_HDDMag
.
Mux
));

302 if(
	`kWaFHDDNoBusy
(
bPrimy
)==
FALSE
)

305 
	`kUock
(&(
gs_HDDMag
.
Mux
));

306  
FALSE
;

314 
	`kOutPtBy
(
wPtBa
+
HDD_PORT_INDEX_SECTORCOUNT
,
iSeCou
);

316 
	`kOutPtBy
(
wPtBa
+
HDD_PORT_INDEX_SECTORNUMBER
,
dwLBA
);

318 
	`kOutPtBy
(
wPtBa
+
HDD_PORT_INDEX_CYLINDERLSB
,
dwLBA
>>8);

320 
	`kOutPtBy
(
wPtBa
+
HDD_PORT_INDEX_CYLINDERMSB
,
dwLBA
>>16);

322 if(
bMa
==
TRUE
)

324 
bDriveFg
 = 
HDD_DRIVEANDHEAD_LBA
;

328 
bDriveFg
 = 
HDD_DRIVEANDHEAD_LBA
|
HDD_DRIVEANDHEAD_SLAVE
;

332 
	`kOutPtBy
(
wPtBa
+
HDD_PORT_INDEX_DRIVEANDHEAD
,
bDriveFg
|((
dwLBA
>>24)&0x0F));

338 if(
	`kWaFHDDRdy
(
bPrimy
)==
FALSE
)

341 
	`kUock
(&(
gs_HDDMag
.
Mux
));

342  
FALSE
;

346 
	`kSHDDIruFg
(
bPrimy
,
FALSE
);

349 
	`kOutPtBy
(
wPtBa
+
HDD_PORT_INDEX_COMMAND
,
HDD_COMMAND_READ
);

355 
i
=0;i<
iSeCou
;i++)

358 
bStus
 = 
	`kRdHDDStus
(
bPrimy
);

359 if((
bStus
&
HDD_STATUS_ERROR
)==HDD_STATUS_ERROR)

361 
	`kPrtf
("Error Occur\n");

363 
	`kUock
(&(
gs_HDDMag
.
Mux
));

364  
i
;

368 if((
bStus
&
HDD_STATUS_DATAREQUEST
)!=HDD_STATUS_DATAREQUEST)

371 
bWaResu
 = 
	`kWaFHDDIru
(
bPrimy
);

372 
	`kSHDDIruFg
(
bPrimy
,
FALSE
);

374 if(
bWaResu
==
FALSE
)

377 if((
bStus
&
HDD_STATUS_DATAREQUEST
)!=HDD_STATUS_DATAREQUEST)

379 
	`kPrtf
("Interrupt Not Occur\n");

381 
	`kUock
(&(
gs_HDDMag
.
Mux
));

382  
FALSE
;

388 
j
=0;j<512/2;j++)

390 ((
WORD
*)
pcBufr
)[
lRdCou
++]=
	`kInPtWd
(
wPtBa
+
HDD_PORT_INDEX_DATA
);

395 
	`kUock
(&(
gs_HDDMag
.
Mux
));

396  
i
;

397 
	}
}

402 
	$kWreHDDSe
(
BOOL
 
bPrimy
,BOOL 
bMa
,
DWORD
 
dwLBA
,
iSeCou
,* 
pcBufr
)

404 
WORD
 
wPtBa
;

405 
WORD
 
WTemp
;

406 
i
,
j
;

407 
BYTE
 
bDriveFg
;

408 
BYTE
 
bStus
;

409 
lRdCou
=0;

410 
BOOL
 
bWaResu
;

413 if((
gs_HDDMag
.
bCWre
==
FALSE
)||(
iSeCou
<=0)||(256<iSeCou)||((
dwLBA
+iSeCou)>=gs_HDDMag.
HDDInfmi
.
dwTٮSes
))

419 if(
bPrimy
==
TRUE
)

422 
wPtBa
 = 
HDD_PORT_PRIMARYBASE
;

427 
wPtBa
 = 
HDD_PORT_SECONDARYBASE
;

431 if(
	`kWaFHDDNoBusy
(
bPrimy
)==
FALSE
)

433  
FALSE
;

437 
	`kLock
(&(
gs_HDDMag
.
Mux
));

443 
	`kOutPtBy
(
wPtBa
+
HDD_PORT_INDEX_SECTORCOUNT
,
iSeCou
);

445 
	`kOutPtBy
(
wPtBa
+
HDD_PORT_INDEX_SECTORNUMBER
,
dwLBA
);

447 
	`kOutPtBy
(
wPtBa
+
HDD_PORT_INDEX_CYLINDERLSB
,
dwLBA
>>8);

449 
	`kOutPtBy
(
wPtBa
+
HDD_PORT_INDEX_CYLINDERMSB
,
dwLBA
>>16);

451 if(
bMa
==
TRUE
)

453 
bDriveFg
 = 
HDD_DRIVEANDHEAD_LBA
;

457 
bDriveFg
 = 
HDD_DRIVEANDHEAD_LBA
|
HDD_DRIVEANDHEAD_SLAVE
;

461 
	`kOutPtBy
(
wPtBa
+
HDD_PORT_INDEX_DRIVEANDHEAD
,
bDriveFg
|((
dwLBA
>>24)&0x0F));

467 if(
	`kWaFHDDRdy
(
bPrimy
)==
FALSE
)

470 
	`kUock
(&(
gs_HDDMag
.
Mux
));

471  
FALSE
;

476 
	`kOutPtBy
(
wPtBa
+
HDD_PORT_INDEX_COMMAND
,
HDD_COMMAND_WRITE
);

481 
bStus
 = 
	`kRdHDDStus
(
bPrimy
);

483 if((
bStus
&
HDD_STATUS_ERROR
)==HDD_STATUS_ERROR)

486 
	`kUock
(&(
gs_HDDMag
.
Mux
));

491 if((
bStus
&
HDD_STATUS_DATAREQUEST
)==HDD_STATUS_DATAREQUEST)

496 
	`kS˕
(1);

503 
i
=0;i<
iSeCou
;i++)

506 
	`kSHDDIruFg
(
bPrimy
,
FALSE
);

507 
j
=0;j<512/2;j++)

509 
	`kOutPtWd
(
wPtBa
+
HDD_PORT_INDEX_DATA
,((
WORD
*)
pcBufr
)[
lRdCou
++]);

513 
bStus
 = 
	`kRdHDDStus
(
bPrimy
);

514 if((
bStus
&
HDD_STATUS_ERROR
)==HDD_STATUS_ERROR)

517 
	`kUock
(&(
gs_HDDMag
.
Mux
));

518  
i
;

522 if((
bStus
&
HDD_STATUS_DATAREQUEST
)!=HDD_STATUS_DATAREQUEST)

525 
bWaResu
 = 
	`kWaFHDDIru
(
bPrimy
);

526 
	`kSHDDIruFg
(
bPrimy
,
FALSE
);

528 if(
bWaResu
==
FALSE
)

530 if((
bStus
&
HDD_STATUS_DATAREQUEST
)!=HDD_STATUS_DATAREQUEST)

533 
	`kPrtf
("Interrupt Not Occur\n");

534 
	`kUock
(&(
gs_HDDMag
.
Mux
));

535  
FALSE
;

543 
	`kUock
(&(
gs_HDDMag
.
Mux
));

544  
i
;

545 
	}
}

	@/home/jk/os/MINT64/02.Kernel64/Source/HardDisk.h

1 #ide
__HARDDISK_H__


2 
	#__HARDDISK_H__


	)

4 
	~"Tys.h
"

5 
	~"Synchrizi.h
"

9 
	#HDD_PORT_PRIMARYBASE
 0x1F0

	)

10 
	#HDD_PORT_SECONDARYBASE
 0x170

	)

13 
	#HDD_PORT_INDEX_DATA
 0x00

	)

14 
	#HDD_PORT_INDEX_SECTORCOUNT
 0x02

	)

15 
	#HDD_PORT_INDEX_SECTORNUMBER
 0x03

	)

16 
	#HDD_PORT_INDEX_CYLINDERLSB
 0x04

	)

17 
	#HDD_PORT_INDEX_CYLINDERMSB
 0x05

	)

18 
	#HDD_PORT_INDEX_DRIVEANDHEAD
 0x06

	)

19 
	#HDD_PORT_INDEX_STATUS
 0x07

	)

20 
	#HDD_PORT_INDEX_COMMAND
 0x07

	)

21 
	#HDD_PORT_INDEX_DIGITALOUTPUT
 0x206

	)

24 
	#HDD_COMMAND_READ
 0x20

	)

25 
	#HDD_COMMAND_WRITE
 0x30

	)

26 
	#HDD_COMMAND_IDENTIFY
 0xEC

	)

29 
	#HDD_STATUS_ERROR
 0x01

	)

30 
	#HDD_STATUS_INDEX
 0x02

	)

31 
	#HDD_STATUS_CORRECTEDDATA
 0x04

	)

32 
	#HDD_STATUS_DATAREQUEST
 0x08

	)

33 
	#HDD_STATUS_SEEKCOMPLETE
 0x10

	)

34 
	#HDD_STATUS_WRITEFAULT
 0x20

	)

35 
	#HDD_STATUS_READY
 0x40

	)

36 
	#HDD_STATUS_BUSY
 0x80

	)

39 
	#HDD_DRIVEANDHEAD_LBA
 0xE0

	)

40 
	#HDD_DRIVEANDHEAD_SLAVE
 0x10

	)

43 
	#HDD_DIGITALOUTPUT_RESET
 0x04

	)

44 
	#HDD_DIGITALOUTPUT_DISABLEINTERRUPT
 0x01

	)

47 
	#HDD_WAITTIME
 500

	)

49 
	#HDD_MAXBULKSECTORCOUNT
 256

	)

53 #agm
ck
(
push
,1)

55 
	skHDDInfmiSu


58 
WORD
 
	mwCfigui
;

61 
WORD
 
	mwNumbOfCyld
;

62 
WORD
 
	mwRerved1
;

65 
WORD
 
	mwNumbOfHd
;

66 
WORD
 
	mwUnfmdByPTck
;

67 
WORD
 
	mwUnfmdByPSe
;

70 
WORD
 
	mwNumbOfSePCyld
;

71 
WORD
 
	mwISeG
;

72 
WORD
 
	mwBysInPhaLock
;

73 
WORD
 
	mwNumbOfVdUniqueStusWd
;

76 
WORD
 
	mvwSlNumb
[10];

77 
WORD
 
	mwCڌrTy
;

78 
WORD
 
	mwBufrSize
;

79 
WORD
 
	mwNumbOfECCBys
;

80 
WORD
 
	mvwFmweRevisi
[4];

83 
WORD
 
	mvwModNumb
[20];

84 
WORD
 
	mvwRerved2
[13];

87 
DWORD
 
	mdwTٮSes
;

88 
WORD
 
	mvwRerved3
[196];

89 } 
	tHDDINFORMATION
;

91 #agm
ck
(
p
)

94 
	skHDDMagSu


97 
BOOL
 
	mbHDDDeed
;

98 
BOOL
 
	mbCWre
;

101 vީ
BOOL
 
	mbPrimyIruOccur
;

102 vީ
BOOL
 
	mbSecdyIruOccur
;

103 
MUTEX
 
	mMux
;

106 
HDDINFORMATION
 
	mHDDInfmi
;

107 } 
	tHDDMANAGER
;

109 
BOOL
 
kInlizeHDD
();

110 
BOOL
 
kRdHDDInfmi
(BOOL 
bPrimy
,BOOL 
bMa
,
HDDINFORMATION
* 
pHDDInfmi
);

111 
kRdHDDSe
(
BOOL
 
bPrimy
,BOOL 
bMa
,
DWORD
 
dwLBA
,
iSeCou
,* 
pcBufr
);

112 
kWreHDDSe
(
BOOL
 
bPrimy
,BOOL 
bMa
,
DWORD
 
dwLBA
,
iSeCou
,* 
pcBufr
);

113 
kSHDDIruFg
(
BOOL
 
bPrimy
,BOOL 
bFg
);

	@/home/jk/os/MINT64/02.Kernel64/Source/IOAPIC.c

1 
	~"IOAPIC.h
"

2 
	~"MPCfigutiTab.h
"

3 
	~"PIC.h
"

6 
IOAPICMANAGER
 
	ggs_IOAPICMag
;

9 
QWORD
 
	$kGIOAPICBaAddssOfISA
()

11 
MPCONFIGURATIONMANAGER
* 
pMPMag
;

12 
IOAPICENTRY
* 
pIOAPICEry
;

15 if(
gs_IOAPICMag
.
qwIOAPICBaAddssOfISA
==
NULL
)

17 
pIOAPICEry
 = 
	`kFdIOAPICEryFISA
();

19 if(
pIOAPICEry
!=
NULL
)

21 
gs_IOAPICMag
.
qwIOAPICBaAddssOfISA
 = 
pIOAPICEry
->
dwMemyMAddss
&0xFFFFFFFF;

26  
gs_IOAPICMag
.
qwIOAPICBaAddssOfISA
;

27 
	}
}

30 
	$kSIOAPICRedeiEry
(
IOREDIRECTIONTABLE
* 
pEry
,
BYTE
 
bAPICID
,BYTE 
bIruMask
,BYTE 
bFgsAndDivyMode
,BYTE 
bVe
)

32 
	`kMemS
(
pEry
,0,(
IOREDIRECTIONTABLE
));

34 
pEry
->
bDei
 = 
bAPICID
;

35 
pEry
->
bFgsAndDivyMode
 = bFlagsAndDeliveryMode;

36 
pEry
->
bIruMask
 = bInterruptMask;

37 
pEry
->
bVe
 = bVector;

38 
	}
}

41 
	$kRdIOAPICRedeiTab
(
iINTIN
,
IOREDIRECTIONTABLE
* 
pEry
)

43 
QWORD
* 
pqwDa
;

44 
QWORD
 
qwIOAPICBaAddss
;

47 
qwIOAPICBaAddss
 = 
	`kGIOAPICBaAddssOfISA
();

50 
pqwDa
 = (
QWORD
*)
pEry
;

58 *(
DWORD
*)(
qwIOAPICBaAddss
 + 
IOAPIC_REGISTER_IOREGISTERSELECTOR

IOAPIC_REGISTERINDEX_HIGHIOREDIRECTIONTABLE
 +
iINTIN
*2;

60 *
pqwDa
 = *(
DWORD
*)(
qwIOAPICBaAddss
 + 
IOAPIC_REGISTER_IOWINDOW
);

61 *
pqwDa
 = *pqwData<<32;

69 *(
DWORD
*)(
qwIOAPICBaAddss
 + 
IOAPIC_REGISTER_IOREGISTERSELECTOR

IOAPIC_REGISTERINDEX_LOWIOREDIRECTIONTABLE
 +
iINTIN
*2;

71 *
pqwDa
 |*(
DWORD
*)(
qwIOAPICBaAddss
 + 
IOAPIC_REGISTER_IOWINDOW
);

72 
	}
}

75 
	$kWreIOAPICRedeiTab
(
iINTIN
,
IOREDIRECTIONTABLE
* 
pEry
)

77 
QWORD
* 
pqwDa
;

78 
QWORD
 
qwIOAPICBaAddss
;

81 
qwIOAPICBaAddss
 = 
	`kGIOAPICBaAddssOfISA
();

84 
pqwDa
 = (
QWORD
*)
pEry
;

93 *(
DWORD
*)(
qwIOAPICBaAddss
 + 
IOAPIC_REGISTER_IOREGISTERSELECTOR

IOAPIC_REGISTERINDEX_HIGHIOREDIRECTIONTABLE
 +
iINTIN
*2;

95 *(
DWORD
*)(
qwIOAPICBaAddss
 + 
IOAPIC_REGISTER_IOWINDOW
*
pqwDa
>>32;

103 *(
DWORD
*)(
qwIOAPICBaAddss
 + 
IOAPIC_REGISTER_IOREGISTERSELECTOR

IOAPIC_REGISTERINDEX_LOWIOREDIRECTIONTABLE
 +
iINTIN
*2;

105 *(
DWORD
*)(
qwIOAPICBaAddss
 +
IOAPIC_REGISTER_IOWINDOW
*
pqwDa
;

106 
	}
}

110 
	$kMaskAIruInIOAPIC
()

112 
IOREDIRECTIONTABLE
 
Ery
;

113 
i
;

116 
i
=0;i<
IOAPIC_MAXIOREDIRECTIONTABLECOUNT
;i++)

119 
	`kRdIOAPICRedeiTab
(
i
,&
Ery
);

120 
Ery
.
bIruMask
 = 
IOAPIC_INTERRUPT_MASK
;

121 
	`kWreIOAPICRedeiTab
(
i
,&
Ery
);

123 
	}
}

126 
	$kInlizeRedeiTab
()

128 
MPCONFIGURATIONMANAGER
* 
MPMag
;

129 
MPCONFIGURATIONTABLEHEADER
* 
pMPHd
;

130 
IOINTERRUPTASSIGNMENTENTRY
* 
pIOAssignmtEry
;

131 
IOREDIRECTIONTABLE
 
IORedeiEry
;

132 
QWORD
 
qwEryAddss
;

133 
BYTE
 
bEryTy
;

134 
BYTE
 
bDei
;

135 
i
;

140 
	`kMemS
(&
gs_IOAPICMag
,0,(gs_stIOAPICManager));

143 
	`kGIOAPICBaAddssOfISA
();

	@/home/jk/os/MINT64/02.Kernel64/Source/IOAPIC.h

1 #ide
__IOAPIC_H__


2 
	#__IOAPIC_H__


	)

4 
	~"Tys.h
"

8 
	#IOAPIC_REGISTER_IOREGISTERSELECTOR
 0x00

	)

9 
	#IOAPIC_REGISTER_IOWINDOW
 0x10

	)

12 
	#IOAPIC_REGISTERINDEX_IOAPICID
 0x00

	)

13 
	#IOAPIC_REGISTERINDEX_IOAPICVERSION
 0x01

	)

14 
	#IOAPIC_REGISTERINDEX_IOAPICARBID
 0x02

	)

15 
	#IOAPIC_REGISTERINDEX_LOWIOREDIRECTIONTABLE
 0x10

	)

16 
	#IOAPIC_REGISTERINDEX_HIGHIOREDIRECTIONTABLE
 0x11

	)

19 
	#IOAPIC_MAXIOREDIRECTIONTABLECOUNT
 24

	)

22 
	#IOAPIC_INTERRUPT_MASK
 0x01

	)

25 
	#IOAPIC_TRIGGERMODE_LEVEL
 0x80

	)

26 
	#IOAPIC_TRIGGERMODE_EDGE
 0x00

	)

29 
	#IOAPIC_REMOTEIRR_EOI
 0x40

	)

30 
	#IOAPIC_REMOTEIRR_ACCEPT
 0x00

	)

33 
	#IOAPIC_POLARITY_ACTIVELOW
 0x20

	)

34 
	#IOAPIC_POLARITY_ACTIVEHIGH
 0x00

	)

37 
	#IOAPIC_DELIVERYSTATUS_SENDPENDING
 0x10

	)

38 
	#IOAPIC_DELIVERYSTATUS_IDLE
 0x00

	)

41 
	#IOAPIC_DESTINATIONMODE_LOGICALMODE
 0x08

	)

42 
	#IOAPIC_DESTINATIONMODE_PHYSICALMODE
 0x00

	)

45 
	#IOAPIC_DELIVERYMODE_FIXED
 0x00

	)

46 
	#IOAPIC_DELIVERYMODE_LOWESTPRIORITY
 0x01

	)

47 
	#IOAPIC_DELIVERYMODE_SMI
 0x02

	)

48 
	#IOAPIC_DELIVERYMODE_NMI
 0x04

	)

49 
	#IOAPIC_DELIVERYMODE_INIT
 0x05

	)

50 
	#IOAPIC_DELIVERYMODE_EXTINT
 0x07

	)

53 
	#IOAPIC_MAXIRQTOINTINMAPCOUNT
 16

	)

57 #agm
ck
(
push
,1)

60 
	skIORedeiTabSu


63 
BYTE
 
	mbVe
;

67 
BYTE
 
	mbFgsAndDivyMode
;

70 
BYTE
 
	mbIruMask
;

73 
BYTE
 
	mvbRerved
[4];

76 
BYTE
 
	mbDei
;

77 } 
	tIOREDIRECTIONTABLE
;

79 #agm
ck
(
p
)

82 
	skIOAPICMagSu


85 
QWORD
 
	mqwIOAPICBaAddssOfISA
;

88 
BYTE
 
	mvbIRQToINTINM
[
IOAPIC_MAXIRQTOINTINMAPCOUNT
];

89 } 
	tIOAPICMANAGER
;

92 
QWORD
 
kGIOAPICBaAddssOfISA
();

93 
kSIOAPICRedeiEry
(
IOREDIRECTIONTABLE
* 
pEry
,
BYTE
 
bAPICID
,BYTE 
bIruMask
,BYTE 
bFgsAndDivyMode
,BYTE 
bVe
);

94 
kRdIOAPICRedeiTab
(
iINTIN
,
IOREDIRECTIONTABLE
* 
pEry
);

95 
kWreIOAPICRedeiTab
(
iINTIN
,
IOREDIRECTIONTABLE
* 
pEry
);

96 
kMaskAIruInIOAPIC
();

97 
kInlizeRedeiTab
();

98 
kPrtIRQTOINTINM
();

	@/home/jk/os/MINT64/02.Kernel64/Source/ISR.asm

1 [
BITS
 64] ; 이하의 코드는 64비트 코드로 설정

3 
	gSECTION
 .
	gxt
 ;ext 섹션(세그먼트)을 정의

5 ; 외부에서 정의된 함수를 쓸 수 있도록 선엄함(
	gImpt
)

6 
kCommExiHdr
, 
kCommIruHdr
, 
kKeybrdHdr


7 
kTimHdr
, 
kDeviNAvaabHdr
, 
kHDDHdr


9 ; 
	gC
 언어에서 호출할 수 있도록 이름을 노출함(
	gExpt
)

10 ; 예외(
	gExi
처리를 위한 
ISR


11 
glob
 
	gkISRDivideE
, 
	gkISRDebug
, 
	gkISRNMI
, 
	gkISRBakPot
, 
kISROvow


12 
glob
 
	gkISRBoundRgeExeded
, 
	gkISRInvidOpcode
, 
	gkISRDeviNAvaab
, 
	gkISRDoubFau
,

13 
glob
 
	gkISRCrossSegmtOvrun
, 
	gkISRInvidTSS
, 
kISRSegmtNP


14 
glob
 
	gkISRSckSegmtFau
, 
	gkISRGPrei
, 
	gkISRPageFau
, 
kISR15


15 
glob
 
	gkISRFPUE
, 
	gkISRAlignmtCheck
, 
	gkISRMacheCheck
, 
	gkISRSIMDE
, 
	gkISRETCExi


17 ; 인터럽트(
	gIru
처리를 위한 
ISR


18 
glob
 
	gkISRTim
, 
	gkISRKeybrd
, 
	gkISRSvePIC
, 
	gkISRSl2
, 
	gkISRSl1
, 
kISRPl2


19 
glob
 
	gkISRFlpy
, 
	gkISRPl1
, 
	gkISRRTC
, 
	gkISRRerved
, 
	gkISRNUd1
, 
kISRNUd2


20 
glob
 
	gkISRMou
, 
	gkISRCross
, 
	gkISRHDD1
, 
	gkISRHDD2
, 
	gkISRETCIru


22 ; 
	gcڋxt
를 저장하고 셀렉터를 교체하는 매크로

23 %
mao
 
	gKSAVECONTEXT
 0 ; 파라미터를 전달받지 않는 KSAVECONTEXT 매크로 정의

24 ; 
	gRBP
 레지스터부터 
	gGS
 세그먼트 셀렉터까지 모두 스택에 삽입

25 
push
 
rbp


26 
mov
 
	grbp
, 
r


27 
push
 
x


28 
push
 
rbx


29 
push
 
rcx


30 
push
 
rdx


31 
push
 
rdi


32 
push
 
rsi


33 
push
 
r8


34 
push
 
r9


35 
push
 
r10


36 
push
 
r11


37 
push
 
r12


38 
push
 
r13


39 
push
 
r14


40 
push
 
r15


42 
mov
 
	gax
, 
	gds
 ; 
	gDS
 세그먼트 셀렉터와 
	gES
 세그먼트 셀렉터는 스택에 직접 삽입할 수 없으므로 
	gRAX
 레지스터에 저장한 후 스택에 삽입

43 
push
 
x


44 
mov
 
	gax
, 
es


45 
push
 
x


46 
push
 
fs


47 
push
 
	ggs


50 
mov
 
	gax
, 0x10 ; 
	gAX
 레지스터에 커널 데이터 세그먼트 디스크립터 저장

51 
mov
 
	gds
, 
	gax
 ; 
	gDS
 세그먼트 셀렉터부터 
	gFS
 세그먼트 셀렉터까지 모두 커널 데이터 세그먼트로 교체

52 
mov
 
	ges
, 
ax


53 
mov
 
	ggs
, 
ax


54 
mov
 
	gfs
, 
	gax


55 %
	gdmao
 ; 매크로 끝

58 ; 
	gcڋxt
를 복원하는 매크로

59 %
mao
 
	gKLOADCONTEXT
 0 ; 파라미터를 전달받지 않는 KLOADCONTEXT 매크로 정의

60 ; 
	gGS
 세그먼트 셀렉터부터 
	gRBP
 레지스터까지 모두 스택에서 꺼내 복원

61 
p
 
gs


62 
p
 
fs


63 
p
 
x


64 
mov
 
	ges
, 
	gax
 ; 
	gES
 세그먼트 셀렉터와 
	gDS
 세그먼트 셀렉터는 스택에 직접 꺼내 복원할 수 없으므로 
	gRAX
 레지스터에 저장한 뒤에 복원

65 
p
 
x


66 
mov
 
	gds
, 
ax


68 
p
 
r15


69 
p
 
r14


70 
p
 
r13


71 
p
 
r12


72 
p
 
r11


73 
p
 
r10


74 
p
 
r9


75 
p
 
r8


76 
p
 
rsi


77 
p
 
rdi


78 
p
 
rdx


79 
p
 
rcx


80 
p
 
rbx


81 
p
 
x


82 
p
 
	grbp


83 %
	gdmao
 ; 매크로 끝

90 ; #0, 
Divide
 
E
 
ISR


91 
	gkISRDivideE
:

92 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

95 
mov
 
	grdi
, 0

96 

 
kCommExiHdr


98 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

99 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

101 ; #1, 
Debug
 
ISR


102 
	gkISRDebug
:

103 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

106 
mov
 
	grdi
, 1

107 

 
kCommExiHdr


109 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

110 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

112 ; #2, 
NMI
 
ISR


113 
	gkISRNMI
:

114 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

117 
mov
 
	grdi
, 2

118 

 
kCommExiHdr


120 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

121 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

123 ; #3, 
BakPot
 
ISR


124 
	gkISRBakPot
:

125 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

128 
mov
 
	grdi
, 3

129 

 
kCommExiHdr


131 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

132 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

134 ; #4, 
Ovow
 
ISR


135 
	gkISROvow
:

136 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

139 
mov
 
	grdi
, 4

140 

 
kCommExiHdr


142 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

143 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

145 ; #5, 
Bound
 
Rge
 
Exeded
 
ISR


146 
	gkISRBoundRgeExeded
:

147 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

150 
mov
 
	grdi
, 5

151 

 
kCommExiHdr


153 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

154 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

156 ; #6, 
Invid
 
Opcode
 
ISR


157 
	gkISRInvidOpcode
:

158 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

161 
mov
 
	grdi
, 6

162 

 
kCommExiHdr


164 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

165 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

167 ; #7, 
Devi
 
N
 
Avaab
 
ISR


168 
	gkISRDeviNAvaab
:

169 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

172 
mov
 
	grdi
, 7

173 

 
kDeviNAvaabHdr


175 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

176 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

178 ; #8, 
Doub
 
Fau
 
ISR


179 
	gkISRDoubFau
:

180 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

183 
mov
 
	grdi
, 8

184 
mov
 
	grsi
,
	gqwd
[
rbp
+8]

185 

 
kCommExiHdr


187 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

188 
add
 
	gr
,8 ; 에러 코드를 스택에서 제거

189 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

191 ; #9, 
Cross
 
Segmt
 
Ovrun
 
ISR


192 
	gkISRCrossSegmtOvrun
:

193 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

196 
mov
 
	grdi
, 9

197 

 
kCommExiHdr


199 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

200 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

202 ; #10, 
Invid
 
TSS
 
ISR


203 
	gkISRInvidTSS
:

204 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

207 
mov
 
	grdi
, 10

208 
mov
 
	grsi
, 
	gqwd
[
rbp
+8]

209 

 
kCommExiHdr


211 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

212 
add
 
	gr
, 8 ; 에러 코드를 스택에서 제거

213 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

215 ; #11, 
Segmt
 
N
 
P
 
ISR


216 
	gkISRSegmtNP
:

217 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

220 
mov
 
	grdi
, 11

221 
mov
 
	grsi
, 
	gqwd
[
rbp
+8]

222 

 
kCommExiHdr


224 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

225 
add
 
	gr
, 8 ; 에러 코드를 스택에서 제거

226 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

228 ; #12, 
Sck
 
Segmt
 
Fau
 
ISR


229 
	gkISRSckSegmtFau
:

230 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

233 
mov
 
	grdi
, 12

234 
mov
 
	grsi
, 
	gqwd
[
rbp
+8]

235 

 
kCommExiHdr


237 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

238 
add
 
	gr
, 8 ; 에러 코드를 스택에서 제거

239 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

241 ; #13, 
G
 
Prei
 
ISR


242 
	gkISRGPrei
:

243 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

246 
mov
 
	grdi
, 13

247 
mov
 
	grsi
, 
	gqwd
[
rbp
+8]

248 

 
kCommExiHdr


250 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

251 
add
 
	gr
, 8 ; 에러 코드를 스택에서 제거

252 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

254 ; #14, 
Page
 
Fau
 
ISR


255 
	gkISRPageFau
:

256 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

259 
mov
 
	grdi
, 14

260 
mov
 
	grsi
, 
	gqwd
[
rbp
+8]

261 

 
kCommExiHdr


263 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

264 
add
 
	gr
, 8 ; 에러 코드를 스택에서 제거

265 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

267 ; #15, 
Rerved
 
ISR


268 
	gkISR15
:

269 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

272 
mov
 
	grdi
, 15

273 

 
kCommExiHdr


275 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

276 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

278 ; #16, 
FPU
 
E
 
ISR


279 
	gkISRFPUE
:

280 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

283 
mov
 
	grdi
, 16

284 

 
kCommExiHdr


286 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

287 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

289 ; #17, 
Alignmt
 
Check
 
ISR


290 
	gkISRAlignmtCheck
:

291 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

294 
mov
 
	grdi
, 17

295 
mov
 
	grsi
, 
	gqwd
[
rbp
+8]

296 

 
kCommExiHdr


298 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

299 
add
 
	gr
, 8 ; 에러 코드를 스택에서 제거

300 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

302 ; #18, 
Mache
 
Check
 
ISR


303 
	gkISRMacheCheck
:

304 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

307 
mov
 
	grdi
, 18

308 

 
kCommExiHdr


310 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

311 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

313 ; #19, 
SIME
 
Fltg
 
Pot
 
Exi
 
ISR


314 
	gkISRSIMDE
:

315 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

318 
mov
 
	grdi
, 19

319 

 
kCommExiHdr


321 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

322 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

324 ; #20~#31, 
Rerved
 
ISR


325 
	gkISRETCExi
:

326 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

329 
mov
 
	grdi
, 20

330 

 
kCommExiHdr


332 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

333 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

341 ; #32, 타이머 
ISR


342 
	gkISRTim
:

343 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

346 
mov
 
	grdi
, 32

347 

 
kTimHdr


349 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

350 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

352 ; #33, 키보드 
ISR


353 
	gkISRKeybrd
:

354 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

357 
mov
 
	grdi
, 33

358 

 
kKeybrdHdr


360 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

361 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

363 ; #34, 슬레이브 
PIC
 
ISR


364 
	gkISRSvePIC
:

365 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

368 
mov
 
	grdi
, 34

369 

 
kCommIruHdr


371 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

372 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

374 ; #35, 시리얼 포트 2 
ISR


375 
	gkISRSl2
:

376 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

379 
mov
 
	grdi
, 35

380 

 
kCommIruHdr


382 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

383 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

385 ; #36, 시리얼 포트 1 
ISR


386 
	gkISRSl1
:

387 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

390 
mov
 
	grdi
, 36

391 

 
kCommIruHdr


393 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

394 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

396 ; #37, 패러렐 포트 2 
ISR


397 
	gkISRPl2
:

398 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

401 
mov
 
	grdi
, 37

402 

 
kCommIruHdr


404 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

405 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

407 ; #38, 플로피 디스크 컨트롤러 
ISR


408 
	gkISRFlpy
:

409 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

412 
mov
 
	grdi
, 38

413 

 
kCommIruHdr


415 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

416 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

418 ; #39, 패러렐 포트 1 
ISR


419 
	gkISRPl1
:

420 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

423 
mov
 
	grdi
, 39

424 

 
kCommIruHdr


426 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

427 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

429 ; #40, 
RTC
 
ISR


430 
	gkISRRTC
:

431 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

434 
mov
 
	grdi
, 40

435 

 
kCommIruHdr


437 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

438 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

440 ; #41, 예약된 인터럽트의 
ISR


441 
	gkISRRerved
:

442 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

445 
mov
 
	grdi
, 41

446 

 
kCommIruHdr


448 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

449 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

452 
	gkISRNUd1
:

453 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

456 
mov
 
	grdi
, 42

457 

 
kCommIruHdr


459 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

460 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

463 
	gkISRNUd2
:

464 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

467 
mov
 
	grdi
, 43

468 

 
kCommIruHdr


470 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

471 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

473 ; #44, 마우스 
ISR


474 
	gkISRMou
:

475 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

478 
mov
 
	grdi
, 44

479 

 
kCommIruHdr


481 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

482 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

484 ; #45, 코프로세서 
ISR


485 
	gkISRCross
:

486 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

489 
mov
 
	grdi
, 45

490 

 
kCommIruHdr


492 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

493 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

495 ; #46, 하드 디스크 1 
ISR


496 
	gkISRHDD1
:

497 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

500 
mov
 
	grdi
, 46

501 

 
kHDDHdr


503 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

504 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

506 ; #47, 하드 디스크 2 
ISR


507 
	gkISRHDD2
:

508 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

511 
mov
 
	grdi
, 47

512 

 
kHDDHdr


514 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

515 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

517 ; #48, 이외의 모든 인터럽트에 대한 
ISR


518 
	gkISRETCIru
:

519 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

522 
mov
 
	grdi
, 48

523 

 
kCommIruHdr


525 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

526 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

	@/home/jk/os/MINT64/02.Kernel64/Source/ISR.h

1 #ide
__ISR_H__


2 
	#__ISR_H__


	)

6 
kISRDivideE
( );

7 
kISRDebug
( );

8 
kISRNMI
( );

9 
kISRBakPot
( );

10 
kISROvow
( );

11 
kISRBoundRgeExeded
( );

12 
kISRInvidOpcode
();

13 
kISRDeviNAvaab
( );

14 
kISRDoubFau
( );

15 
kISRCrossSegmtOvrun
( );

16 
kISRInvidTSS
( );

17 
kISRSegmtNP
( );

18 
kISRSckSegmtFau
( );

19 
kISRGPrei
( );

20 
kISRPageFau
( );

21 
kISR15
( );

22 
kISRFPUE
( );

23 
kISRAlignmtCheck
( );

24 
kISRMacheCheck
( );

25 
kISRSIMDE
( );

26 
kISRETCExi
( );

29 
kISRTim
( );

30 
kISRKeybrd
( );

31 
kISRSvePIC
( );

32 
kISRSl2
( );

33 
kISRSl1
( );

34 
kISRPl2
( );

35 
kISRFlpy
( );

36 
kISRPl1
( );

37 
kISRRTC
( );

38 
kISRRerved
( );

39 
kISRNUd1
( );

40 
kISRNUd2
( );

41 
kISRMou
( );

42 
kISRCross
( );

43 
kISRHDD1
( );

44 
kISRHDD2
( );

45 
kISRETCIru
( );

	@/home/jk/os/MINT64/02.Kernel64/Source/InterruptHandler.c

1 
	~"IruHdr.h
"

2 
	~"PIC.h
"

3 
	~"Keybrd.h
"

4 
	~"Cse.h
"

5 
	~"Uty.h
"

6 
	~"Task.h
"

7 
	~"Dest.h
"

8 
	~"AsmblyUty.h
"

9 
	~"HdDisk.h
"

12 
	$kCommExiHdr
(
iVeNumb
,
QWORD
 
qwECode
)

14 
vcBufr
[3]={0,};

17 
vcBufr
[0] = '0'+
iVeNumb
/10;

18 
vcBufr
[1] = '0'+
iVeNumb
%10;

20 
	`kPrtSgXY
( 0, 0, "====================================================" );

21 
	`kPrtSgXY
( 0, 1, " Exception Occur~!!!! " );

22 
	`kPrtSgXY
( 0, 2, " Vector: " );

23 
	`kPrtSgXY
27,2,
vcBufr
);

24 
	`kPrtSgXY
( 0, 3, "====================================================" );

27 
	}
}

30 
	$kCommIruHdr
(
iVeNumb
)

32 
vcBufr
[] ="[INT: , ]";

33 
g_iCommIruCou
=0;

37 
vcBufr
[5]='0'+
iVeNumb
/10;

38 
vcBufr
[6]='0'+
iVeNumb
%10;

40 
vcBufr
[8]='0'+
g_iCommIruCou
;

41 
g_iCommIruCou
=(g_iCommonInterruptCount+1)%10;

42 
	`kPrtSgXY
(70,0,
vcBufr
);

45 
	`kSdEOIToPIC
(
iVeNumb
-
PIC_IRQSTARTVECTOR
);

46 
	}
}

49 
	$kKeybrdHdr
(
iVeNumb
)

52 
vcBufr
[] ="[INT: , ]";

53 
g_iKeybrdIruCou
=0;

54 
BYTE
 
bTemp
;

58 
vcBufr
[5]='0'+
iVeNumb
/10;

59 
vcBufr
[6]='0'+
iVeNumb
%10;

61 
vcBufr
[8]='0'+
g_iKeybrdIruCou
;

62 
g_iKeybrdIruCou
=(g_iKeyboardInterruptCount+1)%10;

63 
	`kPrtSgXY
(0,0,
vcBufr
);

66 if(
	`kIsOuutBufrFu
()==
TRUE
)

68 
bTemp
=
	`kGKeybrdSnCode
();

69 
	`kCvtSnCodeAndPutQueue
(
bTemp
);

73 
	`kSdEOIToPIC
(
iVeNumb
-
PIC_IRQSTARTVECTOR
);

75 
	}
}

78 
	$kTimHdr
(
iVeNumb
)

80 
vcBufr
[] ="[INT: , ]";

81 
g_iTimIruCou
=0;

82 
i
=0;

86 
vcBufr
[5]='0'+
iVeNumb
/10;

87 
vcBufr
[6]='0'+
iVeNumb
%10;

89 
vcBufr
[8]='0'+
g_iTimIruCou
;

90 
g_iTimIruCou
=(g_iTimerInterruptCount+1)%10;

91 
	`kPrtSgXY
(70,0,
vcBufr
);

94 
	`kSdEOIToPIC
(
iVeNumb
-
PIC_IRQSTARTVECTOR
);

97 
g_qwTickCou
++;

101 
	`kDeProssTime
();

103 if(
	`kIsProssTimeExped
()==
TRUE
)

105 
	`kScheduInIru
();

107 
	}
}

111 
	$kDeviNAvaabHdr
(
iVeNumb
)

113 
TCB
* 
pFPUTask
,* 
pCutTask
;

114 
QWORD
 
qwLaFPUTaskID
;

118 
vcBufr
[] = "[EXC: , ]";

119 
g_iFPUIruCou
=0;

122 
vcBufr
[5] = '0' + 
iVeNumb
/10;

123 
vcBufr
[7] = '0' + 
iVeNumb
%10;

125 
vcBufr
[8] = '0' + 
g_iFPUIruCou
;

126 
g_iFPUIruCou
 = (g_iFPUInterruptCount+1)%10;

127 
	`kPrtSgXY
(0,0,
vcBufr
);

131 
	`kCˬTS
();

134 
qwLaFPUTaskID
 = 
	`kGLaFPUUdTaskID
();

135 
pCutTask
 = 
	`kGRugTask
();

138 if
qwLaFPUTaskID
 =
pCutTask
->
Lk
.
qwID
)

143 if(
qwLaFPUTaskID
!=
TASK_INVALIDID
)

145 
pFPUTask
 = 
	`kGTCBInTCBPo
(
	`GETTCBOFFSET
(
qwLaFPUTaskID
));

146 if((
pFPUTask
!=
NULL
)&&աFPUTask->
Lk
.
qwID
==
qwLaFPUTaskID
))

148 
	`kSaveFPUCڋxt
(
pFPUTask
->
vqwFPUCڋxt
);

154 if(
pCutTask
->
bFPUUd
 ==
FALSE
)

156 
	`kInlizeFPU
();

157 
pCutTask
->
bFPUUd
 = 
TRUE
;

161 
	`kLdFPUCڋxt
(
pCutTask
->
vqwFPUCڋxt
);

165 
	`kSLaFPUUdTaskID
(
pCutTask
->
Lk
.
qwID
);

166 
	}
}

169 
	$kHDDHdr
(
iVeNumb
)

171 
vcBufr
[]="[INT: , ]";

172 
g_iHDDIruCou
=0;

173 
BYTE
 
bTemp
;

178 
vcBufr
[5] = '0' + 
iVeNumb
/10;

179 
vcBufr
[6] = '0' + 
iVeNumb
%10;

181 
vcBufr
[8] = '0' + 
g_iHDDIruCou
;

182 
g_iHDDIruCou
 = (g_iHDDInterruptCount+1)%10;

184 
	`kPrtSgXY
(10,0,
vcBufr
);

188 if(
iVeNumb
 - 
PIC_IRQSTARTVECTOR
 == 14)

191 
	`kSHDDIruFg
(
TRUE
,TRUE);

197 
	`kSHDDIruFg
(
FALSE
,
TRUE
);

201 
	`kSdEOIToPIC
(
iVeNumb
-
PIC_IRQSTARTVECTOR
);

202 
	}
}

	@/home/jk/os/MINT64/02.Kernel64/Source/InterruptHandler.h

1 #ide
__INTERRUPTHANDLER_H__


2 
	#__INTERRUPTHANDLER_H__


	)

4 
	~"Tys.h
"

7 
kCommExiHdr
(
iVeNumb
,
QWORD
 
qwECode
);

8 
kCommIruHdr
(
iVeNumb
);

9 
kKeybrdHdr
(
iVeNumb
);

10 
kTimHdr
(
iVeNumb
);

11 
kDeviNAvaabHdr
(
iVeNumb
);

12 
kHDDHdr
(
iVeNumb
);

	@/home/jk/os/MINT64/02.Kernel64/Source/Keyboard.c

1 
	~"Tys.h
"

2 
	~"AsmblyUty.h
"

3 
	~"Keybrd.h
"

4 
	~"Queue.h
"

5 
	~"Synchrizi.h
"

11 
BOOL
 
	$kIsOuutBufrFu
()

15 if(
	`kInPtBy
(0x64)&0x01)

17  
TRUE
;

19  
FALSE
;

20 
	}
}

23 
BOOL
 
	$kIsIutBufrFu
()

27 if(
	`kInPtBy
(0x64)&0x02)

29  
TRUE
;

31  
FALSE
;

32 
	}
}

35 
BOOL
 
	$kAiveKeybrd
()

37 
i
;

38 
j
;

42 
	`kOutPtBy
(0x64,0xAE);

47 
i
=0;i<0xFFFF;i++)

50 if(
	`kIsIutBufrFu
()==
FALSE
)

58 
	`kOutPtBy
(0x60,0xF4);

63 
j
=0;j<100;j++)

68 
i
=0;i<0xFFFF;i++)

70 if(
	`kIsOuutBufrFu
()==
TRUE
)

77 if(
	`kInPtBy
(0x60)==0xFA)

79  
TRUE
;

84  
FALSE
;

85 
	}
}

89 
BYTE
 
	$kGKeybrdSnCode
()

92 
	`kIsOuutBufrFu
()==
FALSE
)

97  
	`kInPtBy
(0x60);

98 
	}
}

101 
BOOL
 
	$kChgeKeybrdLED
(
BOOL
 
bCsLockOn
,BOOL 
bNumLockOn
,BOOL 
bSlLockOn
)

103 
i
,
j
;

105 
i
=0;i<0xFFFF;i++)

108 if(
	`kIsIutBufrFu
()==
FALSE
)

115 
	`kOutPtBy
(0x60,0xED);

116 
i
=0;i<0xFFFF;i++)

119 if(
	`kIsIutBufrFu
()==
FALSE
)

126 
j
=0;j<100;j++)

131 
i
=0;i<0xFFFF;i++)

133 if(
	`kIsOuutBufrFu
()==
TRUE
)

140 if(
	`kInPtBy
(0x60)==0xFA)

148 if(
j
>=100)

150  
FALSE
;

154 
	`kOutPtBy
(0x60,(
bCsLockOn
<<2)|(
bNumLockOn
<<1)|
bSlLockOn
);

155 
i
=0;i<0xFFFF;i++)

158 if(
	`kIsIutBufrFu
()==
FALSE
)

165 
j
=0;j<100;j++)

170 
i
=0;i<0xFFFF;i++)

172 if(
	`kIsOuutBufrFu
()==
TRUE
)

179 if(
	`kInPtBy
(0x60)==0xFA)

186 if(
j
>=100)

188  
FALSE
;

191  
TRUE
;

192 
	}
}

195 
	$kEbA20Ge
()

197 
BYTE
 
bOuutPtDa
;

198 
i
;

201 
	`kOutPtBy
(0x64,0xD0);

204 
i
=0;i<0xFFFF;i++)

208 if(
	`kIsOuutBufrFu
()==
TRUE
)

215 
bOuutPtDa
 = 
	`kInPtBy
(0x60);

218 
bOuutPtDa
 |=0x01;

221 
i
=0;i<0xFFFF;i++)

224 if(
	`kIsIutBufrFu
()==
FALSE
)

231 
	`kOutPtBy
(0x64,0xD1);

234 
	`kOutPtBy
(0x60,
bOuutPtDa
);

235 
	}
}

238 
	$kRebo
()

240 
i
;

243 
i
=0;i<0xFFFF;i++)

246 if(
	`kIsIutBufrFu
()==
FALSE
)

253 
	`kOutPtBy
(0x64,0xD1);

256 
	`kOutPtBy
(0x60,0x00);

262 
	}
}

269 
KEYBOARDMANAGER
 
	ggs_KeybrdMag
={0,};

272 
QUEUE
 
	ggs_KeyQueue
;

273 
KEYDATA
 
	ggs_vKeyQueueBufr
[
KEY_MAXQUEUECOUNT
];

276 
KEYMAPPINGENTRY
 
	ggs_vKeyMpgTab
[
KEY_MAPPINGTABLEMAXCOUNT
]=

277 { { 
KEY_NONE
 , KEY_NONE },

278  { 
KEY_ESC
 , KEY_ESC },

291  { 
KEY_BACKSPACE
 , KEY_BACKSPACE },

292  { 
KEY_TAB
 , KEY_TAB },

306  { 
KEY_CTRL
 , KEY_CTRL },

319  { 
KEY_LSHIFT
 , KEY_LSHIFT },

331  { 
KEY_RSHIFT
 , KEY_RSHIFT },

333  { 
KEY_LALT
 , KEY_LALT },

335  { 
KEY_CAPSLOCK
 , KEY_CAPSLOCK },

336  { 
KEY_F1
 , KEY_F1 },

337  { 
KEY_F2
 , KEY_F2 },

338  { 
KEY_F3
 , KEY_F3 },

339  { 
KEY_F4
 , KEY_F4 },

340  { 
KEY_F5
 , KEY_F5 },

341  { 
KEY_F6
 , KEY_F6 },

342  { 
KEY_F7
 , KEY_F7 },

343  { 
KEY_F8
 , KEY_F8 },

344  { 
KEY_F9
 , KEY_F9 },

345  { 
KEY_F10
 , KEY_F10 },

346  { 
KEY_NUMLOCK
 , KEY_NUMLOCK },

347  { 
KEY_SCROLLLOCK
 , KEY_SCROLLLOCK },

349  { 
KEY_HOME
 , '7' },

350  { 
KEY_UP
 , '8' },

351  { 
KEY_PAGEUP
 , '9' },

353  { 
KEY_LEFT
 , '4' },

354  { 
KEY_CENTER
 , '5' },

355  { 
KEY_RIGHT
 , '6' },

357  { 
KEY_END
 , '1' },

358  { 
KEY_DOWN
 , '2' },

359  { 
KEY_PAGEDOWN
 , '3' },

360  { 
KEY_INS
 , '0' },

361  { 
KEY_DEL
 , '.' },

362  { 
KEY_NONE
 , KEY_NONE },

363  { 
KEY_NONE
 , KEY_NONE },

364  { 
KEY_NONE
 , KEY_NONE },

365  { 
KEY_F11
 , KEY_F11 },

366  { 
KEY_F12
 , KEY_F12 }

370 
BOOL
 
	$kIsAhabSnCode
(
BYTE
 
bSnCode
)

373 if(('a'<=
gs_vKeyMpgTab
[
bSnCode
].
bNmCode
)&&(gs_vstKeyMappingTable[bScanCode].bNormalCode<='z'))

375  
TRUE
;

378  
FALSE
;

379 
	}
}

382 
BOOL
 
	$kIsNumbOrSymbSnCode
(
BYTE
 
bSnCode
)

385 if((2<=
bSnCode
)&&(bSnCode<=53)&&(
	`kIsAhabSnCode
(bSnCode)==
FALSE
))

387  
TRUE
;

390  
FALSE
;

391 
	}
}

394 
BOOL
 
	$kIsNumbPadSnCode
(
BYTE
 
bSnCode
)

397 if((71<=
bSnCode
)&&(bScanCode<=83))

399  
TRUE
;

402  
FALSE
;

403 
	}
}

406 
BOOL
 
	$kIsUCombedCode
(
BYTE
 
bSnCode
)

408 
BYTE
 
bDownSnCode
;

409 
BOOL
 
bUCombedKey
=
FALSE
;

411 
bDownSnCode
 = 
bSnCode
&0x7F;

414 if(
	`kIsAhabSnCode
(
bDownSnCode
)==
TRUE
)

417 if(
gs_KeybrdMag
.
bShiDown
^gs_KeybrdMag.
bCsLockOn
)

419 
bUCombedKey
=
TRUE
;

423 
bUCombedKey
=
FALSE
;

427 if(
	`kIsNumbOrSymbSnCode
(
bDownSnCode
)==
TRUE
)

430 if(
gs_KeybrdMag
.
bShiDown
==
TRUE
)

432 
bUCombedKey
=
TRUE
;

436 
bUCombedKey
=
FALSE
;

441 if((
	`kIsNumbPadSnCode
(
bDownSnCode
)==
TRUE
)&&(
gs_KeybrdMag
.
bExndedCodeIn
==
FALSE
))

444 if(
gs_KeybrdMag
.
bNumLockOn
==
TRUE
)

446 
bUCombedKey
=
TRUE
;

450 
bUCombedKey
=
FALSE
;

454  
bUCombedKey
;

455 
	}
}

458 
	$UpdeCombiKeyStusAndLED
(
BYTE
 
bSnCode
)

460 
BOOL
 
bDown
;

461 
BYTE
 
bDownSnCode
;

462 
BOOL
 
bLEDStusChged
=
FALSE
;

465 if(
bSnCode
&0x80)

467 
bDown
=
FALSE
;

468 
bDownSnCode
=
bSnCode
&0x7F;

472 
bDown
=
TRUE
;

473 
bDownSnCode
=
bSnCode
;

478 if((
bDownSnCode
==42)||(bDownScanCode==54))

480 
gs_KeybrdMag
.
bShiDown
=
bDown
;

483 if((
bDownSnCode
==58)&&(
bDown
==
TRUE
))

485 
gs_KeybrdMag
.
bCsLockOn
^=
TRUE
;

486 
bLEDStusChged
=
TRUE
;

489 if((
bDownSnCode
==69)&&(
bDown
==
TRUE
))

491 
gs_KeybrdMag
.
bNumLockOn
^=
TRUE
;

492 
bLEDStusChged
=
TRUE
;

495 if((
bDownSnCode
==70)&&(
bDown
==
TRUE
))

497 
gs_KeybrdMag
.
bSlLockOn
^=
TRUE
;

498 
bLEDStusChged
=
TRUE
;

503 if(
bLEDStusChged
==
TRUE
)

505 
	`kChgeKeybrdLED
(
gs_KeybrdMag
.
bCsLockOn
,gs_KeybrdMag.
bNumLockOn
,gs_KeybrdMag.
bSlLockOn
);

507 
	}
}

510 
BOOL
 
	$kCvtSnCodeToASCIICode
(
BYTE
 
bSnCode
,BYTE* 
pbASCIICODE
,
BOOL
* 
pbFgs
)

512 
BOOL
 
bUCombedKey
;

515 if(
gs_KeybrdMag
.
iSkCouFPau
>0)

517 
gs_KeybrdMag
.
iSkCouFPau
--;

518  
FALSE
;

522 if(
bSnCode
==0xE1)

524 *
pbASCIICODE
==
KEY_PAUSE
;

525 *
pbFgs
=
KEY_FLAGS_DOWN
;

526 
gs_KeybrdMag
.
iSkCouFPau
=
KEY_SKIPCOUNTFORPAUSE
;

527  
TRUE
;

530 if(
bSnCode
==0xE0)

532 
gs_KeybrdMag
.
bExndedCodeIn
=
TRUE
;

533  
FALSE
;

537 
bUCombedKey
=
	`kIsUCombedCode
(
bSnCode
);

540 if(
bUCombedKey
==
TRUE
)

542 *
pbASCIICODE
=
gs_vKeyMpgTab
[
bSnCode
&0x7F].
bCombedCode
;

546 *
pbASCIICODE
=
gs_vKeyMpgTab
[
bSnCode
&0x7F].
bNmCode
;

550 if(
gs_KeybrdMag
.
bExndedCodeIn
==
TRUE
)

552 *
pbFgs
=
KEY_FLAGS_EXTENDEDKEY
;

553 
gs_KeybrdMag
.
bExndedCodeIn
=
FALSE
;

557 *
pbFgs
=0;

560 if((
bSnCode
&0x80)==0)

562 *
pbFgs
|=
KEY_FLAGS_DOWN
;

566 
	`UpdeCombiKeyStusAndLED
(
bSnCode
);

567  
TRUE
;

568 
	}
}

571 
BOOL
 
	$kInlizeKeybrd
()

574 
	`kInlizeQueue
(&
gs_KeyQueue
,
gs_vKeyQueueBufr
,
KEY_MAXQUEUECOUNT
,(
KEYDATA
));

577  
	`kAiveKeybrd
();

578 
	}
}

583 
BOOL
 
	$kCvtSnCodeAndPutQueue
(
BYTE
 
bSnCode
)

585 
KEYDATA
 
Da
;

586 
BOOL
 
bResu
 = 
FALSE
;

587 
BOOL
 
bPviousIru
;

590 
Da
.
bSnCode
 = bScanCode;

593 if(
	`kCvtSnCodeToASCIICode
(
bSnCode
,&(
Da
.
bASCIICode
),&(Da.
bFgs
))==
TRUE
)

596 
bPviousIru
 = 
	`kLockFSyemDa
();

598 
bResu
=
	`kPutQueue
(&
gs_KeyQueue
,&
Da
);

601 
	`kUockFSyemDa
(
bPviousIru
);

604  
bResu
;

605 
	}
}

608 
BOOL
 
	$kGKeyFromKeyQueue
(
KEYDATA
* 
pDa
)

610 
BOOL
 
bResu
;

611 
BOOL
 
bPviousIru
;

614 
bPviousIru
 = 
	`kLockFSyemDa
();

617 
bResu
 = 
	`kGQueue
(&
gs_KeyQueue
,
pDa
);

620 
	`kUockFSyemDa
(
bPviousIru
);

621  
bResu
;

622 
	}
}

	@/home/jk/os/MINT64/02.Kernel64/Source/Keyboard.h

1 #ide
__KEYBOARD_H__


2 
	#__KEYBOARD_H__


	)

4 
	~"Tys.h
"

8 
	#KEY_SKIPCOUNTFORPAUSE
 2

	)

11 
	#KEY_FLAGS_UP
 0x00

	)

12 
	#KEY_FLAGS_DOWN
 0x01

	)

13 
	#KEY_FLAGS_EXTENDEDKEY
 0x02

	)

16 
	#KEY_MAPPINGTABLEMAXCOUNT
 89

	)

18 
	#KEY_NONE
 0x00

	)

19 
	#KEY_ENTER
 '\n'

	)

20 
	#KEY_TAB
 '\t'

	)

21 
	#KEY_ESC
 0x1B

	)

22 
	#KEY_BACKSPACE
 0x08

	)

24 
	#KEY_CTRL
 0x81

	)

25 
	#KEY_LSHIFT
 0x82

	)

26 
	#KEY_RSHIFT
 0x83

	)

27 
	#KEY_PRINTSCREEN
 0x84

	)

28 
	#KEY_LALT
 0x85

	)

29 
	#KEY_CAPSLOCK
 0x86

	)

30 
	#KEY_F1
 0x87

	)

31 
	#KEY_F2
 0x88

	)

32 
	#KEY_F3
 0x89

	)

33 
	#KEY_F4
 0x8A

	)

34 
	#KEY_F5
 0x8B

	)

35 
	#KEY_F6
 0x8C

	)

36 
	#KEY_F7
 0x8D

	)

37 
	#KEY_F8
 0x8E

	)

38 
	#KEY_F9
 0x8F

	)

39 
	#KEY_F10
 0x90

	)

40 
	#KEY_NUMLOCK
 0x91

	)

41 
	#KEY_SCROLLLOCK
 0x92

	)

42 
	#KEY_HOME
 0x93

	)

43 
	#KEY_UP
 0x94

	)

44 
	#KEY_PAGEUP
 0x95

	)

45 
	#KEY_LEFT
 0x96

	)

46 
	#KEY_CENTER
 0x97

	)

47 
	#KEY_RIGHT
 0x98

	)

48 
	#KEY_END
 0x99

	)

49 
	#KEY_DOWN
 0x9A

	)

50 
	#KEY_PAGEDOWN
 0x9B

	)

51 
	#KEY_INS
 0x9C

	)

52 
	#KEY_DEL
 0x9D

	)

53 
	#KEY_F11
 0x9E

	)

54 
	#KEY_F12
 0x9F

	)

55 
	#KEY_PAUSE
 0xA0

	)

58 
	#KEY_MAXQUEUECOUNT
 100

	)

61 #agm
ck

push
, 1 )

64 
	skKeyMpgErySu


67 
BYTE
 
	mbNmCode
;

70 
BYTE
 
	mbCombedCode
;

71 } 
	tKEYMAPPINGENTRY
;

74 
	skKeybrdMagSu


77 
BOOL
 
	mbShiDown
;

78 
BOOL
 
	mbCsLockOn
;

79 
BOOL
 
	mbNumLockOn
;

80 
BOOL
 
	mbSlLockOn
;

83 
BOOL
 
	mbExndedCodeIn
;

84 
	miSkCouFPau
;

85 } 
	tKEYBOARDMANAGER
;

88 
	skKeyDaSu


91 
BYTE
 
	mbSnCode
;

93 
BYTE
 
	mbASCIICode
;

95 
BYTE
 
	mbFgs
;

96 } 
	tKEYDATA
;

98 #agm
ck

p
 )

101 
BOOL
 
kIsOuutBufrFu
( );

102 
BOOL
 
kIsIutBufrFu
( );

103 
BOOL
 
kAiveKeybrd
( );

104 
BYTE
 
kGKeybrdSnCode
( );

105 
BOOL
 
kChgeKeybrdLED
BOOL 
bCsLockOn
, BOOL 
bNumLockOn
, BOOL 
bSlLockOn
 );

106 
kEbA20Ge
( );

107 
kRebo
( );

108 
BOOL
 
kIsAhabSnCode

BYTE
 
bSnCode
 );

109 
BOOL
 
kIsNumbOrSymbSnCode

BYTE
 
bSnCode
 );

110 
BOOL
 
kIsNumbPadSnCode

BYTE
 
bSnCode
 );

111 
BOOL
 
kIsUCombedCode

BYTE
 
bSnCode
 );

112 
UpdeCombiKeyStusAndLED

BYTE
 
bSnCode
 );

113 
BOOL
 
kCvtSnCodeToASCIICode

BYTE
 
bSnCode
, BYTE* 
pbASCIICode
, BOOL* 
pbFgs
 );

114 
BOOL
 
kInlizeKeybrd
();

115 
BOOL
 
kCvtSnCodeAndPutQueue
(
BYTE
 
bSnCode
);

116 
BOOL
 
kGKeyFromKeyQueue
(
KEYDATA
* 
pDa
);

	@/home/jk/os/MINT64/02.Kernel64/Source/List.c

1 
	~"Li.h
"

4 
	$kInlizeLi
(
LIST
* 
pLi
)

6 
pLi
->
iImCou
 = 0;

7 
pLi
->
pvHd
 = 
NULL
;

8 
pLi
->
pvTa
 = 
NULL
;

9 
	}
}

12 
	$kGLiCou
(cڡ 
LIST
* 
pLi
)

14  
pLi
->
iImCou
;

15 
	}
}

18 
	$kAddLiToTa
(
LIST
* 
pLi
,* 
pvIm
)

20 
LISTLINK
* 
pLk
;

23 
pLk
 = (
LISTLINK
*)
pvIm
;

24 
pLk
->
pvNext
=
NULL
;

25 
pLk
->
pvPvious
=
pLi
->
pvTa
;

28 if(
pLi
->
pvHd
==
NULL
)

30 
pLi
->
pvHd
=
pvIm
;

31 
pLi
->
pvTa
=
pvIm
;

32 
pLi
->
iImCou
=1;

37 ((
LISTLINK
*)
pLi
->
pvTa
)->
pvNext
=
pLk
;

40 
pLi
->
pvTa
=
pvIm
;

41 
pLi
->
iImCou
++;

42 
	}
}

45 
	$kAddLiToHd
(
LIST
* 
pLi
,* 
pvIm
)

47 
LISTLINK
* 
pLk
;

50 
pLk
=(
LISTLINK
*)
pvIm
;

51 
pLk
->
pvNext
=
pLi
->
pvHd
;

52 
pLk
->
pvPvious
=
NULL
;

55 if(
pLi
->
pvHd
==
NULL
)

57 
pLi
->
pvHd
=
pvIm
;

58 
pLi
->
pvTa
=
pvIm
;

59 
pLi
->
iImCou
=1;

64 ((
LISTLINK
*)
pLi
->
pvHd
)->
pvPvious
=
pLk
;

65 
pLi
->
pvHd
=
pvIm
;

66 
pLi
->
iImCou
++;

67 
	}
}

70 * 
	$kRemoveLi
(
LIST
* 
pLi
,
QWORD
 
qwID
)

72 
LISTLINK
* 
pLk
;

73 
pLk
=
	`kFdLi
(
pLi
,
qwID
);

75 if(
pLk
!=
NULL
)

78 if((
pLk
==
pLi
->
pvHd
)&&աLk=Li->
pvTa
))

80 
pLi
->
pvHd
=
NULL
;

81 
pLi
->
pvTa
=
NULL
;

84 if(
pLk
==
pLi
->
pvHd
)

86 
pLi
->
pvHd
=
pLk
->
pvNext
;

87 ((
LISTLINK
*)
pLi
->
pvHd
)->
pvPvious
=
NULL
;

90 if(
pLk
==
pLi
->
pvTa
)

92 
pLi
->
pvTa
=
pLk
->
pvPvious
;

93 ((
LISTLINK
*)
pLi
->
pvTa
)->
pvNext
=
NULL
;

97 ((
LISTLINK
*)
pLk
->
pvPvious
)->
pvNext
=pstLink->pvNext;

98 ((
LISTLINK
*)
pLk
->
pvNext
)->
pvPvious
=pstLink->pvPrevious;

100 
pLi
->
iImCou
--;

101  
pLk
;

104  
NULL
;

105 
	}
}

108 * 
	$kRemoveLiFromHd
(
LIST
* 
pLi
)

110 
LISTLINK
* 
pLk
;

111 if(
pLi
->
iImCou
==0)

113  
NULL
;

117 
pLk
=(
LISTLINK
*)
pLi
->
pvHd
;

118  
	`kRemoveLi
(
pLi
,
pLk
->
qwID
);

119 
	}
}

122 * 
	$kRemoveLiFromTa
(
LIST
* 
pLi
)

124 
LISTLINK
* 
pLk
;

125 if(
pLi
->
iImCou
==0)

127  
NULL
;

131 
pLk
=(
LISTLINK
*)
pLi
->
pvTa
;

132  
	`kRemoveLi
(
pLi
,
pLk
->
qwID
);

133 
	}
}

137 * 
	$kFdLi
(cڡ 
LIST
* 
pLi
,
QWORD
 
qwID
)

139 
LISTLINK
* 
pLk
;

141 
pLk
=(
LISTLINK
*)
pLi
->
pvHd
;pLk!=
NULL
;pLkLk->
pvNext
)

144 if(
pLk
->
qwID
==qwID)

146  
pLk
;

149  
NULL
;

150 
	}
}

153 * 
	$kGHdFromLi
(cڡ 
LIST
* 
pLi
)

155  
pLi
->
pvHd
;

156 
	}
}

159 * 
	$kGTaFromLi
(cڡ 
LIST
* 
pLi
)

161  
pLi
->
pvTa
;

162 
	}
}

165 * 
	$kGNextFromLi
(cڡ 
LIST
* 
pLi
,* 
pCut
)

167 
LISTLINK
* 
pLk
;

168 
pLk
=(
LISTLINK
*)
pCut
;

169  
pLk
->
pvNext
;

170 
	}
}

173 * 
	$kGPviousFromLi
(cڡ 
LIST
* 
pLi
,* 
pCut
)

175 
LISTLINK
* 
pLk
;

176 
pLk
=(
LISTLINK
*)
pCut
;

177  
pLk
->
pvPvious
;

178 
	}
}

	@/home/jk/os/MINT64/02.Kernel64/Source/List.h

1 #ide
__LIST_H__


2 
	#__LIST_H__


	)

4 
	~"Tys.h
"

8 #agm
ck
(
push
,1)

12 
	skLiLkSu


15 * 
	mpvNext
;

16 * 
	mpvPvious
;

17 
QWORD
 
	mqwID
;

18 } 
	tLISTLINK
;

35 
	skLiMagSu


38 
	miImCou
;

41 * 
	mpvHd
;

42 * 
	mpvTa
;

43 } 
	tLIST
;

45 #agm
ck
(
p
)

48 
kInlizeLi
(
LIST
* 
pLi
);

49 
kGLiCou
(cڡ 
LIST
* 
pLi
);

50 
kAddLiToTa
(
LIST
* 
pLi
,* 
pvIm
);

51 
kAddLiToHd
(
LIST
* 
pLi
,* 
pvIm
);

52 * 
kRemoveLi
(
LIST
* 
pLi
,
QWORD
 
qwID
);

53 * 
kRemoveLiFromHd
(
LIST
* 
pLi
);

54 * 
kRemoveLiFromTa
(
LIST
* 
pLi
);

55 * 
kFdLi
(cڡ 
LIST
* 
pLi
,
QWORD
 
qwID
);

56 * 
kGHdFromLi
(cڡ 
LIST
* 
pLi
);

57 * 
kGTaFromLi
(cڡ 
LIST
* 
pLi
);

58 * 
kGNextFromLi
(cڡ 
LIST
* 
pLi
,* 
pCut
);

59 * 
kGPviousFromLi
(cڡ 
LIST
* 
pLi
,* 
pCut
);

	@/home/jk/os/MINT64/02.Kernel64/Source/LocalAPIC.c

1 
	~"LolAPIC.h
"

2 
	~"MPCfigutiTab.h
"

5 
QWORD
 
	$kGLolAPICBaAddss
()

7 
MPCONFIGURATIONTABLEHEADER
* 
pMPHd
;

10 
pMPHd
 = 
	`kGMPCfigutiMag
()->
pMPCfigutiTabHd
;

11  
pMPHd
->
dwMemyMIOAddssOfLolAPIC
;

12 
	}
}

16 
	$kEbSoweLolAPIC
()

18 
QWORD
 
qwLolAPICBaAddss
;

21 
qwLolAPICBaAddss
 = 
	`kGLolAPICBaAddss
();

25 *(
DWORD
*)(
qwLolAPICBaAddss
+
APIC_REGISTER_SVR
)|=0x100;

26 
	}
}

	@/home/jk/os/MINT64/02.Kernel64/Source/LocalAPIC.h

1 #ide
__LOCALAPIC_H__


2 
	#__LOCALAPIC_H__


	)

4 
	~"Tys.h
"

8 
	#APIC_REGISTER_EOI
 0x0000B0

	)

9 
	#APIC_REGISTER_SVR
 0x0000F0

	)

10 
	#APIC_REGISTER_APICID
 0x000020

	)

11 
	#APIC_REGISTER_TASKPRIORITY
 0x000080

	)

12 
	#APIC_REGISTER_TIMER
 0x000320

	)

13 
	#APIC_REGISTER_THERMALSENSOR
 0x000330

	)

14 
	#APIC_REGISTER_PERFORMANCEMONITORINGCOUNTER
 0x000340

	)

15 
	#APIC_REGISTER_LINT0
 0x000350

	)

16 
	#APIC_REGISTER_LINT1
 0x000360

	)

17 
	#APIC_REGISTER_ERROR
 0x000370

	)

18 
	#APIC_REGISTER_ICR_LOWER
 0x000300

	)

19 
	#APIC_REGISTER_ICR_UPPER
 0x000310

	)

22 
	#APIC_DELIVERYMODE_FIXED
 0x000000

	)

23 
	#APIC_DELIVERYMODE_LOWESTPRIORITY
 0x000100

	)

24 
	#APIC_DELIVERYMODE_SMI
 0x000200

	)

25 
	#APIC_DELIVERYMODE_NMI
 0x000400

	)

26 
	#APIC_DELIVERYMODE_INIT
 0x000500

	)

27 
	#APIC_DELIVERYMODE_STARTUP
 0x000600

	)

28 
	#APIC_DELIVERYMODE_EXTINT
 0x000700

	)

31 
	#APIC_DESTINATIONMODE_PHYSICAL
 0x000000

	)

32 
	#APIC_DESTINATIONMODE_LOGICAL
 0x000800

	)

35 
	#APIC_DELIVERYSTATUS_IDLE
 0x000000

	)

36 
	#APIC_DELIVERYSTATUS_PENDING
 0x001000

	)

39 
	#APIC_LEVEL_DEASSERT
 0x000000

	)

40 
	#APIC_LEVEL_ASSERT
 0x004000

	)

43 
	#APIC_TRIGGERMODE_EDGE
 0x000000

	)

44 
	#APIC_TRIGGERMODE_LEVEL
 0x008000

	)

47 
	#APIC_DESTINATIONSHORTHAND_NOSHORTHAND
 0x000000

	)

48 
	#APIC_DESTINATIONSHORTHAND_SELF
 0x040000

	)

49 
	#APIC_DESTINATIONSHORTHAND_ALLINCLUDINGSELF
 0x080000

	)

50 
	#APIC_DESTINATIONSHORTHAND_ALLEXCLUDINGSELF
 0x0C0000

	)

53 
QWORD
 
kGLolAPICBaAddss
();

54 
kEbSoweLolAPIC
();

	@/home/jk/os/MINT64/02.Kernel64/Source/MPConfigurationTable.c

1 
	~"MPCfigutiTab.h
"

2 
	~"Cse.h
"

5 
MPCONFIGURATIONMANAGER
 
	ggs_MPCfigutiMag
 = {0,};

8 
BOOL
 
	$kFdMPFltgPorAddss
(
QWORD
* 
pAddss
)

10 * 
pcMPFltgPor
;

11 
QWORD
 
qwEBDAddss
;

12 
QWORD
 
qwSyemBaMemy
;

15 
	`kPrtf
("Exnded BIOS DA[0x%x]\n",(
DWORD
)(*(
WORD
*)0x040E)*16);

16 
	`kPrtf
("Syem Ba Adds[0x%x]\n",(
DWORD
)(*(
WORD
*)0x0413)*1024);

20 
qwEBDAddss
 = *(
WORD
*)(0x040E);

22 
qwEBDAddss
 *= 16;

24 
pcMPFltgPor
 = (*)
qwEBDAddss
;(
QWORD
)pcMPFloatingPointer<=(qwEBDAddress+1024);pcMPFloatingPointer++)

26 if(
	`kMemCmp
(
pcMPFltgPor
,"_MP_",4)==0)

28 
	`kPrtf
("MP Fltg PoIIEBDA, [0x%x] Addss\n",(
DWORD
)
pcMPFltgPor
);

29 *
pAddss
 = (
QWORD

pcMPFltgPor
;

30  
TRUE
;

38 
qwSyemBaMemy
 = *(
WORD
*)0x0413;

39 
qwSyemBaMemy
 *= 1024;

41 
pcMPFltgPor
 = (*(
qwSyemBaMemy
 - 1024);(
QWORD
)pcMPFloatingPointer <= qwSystemBaseMemory ;cMPFloatingPointer++)

43 if(
	`kMemCmp
(
pcMPFltgPor
,"_MP_",4)==0)

45 
	`kPrtf
("MP Fltg PoIISyem Ba Memy, [0x%x] Addss\n",(
DWORD
)
pcMPFltgPor
);

46 *
pAddss
 = (
QWORD
)
pcMPFltgPor
;

48  
TRUE
;

53 
pcMPFltgPor
 = (*)0x0F0000;(
QWORD
)pcMPFloatingPointer<0x0FFFFF;pcMPFloatingPointer++)

55 if(
	`kMemCmp
(
pcMPFltgPor
,"_MP_",4)==0)

57 
	`kPrtf
("MP Fltg PoIIROM, [0x%x] Addss\n",
pcMPFltgPor
);

58 *
pAddss
 = (
QWORD
)
pcMPFltgPor
;

59  
TRUE
;

63  
FALSE
;

64 
	}
}

67 
BOOL
 
	$kAlysisMPCfigutiTab
()

69 
QWORD
 
qwMPFltgPorAddss
;

70 
MPFLOATINGPOINTER
* 
pMPFltgPor
;

71 
MPCONFIGURATIONTABLEHEADER
* 
pMPCfigutiHd
;

72 
BYTE
 
bEryTy
;

73 
WORD
 
i
;

74 
QWORD
 
qwEryAddss
;

75 
PROCESSORENTRY
* 
pProssEry
;

76 
BUSENTRY
* 
pBusEry
;

79 
	`kMemS
(&
gs_MPCfigutiMag
,0,(
MPCONFIGURATIONMANAGER
));

80 
gs_MPCfigutiMag
.
bISABusID
 = 0xFF;

83 if(
	`kFdMPFltgPorAddss
(&
qwMPFltgPorAddss
)==
FALSE
)

85  
FALSE
;

89 
pMPFltgPor
 = (
MPFLOATINGPOINTER
*)
qwMPFltgPorAddss
;

90 
gs_MPCfigutiMag
.
pMPFltgPor
 =stMPFloatingPointer;

91 
pMPCfigutiHd
 = (
MPCONFIGURATIONTABLEHEADER
*)((
QWORD
)
pMPFltgPor
->
dwMPCfigutiTabAddss
&0xFFFFFFFF);

94 if(
pMPFltgPor
->
vbMPFtuBy
[1]&
MP_FLOATINGPOINTER_FEATUREBYTE2_PICMODE
)

96 
gs_MPCfigutiMag
.
bUPICMode
 = 
TRUE
;

100 
gs_MPCfigutiMag
.
pMPCfigutiTabHd
 = 
pMPCfigutiHd
;

101 
gs_MPCfigutiMag
.
qwBaErySAddss
 = 
pMPFltgPor
->
dwMPCfigutiTabAddss
 + (
MPCONFIGURATIONTABLEHEADER
);

104 
qwEryAddss
 = 
gs_MPCfigutiMag
.
qwBaErySAddss
;

105 
i
=0;i<
pMPCfigutiHd
->
wEryCou
;i++)

107 
bEryTy
 = *(
BYTE
*)
qwEryAddss
;

109 
bEryTy
)

112 
MP_ENTRYTYPE_PROCESSOR
:

113 
pProssEry
 = (
PROCESSORENTRY
*)
qwEryAddss
;

115 if(
pProssEry
->
bCPUFgs
&
MP_PROCESSOR_CPUFLAGS_ENABLE
)

117 
gs_MPCfigutiMag
.
iProssCou
++;

120 
qwEryAddss
 +=(
PROCESSORENTRY
);

123 
MP_ENTRYTYPE_BUS
:

124 
pBusEry
 = (
BUSENTRY
*)
qwEryAddss
;

125 if(
	`kMemCmp
(
pBusEry
->
vcBusTySg
,
MP_BUS_TYPESTRING_ISA
,
	`kSL
(MP_BUS_TYPESTRING_ISA))==0)

127 
gs_MPCfigutiMag
.
bISABusID
 = 
pBusEry
->
bBusID
;

129 
qwEryAddss
 +(
BUSENTRY
);

132 
MP_ENTRYTYPE_IOAPIC
:

133 
MP_ENTRYTYPE_IOINTERRUPTASSIGNMENT
:

134 
MP_ENTRYTYPE_LOCALINTERRUPTASSIGNMENT
:

136 
qwEryAddss
+=8;

141  
TRUE
;

142 
	}
}

145 
MPCONFIGURATIONMANAGER
* 
	$kGMPCfigutiMag
()

147  &
gs_MPCfigutiMag
;

148 
	}
}

151 
	$kPrtMPCfigutiTab
()

153 
MPCONFIGURATIONMANAGER
* 
pMPCfigutiMag
;

154 
QWORD
 
qwMPFltgPorAddss
;

155 
MPFLOATINGPOINTER
* 
pMPFltgPor
;

156 
MPCONFIGURATIONTABLEHEADER
* 
pMPTabHd
;

157 
PROCESSORENTRY
* 
pProssEry
;

158 
BUSENTRY
* 
pBusEry
;

159 
IOAPICENTRY
* 
pIOAPICEry
;

160 
IOINTERRUPTASSIGNMENTENTRY
* 
pIOAssignmtEry
;

161 
LOCALINTERRUPTASSIGNMENTENTRY
* 
pLolAssignmtEry
;

162 
QWORD
 
qwBaEryAddss
;

163 
vcSgBufr
[20];

164 
WORD
 
i
;

165 
BYTE
 
bEryTy
;

168 * 
vpcIruTy
[4] = {"INT","NMI","SMI","ExtINT"};

169 * 
vpcIruFgsPO
[4] = {"Conform","Active High","Reserved","Active Low"};

170 * 
vpcIruFgsEL
[4] = {"Conform","Edge-Trigger","Reserved","Level-Trigger"};

176 
	`kPrtf
("=========== MP Configuration Table Summary ===================\n");

177 
pMPCfigutiMag
 = 
	`kGMPCfigutiMag
();

179 if((
pMPCfigutiMag
->
qwBaErySAddss
==0)&&(
	`kAlysisMPCfigutiTab
()==
FALSE
))

181 
	`kPrtf
("MP configuration Table Analysis Fail\n");

184 
	`kPrtf
("MP Configuration Table Analysis Success\n");

186 
	`kPrtf
("MP Fltg PoAdds: 0x%q\n",
pMPCfigutiMag
->
pMPFltgPor
);

187 
	`kPrtf
("PIC ModSu܈: %d\n",
pMPCfigutiMag
->
bUPICMode
);

188 
	`kPrtf
("MP Cfiguti Tab Hd Adds: 0x%q\n",
pMPCfigutiMag
->
pMPCfigutiTabHd
);

189 
	`kPrtf
("Ba MP Cfiguti Tab Ery S Adds: 0x%q\n",
pMPCfigutiMag
->
qwBaErySAddss
);

190 
	`kPrtf
("Pross Cou : %d\n",
pMPCfigutiMag
->
iProssCou
);

191 
	`kPrtf
("ISA BUS ID : %d\n",
pMPCfigutiMag
->
bISABusID
);

193 
	`kPrtf
("Pressny keyo continue... ('q' isxit) : ");

195 if(
	`kGCh
()=='q')

197 
	`kPrtf
("\n");

201 
	`kPrtf
("\n");

206 
	`kPrtf
("======================= MP Floating Pointer ================\n");

207 
pMPFltgPor
 = 
pMPCfigutiMag
->pstMPFloatingPointer;

208 
	`kMemCpy
(
vcSgBufr
,
pMPFltgPor
->
vcSigtu
,4);

209 
vcSgBufr
[4] = '\0';

210 
	`kPrtf
("Sigtu : %s\n",
vcSgBufr
);

211 
	`kPrtf
("MP Cfiguti Tab Adds: 0x%q\n",
pMPFltgPor
->
dwMPCfigutiTabAddss
);

212 
	`kPrtf
("Lgth : %d*16 By\n",
pMPFltgPor
->
bLgth
);

213 
	`kPrtf
("Vsi : %d\n",
pMPFltgPor
->
bRevisi
);

214 
	`kPrtf
("CheckSum : 0x%x\n",
pMPFltgPor
->
bCheckSum
);

215 
	`kPrtf
("Ftu By 1 : 0x%x ",
pMPFltgPor
->
vbMPFtuBy
[0]);

218 if(
pMPFltgPor
->
vbMPFtuBy
[0]==0)

220 
	`kPrtf
("Use MP Configuration Table\n");

224 
	`kPrtf
("Use Default Configuration\n");

228 
	`kPrtf
("Ftu By 2 : 0x%x ",
pMPFltgPor
->
vbMPFtuBy
[1]);

229 if(
pMPFltgPor
->
vbMPFtuBy
[2]&
MP_FLOATINGPOINTER_FEATUREBYTE2_PICMODE
)

231 
	`kPrtf
("(PIC Mode Support\n");

235 
	`kPrtf
("(Virtual Wire Mode Support\n");

241 
	`kPrtf
("\n============================== MP Configuration Table Header ======================\n");

242 
pMPTabHd
 = 
pMPCfigutiMag
->
pMPCfigutiTabHd
;

244 
	`kMemCpy
(
vcSgBufr
, 
pMPTabHd
->
vcSigtu
,4);

245 
vcSgBufr
[4]='\0';

246 
	`kPrtf
("Sigtu : %s\n",
vcSgBufr
);

247 
	`kPrtf
("Lgth : %d By\n",
pMPTabHd
->
wBaTabLgth
);

248 
	`kPrtf
("vsi : %d\n",
pMPTabHd
->
bRevisi
);

249 
	`kPrtf
("CheckSum : 0x%x\n",
pMPTabHd
->
bCheckSum
);

250 
	`kMemCpy
(
vcSgBufr
,
pMPTabHd
->
vcOEMIDSg
,8);

251 
vcSgBufr
[8] = '\0';

252 
	`kPrtf
("OEM ID Sg : %s\n",
vcSgBufr
);

253 
	`kMemCpy
(
vcSgBufr
,
pMPTabHd
->
vcProduIDSg
,12);

254 
vcSgBufr
[12]='\0';

255 
	`kPrtf
("Produ ID Sg : %s\n",
vcSgBufr
);

256 
	`kPrtf
("OEM Tab Po: 0x%x\n",
pMPTabHd
->
dwOEMTabPorAddss
);

257 
	`kPrtf
("OEM Tab Siz: %d By\n",
pMPTabHd
->
wOEMTabSize
);

258 
	`kPrtf
("Ery Cou : %d\n",
pMPTabHd
->
wEryCou
);

259 
	`kPrtf
("Memy Md I/O AddsOLoAPIC : 0x%x\n",
pMPTabHd
->
dwMemyMIOAddssOfLolAPIC
);

260 
	`kPrtf
("Exnded Tab Lgth : %d By\n",
pMPTabHd
->
wExndedTabLgth
);

261 
	`kPrtf
("Exnded Tab CheckSum : 0x%x\n",
pMPTabHd
->
bExndedTabChecksum
);

263 
	`kPrtf
("Pressny keyo continue... ('q' isxit) : ");

264 if(
	`kGCh
()=='q')

266 
	`kPrtf
("\n");

270 
	`kPrtf
("\n");

275 
	`kPrtf
("\n========================== Base MP Configuration Table Entry =================\n");

276 
qwBaEryAddss
 = 
pMPFltgPor
->
dwMPCfigutiTabAddss
+(
MPCONFIGURATIONTABLEHEADER
);

278 
i
=0;i<
pMPTabHd
->
wEryCou
;i++)

280 
bEryTy
 = *(
BYTE
*)
qwBaEryAddss
;

282 
bEryTy
)

285 
MP_ENTRYTYPE_PROCESSOR
:

286 
pProssEry
 = ( 
PROCESSORENTRY
* ) 
qwBaEryAddss
;

287 
	`kPrtf
( "Entry Type : Processor\n" );

288 
	`kPrtf
"LoAPIC ID : %d\n", 
pProssEry
->
bLolAPICID
 );

289 
	`kPrtf
"LoAPIC Vsi : 0x%X\n", 
pProssEry
->
bLolAPICVsi
 );

290 
	`kPrtf
"CPU Fg: 0x%X ", 
pProssEry
->
bCPUFgs
 );

292 if
pProssEry
->
bCPUFgs
 & 
MP_PROCESSOR_CPUFLAGS_ENABLE
 )

294 
	`kPrtf
( "(Enable, " );

298 
	`kPrtf
( "(Disable, " );

301 if
pProssEry
->
bCPUFgs
 & 
MP_PROCESSOR_CPUFLAGS_BSP
 )

303 
	`kPrtf
( "BSP)\n" );

307 
	`kPrtf
( "AP)\n" );

309 
	`kPrtf
"CPU Sigtu : 0x%X\n", 
pProssEry
->
vbCPUSigtu
 );

310 
	`kPrtf
"Ftu Fg: 0x%X\n\n", 
pProssEry
->
dwFtuFgs
 );

313 
qwBaEryAddss
 +
PROCESSORENTRY
 );

317 
MP_ENTRYTYPE_BUS
:

318 
pBusEry
 = ( 
BUSENTRY
* ) 
qwBaEryAddss
;

319 
	`kPrtf
( "Entry Type : Bus\n" );

320 
	`kPrtf
"BuID : %d\n", 
pBusEry
->
bBusID
 );

321 
	`kMemCpy

vcSgBufr
, 
pBusEry
->
vcBusTySg
, 6 );

322 
vcSgBufr
[ 6 ] = '\0';

323 
	`kPrtf
"BuTy Sg : %s\n\n", 
vcSgBufr
 );

326 
qwBaEryAddss
 +
BUSENTRY
 );

330 
MP_ENTRYTYPE_IOAPIC
:

331 
pIOAPICEry
 = ( 
IOAPICENTRY
* ) 
qwBaEryAddss
;

332 
	`kPrtf
( "Entry Type : I/O APIC\n" );

333 
	`kPrtf
"I/O APIC ID : %d\n", 
pIOAPICEry
->
bIOAPICID
 );

334 
	`kPrtf
"I/O APIC Vsi : 0x%X\n", 
pIOAPICEry
->
bIOAPICVsi
 );

335 
	`kPrtf
"I/O APIC Fg: 0x%X ", 
pIOAPICEry
->
bIOAPICFgs
 );

337 if
pIOAPICEry
->
bIOAPICFgs
 == 1 )

339 
	`kPrtf
( "(Enable)\n" );

343 
	`kPrtf
( "(Disable)\n" );

345 
	`kPrtf
( "Memory Mapped I/O Address : 0x%X\n\n",

346 
pIOAPICEry
->
dwMemyMAddss
 );

349 
qwBaEryAddss
 +
IOAPICENTRY
 );

353 
MP_ENTRYTYPE_IOINTERRUPTASSIGNMENT
:

354 
pIOAssignmtEry
 = ( 
IOINTERRUPTASSIGNMENTENTRY
* )

355 
qwBaEryAddss
;

356 
	`kPrtf
( "Entry Type : I/O Interrupt Assignment\n" );

357 
	`kPrtf
"Iru Ty : 0x%X ", 
pIOAssignmtEry
->
bIruTy
 );

359 
	`kPrtf
"(%s)\n", 
vpcIruTy
[ 
pIOAssignmtEry
->
bIruTy
 ] );

360 
	`kPrtf
"I/O Iru Fg: 0x%X ", 
pIOAssignmtEry
->
wIruFgs
 );

362 
	`kPrtf
"(%s, %s)\n", 
vpcIruFgsPO
[ 
pIOAssignmtEry
->
wIruFgs
 & 0x03 ],

363 
vpcIruFgsEL
[ ( 
pIOAssignmtEry
->
wIruFgs
 >> 2 ) & 0x03 ] );

364 
	`kPrtf
"Sour BUS ID : %d\n", 
pIOAssignmtEry
->
bSourBUSID
 );

365 
	`kPrtf
"Sour BUS IRQ : %d\n", 
pIOAssignmtEry
->
bSourBUSIRQ
 );

366 
	`kPrtf
( "Destination I/O APIC ID : %d\n",

367 
pIOAssignmtEry
->
bDeiIOAPICID
 );

368 
	`kPrtf
( "Destination I/O APIC INTIN : %d\n\n",

369 
pIOAssignmtEry
->
bDeiIOAPICINTIN
 );

372 
qwBaEryAddss
 +
IOINTERRUPTASSIGNMENTENTRY
 );

376 
MP_ENTRYTYPE_LOCALINTERRUPTASSIGNMENT
:

377 
pLolAssignmtEry
 = ( 
LOCALINTERRUPTASSIGNMENTENTRY
* )

378 
qwBaEryAddss
;

379 
	`kPrtf
( "Entry Type : Local Interrupt Assignment\n" );

380 
	`kPrtf
"Iru Ty : 0x%X ", 
pLolAssignmtEry
->
bIruTy
 );

382 
	`kPrtf
"(%s)\n", 
vpcIruTy
[ 
pLolAssignmtEry
->
bIruTy
 ] );

383 
	`kPrtf
"I/O Iru Fg: 0x%X ", 
pLolAssignmtEry
->
wIruFgs
 );

385 
	`kPrtf
"(%s, %s)\n", 
vpcIruFgsPO
[ 
pLolAssignmtEry
->
wIruFgs
 & 0x03 ],

386 
vpcIruFgsEL
[ ( 
pLolAssignmtEry
->
wIruFgs
 >> 2 ) & 0x03 ] );

387 
	`kPrtf
"Sour BUS ID : %d\n", 
pLolAssignmtEry
->
bSourBUSID
 );

388 
	`kPrtf
"Sour BUS IRQ : %d\n", 
pLolAssignmtEry
->
bSourBUSIRQ
 );

389 
	`kPrtf
( "Destination Local APIC ID : %d\n",

390 
pLolAssignmtEry
->
bDeiLolAPICID
 );

391 
	`kPrtf
( "Destination Local APIC LINTIN : %d\n\n",

392 
pLolAssignmtEry
->
bDeiLolAPICINTIN
 );

395 
qwBaEryAddss
 +
LOCALINTERRUPTASSIGNMENTENTRY
 );

399 
	`kPrtf
"UnknowEry Ty. %d\n", 
bEryTy
 );

404 if
i
 != 0 ) && ( ( ( i + 1 ) % 3 ) == 0 ) )

406 
	`kPrtf
( "Pressny keyo continue... ('q' isxit) : " );

407 if
	`kGCh
() == 'q' )

409 
	`kPrtf
( "\n" );

412 
	`kPrtf
( "\n" );

415 
	}
}

418 
	$kGProssCou
( )

421 if
gs_MPCfigutiMag
.
iProssCou
 == 0 )

425  
gs_MPCfigutiMag
.
iProssCou
;

426 
	}
}

	@/home/jk/os/MINT64/02.Kernel64/Source/MPConfigurationTable.h

1 #ide
__MPCONFIGURATIONTABLE__


2 
	#__MPCONFIGURATIONTABLE__


	)

4 
	~"Tys.h
"

8 
	#MP_FLOATINGPOINTER_FEATUREBYTE1_USEMPTABLE
 0x00

	)

9 
	#MP_FLOATINGPOINTER_FEATUREBYTE2_PICMODE
 0x80

	)

12 
	#MP_ENTRYTYPE_PROCESSOR
 0

	)

13 
	#MP_ENTRYTYPE_BUS
 1

	)

14 
	#MP_ENTRYTYPE_IOAPIC
 2

	)

15 
	#MP_ENTRYTYPE_IOINTERRUPTASSIGNMENT
 3

	)

16 
	#MP_ENTRYTYPE_LOCALINTERRUPTASSIGNMENT
 4

	)

19 
	#MP_PROCESSOR_CPUFLAGS_ENABLE
 0x01

	)

20 
	#MP_PROCESSOR_CPUFLAGS_BSP
 0x02

	)

23 
	#MP_BUS_TYPESTRING_ISA
 "ISA"

	)

24 
	#MP_BUS_TYPESTRING_PCI
 "PCI"

	)

25 
	#MP_BUS_TYPESTRING_PCMCIA
 "PCMCIA"

	)

26 
	#MP_BUS_TYPESTRING_VESALOCALBUS
 "VL"

	)

29 
	#MP_INTERRUPTTYPE_INT
 0

	)

30 
	#MP_INTERRUPTTYPE_NMI
 1

	)

31 
	#MP_INTERRUPTTYPE_SMI
 2

	)

32 
	#MP_INTERRUPTTYPE_EXITINT
 3

	)

35 
	#MP_INTERRUPT_FLAGS_CONFORMPOLARITY
 0x00

	)

36 
	#MP_INTERRUPT_FLAGS_ACTIVVEHIGH
 0x01

	)

37 
	#MP_INTERRUPT_FLAGS_ACTIVELOW
 0x03

	)

38 
	#MP_INTERRUPT_FLAGS_CONFORMTRIGGER
 0x00

	)

39 
	#MP_INTERRUPT_FLAGS_EDGETRIGGERED
 0x04

	)

40 
	#MP_INTERRUPT_FLAGS_LEVELTRIGGERED
 0x0c

	)

44 #agm
ck
(
push
,1)

47 
	skMPFltgPorSu


50 
	mvcSigtu
[4];

52 
DWORD
 
	mdwMPCfigutiTabAddss
;

54 
BYTE
 
	mbLgth
;

56 
BYTE
 
	mbRevisi
;

58 
BYTE
 
	mbCheckSum
;

60 
BYTE
 
	mvbMPFtuBy
[5];

61 } 
	tMPFLOATINGPOINTER
;

64 
	skMPCfigutiTabHdSu


67 
	mvcSigtu
[4];

69 
WORD
 
	mwBaTabLgth
;

71 
BYTE
 
	mbRevisi
;

73 
BYTE
 
	mbCheckSum
;

75 
	mvcOEMIDSg
[8];

77 
	mvcProduIDSg
[12];

79 
DWORD
 
	mdwOEMTabPorAddss
;

81 
WORD
 
	mwOEMTabSize
;

83 
WORD
 
	mwEryCou
;

85 
DWORD
 
	mdwMemyMIOAddssOfLolAPIC
;

87 
WORD
 
	mwExndedTabLgth
;

89 
BYTE
 
	mbExndedTabChecksum
;

91 
BYTE
 
	mbRerved
;

92 } 
	tMPCONFIGURATIONTABLEHEADER
;

95 
	skProssErySu


98 
BYTE
 
	mbEryTy
;

100 
BYTE
 
	mbLolAPICID
;

102 
BYTE
 
	mbLolAPICVsi
;

104 
BYTE
 
	mbCPUFgs
;

106 
BYTE
 
	mvbCPUSigtu
[4];

108 
DWORD
 
	mdwFtuFgs
;

110 
DWORD
 
	mvdwRerved
[2];

111 } 
	tPROCESSORENTRY
;

114 
	skBusErySu


117 
BYTE
 
	mbEryTy
;

119 
BYTE
 
	mbBusID
;

121 
	mvcBusTySg
[6];

122 } 
	tBUSENTRY
;

125 
	skIOAPICErySu


128 
BYTE
 
	mbEryTy
;

130 
BYTE
 
	mbIOAPICID
;

132 
BYTE
 
	mbIOAPICVsi
;

134 
BYTE
 
	mbIOAPICFgs
;

136 
DWORD
 
	mdwMemyMAddss
;

137 } 
	tIOAPICENTRY
;

140 
	skIOIruAssignmtErySu


143 
BYTE
 
	mbEryTy
;

145 
BYTE
 
	mbIruTy
;

147 
WORD
 
	mwIruFgs
;

149 
BYTE
 
	mbSourBUSID
;

151 
BYTE
 
	mbSourBUSIRQ
;

153 
BYTE
 
	mbDeiIOAPICID
;

155 
BYTE
 
	mbDeiIOAPICINTIN
;

156 } 
	tIOINTERRUPTASSIGNMENTENTRY
;

159 
	skLolIruErySu


162 
BYTE
 
	mbEryTy
;

164 
BYTE
 
	mbIruTy
;

166 
WORD
 
	mwIruFgs
;

168 
BYTE
 
	mbSourBUSID
;

170 
BYTE
 
	mbSourBUSIRQ
;

172 
BYTE
 
	mbDeiLolAPICID
;

174 
BYTE
 
	mbDeiLolAPICINTIN
;

175 } 
	tLOCALINTERRUPTASSIGNMENTENTRY
;

177 #agm
ck
(
p
)

180 
	skMPCfigutiMagSu


183 
MPFLOATINGPOINTER
* 
	mpMPFltgPor
;

185 
MPCONFIGURATIONTABLEHEADER
* 
	mpMPCfigutiTabHd
;

187 
QWORD
 
	mqwBaErySAddss
;

189 
	miProssCou
;

191 
BOOL
 
	mbUPICMode
;

193 
BYTE
 
	mbISABusID
;

194 } 
	tMPCONFIGURATIONMANAGER
;

197 
BOOL
 
kFdMPFltgPorAddss
(
QWORD
* 
pAddss
);

198 
BOOL
 
kAlysisMPCfigutiTab
();

199 
MPCONFIGURATIONMANAGER
* 
kGMPCfigutiMag
(
voic
);

200 
kPrtMPCfigutiTab
();

201 
kGProssCou
();

	@/home/jk/os/MINT64/02.Kernel64/Source/Main.c

9 
	~"Tys.h
"

10 
	~"Keybrd.h
"

11 
	~"Dest.h
"

12 
	~"PIC.h
"

13 
	~"Cse.h
"

14 
	~"CseShl.h
"

15 
	~"Task.h
"

16 
	~"PIT.h
"

17 
	~"DymicMemy.h
"

18 
	~"HdDisk.h
"

19 
	~"FeSyem.h
"

20 
	~"SlPt.h
"

21 
	~"MuiPross.h
"

24 
MaFAlitiPross
( );

30 
	$Ma
( )

32 
iCursX
, 
iCursY
;

36 if*
BYTE
* ) 
BOOTSTRAPPROCESSOR_FLAGADDRESS
 ) == 0 )

38 
	`MaFAlitiPross
();

43 *
BYTE
* ) 
BOOTSTRAPPROCESSOR_FLAGADDRESS
 ) = 0;

46 
	`kInlizeCse
( 0, 10 );

47 
	`kPrtf
( "Switch To IA-32e Mode Success~!!\n" );

48 
	`kPrtf
( "IA-32e C Language Kernel Start..............[Pass]\n" );

49 
	`kPrtf
( "Initialize Console..........................[Pass]\n" );

52 
	`kGCurs
&
iCursX
, &
iCursY
 );

53 
	`kPrtf
( "GDT Initialize And Switch For IA-32e Mode...[ ]" );

54 
	`kInlizeGDTTabAndTSS
();

55 
	`kLdGDTR

GDTR_STARTADDRESS
 );

56 
	`kSCurs
45, 
iCursY
++ );

57 
	`kPrtf
( "Pass\n" );

59 
	`kPrtf
( "TSS Segment Load............................[ ]" );

60 
	`kLdTR

GDT_TSSSEGMENT
 );

61 
	`kSCurs
45, 
iCursY
++ );

62 
	`kPrtf
( "Pass\n" );

64 
	`kPrtf
( "IDT Initialize..............................[ ]" );

65 
	`kInlizeIDTTabs
();

66 
	`kLdIDTR

IDTR_STARTADDRESS
 );

67 
	`kSCurs
45, 
iCursY
++ );

68 
	`kPrtf
( "Pass\n" );

70 
	`kPrtf
( "Total RAM Size Check........................[ ]" );

71 
	`kCheckTٮRAMSize
();

72 
	`kSCurs
45, 
iCursY
++ );

73 
	`kPrtf
"Pass], Siz%d MB\n", 
	`kGTٮRAMSize
() );

75 
	`kPrtf
( "TCB Pool And Scheduler Initialize...........[Pass]\n" );

76 
iCursY
++;

77 
	`kInlizeSchedur
();

80 
	`kPrtf
( "Dynamic Memory Initialize...................[Pass]\n" );

81 
iCursY
++;

82 
	`kInlizeDymicMemy
();

85 
	`kInlizePIT

	`MSTOCOUNT
( 1 ), 1 );

87 
	`kPrtf
( "Keyboard Activate And Queue Initialize......[ ]" );

89 if
	`kInlizeKeybrd
(=
TRUE
 )

91 
	`kSCurs
45, 
iCursY
++ );

92 
	`kPrtf
( "Pass\n" );

93 
	`kChgeKeybrdLED

FALSE
, FALSE, FALSE );

97 
	`kSCurs
45, 
iCursY
++ );

98 
	`kPrtf
( "Fail\n" );

102 
	`kPrtf
( "PIC Controller And Interrupt Initialize.....[ ]" );

104 
	`kInlizePIC
();

105 
	`kMaskPICIru
( 0 );

106 
	`kEbIru
();

107 
	`kSCurs
45, 
iCursY
++ );

108 
	`kPrtf
( "Pass\n" );

111 
	`kPrtf
( "File System Initialize......................[ ]" );

112 if
	`kInlizeFeSyem
(=
TRUE
 )

114 
	`kSCurs
45, 
iCursY
++ );

115 
	`kPrtf
( "Pass\n" );

119 
	`kSCurs
45, 
iCursY
++ );

120 
	`kPrtf
( "Fail\n" );

124 
	`kPrtf
( "Serial Port Initialize......................[Pass]\n" );

125 
iCursY
++;

126 
	`kInlizeSlPt
();

129 
	`kCeTask

TASK_FLAGS_LOWEST
 | 
TASK_FLAGS_THREAD
 | 
TASK_FLAGS_SYSTEM
 | 
TASK_FLAGS_IDLE
, 0, 0,

130 
QWORD
 ) 
kIdTask
 );

131 
	`kSCseShl
();

132 
	}
}

139 
	$MaFAlitiPross
( )

141 
QWORD
 
qwTickCou
;

144 
	`kLdGDTR

GDTR_STARTADDRESS
 );

148 
	`kLdTR

GDT_TSSSEGMENT
 + ( 
	`kGAPICID
(* 
GDTENTRY16
 ) ) );

151 
	`kLdIDTR

IDTR_STARTADDRESS
 );

154 
qwTickCou
 = 
	`kGTickCou
();

157 if
	`kGTickCou
(- 
qwTickCou
 > 1000 )

159 
qwTickCou
 = 
	`kGTickCou
();

161 
	`kPrtf
( "Application Processor[APIC ID: %d] Is Activated\n",

162 
	`kGAPICID
() );

165 
	}
}

	@/home/jk/os/MINT64/02.Kernel64/Source/MultiProcessor.c

1 
	~"MuiPross.h
"

2 
	~"MPCfigutiTab.h
"

3 
	~"AsmblyUty.h
"

4 
	~"LolAPIC.h
"

5 
	~"PIT.h
"

7 
BOOL
 
kWakeUpAlitiPross
();

10 vީ
	gg_iWakeUpAlitiProssCou
 = 0;

12 vީ
QWORD
 
	gg_qwAPICIDAddss
 = 0;

15 
BOOL
 
	$kSUpAlitiPross
()

18 if(
	`kAlysisMPCfigutiTab
()==
FALSE
)

20  
FALSE
;

24 
	`kEbGlobLolAPIC
();

27 
	`kEbSoweLolAPIC
();

30 if(
	`kWakeUpAlitiPross
()==
FALSE
)

32  
FALSE
;

35  
TRUE
;

36 
	}
}

40 
BOOL
 
	$kWakeUpAlitiPross
()

42 
MPCONFIGURATIONMANAGER
* 
pMPMag
;

43 
MPCONFIGURATIONTABLEHEADER
* 
pMPHd
;

44 
QWORD
 
qwLolAPICBaAddss
;

45 
BOOL
 
bIruFg
;

46 
i
;

49 
bIruFg
 = 
	`kSIruFg
(
FALSE
);

52 
pMPMag
 = 
	`kGMPCfigutiMag
();

53 
pMPHd
 = 
pMPMag
->
pMPCfigutiTabHd
;

54 
qwLolAPICBaAddss
 = 
pMPHd
->
dwMemyMIOAddssOfLolAPIC
;

58 
g_qwAPICIDAddss
 = 
qwLolAPICBaAddss
 + 
APIC_REGISTER_APICID
;

68 *(
DWORD
*)(
qwLolAPICBaAddss
+
APIC_REGISTER_ICR_LOWER
)=
APIC_DESTINATIONSHORTHAND_ALLEXCLUDINGSELF
 | 
APIC_TRIGGERMODE_EDGE
 | 
APIC_LEVEL_ASSERT
 | 
APIC_DESTINATIONMODE_PHYSICAL
 | 
APIC_DELIVERYMODE_INIT
;

71 
	`kWaUsgDePIT
(
	`MSTOCOUNT
(10));

75 if(*(
DWORD
*)(
qwLolAPICBaAddss
+
APIC_REGISTER_ICR_LOWER
)&
APIC_DELIVERYSTATUS_PENDING
)

78 
	`kInlizePIT
(
	`MSTOCOUNT
(1),
TRUE
);

81 
	`kSIruFg
(
bIruFg
);

82  
FALSE
;

88 
i
=0;i<2;i++)

95 *(
DWORD
*)(
qwLolAPICBaAddss
+
APIC_REGISTER_ICR_LOWER

APIC_DESTINATIONSHORTHAND_ALLEXCLUDINGSELF
 | 
APIC_TRIGGERMODE_EDGE
 | 
APIC_LEVEL_ASSERT
 | 
APIC_DESTINATIONMODE_PHYSICAL
 | 
APIC_DELIVERYMODE_STARTUP
 | 0x10;

98 
	`kWaUsgDePIT
(
	`USTOCOUNT
(200));

102 if(*(
DWORD
*)(
qwLolAPICBaAddss
+
APIC_REGISTER_ICR_LOWER
)&
APIC_DELIVERYSTATUS_PENDING
)

105 
	`kInlizePIT
(
	`MSTOCOUNT
(1),
TRUE
);

108 
	`kSIruFg
(
bIruFg
);

109  
FALSE
;

114 
	`kInlizePIT
(
	`MSTOCOUNT
(1),
TRUE
);

117 
	`kSIruFg
(
bIruFg
);

120 
g_iWakeUpAlitiProssCou
<(
pMPMag
->
iProssCou
-1))

122 
	`kS˕
(50);

125  
TRUE
;

126 
	}
}

129 
BYTE
 
	$kGAPICID
()

131 
MPCONFIGURATIONTABLEHEADER
* 
pMPHd
;

132 
QWORD
 
qwLolAPICBaAddss
;

135 if(
g_qwAPICIDAddss
==0)

138 
pMPHd
 = 
	`kGMPCfigutiMag
()->
pMPCfigutiTabHd
;

139 if(
pMPHd
==
NULL
)

145 
qwLolAPICBaAddss
 = 
pMPHd
->
dwMemyMIOAddssOfLolAPIC
;

146 
g_qwAPICIDAddss
 = 
qwLolAPICBaAddss
 + 
APIC_REGISTER_APICID
;

150  *((
DWORD
*)
g_qwAPICIDAddss
)>>24;

151 
	}
}

	@/home/jk/os/MINT64/02.Kernel64/Source/MultiProcessor.h

1 #ide
__MULTIPROCESSOR_H__


2 
	#__MULTIPROCESSOR_H__


	)

4 
	~"Tys.h
"

8 
	#BOOTSTRAPPROCESSOR_FLAGADDRESS
 0x7C09

	)

10 
	#MAXPROCESSORCOUNT
 16

	)

13 
BOOL
 
kSUpAlitiPross
();

14 
BYTE
 
kGAPICID
();

	@/home/jk/os/MINT64/02.Kernel64/Source/PIC.c

1 
	~"PIC.h
"

4 
	$kInlizePIC
()

9 
	`kOutPtBy
(
PIC_MASTER_PORT1
,0x11);

12 
	`kOutPtBy
(
PIC_MASTER_PORT2
,
PIC_IRQSTARTVECTOR
);

16 
	`kOutPtBy
(
PIC_MASTER_PORT2
,0x04);

19 
	`kOutPtBy
(
PIC_MASTER_PORT2
,0x01);

24 
	`kOutPtBy
(
PIC_SLAVE_PORT1
,0x11);

27 
	`kOutPtBy
(
PIC_SLAVE_PORT2
,
PIC_IRQSTARTVECTOR
+8);

31 
	`kOutPtBy
(
PIC_SLAVE_PORT2
,0x02);

34 
	`kOutPtBy
(
PIC_SLAVE_PORT2
,0x01);

35 
	}
}

38 
	$kMaskPICIru
(
WORD
 
wIRQBmask
)

42 
	`kOutPtBy
(
PIC_MASTER_PORT2
,(
BYTE
)
wIRQBmask
);

46 
	`kOutPtBy
(
PIC_SLAVE_PORT2
,(
BYTE
)
wIRQBmask
>>8);

47 
	}
}

52 
	$kSdEOIToPIC
(
iIRQNumb
)

56 
	`kOutPtBy
(
PIC_MASTER_PORT1
,0x20);

59 if(
iIRQNumb
>=8)

62 
	`kOutPtBy
(
PIC_SLAVE_PORT1
,0x20);

64 
	}
}

	@/home/jk/os/MINT64/02.Kernel64/Source/PIC.h

1 #ide
__PIC_H__


2 
	#__PIC_H__


	)

4 
	~"Tys.h
"

8 
	#PIC_MASTER_PORT1
 0x20

	)

9 
	#PIC_MASTER_PORT2
 0x21

	)

10 
	#PIC_SLAVE_PORT1
 0xA0

	)

11 
	#PIC_SLAVE_PORT2
 0xA1

	)

14 
	#PIC_IRQSTARTVECTOR
 0x20

	)

17 
kInlizePIC
( );

18 
kMaskPICIru

WORD
 
wIRQBmask
 );

19 
kSdEOIToPIC

iIRQNumb
 );

	@/home/jk/os/MINT64/02.Kernel64/Source/PIT.c

1 
	~"PIT.h
"

2 
	~"AsmblyUty.h
"

5 
	$kInlizePIT
(
WORD
 
wCou
,
BOOL
 
bPiodic
)

9 if(
bPiodic
==
TRUE
)

12 
	`kOutPtBy
(
PIT_PORT_CONTROL
,
PIT_COUNTER0_PERIODIC
);

16 
	`kOutPtBy
(
PIT_PORT_CONTROL
,
PIT_COUNTER0_ONCE
);

20 
	`kOutPtBy
(
PIT_PORT_COUNTER0
,
wCou
);

21 
	`kOutPtBy
(
PIT_PORT_COUNTER0
,
wCou
>>8);

22 
	}
}

25 
WORD
 
	$kRdCou0
()

27 
BYTE
 
bHighBy
,
bLowBy
;

28 
WORD
 
wTemp
=0;

31 
	`kOutPtBy
(
PIT_PORT_CONTROL
,
PIT_CONTER0_LATCH
);

34 
bLowBy
 = 
	`kInPtBy
(
PIT_PORT_COUNTER0
);

35 
bHighBy
 = 
	`kInPtBy
(
PIT_PORT_COUNTER0
);

38 
wTemp
 = 
bHighBy
;

39 
wTemp
 = (wTemp<<8)|
bLowBy
;

40  
wTemp
;

41 
	}
}

47 
	$kWaUsgDePIT
(
WORD
 
wCou
)

49 
WORD
 
wLaCou0
;

50 
WORD
 
wCuCou0
;

53 
	`kInlizePIT
(0,
TRUE
);

56 
wLaCou0
 = 
	`kRdCou0
();

60 
wCuCou0
=
	`kRdCou0
();

61 if(((
wLaCou0
-
wCuCou0
)&0xFFFF)>=
wCou
)

66 
	}
}

	@/home/jk/os/MINT64/02.Kernel64/Source/PIT.h

1 #ide
__PIT_H__


2 
	#__PIT_H__


	)

4 
	~"Tys.h
"

7 
	#PIT_FREQUENCY
 1193182

	)

8 
	#MSTOCOUNT
(
x
(
PIT_FREQUENCY
*(x)/1000)

	)

9 
	#USTOCOUNT
(
x
(
PIT_FREQUENCY
*(x)/1000000)

	)

12 
	#PIT_PORT_CONTROL
 0x43

	)

13 
	#PIT_PORT_COUNTER0
 0x40

	)

14 
	#PIT_PORT_COUNTER1
 0x41

	)

15 
	#PIT_PORT_COUNTER2
 0x42

	)

18 
	#PIT_CONTROL_COUNTER0
 0x00

	)

19 
	#PIT_CONTROL_COUNTER1
 0x40

	)

20 
	#PIT_CONTROL_COUNTER2
 0x80

	)

21 
	#PIT_CONTROL_LSBMSBRW
 0x30

	)

22 
	#PIT_CONTROL_LATCH
 0x00

	)

23 
	#PIT_CONTROL_MODE0
 0x00

	)

24 
	#PIT_CONTROL_MODE2
 0x04

	)

27 
	#PIT_CONTROL_BINARYCOUNTER
 0x00

	)

28 
	#PIT_CONTROL_BCDCOUNTER
 0x01

	)

30 
	#PIT_COUNTER0_ONCE
 (
PIT_CONTROL_COUNTER0
|
PIT_CONTROL_LSBMSBRW
|
PIT_CONTROL_MODE0
|
PIT_CONTROL_BINARYCOUNTER
)

	)

31 
	#PIT_COUNTER0_PERIODIC
 (
PIT_CONTROL_COUNTER0
|
PIT_CONTROL_LSBMSBRW
|
PIT_CONTROL_MODE2
|
PIT_CONTROL_BINARYCOUNTER
)

	)

32 
	#PIT_CONTER0_LATCH
 (
PIT_CONTROL_COUNTER0
|
PIT_CONTROL_LATCH
)

	)

35 
kInlizePIT
(
WORD
 
wCou
,
BOOL
 
bPiodic
);

36 
WORD
 
kRdCou0
();

37 
kWaUsgDePIT
(
WORD
 
wCou
);

	@/home/jk/os/MINT64/02.Kernel64/Source/Queue.c

1 
	~"Queue.h
"

2 
	~"Uty.h
"

5 
	$kInlizeQueue
(
QUEUE
* 
pQueue
,* 
pvQueueBufr
,
iMaxDaCou
,
iDaSize
)

8 
pQueue
->
iMaxDaCou
=iMaxDataCount;

9 
pQueue
->
iDaSize
=iDataSize;

10 
pQueue
->
pvQueueAay
=
pvQueueBufr
;

13 
pQueue
->
iPutIndex
=0;

14 
pQueue
->
iGdex
=0;

15 
pQueue
->
bLaOiPut
=
FALSE
;

16 
	}
}

19 
BOOL
 
	$kIsQueueFu
(cڡ 
QUEUE
* 
pQueue
)

22 if((
pQueue
->
iGdex
=Queue->
iPutIndex
)&&աQueue->
bLaOiPut
==
TRUE
))

24  
TRUE
;

26  
FALSE
;

27 
	}
}

30 
BOOL
 
	$kIsQueueEmy
(cڡ 
QUEUE
* 
pQueue
)

33 if((
pQueue
->
iGdex
=Queue->
iPutIndex
)&&աQueue->
bLaOiPut
==
FALSE
))

35  
TRUE
;

37  
FALSE
;

38 
	}
}

41 
BOOL
 
	$kPutQueue
(
QUEUE
* 
pQueue
,cڡ * 
pvDa
)

43 if(
	`kIsQueueFu
(
pQueue
)==
TRUE
)

45  
FALSE
;

49 
	`kMemCpy
((*)
pQueue
->
pvQueueAay
+աQueue->
iDaSize
*pQueue->
iPutIndex
),
pvDa
,pstQueue->iDataSize);

52 
pQueue
->
iPutIndex
=աQueue->iPutIndex+1)%pQueue->
iMaxDaCou
;

53 
pQueue
->
bLaOiPut
=
TRUE
;

54  
TRUE
;

55 
	}
}

58 
BOOL
 
	$kGQueue
(
QUEUE
* 
pQueue
,* 
pvDa
)

61 if(
	`kIsQueueEmy
(
pQueue
)==
TRUE
)

63  
FALSE
;

67 
	`kMemCpy
(
pvDa
,(*)
pQueue
->
pvQueueAay
+աQueue->
iDaSize
*pQueue->
iGdex
),pstQueue->iDataSize);

70 
pQueue
->
iGdex
=աQueue->iGdex+1)%pQueue->
iMaxDaCou
;

71 
pQueue
->
bLaOiPut
=
FALSE
;

72  
TRUE
;

73 
	}
}

	@/home/jk/os/MINT64/02.Kernel64/Source/Queue.h

1 #ide
__QUEUE_H__


2 
	#__QUEUE_H__


	)

4 
	~"Tys.h
"

8 #agm
ck
(
push
,1)

11 
	skQueueMagSu


14 
	miDaSize
;

15 
	miMaxDaCou
;

18 * 
	mpvQueueAay
;

19 
	miPutIndex
;

20 
	miGdex
;

23 
BOOL
 
	mbLaOiPut
;

24 } 
	tQUEUE
;

26 #agm
ck
(
p
)

29 
kInlizeQueue
(
QUEUE
* 
pQueue
,* 
pvQueueBufr
,
iMaxDaCou
,
iDaSize
);

30 
BOOL
 
kIsQueueFu
(cڡ 
QUEUE
* 
pQueue
);

31 
BOOL
 
kIsQueueEmy
(cڡ 
QUEUE
* 
pQueue
);

32 
BOOL
 
kPutQueue
(
QUEUE
* 
pQueue
,cڡ * 
pvDa
);

33 
BOOL
 
kGQueue
(
QUEUE
* 
pQueue
,* 
pvDa
);

	@/home/jk/os/MINT64/02.Kernel64/Source/RAMDisk.c

1 
	~"RAMDisk.h
"

2 
	~"Uty.h
"

3 
	~"DymicMemy.h
"

6 
RDDMANAGER
 
	ggs_RDDMag
;

9 
BOOL
 
	$kInlizeRDD
(
DWORD
 
dwTٮSeCou
)

12 
	`kMemS
(&
gs_RDDMag
,0,(gs_stRDDManager));

15 
gs_RDDMag
.
pbBufr
 = (
BYTE
*)
	`kAoMemy
(
dwTٮSeCou
*512);

16 if(
gs_RDDMag
.
pbBufr
==
NULL
)

18  
NULL
;

22 
gs_RDDMag
.
dwTٮSeCou
 = dwTotalSectorCount;

23 
	`kInlizeMux
(&(
gs_RDDMag
.
Mux
));

25  
TRUE
;

26 
	}
}

29 
BOOL
 
	$kRdRDDInfmi
(
BOOL
 
bPrimy
,BOOL 
bMa
,
HDDINFORMATION
* 
pHDDInfmi
)

32 
	`kMemS
(
pHDDInfmi
,0,(
HDDINFORMATION
));

35 
pHDDInfmi
->
dwTٮSes
 = 
gs_RDDMag
.
dwTٮSeCou
;

36 
	`kMemCpy
(
pHDDInfmi
->
vwSlNumb
,"0000-0000",9);

37 
	`kMemCpy
(
pHDDInfmi
->
vwModNumb
,"MINT RAM Disk v1.0",18);

39  
TRUE
;

40 
	}
}

43 
	$kRdRDDSe
(
BOOL
 
bPrimy
,BOOL 
bMa
,
DWORD
 
dwLBA
,
iSeCou
,* 
pcBufr
)

45 
iRlRdCou
;

49 
iRlRdCou
 = 
	`MIN
(
gs_RDDMag
.
dwTٮSeCou
-
dwLBA
,
iSeCou
);

52 
	`kMemCpy
(
pcBufr
,
gs_RDDMag
.
pbBufr
+(
dwLBA
*512),
iRlRdCou
*512);

54  
iRlRdCou
;

55 
	}
}

58 
	$kWreRDDSe
(
BOOL
 
bPrimy
,BOOL 
bMa
,
DWORD
 
dwLBA
,
iSeCou
,* 
pcBufr
)

60 
iRlWreCou
;

64 
iRlWreCou
 = 
	`MIN
(
gs_RDDMag
.
dwTٮSeCou
 - 
dwLBA
,
iSeCou
);

67 
	`kMemCpy
(
gs_RDDMag
.
pbBufr
+(
dwLBA
*512),
pcBufr
,
iRlWreCou
*512);

69  
iRlWreCou
;

70 
	}
}

	@/home/jk/os/MINT64/02.Kernel64/Source/RAMDisk.h

1 #ide
__RAMDISK_H__


2 
	#__RAMDISK_H__


	)

5 
	~"Tys.h
"

6 
	~"Synchrizi.h
"

7 
	~"HdDisk.h
"

11 
	#RDD_TOTALSECTORCOUNT
 (8*1024*1024/512)

	)

15 #agm
ck
(
push
,1)

18 
	skRDDMagSu


21 
BYTE
* 
	mpbBufr
;

24 
DWORD
 
	mdwTٮSeCou
;

27 
MUTEX
 
	mMux
;

28 } 
	tRDDMANAGER
;

30 #agm
ck
(
p
)

33 
BOOL
 
kInlizeRDD
(
DWORD
 
dwTٮSeCou
);

34 
BOOL
 
kRdRDDInfmi
(BOOL 
bPrimy
,BOOL 
bMa
,
HDDINFORMATION
* 
pHDDInfmi
);

35 
kRdRDDSe
(
BOOL
 
bPrimy
,BOOL 
bMa
,
DWORD
 
dwLBA
,
iSeCou
,* 
pcBufr
);

36 
kWreRDDSe
(
BOOL
 
bPrimy
,BOOL 
bMa
,
DWORD
 
dwLBA
,
iSeCou
,* 
pcBufr
);

	@/home/jk/os/MINT64/02.Kernel64/Source/RTC.c

1 
	~"RTC.h
"

2 
	~"AsmblyUty.h
"

5 
	$kRdRTCTime
(
BYTE
* 
pbHour
,BYTE* 
pbMu
,BYTE* 
pbSecd
)

7 
BYTE
 
bDa
;

10 
	`kOutPtBy
(
RTC_CMOSADDRESS
,
RTC_ADDRESS_HOUR
);

12 
bDa
 = 
	`kInPtBy
(
RTC_CMOSDATA
);

13 *
pbHour
 = 
	`RTC_BCDTOBINARY
(
bDa
);

16 
	`kOutPtBy
(
RTC_CMOSADDRESS
,
RTC_ADDRESS_MINUTE
);

18 
bDa
 = 
	`kInPtBy
(
RTC_CMOSDATA
);

19 *
pbMu
 = 
	`RTC_BCDTOBINARY
(
bDa
);

22 
	`kOutPtBy
(
RTC_CMOSADDRESS
,
RTC_ADDRESS_SECOND
);

24 
bDa
 = 
	`kInPtBy
(
RTC_CMOSDATA
);

25 *
pbSecd
 = 
	`RTC_BCDTOBINARY
(
bDa
);

26 
	}
}

29 
	$kRdRTCDa
(
WORD
* 
pwYr
,
BYTE
* 
pbMth
,BYTE* 
pbDayOfMth
,BYTE* 
pbDayOfWk
)

31 
BYTE
 
bDa
;

34 
	`kOutPtBy
(
RTC_CMOSADDRESS
,
RTC_ADDRESS_YEAR
);

36 
bDa
 = 
	`kInPtBy
(
RTC_CMOSDATA
);

37 *
pwYr
 = 
	`RTC_BCDTOBINARY
(
bDa
)+2000;

40 
	`kOutPtBy
(
RTC_CMOSADDRESS
,
RTC_ADDRESS_MONTH
);

42 
bDa
 = 
	`kInPtBy
(
RTC_CMOSDATA
);

43 *
pbMth
 = 
	`RTC_BCDTOBINARY
(
bDa
);

46 
	`kOutPtBy
(
RTC_CMOSADDRESS
,
RTC_ADDRESS_DAYOFMONTH
);

48 
bDa
 = 
	`kInPtBy
(
RTC_CMOSDATA
);

49 *
pbDayOfMth
 = 
	`RTC_BCDTOBINARY
(
bDa
);

52 
	`kOutPtBy
(
RTC_CMOSADDRESS
,
RTC_ADDRESS_DAYOFWEEK
);

54 
bDa
 = 
	`kInPtBy
(
RTC_CMOSDATA
);

55 *
pbDayOfWk
 = 
	`RTC_BCDTOBINARY
(
bDa
);

56 
	}
}

59 * 
	$kCvtDayOfWkToSg
(
BYTE
 
bDayOfWk
)

61 * 
vpcDayOfWkSg
[8] = {"Error","Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"};

64 if(
bDayOfWk
>=8)

66  
vpcDayOfWkSg
[0];

70  
vpcDayOfWkSg
[
bDayOfWk
];

71 
	}
}

	@/home/jk/os/MINT64/02.Kernel64/Source/RTC.h

1 #ide
__RTC_H__


2 
	#__RTC_H__


	)

4 
	~"Tys.h
"

8 
	#RTC_CMOSADDRESS
 0x70

	)

9 
	#RTC_CMOSDATA
 0x71

	)

12 
	#RTC_ADDRESS_SECOND
 0x00

	)

13 
	#RTC_ADDRESS_MINUTE
 0x02

	)

14 
	#RTC_ADDRESS_HOUR
 0x04

	)

15 
	#RTC_ADDRESS_DAYOFWEEK
 0x06

	)

16 
	#RTC_ADDRESS_DAYOFMONTH
 0x07

	)

17 
	#RTC_ADDRESS_MONTH
 0x08

	)

18 
	#RTC_ADDRESS_YEAR
 0x09

	)

21 
	#RTC_BCDTOBINARY
(
x
((((x)>>4)*10)+((x)&0x0F))

	)

24 
kRdRTCTime
(
BYTE
* 
pbHour
,BYTE* 
pbMu
,BYTE* 
pbSecd
);

25 
kRdRTCDa
(
WORD
* 
pwYr
,
BYTE
* 
pbMth
,BYTE* 
pbDayOfMth
,BYTE* 
pbDayOfWk
);

26 * 
kCvtDayOfWkToSg
(
BYTE
 
bDayOfWk
);

	@/home/jk/os/MINT64/02.Kernel64/Source/SerialPort.c

1 
	~"SlPt.h
"

2 
	~"Uty.h
"

5 
SERIALMANAGER
 
	ggs_SlMag
;

8 
BOOL
 
kIsSlTnsmrBufrEmy
();

9 
BOOL
 
kIsSlReiveBufrFu
();

12 
	$kInlizeSlPt
()

14 
WORD
 
wPtBaAddss
;

17 
	`kInlizeMux
(&(
gs_SlMag
.
Lock
));

20 
wPtBaAddss
 = 
SERIAL_PORT_COM1
;

23 
	`kOutPtBy
(
wPtBaAddss
+
SERIAL_PORT_INDEX_INTERRUPTENABLE
,0);

27 
	`kOutPtBy
(
wPtBaAddss
+
SERIAL_PORT_INDEX_LINECONTROL
,
SERIAL_LINECONTROL_DLAB
);

29 
	`kOutPtBy
(
wPtBaAddss
+
SERIAL_PORT_INDEX_DIVISORLATCHLSB
,
SERIAL_DIVISORLATCH_115200
);

31 
	`kOutPtBy
(
wPtBaAddss
+
SERIAL_PORT_INDEX_DIVISORLATCHMSB
,
SERIAL_DIVISORLATCH_115200
>>8);

36 
	`kOutPtBy
(
wPtBaAddss
+
SERIAL_PORT_INDEX_LINECONTROL
,
SERIAL_LINECONTROL_8BIT
|
SERIAL_LINECONTROL_NOPARITY
|
SERIAL_LINECONTROL_1BITSTOP
);

39 
	`kOutPtBy
(
wPtBaAddss
+
SERIAL_PORT_INDEX_FIFOCONTROL
,
SERIAL_FIFOCONTROL_FIFOENABLE
|
SERIAL_FIFOCONTROL_14BYTEFIFO
);

40 
	}
}

43 
BOOL
 
	$kIsSlTnsmrBufrEmy
()

45 
BYTE
 
bDa
;

49 
bDa
 = 
	`kInPtBy
(
SERIAL_PORT_COM1
+
SERIAL_PORT_INDEX_LINESTATUS
);

50 if((
bDa
&
SERIAL_LINESTATUS_TRANSMITBUFFEREMPTY
)==SERIAL_LINESTATUS_TRANSMITBUFFEREMPTY)

52  
TRUE
;

55  
FALSE
;

56 
	}
}

59 
	$kSdSlDa
(
BYTE
* 
pbBufr
,
iSize
)

61 
iStBy
;

62 
iTempSize
;

63 
j
;

66 
	`kLock
(&(
gs_SlMag
.
Lock
));

69 
iStBy
!=
iSize
)

72 
	`kIsSlTnsmrBufrEmy
()==
FALSE
)

74 
	`kS˕
(0);

79 
iTempSize
 = 
	`MIN
(
iSize
-
iStBy
,
SERIAL_FIFOMAXSIZE
);

81 
j
=0;j<
iTempSize
;j++)

84 
	`kOutPtBy
(
SERIAL_PORT_COM1
+
SERIAL_PORT_INDEX_TRANSMITBUFFER
,
pbBufr
[
iStBy
+
j
]);

87 
iStBy
 +
iTempSize
;

91 
	`kUock
(&(
gs_SlMag
.
Lock
));

92 
	}
}

95 
BOOL
 
	$kIsSlReiveBufrFu
()

97 
BYTE
 
bDa
;

101 
bDa
 = 
	`kInPtBy
(
SERIAL_PORT_COM1
+
SERIAL_PORT_INDEX_LINESTATUS
);

102 if((
bDa
&
SERIAL_LINESTATUS_RECEIVEDDATAREADY
)==SERIAL_LINESTATUS_RECEIVEDDATAREADY)

104  
TRUE
;

107  
FALSE
;

108 
	}
}

111 
	$kReiveSlDa
(
BYTE
* 
pbBufr
,
iSize
)

113 
i
;

116 
	`kLock
(&(
gs_SlMag
.
Lock
));

119 
i
=0;i<
iSize
;i++)

122 if(
	`kIsSlReiveBufrFu
()==
FALSE
)

128 
pbBufr
[
i
] = 
	`kInPtBy
(
SERIAL_PORT_COM1
+
SERIAL_PORT_INDEX_RECEIVERBUFFER
);

132 
	`kUock
(&(
gs_SlMag
.
Lock
));

135  
i
;

136 
	}
}

139 
	$kCˬSlFIFO
()

142 
	`kLock
(&(
gs_SlMag
.
Lock
));

146 
	`kOutPtBy
(
SERIAL_PORT_COM1
+
SERIAL_PORT_INDEX_FIFOCONTROL
,
SERIAL_FIFOCONTROL_FIFOENABLE
|
SERIAL_FIFOCONTROL_14BYTEFIFO
|
SERIAL_FIFOCONTROL_CLEARRECEIVEFIFO
|
SERIAL_FIFOCONTROL_CLEARTRANSMITFIFO
);

149 
	`kUock
(&(
gs_SlMag
.
Lock
));

150 
	}
}

	@/home/jk/os/MINT64/02.Kernel64/Source/SerialPort.h

1 #ide
__SERIALPORT_H__


2 
	#__SERIALPORT_H__


	)

4 
	~"Tys.h
"

5 
	~"Queue.h
"

6 
	~"Synchrizi.h
"

10 
	#SERIAL_PORT_COM1
 0x3F8

	)

11 
	#SERIAL_PORT_COM2
 0x2F8

	)

12 
	#SERIAL_PORT_COM3
 0x3E8

	)

13 
	#SERIAL_PORT_COM4
 0x2E8

	)

16 
	#SERIAL_PORT_INDEX_RECEIVERBUFFER
 0x00

	)

17 
	#SERIAL_PORT_INDEX_TRANSMITBUFFER
 0x00

	)

18 
	#SERIAL_PORT_INDEX_INTERRUPTENABLE
 0x01

	)

19 
	#SERIAL_PORT_INDEX_DIVISORLATCHLSB
 0x00

	)

20 
	#SERIAL_PORT_INDEX_DIVISORLATCHMSB
 0x01

	)

21 
	#SERIAL_PORT_INDEX_INTERRUPTIDENTIFICATION
 0x02

	)

22 
	#SERIAL_PORT_INDEX_FIFOCONTROL
 0x02

	)

23 
	#SERIAL_PORT_INDEX_LINECONTROL
 0x03

	)

24 
	#SERIAL_PORT_INDEX_MODEMCONTROL
 0x04

	)

25 
	#SERIAL_PORT_INDEX_LINESTATUS
 0x05

	)

26 
	#SERIAL_PORT_INDEX_MODEMSTATUS
 0x06

	)

29 
	#SERIAL_INTERRUPTENABLE_RECEIVEBUFFERFULL
 0x01

	)

30 
	#SERIAL_INTERRUPTENABLE_TRANSMITTERBUFFEREMPTY
 0x02

	)

31 
	#SERIAL_INTERRUPTENABLE_LINESTATUS
 0x04

	)

32 
	#SERIAL_INTERRUPTENABLE_DELTASTATUS
 0x08

	)

35 
	#SERIAL_FIFOCONTROL_FIFOENABLE
 0x01

	)

36 
	#SERIAL_FIFOCONTROL_CLEARRECEIVEFIFO
 0x02

	)

37 
	#SERIAL_FIFOCONTROL_CLEARTRANSMITFIFO
 0x04

	)

38 
	#SERIAL_FIFOCONTROL_ENABLEDMA
 0x08

	)

39 
	#SERIAL_FIFOCONTROL_1BYTEFIFO
 0x00

	)

40 
	#SERIAL_FIFOCONTROL_4BYTEFIFO
 0x40

	)

41 
	#SERIAL_FIFOCONTROL_8BYTEFIFO
 0x80

	)

42 
	#SERIAL_FIFOCONTROL_14BYTEFIFO
 0xC0

	)

45 
	#SERIAL_LINECONTROL_8BIT
 0x03

	)

46 
	#SERIAL_LINECONTROL_1BITSTOP
 0x00

	)

47 
	#SERIAL_LINECONTROL_NOPARITY
 0x00

	)

48 
	#SERIAL_LINECONTROL_ODDPARITY
 0x08

	)

49 
	#SERIAL_LINECONTROL_EVENPARITY
 0x18

	)

50 
	#SERIAL_LINECONTROL_MARKPARITY
 0x28

	)

51 
	#SERIAL_LINECONTROL_SPACEPARITY
 0x38

	)

52 
	#SERIAL_LINECONTROL_DLAB
 0x80

	)

55 
	#SERIAL_LINESTATUS_RECEIVEDDATAREADY
 0x01

	)

56 
	#SERIAL_LINESTATUS_OVERRUNERROR
 0x02

	)

57 
	#SERIAL_LINESTATUS_PARITYERROR
 0x04

	)

58 
	#SERIAL_LINESTATUS_FRAMINGERROR
 0x08

	)

59 
	#SERIAL_LINESTATUS_BREAKINDICATOR
 0x10

	)

60 
	#SERIAL_LINESTATUS_TRANSMITBUFFEREMPTY
 0x20

	)

61 
	#SERIAL_LINESTATUS_TRANSMITEMPTY
 0x40

	)

62 
	#SERIAL_LINESTATUS_RECEIVEDCHARACTORERROR
 0x80

	)

65 
	#SERIAL_DIVISORLATCH_115200
 1

	)

66 
	#SERIAL_DIVISORLATCH_57600
 2

	)

67 
	#SERIAL_DIVISORLATCH_38400
 3

	)

68 
	#SERIAL_DIVISORLATCH_19200
 6

	)

69 
	#SERIAL_DIVISORLATCH_9600
 12

	)

70 
	#SERIAL_DIVISORLATCH_4800
 24

	)

71 
	#SERIAL_DIVISORLATCH_2400
 48

	)

74 
	#SERIAL_FIFOMAXSIZE
 16

	)

78 
	skSlPtMag


81 
MUTEX
 
	mLock
;

82 } 
	tSERIALMANAGER
;

85 
kInlizeSlPt
();

86 
kSdSlDa
(
BYTE
* 
pbBufr
,
iSize
);

87 
kReiveSlDa
(
BYTE
* 
pbBufr
,
iSize
);

88 
kCˬSlFIFO
();

	@/home/jk/os/MINT64/02.Kernel64/Source/Synchronization.c

1 
	~"Synchrizi.h
"

2 
	~"Uty.h
"

3 
	~"Task.h
"

6 
BOOL
 
	$kLockFSyemDa
()

8  
	`kSIruFg
(
FALSE
);

9 
	}
}

12 
	$kUockFSyemDa
(
BOOL
 
bIruFg
)

14 
	`kSIruFg
(
bIruFg
);

15 
	}
}

18 
	$kInlizeMux
(
MUTEX
* 
pMux
)

21 
pMux
->
bLockFg
 = 
FALSE
;

22 
pMux
->
dwLockCou
=0;

23 
pMux
->
qwTaskID
=
TASK_INVALIDID
;

24 
	}
}

27 
	$kLock
(
MUTEX
* 
pMux
)

30 if(
	`kTeAndS
(&(
pMux
->
bLockFg
),0,1)==
FALSE
)

33 if(
pMux
->
qwTaskID
==
	`kGRugTask
()->
Lk
.
qwID
)

35 
pMux
->
dwLockCou
++;

40 
	`kTeAndS
(&(
pMux
->
bLockFg
),0,1)==
FALSE
)

42 
	`kSchedu
();

47 
pMux
->
dwLockCou
 =1;

48 
pMux
->
qwTaskID
=
	`kGRugTask
()->
Lk
.
qwID
;

50 
	}
}

53 
	$kUock
(
MUTEX
* 
pMux
)

56 if((
pMux
->
bLockFg
==
FALSE
)||աMux->
qwTaskID
!=
	`kGRugTask
()->
Lk
.
qwID
))

62 if(
pMux
->
dwLockCou
>1)

64 
pMux
->
dwLockCou
--;

69 
pMux
->
qwTaskID
 = 
TASK_INVALIDID
;

70 
pMux
->
dwLockCou
 = 0;

71 
pMux
->
bLockFg
=
FALSE
;

73 
	}
}

	@/home/jk/os/MINT64/02.Kernel64/Source/Synchronization.h

1 #ide
__SYNCHRONIZATION_H__


2 
	#__SYNCHRONIZATION_H__


	)

4 
	~"Tys.h
"

8 #agm
ck
(
push
,1)

11 
	skMuxtSu


14 vީ
QWORD
 
	mqwTaskID
;

15 vީ
DWORD
 
	mdwLockCou
;

18 vީ
BOOL
 
	mbLockFg
;

21 
BYTE
 
	mvbPaddg
[3];

22 } 
	tMUTEX
;

24 #agm
ck
(
p
)

27 
BOOL
 
kLockFSyemDa
();

28 
kUockFSyemDa
(
BOOL
 
bIruFg
);

30 
kInlizeMux
(
MUTEX
* 
pMux
);

31 
kLock
(
MUTEX
* 
pMux
);

32 
kUock
(
MUTEX
* 
pMux
);

	@/home/jk/os/MINT64/02.Kernel64/Source/Task.c

1 
	~"Task.h
"

2 
	~"Dest.h
"

3 
	~"Synchrizi.h
"

6 
SCHEDULER
 
	ggs_Schedur
;

7 
TCBPOOLMANAGER
 
	ggs_TCBPoMag
;

11 
kInlizeTCBPo
();

12 
TCB
* 
kAoTCB
();

13 
kFeTCB
(
QWORD
 
qwID
);

14 
kSUpTask
(
TCB
* 
pTCB
,
QWORD
 
qwFgs
,QWORD 
qwEryPotAddss
,* 
pvSckAddss
,QWORD 
qwSckSize
);

17 
TCB
* 
kGNextTaskToRun
();

18 
BOOL
 
kAddTaskToRdyLi
(
TCB
* 
pTask
);

19 
TCB
* 
kRemoveTaskFromRdyLi
(
QWORD
 
qwTaskID
);

20 
TCB
* 
kGProssByThad
(TCB* 
pThad
);

27 
	$kInlizeTCBPo
()

29 
i
;

31 
	`kMemS
(&(
gs_TCBPoMag
),0,(gs_stTCBPoolManager));

34 
gs_TCBPoMag
.
pSAddss
=(
TCB
*)
TASK_TCBPOOLADDRESS
;

35 
	`kMemS
(
TASK_TCBPOOLADDRESS
,0,(
TCB
)*
TASK_MAXCOUNT
);

38 
i
=0;i<
TASK_MAXCOUNT
;i++)

40 
gs_TCBPoMag
.
pSAddss
[
i
].
Lk
.
qwID
=i;

44 
gs_TCBPoMag
.
iMaxCou
=
TASK_MAXCOUNT
;

45 
gs_TCBPoMag
.
iAodCou
=1;

46 
gs_TCBPoMag
.
iUCou
=0;

47 
	}
}

50 
TCB
* 
	$kAoTCB
()

52 
TCB
* 
pEmyTCB
;

53 
i
;

55 if(
gs_TCBPoMag
.
iUCou
==gs_TCBPoMag.
iMaxCou
)

57  
NULL
;

60 
i
=0;i<
gs_TCBPoMag
.
iMaxCou
;i++)

63 if((
gs_TCBPoMag
.
pSAddss
[
i
].
Lk
.
qwID
>>32)==0)

65 
pEmyTCB
=&(
gs_TCBPoMag
.
pSAddss
[
i
]);

71 
pEmyTCB
->
Lk
.
qwID
=((
QWORD
)
gs_TCBPoMag
.
iAodCou
<<32)|
i
;

72 
gs_TCBPoMag
.
iUCou
++;

73 
gs_TCBPoMag
.
iAodCou
++;

74 if(
gs_TCBPoMag
.
iAodCou
==0)

76 
gs_TCBPoMag
.
iAodCou
=1;

78  
pEmyTCB
;

79 
	}
}

82 
	$kFeTCB
(
QWORD
 
qwID
)

84 
i
;

87 
i
 = 
	`GETTCBOFFSET
(
qwID
);

90 
	`kMemS
(&(
gs_TCBPoMag
.
pSAddss
[
i
].
Cڋxt
),0,(
CONTEXT
));

91 
gs_TCBPoMag
.
pSAddss
[
i
].
Lk
.
qwID
=i;

93 
gs_TCBPoMag
.
iUCou
--;

94 
	}
}

99 
TCB
* 
	$kCeTask
(
QWORD
 
qwFgs
,* 
pvMemyAddss
,QWORD 
qwMemySize
,QWORD 
qwEryPotAddss
)

101 
TCB
* 
pTask
,* 
pPross
;

102 * 
pvSckAddss
;

103 
BOOL
 
bPviousFg
;

106 
bPviousFg
 = 
	`kLockFSyemDa
();

107 
pTask
=
	`kAoTCB
();

108 if(
pTask
==
NULL
)

111 
	`kUockFSyemDa
(
bPviousFg
);

112  
NULL
;

116 
pPross
 = 
	`kGProssByThad
(
	`kGRugTask
());

118 if(
pPross
==
NULL
)

120 
	`kFeTCB
(
pTask
->
Lk
.
qwID
);

122 
	`kUockFSyemDa
(
bPviousFg
);

123  
NULL
;

127 if(
qwFgs
&
TASK_FLAGS_THREAD
)

130 
pTask
->
qwPtProssID
 = 
pPross
->
Lk
.
qwID
;

131 
pTask
->
pvMemyAddss
 = 
pPross
->pvMemoryAddress;

132 
pTask
->
qwMemySize
 = 
pPross
->qwMemorySize;

135 
	`kAddLiToTa
(&(
pPross
->
ChdThadLi
),&(
pTask
->
ThadLk
));

140 
pTask
->
qwPtProssID
 = 
pPross
->
Lk
.
qwID
;

141 
pTask
->
pvMemyAddss
 =vMemoryAddress;

142 
pTask
->
qwMemySize
 = qwMemorySize;

146 
pTask
->
ThadLk
.
qwID
 =Task->
Lk
.qwID;

149 
	`kUockFSyemDa
(
bPviousFg
);

152 
pvSckAddss
=(*)(
TASK_STACKPOOLADDRESS
+(
TASK_STACKSIZE
*
	`GETTCBOFFSET
(
pTask
->
Lk
.
qwID
)));

155 
	`kSUpTask
(
pTask
,
qwFgs
,
qwEryPotAddss
,
pvSckAddss
,
TASK_STACKSIZE
);

158 
	`kInlizeLi
(&(
pTask
->
ChdThadLi
));

161 
pTask
->
bFPUUd
 = 
FALSE
;

164 
bPviousFg
 = 
	`kLockFSyemDa
();

167 
	`kAddTaskToRdyLi
(
pTask
);

170 
	`kUockFSyemDa
(
bPviousFg
);

172  
pTask
;

173 
	}
}

176 
	$kSUpTask
(
TCB
* 
pTCB
,
QWORD
 
qwFgs
,QWORD 
qwEryPotAddss
,* 
pvSckAddss
,QWORD 
qwSckSize
)

179 
	`kMemS
(
pTCB
->
Cڋxt
.
vqRegi
,0,(pstTCB->stContext.vqRegister));

182 
pTCB
->
Cڋxt
.
vqRegi
[
TASK_RSPOFFSET
]=(
QWORD
)
pvSckAddss
+
qwSckSize
-8;

183 
pTCB
->
Cڋxt
.
vqRegi
[
TASK_RBPOFFSET
]=(
QWORD
)
pvSckAddss
+
qwSckSize
-8;

187 *(
QWORD
*)((QWORD)
pvSckAddss
+
qwSckSize
-8)=(QWORD)
kExTask
;

190 
pTCB
->
Cڋxt
.
vqRegi
[
TASK_CSOFFSET
]=
GDT_KERNELCODESEGMENT
;

191 
pTCB
->
Cڋxt
.
vqRegi
[
TASK_DSOFFSET
]=
GDT_KERNELDATASEGMENT
;

192 
pTCB
->
Cڋxt
.
vqRegi
[
TASK_ESOFFSET
]=
GDT_KERNELDATASEGMENT
;

193 
pTCB
->
Cڋxt
.
vqRegi
[
TASK_FSOFFSET
]=
GDT_KERNELDATASEGMENT
;

194 
pTCB
->
Cڋxt
.
vqRegi
[
TASK_GSOFFSET
]=
GDT_KERNELDATASEGMENT
;

195 
pTCB
->
Cڋxt
.
vqRegi
[
TASK_SSOFFSET
]=
GDT_KERNELDATASEGMENT
;

198 
pTCB
->
Cڋxt
.
vqRegi
[
TASK_RIPOFFSET
]=
qwEryPotAddss
;

201 
pTCB
->
Cڋxt
.
vqRegi
[
TASK_RFLAGSOFFSET
]|=0x0200;

204 
pTCB
->
pvSckAddss
=pvStackAddress;

205 
pTCB
->
qwSckSize
=qwStackSize;

206 
pTCB
->
qwFgs
=qwFlags;

207 
	}
}

214 
	$kInlizeSchedur
()

216 
i
;

217 
TCB
* 
pTask
;

220 
	`kInlizeTCBPo
();

223 
i
=0;i<
TASK_MAXREADYLISTCOUNT
;i++)

225 
	`kInlizeLi
(&(
gs_Schedur
.
vRdyLi
[
i
]));

226 
gs_Schedur
.
viExecuCou
[
i
]=0;

228 
	`kInlizeLi
(&(
gs_Schedur
.
WaLi
));

231 
pTask
 = 
	`kAoTCB
();

232 
gs_Schedur
.
pRugTask
 = 
pTask
;

233 
pTask
->
qwFgs
 = 
TASK_FLAGS_HIGHEST
 | 
TASK_FLAGS_PROCESS
 | 
TASK_FLAGS_SYSTEM
;

234 
pTask
->
qwPtProssID
 =Task->
Lk
.
qwID
;

235 
pTask
->
pvMemyAddss
 = (*)0x100000;

236 
pTask
->
qwMemySize
 = 0x500000;

237 
pTask
->
pvSckAddss
 = (*)0x600000;

238 
pTask
->
qwSckSize
 = 0x100000;

239 
	`kInlizeLi
(&(
pTask
->
ChdThadLi
));

242 
gs_Schedur
.
qwSndProssTimeInIdTask
=0;

243 
gs_Schedur
.
qwProssLd
=0;

246 
gs_Schedur
.
qwLaFPUUdTaskID
 = 
TASK_INVALIDID
;

248 
	}
}

252 
	$kSRugTask
(
TCB
* 
pTask
)

254 
BOOL
 
bPviousFg
;

257 
bPviousFg
 = 
	`kLockFSyemDa
();

259 
gs_Schedur
.
pRugTask
=
pTask
;

262 
	`kUockFSyemDa
(
bPviousFg
);

263 
	}
}

266 
TCB
* 
	$kGRugTask
()

268 
BOOL
 
bPviousFg
;

269 
TCB
* 
pRugTask
;

272 
bPviousFg
 = 
	`kLockFSyemDa
();

274 
pRugTask
 = 
gs_Schedur
.pstRunningTask;

277 
	`kUockFSyemDa
(
bPviousFg
);

279  
pRugTask
;

280 
	}
}

286 
	$kSchedu
()

288 
TCB
* 
pRugTask
, * 
pNextTask
;

289 
BOOL
 
bPviousFg
;

292 if(
	`kGRdyTaskCou
()<1)

299 
bPviousFg
=
	`kLockFSyemDa
();

302 
pNextTask
=
	`kGNextTaskToRun
();

303 if(
pNextTask
==
NULL
)

306 
	`kUockFSyemDa
(
bPviousFg
);

311 
pRugTask
=
gs_Schedur
.pstRunningTask;

312 
gs_Schedur
.
pRugTask
=
pNextTask
;

315 if((
pRugTask
->
qwFgs
&
TASK_FLAGS_IDLE
)==TASK_FLAGS_IDLE)

317 
gs_Schedur
.
qwSndProssTimeInIdTask
+=
TASK_PROCESSORTIME
-gs_Schedur.
iProssTime
;

321 if(
gs_Schedur
.
qwLaFPUUdTaskID
!=
pNextTask
->
Lk
.
qwID
)

323 
	`kSTS
();

327 
	`kCˬTS
();

336 
gs_Schedur
.
iProssTime
=
TASK_PROCESSORTIME
;

339 if(
pRugTask
->
qwFgs
&
TASK_FLAGS_ENDTASK
)

341 
	`kAddLiToTa
(&(
gs_Schedur
.
WaLi
),
pRugTask
);

342 
	`kSwchCڋxt
(
NULL
,&(
pNextTask
->
Cڋxt
));

346 
	`kAddTaskToRdyLi
(
pRugTask
);

347 
	`kSwchCڋxt
(&(
pRugTask
->
Cڋxt
),&(
pNextTask
->stContext));

353 
	`kUockFSyemDa
(
bPviousFg
);

354 
	}
}

365 
BOOL
 
	$kScheduInIru
()

367 
TCB
* 
pRugTask
, * 
pNextTask
;

368 * 
pcCڋxtAddss
;

369 
BOOL
 
bPviousFg
;

372 
bPviousFg
 = 
	`kLockFSyemDa
();

375 
pNextTask
=
	`kGNextTaskToRun
();

376 if(
pNextTask
==
NULL
)

379 
	`kUockFSyemDa
(
bPviousFg
);

380  
FALSE
;

387 
pcCڋxtAddss
=(*)
IST_STARTADDRESS
+
IST_SIZE
-(
CONTEXT
);

390 
pRugTask
 = 
gs_Schedur
.pstRunningTask;

391 
gs_Schedur
.
pRugTask
 = 
pNextTask
;

395 if((
pRugTask
->
qwFgs
&
TASK_FLAGS_IDLE
)==TASK_FLAGS_IDLE)

397 
gs_Schedur
.
qwSndProssTimeInIdTask
+=
TASK_PROCESSORTIME
-gs_Schedur.
iProssTime
;

401 if(
pRugTask
->
qwFgs
&
TASK_FLAGS_ENDTASK
)

403 
	`kAddLiToTa
(&(
gs_Schedur
.
WaLi
),
pRugTask
);

409 
	`kMemCpy
(&(
pRugTask
->
Cڋxt
),
pcCڋxtAddss
,(
CONTEXT
));

410 
	`kAddTaskToRdyLi
(
pRugTask
);

414 
	`kUockFSyemDa
(
bPviousFg
);

417 if(
gs_Schedur
.
qwLaFPUUdTaskID
!=
pNextTask
->
Lk
.
qwID
)

419 
	`kSTS
();

423 
	`kCˬTS
();

428 
	`kMemCpy
(
pcCڋxtAddss
,&(
pNextTask
->
Cڋxt
),(
CONTEXT
));

431 
gs_Schedur
.
iProssTime
=
TASK_PROCESSORTIME
;

432  
TRUE
;

433 
	}
}

436 
	$kDeProssTime
()

438 if(
gs_Schedur
.
iProssTime
>0)

440 
gs_Schedur
.
iProssTime
--;

442 
	}
}

445 
BOOL
 
	$kIsProssTimeExped
()

447 if(
gs_Schedur
.
iProssTime
<=0)

449  
TRUE
;

451  
FALSE
;

452 
	}
}

455 
TCB
* 
	$kGNextTaskToRun
()

457 
TCB
* 
pTg
=
NULL
;

458 
iTaskCou
,
i
,
j
;

462 
j
=0;j<2;j++)

465 
i
=0;i<
TASK_MAXREADYLISTCOUNT
;i++)

467 
iTaskCou
 = 
	`kGLiCou
(&(
gs_Schedur
.
vRdyLi
[
i
]));

470 if(
gs_Schedur
.
viExecuCou
[
i
]<
iTaskCou
)

472 
pTg
=(
TCB
*)
	`kRemoveLiFromHd
(&(
gs_Schedur
.
vRdyLi
[
i
]));

473 
gs_Schedur
.
viExecuCou
[
i
]++;

479 
gs_Schedur
.
viExecuCou
[
i
]=0;

484 if(
pTg
!=
NULL
)

490  
pTg
;

491 
	}
}

494 
BOOL
 
	$kAddTaskToRdyLi
(
TCB
* 
pTask
)

496 
BYTE
 
bPriܙy
;

498 
bPriܙy
 = 
	`GETPRIORITY
(
pTask
->
qwFgs
);

499 if(
bPriܙy
>=
TASK_MAXREADYLISTCOUNT
)

501  
FALSE
;

504 
	`kAddLiToTa
(&(
gs_Schedur
.
vRdyLi
[
bPriܙy
]),
pTask
);

505  
TRUE
;

506 
	}
}

509 
TCB
* 
	$kRemoveTaskFromRdyLi
(
QWORD
 
qwTaskID
)

511 
TCB
* 
pTg
;

512 
BYTE
 
bPriܙy
;

515 if(
	`GETTCBOFFSET
(
qwTaskID
)>=
TASK_MAXCOUNT
)

517  
NULL
;

521 
pTg
=&(
gs_TCBPoMag
.
pSAddss
[
	`GETTCBOFFSET
(
qwTaskID
)]);

522 if(
pTg
->
Lk
.
qwID
!=
qwTaskID
)

524  
NULL
;

528 
bPriܙy
 = 
	`GETPRIORITY
(
pTg
->
qwFgs
);

530 
pTg
 = 
	`kRemoveLi
(&(
gs_Schedur
.
vRdyLi
[
bPriܙy
]),
qwTaskID
);

531  
pTg
;

532 
	}
}

535 
BOOL
 
	$kChgePriܙy
(
QWORD
 
qwTaskID
,
BYTE
 
bPriܙy
)

537 
TCB
* 
pTg
;

538 
BOOL
 
bPviousFg
;

541 if(
bPriܙy
>
TASK_MAXREADYLISTCOUNT
)

543  
FALSE
;

547 
bPviousFg
 = 
	`kLockFSyemDa
();

552 
pTg
 = 
gs_Schedur
.
pRugTask
;

553 if(
pTg
->
Lk
.
qwID
 =
qwTaskID
)

555 
	`SETPRIORITY
(
pTg
->
qwFgs
,
bPriܙy
);

561 
pTg
 = 
	`kRemoveTaskFromRdyLi
(
qwTaskID
);

562 if(
pTg
==
NULL
)

567 
pTg
 = 
	`kGTCBInTCBPo
(
	`GETTCBOFFSET
(
qwTaskID
));

568 if((
pTg
!=
NULL
)&&(
qwTaskID
=Tg->
Lk
.
qwID
))

571 
	`SETPRIORITY
(
pTg
->
qwFgs
,
bPriܙy
);

573  
FALSE
;

578 
	`SETPRIORITY
(
pTg
->
qwFgs
,
bPriܙy
);

579 
	`kAddTaskToRdyLi
(
pTg
);

584 
	`kUockFSyemDa
(
bPviousFg
);

585  
TRUE
;

586 
	}
}

589 
BOOL
 
	$kEndTask
(
QWORD
 
qwTaskID
)

591 
TCB
* 
pTg
;

592 
BYTE
 
bPriܙy
;

593 
BOOL
 
bPviousFg
;

596 
bPviousFg
 = 
	`kLockFSyemDa
();

599 
pTg
 = 
gs_Schedur
.
pRugTask
;

600 if(
pTg
->
Lk
.
qwID
==
qwTaskID
)

602 
pTg
->
qwFgs
|=
TASK_FLAGS_ENDTASK
;

604 
	`SETPRIORITY
(
pTg
->
qwFgs
,
TASK_FLAGS_WAIT
);

607 
	`kUockFSyemDa
(
bPviousFg
);

609 
	`kSchedu
();

618 
pTg
=
	`kRemoveTaskFromRdyLi
(
qwTaskID
);

619 if(
pTg
==
NULL
)

626 
pTg
 = 
	`kGTCBInTCBPo
(
	`GETTCBOFFSET
(
qwTaskID
));

627 if((
pTg
!=
NULL
)&&աTg->
Lk
.
qwID
==
qwTaskID
))

629 
pTg
->
qwFgs
|=
TASK_FLAGS_ENDTASK
;

630 
	`SETPRIORITY
(
pTg
->
qwFgs
,
TASK_FLAGS_WAIT
);

634 
	`kUockFSyemDa
(
bPviousFg
);

635  
FALSE
;

638 
pTg
->
qwFgs
|=
TASK_FLAGS_ENDTASK
;

639 
	`SETPRIORITY
(
pTg
->
qwFgs
,
TASK_FLAGS_WAIT
);

640 
	`kAddLiToTa
(&(
gs_Schedur
.
WaLi
),
pTg
);

644 
	`kUockFSyemDa
(
bPviousFg
);

645  
TRUE
;

646 
	}
}

649 
	$kExTask
()

651 
	`kEndTask
(
gs_Schedur
.
pRugTask
->
Lk
.
qwID
);

652 
	}
}

655 
	$kGRdyTaskCou
()

657 
iTٮCou
=0;

658 
i
;

659 
BOOL
 
bPviousFg
;

662 
bPviousFg
 = 
	`kLockFSyemDa
();

665 
i
=0;i<
TASK_MAXREADYLISTCOUNT
;i++)

667 
iTٮCou
+=
	`kGLiCou
(&(
gs_Schedur
.
vRdyLi
[
i
]));

670 
	`kUockFSyemDa
(
bPviousFg
);

671  
iTٮCou
;

672 
	}
}

675 
	$kGTaskCou
()

677 
iTٮCou
;

678 
BOOL
 
bPviousFg
;

681 
iTٮCou
=
	`kGRdyTaskCou
();

684 
bPviousFg
 = 
	`kLockFSyemDa
();

686 
iTٮCou
+=
	`kGLiCou
(&(
gs_Schedur
.
WaLi
))+1;

689 
	`kUockFSyemDa
(
bPviousFg
);

690  
iTٮCou
;

691 
	}
}

694 
TCB
* 
	$kGTCBInTCBPo
(
iOfft
)

696 if((
iOfft
<-1)||(iOfft>
TASK_MAXCOUNT
))

698  
NULL
;

701  &(
gs_TCBPoMag
.
pSAddss
[
iOfft
]);

702 
	}
}

705 
BOOL
 
	$kIsTaskExi
(
QWORD
 
qwID
)

707 
TCB
* 
pTCB
;

710 
pTCB
 = 
	`kGTCBInTCBPo
(
	`GETTCBOFFSET
(
qwID
));

712 if((
pTCB
==
NULL
)||աTCB->
Lk
.
qwID
!=qwID))

714  
FALSE
;

717  
TRUE
;

718 
	}
}

721 
QWORD
 
	$kGProssLd
()

723  
gs_Schedur
.
qwProssLd
;

724 
	}
}

727 
TCB
* 
	$kGProssByThad
(
TCB
* 
pThad
)

729 
TCB
* 
pPross
;

732 if(
pThad
->
qwFgs
&
TASK_FLAGS_PROCESS
)

734  
pThad
;

739 
pPross
 = 
	`kGTCBInTCBPo
(
	`GETTCBOFFSET
(
pThad
->
qwPtProssID
));

742 if((
pPross
==
NULL
)||աPross->
Lk
.
qwID
!=
pThad
->
qwPtProssID
))

744  
NULL
;

747  
pPross
;

748 
	}
}

755 
	$kIdTask
()

757 
TCB
* 
pTask
,* 
pChdThad
,* 
pPross
;

758 
QWORD
 
qwLaMsuTickCou
,
qwLaSndTickInIdTask
;

759 
QWORD
 
qwCutMsuTickCou
,
qwCutSndTickInIdTask
;

760 
BOOL
 
bPviousFg
;

761 
i
, 
iCou
;

762 
QWORD
 
qwTaskID
;

763 * 
pThadLk
;

766 
qwLaSndTickInIdTask
 = 
gs_Schedur
.
qwSndProssTimeInIdTask
;

767 
qwLaMsuTickCou
 = 
	`kGTickCou
();

772 
qwCutMsuTickCou
 = 
	`kGTickCou
();

773 
qwCutSndTickInIdTask
 = 
gs_Schedur
.
qwSndProssTimeInIdTask
;

777 if(
qwCutMsuTickCou
-
qwLaMsuTickCou
==0)

779 
gs_Schedur
.
qwProssLd
=0;

783 
gs_Schedur
.
qwProssLd
=100-(
qwCutSndTickInIdTask
-
qwLaSndTickInIdTask
)*100/(
qwCutMsuTickCou
-
qwLaMsuTickCou
);

786 
qwLaMsuTickCou
 = 
qwCutMsuTickCou
;

787 
qwLaSndTickInIdTask
 = 
qwCutSndTickInIdTask
;

790 
	`kHtProssByLd
();

793 if(
	`kGLiCou
(&(
gs_Schedur
.
WaLi
))>=0)

798 
bPviousFg
 = 
	`kLockFSyemDa
();

799 
pTask
=
	`kRemoveLiFromHd
(&(
gs_Schedur
.
WaLi
));

800 if(
pTask
==
NULL
)

803 
	`kUockFSyemDa
(
bPviousFg
);

807 if(
pTask
->
qwFgs
&
TASK_FLAGS_PROCESS
)

818 
iCou
 = 
	`kGLiCou
(&(
pTask
->
ChdThadLi
));

819 
i
=0;i<
iCou
;i++)

822 
pThadLk
 = (
TCB
*)
	`kRemoveLiFromHd
(&(
pTask
->
ChdThadLi
));

823 if(
pThadLk
==
NULL
)

831 
pChdThad
 = 
	`GETTCBFROMTHREADLINK
(
pThadLk
);

832 
	`kAddLiToTa
(&(
pTask
->
ChdThadLi
),&(
pChdThad
->
ThadLk
));

835 
	`kEndTask
(
pChdThad
->
Lk
.
qwID
);

840 if(
	`kGLiCou
(&(
pTask
->
ChdThadLi
))>0)

842 
	`kAddLiToTa
(&(
gs_Schedur
.
WaLi
),
pTask
);

845 
	`kUockFSyemDa
(
bPviousFg
);

854 if(
pTask
->
qwFgs
&
TASK_FLAGS_THREAD
)

857 
pPross
 = 
	`kGProssByThad
(
pTask
);

858 if(
pPross
!=
NULL
)

860 
	`kRemoveLi
(&(
pPross
->
ChdThadLi
),
pTask
->
Lk
.
qwID
);

865 
qwTaskID
 = 
pTask
->
Lk
.
qwID
;

866 
	`kFeTCB
(
qwTaskID
);

868 
	`kUockFSyemDa
(
bPviousFg
);

869 
	`kPrtf
("IDLE: Task Id[0x%q] icomynded.\n",
qwTaskID
);

874 
	`kSchedu
();

876 
	}
}

879 
	$kHtProssByLd
()

881 if(
gs_Schedur
.
qwProssLd
<40)

883 
	`kH
();

884 
	`kH
();

885 
	`kH
();

887 if(
gs_Schedur
.
qwProssLd
<80)

889 
	`kH
();

890 
	`kH
();

892 if(
gs_Schedur
.
qwProssLd
<95)

894 
	`kH
();

896 
	}
}

902 
QWORD
 
	$kGLaFPUUdTaskID
()

904  
gs_Schedur
.
qwLaFPUUdTaskID
;

905 
	}
}

908 
	$kSLaFPUUdTaskID
(
QWORD
 
qwTaskID
)

910 
gs_Schedur
.
qwLaFPUUdTaskID
 = 
qwTaskID
;

911 
	}
}

	@/home/jk/os/MINT64/02.Kernel64/Source/Task.h

1 #ide
__TASK_H__


2 
	#__TASK_H__


	)

4 
	~"Tys.h
"

5 
	~"Li.h
"

9 
	#TASK_REGISTERCOUNT
 (5+19)

	)

10 
	#TASK_REGISTERSIZE
 8

	)

13 
	#TASK_GSOFFSET
 0

	)

14 
	#TASK_FSOFFSET
 1

	)

15 
	#TASK_ESOFFSET
 2

	)

16 
	#TASK_DSOFFSET
 3

	)

17 
	#TASK_R15OFFSET
 4

	)

18 
	#TASK_R14OFFSET
 5

	)

19 
	#TASK_R13OFFSET
 6

	)

20 
	#TASK_R12OFFSET
 7

	)

21 
	#TASK_R11OFFSET
 8

	)

22 
	#TASK_R10OFFSET
 9

	)

23 
	#TASK_R9OFFSET
 10

	)

24 
	#TASK_R8OFFSET
 11

	)

25 
	#TASK_RSIOFFSET
 12

	)

26 
	#TASK_RDIOFFSET
 13

	)

27 
	#TASK_RDXOFFSET
 14

	)

28 
	#TASK_RCXOFFSET
 15

	)

29 
	#TASK_RBXOFFSET
 16

	)

30 
	#TASK_RAXOFFSET
 17

	)

31 
	#TASK_RBPOFFSET
 18

	)

32 
	#TASK_RIPOFFSET
 19

	)

33 
	#TASK_CSOFFSET
 20

	)

34 
	#TASK_RFLAGSOFFSET
 21

	)

35 
	#TASK_RSPOFFSET
 22

	)

36 
	#TASK_SSOFFSET
 23

	)

39 
	#TASK_TCBPOOLADDRESS
 0x800000

	)

40 
	#TASK_MAXCOUNT
 1024

	)

43 
	#TASK_STACKPOOLADDRESS
 (
TASK_TCBPOOLADDRESS
+(
TCB
)*
TASK_MAXCOUNT
)

	)

44 
	#TASK_STACKSIZE
 8192

	)

47 
	#TASK_INVALIDID
 0xFFFFFFFFFFFFFFFF

	)

50 
	#TASK_PROCESSORTIME
 5

	)

53 
	#TASK_MAXREADYLISTCOUNT
 5

	)

56 
	#TASK_FLAGS_HIGHEST
 0

	)

57 
	#TASK_FLAGS_HIGH
 1

	)

58 
	#TASK_FLAGS_MEDIUM
 2

	)

59 
	#TASK_FLAGS_LOW
 3

	)

60 
	#TASK_FLAGS_LOWEST
 4

	)

61 
	#TASK_FLAGS_WAIT
 0xFF

	)

64 
	#TASK_FLAGS_ENDTASK
 0x8000000000000000

	)

65 
	#TASK_FLAGS_SYSTEM
 0x4000000000000000

	)

66 
	#TASK_FLAGS_PROCESS
 0x2000000000000000

	)

67 
	#TASK_FLAGS_THREAD
 0x1000000000000000

	)

68 
	#TASK_FLAGS_IDLE
 0x0800000000000000

	)

71 
	#GETPRIORITY
(
x
((x)&0xFF)

	)

72 
	#SETPRIORITY
(
x
,
iܙy
((x)=((x)&0xFFFFFFFFFFFFFF00)|riܙy))

	)

73 
	#GETTCBOFFSET
(
x
((x)&0xFFFFFFFF)

	)

76 
	#GETTCBFROMTHREADLINK
(
x
(
TCB
*)((
QWORD
)(x)-
	`offtof
(TCB,
ThadLk
))

	)

80 #agm
ck
(
push
,1)

83 
	skCڋxtSu


85 
QWORD
 
	mvqRegi
[
TASK_REGISTERCOUNT
];

86 } 
	tCONTEXT
;

90 
	skTaskCڌBlockSu


93 
LISTLINK
 
	mLk
;

96 
QWORD
 
	mqwFgs
;

99 * 
	mpvMemyAddss
;

100 
QWORD
 
	mqwMemySize
;

106 
LISTLINK
 
	mThadLk
;

109 
QWORD
 
	mqwPtProssID
;

112 
QWORD
 
	mvqwFPUCڋxt
[512/8];

115 
LIST
 
	mChdThadLi
;

118 
CONTEXT
 
	mCڋxt
;

121 * 
	mpvSckAddss
;

122 
QWORD
 
	mqwSckSize
;

125 
BOOL
 
	mbFPUUd
;

128 
	mvcPaddg
[11];

129 } 
	tTCB
;

132 
	skTCBPoMagSu


135 
TCB
* 
	mpSAddss
;

136 
	miMaxCou
;

137 
	miUCou
;

140 
	miAodCou
;

141 } 
	tTCBPOOLMANAGER
;

144 
	skSchedurSu


147 
TCB
* 
	mpRugTask
;

150 
	miProssTime
;

153 
LIST
 
	mvRdyLi
[
TASK_MAXREADYLISTCOUNT
];

156 
LIST
 
	mWaLi
;

159 
	mviExecuCou
[
TASK_MAXREADYLISTCOUNT
];

162 
QWORD
 
	mqwProssLd
;

165 
QWORD
 
	mqwSndProssTimeInIdTask
;

168 
QWORD
 
	mqwLaFPUUdTaskID
;

170 } 
	tSCHEDULER
;

173 #agm
ck
(
p
)

180 
TCB
* 
kCeTask
(
QWORD
 
qwFgs
,* 
pvMemyAddss
,QWORD 
qwMemySize
,QWORD 
qwEryPotAddss
);

186 
kInlizeSchedur
();

187 
kSRugTask
(
TCB
* 
pTask
);

188 
TCB
* 
kGRugTask
();

189 
kSchedu
();

190 
BOOL
 
kScheduInIru
();

191 
kDeProssTime
();

192 
BOOL
 
kIsProssTimeExped
();

193 
BOOL
 
kChgePriܙy
(
QWORD
 
qwID
,
BYTE
 
bPriܙy
);

194 
BOOL
 
kEndTask
(
QWORD
 
qwTaskID
);

195 
kExTask
();

196 
kGRdyTaskCou
();

197 
kGTaskCou
();

198 
TCB
* 
kGTCBInTCBPo
(
iOfft
);

199 
BOOL
 
kIsTaskExi
(
QWORD
 
qwID
);

200 
QWORD
 
kGProssLd
();

206 
kIdTask
();

207 
kHtProssByLd
();

212 
QWORD
 
kGLaFPUUdTaskID
();

213 
kSLaFPUUdTaskID
(
QWORD
 
qwTaskID
);

	@/home/jk/os/MINT64/02.Kernel64/Source/Types.h

1 #ide
__TYPES_H__


2 
	#__TYPES_H__


	)

4 
	#BYTE
 

	)

5 
	#WORD
 

	)

6 
	#DWORD
 

	)

7 
	#QWORD
 

	)

8 
	#BOOL
 

	)

10 
	#TRUE
 1

	)

11 
	#FALSE
 0

	)

12 
	#NULL
 0

	)

15 
	#offtof
(
TYPE
,
MEMBER

	`__but_offtof
(TYPE,MEMBER)

	)

17 #agm
ck
(
push
,1)

19 
	skChaSu


21 
BYTE
 
	mbCha
;

22 
BYTE
 
	mbAribu
;

23 } 
	tCHARACTER
;

25 #agm
ck
(
p
)

	@/home/jk/os/MINT64/02.Kernel64/Source/Utility.c

1 
	~"Uty.h
"

2 
	~"AsmblyUty.h
"

3 
	~<dg.h
>

6 vީ
QWORD
 
	gg_qwTickCou
=0;

9 
	$kMemS
(* 
pvDei
,
BYTE
 
bDa
,
iSize
)

11 
i
;

13 
i
=0;i<
iSize
;i++)

15 ((*)
pvDei
)[
i
]=
bDa
;

17 
	}
}

20 
	$kMemCpy
(* 
pvDei
,cڡ * 
pvSour
,
iSize
)

22 
i
;

24 
i
=0;i<
iSize
;i++)

26 ((*)
pvDei
)[
i
]=((*)
pvSour
)[i];

29  
iSize
;

30 
	}
}

33 
	$kMemCmp
(cڡ * 
pvDei
,cڡ * 
pvSour
,
iSize
)

35 
i
;

36 
cTemp
;

38 
i
=0;i<
iSize
;i++)

40 
cTemp
=((*)
pvDei
)[
i
]-((*)
pvSour
)[i];

42 if(
cTemp
!=0)

44  ()
cTemp
;

49 
	}
}

52 
BOOL
 
	$kSIruFg
(
BOOL
 
bEbIru
)

54 
QWORD
 
qwRFLAGS
;

57 
qwRFLAGS
=
	`kRdRFLAGS
();

58 if(
bEbIru
==
TRUE
)

60 
	`kEbIru
();

64 
	`kDibIru
();

68 if(
qwRFLAGS
&0x0200)

70  
TRUE
;

73  
FALSE
;

74 
	}
}

77 
	$kSL
(cڡ * 
pcBufr
)

79 
i
;

81 
i
=0;;i++)

83 if(
pcBufr
[
i
]=='\0')

89  
i
;

90 
	}
}

93 
	ggs_qwTٮRAMMBSize
=0;

96 
	$kCheckTٮRAMSize
()

98 
DWORD
* 
pdwCutAddss
;

99 
DWORD
 
dwPviousVue
;

102 
pdwCutAddss
 =(
DWORD
*)0x4000000;

106 
dwPviousVue
 = *
pdwCutAddss
;

108 *
pdwCutAddss
 = 0x12345678;

109 if(*
pdwCutAddss
!=0x12345678)

115 *
pdwCutAddss
=
dwPviousVue
;

117 
pdwCutAddss
+=(0x400000/4);

122 
gs_qwTٮRAMMBSize
 = (
QWORD
)
pdwCutAddss
/0x100000;

123 
	}
}

126 
QWORD
 
	$kGTٮRAMSize
()

128  
gs_qwTٮRAMMBSize
;

129 
	}
}

132 
	$kAToI
(cڡ * 
pcBufr
,
iRadix
)

134 
lRu
;

136 
iRadix
)

141 
lRu
 = 
	`kHexSgToQwd
(
pcBufr
);

147 
lRu
 = 
	`kDecimSgToLg
(
pcBufr
);

151  
lRu
;

152 
	}
}

155 
QWORD
 
	$kHexSgToQwd
(cڡ * 
pcBufr
)

157 
QWORD
 
qwVue
 = 0;

158 
i
;

161 
i
=0;
pcBufr
[i]!='\0';i++)

163 
qwVue
*=16;

164 if(('A'<=
pcBufr
[
i
])&&(pcBuffer[i]<='Z'))

166 
qwVue
+=((
pcBufr
[
i
]-'A')+10);

168 if(('a'<=
pcBufr
[
i
])&&(pcBuffer[i]<='z'))

170 
qwVue
+=((
pcBufr
[
i
]-'a')+10);

174 
qwVue
+=(
pcBufr
[
i
]-'0');

178  
qwVue
;

179 
	}
}

182 
	$kDecimSgToLg
(cڡ * 
pcBufr
)

184 
lVue
=0;

185 
i
;

188 if(
pcBufr
[0]=='-')

190 
i
=1;

194 
i
=0;

198 ;
pcBufr
[
i
]!='\0';i++)

200 
lVue
*=10;

201 
lVue
+=
pcBufr
[
i
]-'0';

205 if(
pcBufr
[0]=='-')

207 
lVue
=-lValue;

210  
lVue
;

211 
	}
}

214 
	$kIToA
(
lVue
,* 
pcBufr
,
iRadix
)

216 
iRu
;

218 
iRadix
)

223 
iRu
=
	`kHexToSg
(
lVue
,
pcBufr
);

229 
iRu
=
	`kDecimTorg
(
lVue
,
pcBufr
);

233  
iRu
;

234 
	}
}

237 
	$kHexToSg
(
QWORD
 
qwVue
,* 
pcBufr
)

239 
QWORD
 
i
;

240 
QWORD
 
qwCutVue
;

243 if(
qwVue
==0)

245 
pcBufr
[0]='0';

246 
pcBufr
[1]='\0';

251 
i
=0;
qwVue
>0;i++)

253 
qwCutVue
=
qwVue
%16;

254 if(
qwCutVue
>=10)

256 
pcBufr
[
i
]='A'+(
qwCutVue
-10);

260 
pcBufr
[
i
]='0'+
qwCutVue
;

263 
qwVue
=qwValue/16;

266 
pcBufr
[
i
]='\0';

269 
	`kRevSg
(
pcBufr
);

270  
i
;

271 
	}
}

274 
	$kDecimTorg
(
lVue
,* 
pcBufr
)

276 
i
;

279 if(
lVue
==0)

281 
pcBufr
[0]='0';

282 
pcBufr
[1]='\0';

287 if(
lVue
<0)

289 
i
=1;

290 
pcBufr
[0]='-';

291 
lVue
=-lValue;

295 
i
=0;

299 ;
lVue
>0;
i
++)

301 
pcBufr
[
i
]='0'+
lVue
%10;

302 
lVue
=lValue/10;

304 
pcBufr
[
i
]='\0';

307 if(
pcBufr
[0]=='-')

310 
	`kRevSg
(&(
pcBufr
[1]));

314 
	`kRevSg
(
pcBufr
);

317  
i
;

318 
	}
}

321 
	$kRevSg
(* 
pcBufr
)

323 
iLgth
;

324 
i
;

325 
cTemp
;

328 
iLgth
=
	`kSL
(
pcBufr
);

329 
i
=0;i<
iLgth
/2;i++)

331 
cTemp
=
pcBufr
[
i
];

332 
pcBufr
[
i
]cBufr[
iLgth
-1-i];

333 
pcBufr
[
iLgth
-1-
i
]=
cTemp
;

335 
	}
}

338 
	$kSPrtf
(* 
pcBufr
,cڡ * 
pcFmSg
,...)

340 
va_li
 

;

341 
iRu
;

344 
	`va_t
(

,
pcFmSg
);

345 
iRu
=
	`kVSPrtf
(
pcBufr
,
pcFmSg
,

);

346 
	`va_d
(

);

348  
iRu
;

349 
	}
}

353 
	$kVSPrtf
(* 
pcBufr
,cڡ * 
pcFmSg
,
va_li
 

)

355 
QWORD
 
i
,
j
,
k
;

356 
iBufrIndex
=0;

357 
iFmLgth
,
iCyLgth
;

358 * 
pcCySg
;

359 
QWORD
 
qwVue
;

360 
iVue
;

361 
dVue
;

364 
iFmLgth
=
	`kSL
(
pcFmSg
);

365 
i
=0;i<
iFmLgth
;i++)

368 if(
pcFmSg
[
i
]=='%')

371 
i
++;

372 
pcFmSg
[
i
])

377 
pcCySg
=(*)(
	`va_g
(

,*));

378 
iCyLgth
=
	`kSL
(
pcCySg
);

380 
	`kMemCpy
(
pcBufr
+
iBufrIndex
,
pcCySg
,
iCyLgth
);

381 
iBufrIndex
+=
iCyLgth
;

387 
pcBufr
[
iBufrIndex
]=()(
	`va_g
(

,));

388 
iBufrIndex
++;

396 
iVue
=()(
	`va_g
(

,));

397 
iBufrIndex
+=
	`kIToA
(
iVue
,
pcBufr
+iBufferIndex,10);

405 
qwVue
=(
DWORD
)(
	`va_g
(

,DWORD))&0xFFFFFFFF;

406 
iBufrIndex
+=
	`kIToA
(
qwVue
,
pcBufr
+iBufferIndex,16);

415 
qwVue
=(
QWORD
)(
	`va_g
(

,QWORD));

416 
iBufrIndex
+=
	`kIToA
(
qwVue
,
pcBufr
+iBufferIndex,16);

420 
dVue
 = ()(
	`va_g
(

,));

422 
dVue
 +=0.005;

424 
pcBufr
[
iBufrIndex
]='0'+(
QWORD
)(
dVue
*100)%10;

425 
pcBufr
[
iBufrIndex
+1]='0'+(
QWORD
)(
dVue
*10)%10;

426 
pcBufr
[
iBufrIndex
+2]='.';

428 
k
=0;;k++)

431 if(((
QWORD
)
dVue
==0)&&(
k
!=0))

435 
pcBufr
[
iBufrIndex
+3+
k
]='0'+((
QWORD
)
dVue
%10);

436 
dVue
=dValue/10;

438 
pcBufr
[
iBufrIndex
+3+
k
]='\0';

440 
	`kRevSg
(
pcBufr
+
iBufrIndex
);

441 
iBufrIndex
+=3+
k
;

446 
pcBufr
[
iBufrIndex
]=
pcFmSg
[
i
];

447 
iBufrIndex
++;

455 
pcBufr
[
iBufrIndex
] = 
pcFmSg
[
i
];

456 
iBufrIndex
++;

461 
pcBufr
[
iBufrIndex
]='\0';

462  
iBufrIndex
;

463 
	}
}

466 
QWORD
 
	$kGTickCou
()

468  
g_qwTickCou
;

469 
	}
}

472 
	$kS˕
(
QWORD
 
qwMlicd
)

474 
QWORD
 
qwLaTickCou
;

476 
qwLaTickCou
 = 
g_qwTickCou
;

478 (
g_qwTickCou
-
qwLaTickCou
)<=
qwMlicd
)

480 
	`kSchedu
();

482 
	}
}

	@/home/jk/os/MINT64/02.Kernel64/Source/Utility.h

1 #ide
__UTILITY_H__


2 
	#__UTILITY_H__


	)

4 
	~"/u/oss/lib/gcc/x86_64-pc-lux/4.8.2/ude/dg.h
"

5 
	~"Tys.h
"

8 
	#MIN
(
x
,
y
(((x)<(y))?(x):(y))

	)

9 
	#MAX
(
x
,
y
(((x)<(y))?(x):(y))

	)

12 
kMemS
(* 
pvDei
, 
BYTE
 
bDa
, 
iSize
);

13 
kMemCpy
(* 
pvDei
,cڡ * 
pvSour
,
iSize
);

14 
kMemCmp
(cڡ * 
pvDei
,cڡ * 
pvSour
,
iSize
);

15 
BOOL
 
kSIruFg
(BOOL 
bEbIru
);

16 
kCheckTٮRAMSize
();

17 
QWORD
 
kGTٮRAMSize
();

18 
kRevSg
(* 
pcBufr
);

19 
kAToI
(cڡ * 
pcBufr
,
iRadix
);

20 
QWORD
 
kHexSgToQwd
(cڡ * 
pcBufr
);

21 
kDecimSgToLg
(cڡ * 
pcBufr
);

22 
kIToA
(
lvue
,* 
pcBufr
,
iRadix
);

23 
kHexToSg
(
QWORD
 
qwVue
,* 
Bufr
);

24 
kDecimTorg
(
lVue
,* 
pcBufr
);

25 
kSPrtf
(* 
pcBufr
,cڡ * 
pcFmSg
,...);

26 
kVSPrtf
(* 
pcBufr
,cڡ * 
pcFmSg
,
va_li
 

);

27 
QWORD
 
kGTickCou
();

28 
kS˕
(
QWORD
 
qwMlicd
);

31 vީ
QWORD
 
g_qwTickCou
;

	@/home/jk/os/MINT64/02.Kernel64/Source/main.c

1 
	~"Tys.h
"

2 
	~"Keybrd.h
"

3 
	~"Dest.h
"

4 
	~"PIC.h
"

5 
	~"Cse.h
"

6 
	~"CseShl.h
"

7 
	~"Task.h
"

8 
	~"PIT.h
"

9 
	~"DymicMemy.h
"

10 
	~"HdDisk.h
"

11 
	~"FeSyem.h
"

12 
	~"SlPt.h
"

13 
	~"MuiPross.h
"

16 
maFAlitiPross
();

19 
	$ma
( )

21 
iCursX
, 
iCursY
;

25 if(*((
BYTE
*)
BOOTSTRAPPROCESSOR_FLAGADDRESS
)==0)

27 
	`maFAlitiPross
();

32 *((
BYTE
*)
BOOTSTRAPPROCESSOR_FLAGADDRESS
)=0;

35 
	`kInlizeCse
( 0, 10 );

36 
	`kPrtf
( "Switch To IA-32e Mode Success~!!\n" );

37 
	`kPrtf
( "IA-32e C Language Kernel Start..............[Pass]\n" );

38 
	`kPrtf
( "Initialize Console..........................[Pass]\n" );

41 
	`kGCurs
&
iCursX
, &
iCursY
 );

42 
	`kPrtf
( "GDT Initialize And Switch For IA-32e Mode...[ ]" );

43 
	`kInlizeGDTTabAndTSS
();

44 
	`kLdGDTR

GDTR_STARTADDRESS
 );

45 
	`kSCurs
45, 
iCursY
++ );

46 
	`kPrtf
( "Pass\n" );

48 
	`kPrtf
( "TSS Segment Load............................[ ]" );

49 
	`kLdTR

GDT_TSSSEGMENT
 );

50 
	`kSCurs
45, 
iCursY
++ );

51 
	`kPrtf
( "Pass\n" );

53 
	`kPrtf
( "IDT Initialize..............................[ ]" );

54 
	`kInlizeIDTTabs
();

55 
	`kLdIDTR

IDTR_STARTADDRESS
 );

56 
	`kSCurs
45, 
iCursY
++ );

57 
	`kPrtf
( "Pass\n" );

59 
	`kPrtf
( "Total RAM Size Check........................[ ]" );

60 
	`kCheckTٮRAMSize
();

61 
	`kSCurs
45, 
iCursY
++ );

62 
	`kPrtf
"Pass], Siz%d MB\n", 
	`kGTٮRAMSize
() );

64 
	`kPrtf
("TCB Poll And Scheduler Initialize...........[Pass]\n");

65 
iCursY
++;

66 
	`kInlizeSchedur
();

69 
	`kPrtf
("Dynamic Memory Initialize...................[Pass]\n");

70 
iCursY
++;

71 
	`kInlizeDymicMemy
();

74 
	`kInlizePIT
(
	`MSTOCOUNT
(1),1);

76 
	`kPrtf
( "Keyboard Activate And Queue Initialize......[ ]" );

78 if
	`kInlizeKeybrd
(=
TRUE
 )

80 
	`kSCurs
45, 
iCursY
++ );

81 
	`kPrtf
( "Pass\n" );

82 
	`kChgeKeybrdLED

FALSE
, FALSE, FALSE );

86 
	`kSCurs
45, 
iCursY
++ );

87 
	`kPrtf
( "Fail\n" );

91 
	`kPrtf
( "PIC Controller And Interrupt Initialize.....[ ]" );

93 
	`kInlizePIC
();

94 
	`kMaskPICIru
( 0 );

95 
	`kEbIru
();

96 
	`kSCurs
45, 
iCursY
++ );

97 
	`kPrtf
( "Pass\n" );

100 
	`kPrtf
("File System Initialize......................[ ]");

101 if(
	`kInlizeFeSyem
()==
TRUE
)

103 
	`kSCurs
(45,
iCursY
++);

104 
	`kPrtf
("Pass\n");

108 
	`kSCurs
(45,
iCursY
++);

109 
	`kPrtf
("Fail\n");

113 
	`kPrtf
("Serial Port Initialize......................[Pass]\n");

114 
iCursY
++;

115 
	`kInlizeSlPt
();

118 
	`kCeTask
(
TASK_FLAGS_LOWEST
 | 
TASK_FLAGS_THREAD
 | 
TASK_FLAGS_SYSTEM
 | 
TASK_FLAGS_IDLE
,0,0,(
QWORD
)
kIdTask
);

119 
	`kSCseShl
();

120 
	}
}

124 
	$maFAlitiPross
()

126 
QWORD
 
qwTickCou
;

129 
	`kLdGDTR
(
GDTR_STARTADDRESS
);

133 
	`kLdTR
(
GDT_TSSSEGMENT
+(
	`kGAPICID
()*(
GDTENTRY16
)));

136 
	`kLdIDTR
(
IDTR_STARTADDRESS
);

139 
qwTickCou
 = 
	`kGTickCou
();

143 if(
	`kGTickCou
()-
qwTickCou
>1000)

145 
qwTickCou
 = 
	`kGTickCou
();

147 
	`kPrtf
("Aliti Pross[APIC ID: %d] IAived\n",
	`kGAPICID
());

150 
	}
}

	@/home/jk/os/MINT64/04.Utility/00.ImageMaker/ImageMaker.c

1 
	~<dio.h
>

2 
	~<dlib.h
>

3 
	~<f.h
>

5 
	~<sys/tys.h
>

6 
	~<sys/.h
>

7 
	~<o.h
>

9 
	#BYTESOFSECTOR
 512

	)

11 
AdjuInSeSize

iFd
, 
iSourSize
 );

12 
WreKlInfmi

iTgFd
, 
iTٮKlSeCou
,
iKlSeCou
 );

13 
CyFe

iSourFd
, 
iTgFd
 );

15 
	$ma
(
gc
, * 
gv
[])

17 
iSourFd
;

18 
iTgFd
;

19 
iBoLdSize
;

20 
iKl32SeCou
;

21 
iKl64SeCou
;

22 
iSourSize
;

24 if
gc
 < 4 )

26 
	`rtf

dr
, "[ERROR] ImageMaker BootLoader.bin Kernel32.bin KErnel64.bin\n" );

27 
	`ex
( -1 );

30 if
iTgFd
 = 
	`ݒ
"Disk.img", 
O_RDWR
 | 
O_CREAT
 | 
O_TRUNC
 |

31 
S_IREAD
 | 
S_IWRITE
 ) ) == -1 )

33 
	`rtf

dr
 , "[ERROR] Disk.img open fail.\n" );

34 
	`ex
( -1 );

37 
	`tf
( "[INFO] Copy bootoadero image file\n" );

38 if
iSourFd
 = 
	`ݒ

gv
[ 1 ], 
O_RDONLY
 ) ) == -1 )

40 
	`rtf

dr
, "[ERROR] %ݒ fa\n", 
gv
[ 1 ] );

41 
	`ex
( -1 );

44 
iSourSize
 = 
	`CyFe

iSourFd
, 
iTgFd
 );

45 
	`o

iSourFd
 );

47 
iBoLdSize
 = 
	`AdjuInSeSize

iTgFd
 , 
iSourSize
 );

48 
	`tf
( "[INFO] %s size = [%d]nd sector count = [%d]\n",

49 
gv
[ 1 ], 
iSourSize
, 
iBoLdSize
 );

51 
	`tf
( "[INFO] Copyrotected mode kernelo image file\n" );

52 if
iSourFd
 = 
	`ݒ

gv
[ 2 ], 
O_RDONLY
) ) == -1 )

54 
	`rtf

dr
, "[ERROR] %ݒ fa\n", 
gv
[ 2 ] );

55 
	`ex
( -1 );

58 
iSourSize
 = 
	`CyFe

iSourFd
, 
iTgFd
 );

59 
	`o

iSourFd
 );

61 
iKl32SeCou
 = 
	`AdjuInSeSize

iTgFd
, 
iSourSize
 );

62 
	`tf
( "[INFO] %s size = [%d]nd sector count = [%d]\n",

63 
gv
[ 2 ], 
iSourSize
, 
iKl32SeCou
 );

66 
	`tf
("[INFO] Copy IA-32e mode kernelo image file\n");

67 if((
iSourFd
=
	`ݒ
(
gv
[3],
O_RDONLY
))==-1)

69 
	`rtf
(
dr
,"[ERROR] %ݒ fa\n",
gv
[3]);

70 
	`ex
(-1);

73 
iSourSize
=
	`CyFe
(
iSourFd
,
iTgFd
);

74 
	`o
(
iSourFd
);

76 
iKl64SeCou
 = 
	`AdjuInSeSize
(
iTgFd
,
iSourSize
);

77 
	`tf
("[INFO] %siz[%d]nd se cou = [%d]\n",
gv
[3],
iSourSize
,
iKl64SeCou
);

79 
	`tf
( "[INFO] Starto write kernel information\n" );

80 
	`WreKlInfmi

iTgFd
,
iKl64SeCou
+
iKl32SeCou
, iKernel32SectorCount );

81 
	`tf
( "[INFO] Image file create complete\n" );

83 
	`o

iTgFd
 );

85 
	}
}

87 
	$AdjuInSeSize

iFd
, 
iSourSize
 )

89 
i
;

90 
iAdjuSizeToSe
;

91 
cCh
;

92 
iSeCou
;

94 
iAdjuSizeToSe
 = 
iSourSize
 % 
BYTESOFSECTOR
;

95 
cCh
 = 0x00;

97 if
iAdjuSizeToSe
 != 0 )

99 
iAdjuSizeToSe
 = 512 - iAdjustSizeToSector;

100 
	`tf
"[INFO] Fsiz[%d]nd f[%d] by\n", 
iSourSize
,

101 
iAdjuSizeToSe
 );

102  
i
 = 0 ; i < 
iAdjuSizeToSe
 ; i++ )

104 
	`wre

iFd
 , &
cCh
 , 1 );

109 
	`tf
( "[INFO] File size isligned 512 byte\n" );

112 
iSeCou
 = ( 
iSourSize
 + 
iAdjuSizeToSe
 ) / 
BYTESOFSECTOR
;

113  
iSeCou
;

114 
	}
}

116 
	$WreKlInfmi

iTgFd
, 
iTٮKlSeCou
, 
iKlSeCou
 )

118 
usDa
;

119 
lPosi
;

121 
lPosi
 = 
	`lek

iTgFd
, 5, 
SEEK_SET
 );

122 if
lPosi
 == -1 )

124 
	`rtf

dr
, "lseek fail. Return value = %ld,rrno = %d, %d\n",

125 
lPosi
, 
o
, 
SEEK_SET
 );

126 
	`ex
( -1 );

129 
usDa
 = (
iTٮKlSeCou
;

130 
	`wre
(
iTgFd
,&
usDa
,2);

131 
usDa
 = ( 
iKlSeCou
;

132 
	`wre

iTgFd
, &
usDa
, 2 );

135 
	`tf
( "[INFO] Total sector countxcept bootoader [%d]\n",

136 
iTٮKlSeCou
 );

137 
	`tf
"[INFO] Tٮ se cou oeed modk[%d]\n",
iKlSeCou
);

139 
	}
}

141 
	$CyFe

iSourFd
, 
iTgFd
 )

143 
iSourFeSize
;

144 
iRd
;

145 
iWre
;

146 
vcBufr
[ 
BYTESOFSECTOR
 ];

148 
iSourFeSize
 = 0;

151 
iRd
 = 
	`ad

iSourFd
, 
vcBufr
, ( vcBuffer ) );

152 
iWre
 = 
	`wre

iTgFd
, 
vcBufr
, 
iRd
 );

154 if
iRd
 !
iWre
 )

156 
	`rtf

dr
, "[ERROR] iRead != iWrite.. \n" );

157 
	`ex
(-1);

159 
iSourFeSize
 +
iRd
;

161 if
iRd
 !
vcBufr
 ) )

166  
iSourFeSize
;

167 
	}
}

	@/home/jk/os/MINT64/04.Utility/01.SerialTransfer/NetworkTransfer.c

1 
	~<dio.h
>

2 
	~<dlib.h
>

3 
	~<f.h
>

4 
	~<rg.h
>

6 
	~<sys/tys.h
>

7 
	~<sys/.h
>

8 
	~<o.h
>

9 
	~<sys/sock.h
>

10 
	~<t/.h
>

13 
	#DWORD
 

	)

14 
	#BYTE
 

	)

15 
	#MIN
(
x
,
y
(((x)<(y))?(x):(y))

	)

18 
	#SERIAL_FIFOMAXSIZE
 16

	)

20 
	$ma
(
gc
,** 
gv
)

22 
vcFeName
[256];

23 
vcDaBufr
[
SERIAL_FIFOMAXSIZE
];

24 
sockaddr_
 
SockAddr
;

25 
iSock
;

26 
BYTE
 
bAck
;

27 
DWORD
 
dwDaLgth
;

28 
DWORD
 
dwStSize
;

29 
DWORD
 
dwTemp
;

30 
FILE
* 

;

36 if(
gc
<2)

38 
	`rtf
(
dr
,"Input File Name: ");

39 
	`gs
(
vcFeName
);

44 
	`ry
(
vcFeName
,
gv
[1]);

48 

 = 
	`fݒ
(
vcFeName
,"rb");

50 if(

==
NULL
)

52 
	`rtf
(
dr
,"%FOE\n",
vcFeName
);

57 
	`fek
(

,0,
SEEK_END
);

58 
dwDaLgth
 = 
	`l
(

);

59 
	`fek
(

,0,
SEEK_SET
);

60 
	`rtf
(
dr
,"FNam%s, DLgth %d By\n",
vcFeName
,
dwDaLgth
);

66 
SockAddr
.
s_my
 = 
AF_INET
;

67 
SockAddr
.
s_pt
 = 
	`hts
(4444);

68 
SockAddr
.
s_addr
.
s_addr
 = 
	`_addr
("127.0.0.1");

71 
iSock
 = 
	`sock
(
AF_INET
,
SOCK_STREAM
,0);

73 if(
	`c
(
iSock
,(
sockaddr
*)&
SockAddr
,(stSocketAddr))==-1)

75 
	`rtf
(
dr
,"Socket Connect Error, IP 127.0.0.1, Port 4444\n");

80 
	`rtf
(
dr
,"Socket Connect Success, IP 127.0.0.1, Port 4444\n");

87 if(
	`nd
(
iSock
,&
dwDaLgth
,4,0)!=4)

89 
	`rtf
(
dr
,"DLgth Sd Fa, [%d] By\n",
dwDaLgth
);

94 
	`rtf
(
dr
,"DLgth Sd Sucss, [%d] By\n",
dwDaLgth
);

98 if(
	`cv
(
iSock
,&
bAck
,1,0)!=1)

100 
	`rtf
(
dr
,"Ack Receive Error\n");

105 
	`rtf
(
dr
,"Now Data Transfer...");

106 
dwStSize
 = 0;

107 
dwStSize
!=
dwDaLgth
)

110 
dwTemp
 = 
	`MIN
(
dwDaLgth
-
dwStSize
,
SERIAL_FIFOMAXSIZE
);

111 
dwStSize
 +
dwTemp
;

113 if(
	`d
(
vcDaBufr
,1,
dwTemp
,

)!=dwTemp)

115 
	`rtf
(
dr
,"File Read Error\n");

120 if(
	`nd
(
iSock
,
vcDaBufr
,
dwTemp
,0)!=dwTemp)

122 
	`rtf
(
dr
,"Socket Send Error\n");

127 if(
	`cv
(
iSock
,&
bAck
,1,0)!=1)

129 
	`rtf
(
dr
,"Ack Receive Error\n");

134 
	`rtf
(
dr
,"#");

138 
	`fo
(

);

139 
	`o
(
iSock
);

142 
	`rtf
(
dr
,"\nSd Come. [%d] By\n",
dwStSize
);

143 
	`rtf
(
dr
,"Press Enter Key To Exit\n");

144 
	`gch
();

147 
	}
}

	@/home/jk/os/MINT64/save/02.Kernel64/Source/AssemblyUtility.asm

1 [
BITS
 64] ; 이하의 코드는 64비트 코드로 설정

3 
	gSECTION
 .
	gxt
 ;ext 섹션(세그먼트)을 정의

5 ; 
	gc
 언어에서 호출할 수 있도록 이름을 노출함

6 
glob
 
	gkInPtBy
, 
	gkOutPtBy
,
	gkInPtWd
,
kOutPtWd


7 
glob
 
	gkLdGDTR
,
	gkLdTR
,
kLdIDTR


8 
glob
 
	gkEbIru
, 
	gkDibIru
, 
kRdRFLAGS


9 
glob
 
kRdTSC


10 
glob
 
	gkSwchCڋxt
, 
	gkH
, 
kTeAndS


11 
glob
 
	gkInlizeFPU
, 
	gkSaveFPUCڋxt
, 
	gkLdFPUCڋxt
, 
	gkSTS
, 
kCˬTS


12 
glob
 
	gkEbGlobLolAPIC


15 ; 
	gPARAM
 : 포트 번호

16 
kInPtBy
:

17 
push
 
rdx
 ; 함수에서 임시로 사용하는 레지스터를 스택에 저장 함수의 마지막 부분에서 스택에 삽입된 값을 꺼내 복원

19 
mov
 
	grdx
, 
	grdi
 ; 
	gRDX
 레지스터에 파라미터 1(포트 번호)를 저장

20 
mov
 
	gx
, 0 ; 
	gRAX
 레지스터를 초기화

21 

 
	g
, 
	gdx
 ; 
	gDX
 레지스터에 저장된 포트 어드레스에서 한 바이트를 읽어 
	gAL
 레지스터에 저장, AL 레지스터는 함수의 반환 값으로 사용됨

24 
p
 
rdx


25 
	gt


29 ; 
	gPARAM
 : 포트 번호, 데이터

30 
	gkOutPtBy
:

31 
push
 
rdx


32 
push
 
x


34 
mov
 
rdx
, 
	grdi
 ; 
	gRDX
 레지스터에 파라미터 1(포트 번호)를 저장

35 
mov
 
	gx
, 
	grsi
 ; 
	gRAX
 레지스터에 파라미터 2(데이터)를 저장

36 
out
 
	gdx
, 
	g
 ; 
	gDX
 레지스터에 저장된 포트 어드레스에 
	gAL
 레지스터에 저장된 한 바이트를 씀

38 
p
 
x


39 
p
 
rdx


40 
	gt


42 ; 
	gGDTR
 레지스터에 
	gGDT
 테이블을 설정

43 ; 
	gPARAM
: 
GDT
 테이블의 정보를 저장하는 자료구조의 어드레스

44 
kLdGDTR
:

45 
lgdt
 [
rdi
] ; 파라미터 1(
	gGDTR
의 어드레스)를 프로세서에 로드하여 
	gGDT
 테이블을 설정

47 
	gt
 ; 
	gGDT
 테이블을 설정

49 ; 
	gTR
 레지스터에 
	gTSS
 세그먼트 디스크립터 설정

50 ; 
	gPARAM
: 
TSS
 세그먼트 디스크립터의 오프셋

51 
kLdTR
:

52 
r
 
di
 ; 파라미터 1(
	gTSS
 세그먼트 디스크립터의 오프셋)을 프로세서에 설정하여 TSS 세그먼트를 로드

54 
	gt


56 ; 
	gIDTR
 레지스터에 
	gIDT
 테이블을 설정

57 ; 
	gPARAM
: 
IDT
 테이블의 정보를 저장하는 자료구조의 어드레스

58 
kLdIDTR
:

59 
lidt
 [
rdi
] ; 파라미터 1(
	gIDTR
의 어드레스)을 프로세서에 로드하여 
	gIDT
 테이블을 설정

61 
	gt


64 ; 
	gPARAM
: 없음

65 
kEbIru
:

66 
i
 ; 인터럽트를 활성화

67 
	gt


70 ; 
	gPARAM
: 없음

71 
kDibIru
:

72 
i
 ; 인터럽트를 비활성화

73 
	gt


75 ; 
	gRFLAGS
 레지스터를 읽어서 되돌려줌

76 ; 
	gPARAM
: 없음

77 
kRdRFLAGS
:

78 
pushfq
 ; 
	gRFLAGS
 레지스터를 스택에 저장

79 
p
 
	gx
 ; 스택에 저장된 
	gRFLAGS
 레지스터를 
	gRAX
 레지스터에 저장하여 함수의 반환 값으로 설정

81 
	gt


84 ; 
	gPARAM
: 없음

85 
kRdTSC
:

86 
push
 
rdx
 ; 
	gRDX
 레지스터를 스택에 저장

88 
	grdtsc
 ; 타임 스탬프 카운터를 읽어서 
	gRDX
:
RAX
에 저장

90 
shl
 
rdx
,32 ; 
	gRDX
 레지스터에 있는 상위 32비트 
	gTSC
 값과 
	gRAX
 레지스터에 있는 하위 32비트 TSC 갑을 
	gOR
하여 RAX 레지스터에 64비트 TSC 값을 저장

91 

 
	gx
,
rdx


93 
p
 
rdx


94 
	gt


100 %
mao
 
	gKSAVECONTEXT
 0 ; 파라미터를 전달받지 않는 KSAVECONTEXT 매크로 정의

101 ; 
	gRBP
 레지스터부터 
	gGS
 세그먼트 셀렉터까지 모두 스택에 삽입

102 
push
 
rbp


103 
push
 
x


104 
push
 
rbx


105 
push
 
rcx


106 
push
 
rdx


107 
push
 
rdi


108 
push
 
rsi


109 
push
 
r8


110 
push
 
r9


111 
push
 
r10


112 
push
 
r11


113 
push
 
r12


114 
push
 
r13


115 
push
 
r14


116 
push
 
r15


118 
mov
 
	gax
, 
	gds
 ; 
	gDS
 세그먼트 셀렉터와 
	gES
 세그먼트 셀렉터는 스택에 직접 삽입할 수 없으므로, 
	gRAX
 레지스터에 저장한 후 스택에 삽입

119 
push
 
x


120 
mov
 
	gax
, 
es


121 
push
 
x


122 
push
 
fs


123 
push
 
	ggs


124 %
	gdmao
 ; 매크로 끝

128 %
mao
 
	gKLOADCONTEXT
 0 ; 파라미터를 전달받지 않는 KLOADCONTEXT 매크로 정의

129 ; 
	gGS
 세그먼트 셀렉터부터 
	gRBP
 레지스터까지 모두 스택에서 꺼내 복원

130 
p
 
gs


131 
p
 
fs


132 
p
 
x


133 
mov
 
	ges
, 
	gax
 ; 
	gES
 세그먼트 셀렉터와 
	gDS
 세그먼트 셀렉터는 스택에서 직접 꺼내 복원할 수 없으므로 
	gRAX
 레지스터에 저장한 뒤에 복원

134 
p
 
x


135 
mov
 
	gds
, 
ax


137 
p
 
r15


138 
p
 
r14


139 
p
 
r13


140 
p
 
r12


141 
p
 
r11


142 
p
 
r10


143 
p
 
r9


144 
p
 
r8


145 
p
 
rsi


146 
p
 
rdi


147 
p
 
rdx


148 
p
 
rcx


149 
p
 
rbx


150 
p
 
x


151 
p
 
	grbp


152 %
	gdmao
 ; 매크로 끝

154 ; 
Cu
 
	gCڋxt
에 현재 콘텍스트를 저장하고 
Next
 
	gTask
에서 콘텍스트를 복구

155 ; 
	gPARAM
: 
Cut
 
Cڋxt
, 
Next
 Context

156 
	gkSwchCڋxt
:

157 
push
 
rbp
 ; 스택에 
	gRBP
 레지스터를 저장하고 
	gRSP
 레지스터를 RBP에 저장

158 
mov
 
	grbp
, 
	gr


160 ; 
Cut
 
	gCڋxt
가 
	gNULL
이면 콘텍스트를 저장할 필요 없음

161 
	gpushfq
 ; 아래의 
	gcmp
의 결과로 
	gRFLAGS
 레지스터가 변하지 않도록 스택에 저장

162 
cmp
 
	grdi
, 0 ; 
Cut
 
	gCڋxt
가 
	gNULL
이면 콘텍스트 복원으로 바로 이동

163 
	gje
 .
LdCڋxt


164 
	gpfq
 ; 스택에 저장한 
	gRFLAGS
 레지스터를 복원

170 
push
 
	gx
 ; 콘텍스트 영역의 오프셋으로 사용할 
	gRAX
 레지스터를 스택에 저장

172 ; 
	gSS
, 
	gRSP
, 
	gRFLAGS
, 
	gCS
, 
	gRIP
 레지스터 순서대로 삽입

173 
mov
 
	gax
, 
	gss
 ; 
	gSS
 레지스터 저장

174 
mov
 
	gqwd
[
rdi
+(23*8)],
x


176 
mov
 
	gx
, 
	grbp
 ; 
	gRBP
에 저장된 
	gRSP
 레지스터 저장

177 
add
 
	gx
, 16 ; 
	gRSP
 레지스터는 
push
 
	grbp
와 
Ru
 
	gAddss
를 제외한 값으로 저장

178 
mov
 
	gqwd
[
rdi
+(22*8)],
x


180 
	gpushfq
 ; 
	gRFLAGS
 레지스터에 저장

181 
p
 
x


182 
mov
 
	gqwd
[
rdi
+(21*8)],
x


184 
mov
 
	gax
, 
	gcs
 ; 
	gCS
 레지스터 저장

185 
mov
 
	gqwd
[
rdi
+(20*8)],
x


187 
mov
 
	gx
, 
	gqwd
[
rbp
+8] ; 
	gRIP
 레지스터를 
Ru
 
	gAddss
로 설정하여 다음 콘텍스트 복원 시에 이 함수를 호출한 위치로 이동하게 함

188 
mov
 
	gqwd
[
rdi
+(19*8)],
	gx


191 
p
 
x


192 
p
 
	grbp


194 ; 가장 끝부분에 
	gSS
, 
	gRSP
, 
	gRFLAGS
, 
	gCS
, 
	gRIP
 레지스터를 저장했으므로, 이전 영역에 
	gpush
 명령어로 콘텍스트를 저장하기 위해 스택을 변경

195 
add
 
	grdi
,(19*8)

196 
mov
 
	gr
, 
rdi


197 
sub
 
	grdi
,(19*8)

199 ; 나머지 레지스터를 모두 
	gCڋxt
 자료구조에 저장

200 
	gKSAVECONTEXT


207 .
	gLdCڋxt
:

208 
mov
 
r
, 
	grsi


210 ; 
	gCڋxt
 자료구조에서 레지스터를 복원

211 
KLOADCONTEXT


212 
	gq


214 ; 
	gPARAM
: 없음

215 
kH
:

216 
h
 ; 프로세서를 대기 상태로 진입시킴

217 
h


218 
	gt


221 ; 
	gDei
과 
	gCom
를 비교하여 같다면 Dei에 
	gSour
 값을 삽입

222 ; 
	gPARAM
: 값을 저장할 어드레스(
Dei
,
	grdi
), 비교할 값 (
	gCom
,
	grsi
)

223 ; 설정할 값 (
	gSour
,
	grdx
)

224 
	gkTeAndS
:

225 
mov
 
x
, 
	grsi
 ; 두 번째 파라미터인 비교할 값을 
	gRAX
 레지스터에 저장

227 ; 
	gRAX
 레지스터에 저장된 비교할 값과 첫 번째 파라미터(
	grdi
)의 메모리 어드레스의 값을 비교하여

228 ; 두 값이 같다면 세 번째 파라미터(
	gdl
)의 값을 첫 번째 파라미터(
	grdi
)가 가리키는 어드레스에 삽입하고 
	gRFLAGS
의 
	gZF
비트를 1로 설정

229 ; 두 값이 다르면 첫 번째 파라미터(
	grdi
)의 값을 두 번째 파라미터(
	gRAX
)에 삽입하고 
	gRFLAGS
의 
	gZF
 비트를 0로 설정

230 ; 
	gLOCK
 명령어는 어셈블리어 코드에서 전치사로 사용되며, 뒤에 따라오는 명령어를 수행하는 동안

232 
lock
 
cmpxchg
 
	gby
[
rdi
],
dl


233 
	gje
 .
	gSUCCESS


235 .
	gNOTSAME
: ; 
	gDei
과 
	gCom
가 다른 경우

236 
mov
 
	gx
, 0x00

237 
	gt


239 .
	gSUCCESS
:

240 
mov
 
x
, 0x01 ; 
	gDei
과 
	gCom
과 같은 경우

241 
	gt


244 ; 
	gFPU
 관련 어셈블리어 함수

246 ; 
	gFPU
를 초기화

247 ; 
	gPARAM
: 없음

248 
kInlizeFPU
:

249 
f
 ; 
	gFPU
 초기화를 수행

250 
	gt


252 ; 
	gFPU
 관련 레지스터를 콘텍스트 버퍼에 저장

253 ; 
	gPARAM
: 
Bufr
 
Addss


254 
kSaveFPUCڋxt
:

255 
fxve
 [
rdi
] ; 첫 번째 파라미터로 전달된 버퍼에 
	gFPU
 레지스터를 저장

256 
	gt


258 ; 
	gFPU
 관련 레지스터를 콘텍스트 버퍼에서 복원

259 ; 
	gPARAM
: 
Bufr
 
Addss


260 
kLdFPUCڋxt
:

261 
fxr
 [
rdi
] ; 첫 번째 파라미터로 전달된 버퍼에서 
	gFPU
 레지스터를 복원

262 
	gt


264 ; 
	gCR0
 컨트롤 레지스터의 
	gTS
 비트를 1로 설정

265 ; 
	gPARAM
: 없음

266 
kSTS
:

267 
push
 
x
 ; 스택에 
	gRAX
 레지스터의 값을 저장

269 
mov
 
	gx
, 
	g0
 ; 
	gCR0
 컨트롤 레지스터의 값을 
	gRAX
 레지스터로 저장

270 

 
	gx
, 0x08 ; 
	gTS
 비트(비트7)를 1로 설정

271 
mov
 
	g0
, 
	gx
 ; 
	gTS
 비트가 1로 설정된 값을 
	gCR0
 컨트롤 레지스터로 저장

273 
p
 
	gx
 ; 스택에서 
	gRAX
 레지스터의 값을 복원

274 
	gt


276 ; 
	gCR0
 컨트롤 레지스터의 
	gTS
 비트를 0으로 설정

277 ; 
	gPARAM
: 없음

278 
kCˬTS
:

279 
ts
 ; 
	gCR0
 컨트롤 레지스터에서 
	gTS
 비트를 0으로 설정

280 
	gt


283 ; 
	gPARAM
: 포트 번호

284 
kInPtWd
:

285 
push
 
rdx
 ; 함수에서 임시로 사용하는 레지스터를 스택에 저장

288 
mov
 
	grdx
, 
	grdi
 ; 
	gRDX
 레지스터에 파라미터 1(포트 번호)을 저장

289 
mov
 
	gx
, 0 ; 
	gRAX
 레지스터를 초기화

290 

 
	gax
, 
	gdx
 ; 
	gDX
 레지스터에 저장된 포트 어드레스에서 두 바이트를 읽어 
	gAX
 레지스터에 저장

291 ; 
	gAX
 레지스터는 함수의 반환 값으로 사용됨

293 
p
 
	grdx
 ; 함수에서 사용이 끝난 레지스터를 복원

294 
	gt
 ; 함수를 호출한 다음 코드의 위치로 복귀

297 ; 
	gPARAM
: 포트 번호, 데이터

298 
	gkOutPtWd
:

299 
push
 
rdx
 ; 함수에서 임시로 사용하는 레지스터를 스택에 저장

300 
push
 
	gx
 ; 함수의 마지막 부분에서 스택에 삽입된 값을 꺼내 복원

302 
mov
 
	grdx
, 
	grdi
 ; 
	gRDX
 레지스터에 파라미터 1(포트 번호)을 저장

303 
mov
 
	gx
, 
	grsi
 ; 
	gRAX
 레지스터에 파라미터 2(데이터)를 저장

304 
out
 
	gdx
, 
	gax
 ; 
	gDX
 레지스터에 저장된 포트 어드레스에 
	gAX
 레지스터에 저장된 두 바이트를 씀

306 
p
 
	gx
 ; 함수에서 사용이 끝난 레지스터를 복원

307 
p
 
rdx


308 
	gt
 ; 함수를 호출한 다음 코드의 위치로 복귀

310 ; 
IA32_APIC_BASE
 
	gMSR
의 
	gAPIC
 전역 활성화 필드(비트 11)를 1로 설정하여 APIC를 활성화함

311 ; 
	gPARAM
 : 없음

312 
kEbGlobLolAPIC
:

313 
push
 
x
 ; 
	gRDMSR
과 
	gWRMSR
에서 사용하는 레지스터를 모두 스택에 저장

314 
push
 
rcx


315 
push
 
	grdx


317 ; 
IA32_APIC
 
BASE
 
	gMSR
에 설정된 기존 값을 읽어서 전역 
	gAPIC
 비트를 활성화

318 
mov
 
	grcx
,27 ; 
IA32_APIC_BASE
 
	gMSR
은 레지스터 어드레스 27에 위치하여,

319 ; 
	gMSR
의 상위 32비트와 하위 32비트는 각각 
	gEDX
 레지스터와

320 ; 
	gEAX
 레지스터를 사용함

322 

 
	gx
, 0x0800 ; 
	gAPIC
 전역 활성/비활성 필드는 비트 11에 위치하므로 하위

323 
	gwrm
 ; 32비트를 담당하는 
	gEAX
 레지스터의 비트 11을 1로 설정한 뒤

324 ; 
	gMSR
 레지스터에 값을 덮어씀

326 
p
 
rdx


327 
p
 
rcx


328 
p
 
x


329 
	gt


	@/home/jk/os/MINT64/save/02.Kernel64/Source/AssemblyUtility.h

1 #ide
__ASSEMBLYUTILITY_H__


2 
	#__ASSEMBLYUTILITY_H__


	)

4 
	~"Tys.h
"

5 
	~"Task.h
"

8 
BYTE
 
kInPtBy
(
WORD
 
wPt
);

9 
kOutPtBy
(
WORD
 
wPt
,
BYTE
 
bDa
);

10 
kLdGDTR
(
QWORD
 
qwGDTRAddss
);

11 
kLdTR
(
WORD
 
wTSSSegmtOfft
);

12 
kLdIDTR
(
QWORD
 
qwIDTRAddss
);

13 
kEbIru
();

14 
kDibIru
();

15 
QWORD
 
kRdRFLAGS
();

16 
QWORD
 
kRdTSC
();

17 
kSwchCڋxt
(
CONTEXT
* 
pCutCڋxt
,CONTEXT* 
pNextCڋxt
);

18 
kH
();

19 
BOOL
 
kTeAndS
(vީ
BYTE
* 
pbDei
,BYTE 
bCom
,BYTE 
bSour
);

20 
kInlizeFPU
();

21 
kSaveFPUCڋxt
(* 
pvFPUCڋxt
);

22 
kLdFPUCڋxt
(* 
pvFPUCڋxt
);

23 
kSTS
();

24 
kCˬTS
();

25 
WORD
 
kInPtWd
(WORD 
wPt
);

26 
WORD
 
kOutPtWd
(WORD 
wPt
,WORD 
wDa
);

27 
kEbGlobLolAPIC
();

	@/home/jk/os/MINT64/save/02.Kernel64/Source/CacheManager.c

1 
	~"CacheMag.h
"

2 
	~"FeSyem.h
"

3 
	~"DymicMemy.h
"

6 
CACHEMANAGER
 
	ggs_CacheMag
;

9 
kCutDownAcssTime
(
iCacheTabIndex
);

12 
BOOL
 
	$kInlizeCacheMag
()

14 
i
;

17 
	`kMemS
(&
gs_CacheMag
,0,(gs_stCacheManager));

20 
gs_CacheMag
.
vdwAcssTime
[
CACHE_CLUSTERLINKTABLEAREA
]=0;

21 
gs_CacheMag
.
vdwAcssTime
[
CACHE_DATAAREA
]=0;

24 
gs_CacheMag
.
vdwMaxCou
[
CACHE_CLUSTERLINKTABLEAREA
]=
CACHE_MAXCLUSTERLINKTABLEAREACOUNT
;

25 
gs_CacheMag
.
vdwMaxCou
[
CACHE_DATAAREA
]=
CACHE_MAXDATAAREACOUNT
;

28 
gs_CacheMag
.
vpbBufr
[
CACHE_CLUSTERLINKTABLEAREA
]=(
BYTE
*)
	`kAoMemy
(
CACHE_MAXCLUSTERLINKTABLEAREACOUNT
*512);

30 if(
gs_CacheMag
.
vpbBufr
[
CACHE_CLUSTERLINKTABLEAREA
]==
NULL
)

32 
	`kFeMemy
(
gs_CacheMag
.
vpbBufr
[
CACHE_CLUSTERLINKTABLEAREA
]);

33  
FALSE
;

37 
i
=0;i<
CACHE_MAXCLUSTERLINKTABLEAREACOUNT
;i++)

40 
gs_CacheMag
.
vvCacheBufr
[
CACHE_CLUSTERLINKTABLEAREA
][
i
].
pbBufr
=gs_CacheMag.
vpbBufr
[CACHE_CLUSTERLINKTABLEAREA]+(i*512);

43 
gs_CacheMag
.
vvCacheBufr
[
CACHE_CLUSTERLINKTABLEAREA
][
i
].
dwTag
=
CACHE_INVALIDTAG
;

47 
gs_CacheMag
.
vpbBufr
[
CACHE_DATAAREA
] = (
BYTE
*)
	`kAoMemy
(
CACHE_MAXDATAAREACOUNT
*
FILESYSTEM_CLUSTERSIZE
);

49 if(
gs_CacheMag
.
vpbBufr
[
CACHE_DATAAREA
]==
NULL
)

52 
	`kFeMemy
(
gs_CacheMag
.
vpbBufr
[
CACHE_DATAAREA
]);

53  
FALSE
;

57 
i
=0;i<
CACHE_MAXDATAAREACOUNT
;i++)

60 
gs_CacheMag
.
vvCacheBufr
[
CACHE_DATAAREA
][
i
].
pbBufr
=gs_CacheMag.
vpbBufr
[CACHE_DATAAREA]+(i*
FILESYSTEM_CLUSTERSIZE
);

63 
gs_CacheMag
.
vvCacheBufr
[
CACHE_DATAAREA
][
i
].
dwTag
=
CACHE_INVALIDTAG
;

66  
TRUE
;

67 
	}
}

70 
CACHEBUFFER
* 
	$kAoCacheBufr
(
iCacheTabIndex
)

72 
CACHEBUFFER
* 
pCacheBufr
;

73 
i
;

76 if(
iCacheTabIndex
>
CACHE_MAXCACHETABLEINDEX
)

78  
NULL
;

82 
	`kCutDownAcssTime
(
iCacheTabIndex
);

85 
pCacheBufr
 = 
gs_CacheMag
.
vvCacheBufr
[
iCacheTabIndex
];

86 
i
=0;i<
gs_CacheMag
.
vdwMaxCou
[
iCacheTabIndex
];i++)

88 if(
pCacheBufr
[
i
].
dwTag
==
CACHE_INVALIDTAG
)

91 
pCacheBufr
[
i
].
dwTag
 = 
CACHE_INVALIDTAG
-1;

94 
pCacheBufr
[
i
].
dwAcssTime
 = 
gs_CacheMag
.
vdwAcssTime
[
iCacheTabIndex
]++;

96  &(
pCacheBufr
[
i
]);

100  
NULL
;

101 
	}
}

104 
CACHEBUFFER
* 
	$kFdCacheBufr
(
iCacheTabIndex
,
DWORD
 
dwTag
)

106 
CACHEBUFFER
* 
pCacheBufr
;

107 
i
;

110 if(
iCacheTabIndex
>
CACHE_MAXCACHETABLEINDEX
)

112  
NULL
;

116 
	`kCutDownAcssTime
(
iCacheTabIndex
);

119 
pCacheBufr
 = 
gs_CacheMag
.
vvCacheBufr
[
iCacheTabIndex
];

120 
i
=0;i<
gs_CacheMag
.
vdwMaxCou
[
iCacheTabIndex
];i++)

122 if(
pCacheBufr
[
i
].
dwTag
==dwTag)

126 
pCacheBufr
[
i
].
dwAcssTime
=
gs_CacheMag
.
vdwAcssTime
[
iCacheTabIndex
]++;

128  &(
pCacheBufr
[
i
]);

132  
NULL
;

133 
	}
}

136 
	$kCutDownAcssTime
(
iCacheTabIndex
)

138 
CACHEBUFFER
 
Temp
;

139 
CACHEBUFFER
* 
pCacheBufr
;

140 
BOOL
 
bS܋d
;

141 
i
,
j
;

144 if(
iCacheTabIndex
>
CACHE_MAXCACHETABLEINDEX
)

150 if(
gs_CacheMag
.
vdwAcssTime
[
iCacheTabIndex
]<0xfffffffe)

157 
pCacheBufr
 = 
gs_CacheMag
.
vvCacheBufr
[
iCacheTabIndex
];

158 
j
=0;j<
gs_CacheMag
.
vdwMaxCou
[
iCacheTabIndex
]-1;j++)

161 
bS܋d
=
TRUE
;

162 
i
=0;i<
gs_CacheMag
.
vdwMaxCou
[
iCacheTabIndex
]-1-
j
;i++)

165 if(
pCacheBufr
[
i
].
dwAcssTime
>pstCacheBuffer[i+1].dwAccessTime)

168 
bS܋d
 = 
FALSE
;

171 
	`kMemCpy
(&
Temp
,&(
pCacheBufr
[
i
]),(
CACHEBUFFER
));

172 
	`kMemCpy
(&(
pCacheBufr
[
i
]),&աCacheBufr[i+1]),(
CACHEBUFFER
));

173 
	`kMemCpy
(&(
pCacheBufr
[
i
+1]),&
Temp
,(
CACHEBUFFER
));

178 if(
bS܋d
==
TRUE
)

187 
i
=0;i<
gs_CacheMag
.
vdwMaxCou
[
iCacheTabIndex
];i++)

189 
pCacheBufr
[
i
].
dwAcssTime
=i;

193 
gs_CacheMag
.
vdwAcssTime
[
iCacheTabIndex
]=
i
;

194 
	}
}

197 
CACHEBUFFER
* 
	$kGViimInCacheBufr
(
iCacheTabIndex
)

199 
DWORD
 
dwOldTime
;

200 
CACHEBUFFER
* 
pCacheBufr
;

201 
iOldIndex
;

202 
i
;

205 if(
iCacheTabIndex
>
CACHE_MAXCACHETABLEINDEX
)

207  
NULL
;

211 
iOldIndex
 = -1;

212 
dwOldTime
 = 0xFFFFFFFF;

215 
pCacheBufr
 = 
gs_CacheMag
.
vvCacheBufr
[
iCacheTabIndex
];

216 
i
=0;i<
gs_CacheMag
.
vdwMaxCou
[
iCacheTabIndex
];i++)

220 if(
pCacheBufr
[
i
].
dwTag
 =
CACHE_INVALIDTAG
)

222 
iOldIndex
 = 
i
;

227 if(
pCacheBufr
[
i
].
dwAcssTime
<
dwOldTime
)

229 
dwOldTime
 = 
pCacheBufr
[
i
].
dwAcssTime
;

230 
iOldIndex
=
i
;

235 if(
iOldIndex
==-1)

237 
	`kPrtf
("Cache Buffer Find Error\n");

239  
NULL
;

243 
pCacheBufr
[
iOldIndex
].
dwAcssTime
 = 
gs_CacheMag
.
vdwAcssTime
[
iCacheTabIndex
]++;

245  &(
pCacheBufr
[
iOldIndex
]);

246 
	}
}

249 
	$kDisrdACacheBufr
(
iCacheTabIndex
)

251 
CACHEBUFFER
* 
pCacheBufr
;

252 
i
;

255 
pCacheBufr
 = 
gs_CacheMag
.
vvCacheBufr
[
iCacheTabIndex
];

256 
i
=0;i<
gs_CacheMag
.
vdwMaxCou
[
iCacheTabIndex
];i++)

258 
pCacheBufr
[
i
].
dwTag
 = 
CACHE_INVALIDTAG
;

262 
gs_CacheMag
.
vdwAcssTime
[
iCacheTabIndex
]=0;

263 
	}
}

266 
BOOL
 
	$kGCacheBufrAndCou
(
iCacheTabIndex
,
CACHEBUFFER
** 
CacheBufr
,* 
piMaxCou
)

269 if(
iCacheTabIndex
>
CACHE_MAXCACHETABLEINDEX
)

271  
FALSE
;

275 *
CacheBufr
 = 
gs_CacheMag
.
vvCacheBufr
[
iCacheTabIndex
];

276 *
piMaxCou
 = 
gs_CacheMag
.
vdwMaxCou
[
iCacheTabIndex
];

278  
TRUE
;

279 
	}
}

	@/home/jk/os/MINT64/save/02.Kernel64/Source/CacheManager.h

1 #ide
__CACHEMANAGER_H__


2 
	#__CACHEMANAGER_H__


	)

4 
	~"Tys.h
"

8 
	#CACHE_MAXCLUSTERLINKTABLEAREACOUNT
 16

	)

10 
	#CACHE_MAXDATAAREACOUNT
 32

	)

12 
	#CACHE_INVALIDTAG
 0xFFFFFFFF

	)

15 
	#CACHE_MAXCACHETABLEINDEX
 2

	)

17 
	#CACHE_CLUSTERLINKTABLEAREA
 0

	)

19 
	#CACHE_DATAAREA
 1

	)

23 
	skCacheBufrSu


26 
DWORD
 
	mdwTag
;

29 
DWORD
 
	mdwAcssTime
;

32 
BOOL
 
	mbChged
;

35 
BYTE
 *
	mpbBufr
;

36 } 
	tCACHEBUFFER
;

39 
	skCacheMagSu


42 
DWORD
 
	mvdwAcssTime
[
CACHE_MAXCACHETABLEINDEX
];

45 
BYTE
* 
	mvpbBufr
[
CACHE_MAXCACHETABLEINDEX
];

49 
CACHEBUFFER
 
	mvvCacheBufr
[
CACHE_MAXCACHETABLEINDEX
][
CACHE_MAXDATAAREACOUNT
];

52 
DWORD
 
	mvdwMaxCou
[
CACHE_MAXCACHETABLEINDEX
];

53 } 
	tCACHEMANAGER
;

56 
BOOL
 
kInlizeCacheMag
();

57 
CACHEBUFFER
* 
kAoCacheBufr
(
iCacheTabIndex
);

58 
CACHEBUFFER
* 
kFdCacheBufr
(
iCacheTabIndex
,
DWORD
 
dwTag
);

59 
CACHEBUFFER
* 
kGViimInCacheBufr
(
iCacheTabIndex
);

60 
kDisrdACacheBufr
(
iCacheTabIndex
);

61 
BOOL
 
kGCacheBufrAndCou
(
iCacheTabIndex
,
CACHEBUFFER
** 
CacheBufr
,* 
piMaxCou
);

	@/home/jk/os/MINT64/save/02.Kernel64/Source/Console.c

1 
	~"/u/oss/lib/gcc/x86_64-pc-lux/4.8.2/ude/dg.h
"

2 
	~"Cse.h
"

3 
	~"Keybrd.h
"

4 
	~"Uty.h
"

5 
	~"AsmblyUty.h
"

6 
	~"Tys.h
"

9 
CONSOLEMANAGER
 
	ggs_CseMag
 = {0,};

12 
	$kInlizeCse
(
iX
,
iY
)

15 
	`kMemS
(&
gs_CseMag
,0,(gs_stConsoleManager));

18 
	`kSCurs
(
iX
,
iY
);

19 
	}
}

23 
	$kSCurs
(
iX
,
iY
)

25 
iLrVue
;

28 
iLrVue
 = 
iY
*
CONSOLE_WIDTH
+
iX
;

31 
	`kOutPtBy
(
VGA_PORT_INDEX
,
VGA_INDEX_UPPERCURSOR
);

33 
	`kOutPtBy
(
VGA_PORT_DATA
,
iLrVue
>>8);

36 
	`kOutPtBy
(
VGA_PORT_INDEX
,
VGA_INDEX_LOWERCURSOR
);

38 
	`kOutPtBy
(
VGA_PORT_DATA
,
iLrVue
&0xFF);

41 
gs_CseMag
.
iCutPrtOfft
=
iLrVue
;

42 
	}
}

45 
	$kGCurs
(* 
piX
,* 
piY
)

48 *
piX
=
gs_CseMag
.
iCutPrtOfft
%
CONSOLE_WIDTH
;

49 *
piY
=
gs_CseMag
.
iCutPrtOfft
/
CONSOLE_WIDTH
;

50 
	}
}

53 
	$kPrtf
(cڡ * 
pcFmSg
,...)

55 
va_li
 

;

56 
vcBufr
[1024];

57 
iNextPrtOfft
;

60 
	`va_t
(

,
pcFmSg
);

61 
	`kVSPrtf
(
vcBufr
,
pcFmSg
,

);

62 
	`va_d
(

);

65 
iNextPrtOfft
=
	`kCsePrtSg
(
vcBufr
);

68 
	`kSCurs
(
iNextPrtOfft
%
CONSOLE_WIDTH
,iNextPrintOffset/CONSOLE_WIDTH);

69 
	}
}

72 
	$kCsePrtSg
(cڡ * 
pcBufr
)

74 
CHARACTER
* 
pSn
 =(CHARACTER*)
CONSOLE_VIDEOMEMORYADDRESS
;

75 
i
,
j
;

76 
iLgth
;

77 
iPrtOfft
;

80 
iPrtOfft
 = 
gs_CseMag
.
iCutPrtOfft
;

83 
iLgth
 = 
	`kSL
(
pcBufr
);

84 
i
=0;i<
iLgth
;i++)

87 if(
pcBufr
[
i
]=='\n')

91 
iPrtOfft
+=(
CONSOLE_WIDTH
-(iPrintOffset%CONSOLE_WIDTH));

95 i(
pcBufr
[
i
]=='\t')

98 
iPrtOfft
+=(8-(iPrintOffset%8));

104 
pSn
[
iPrtOfft
].
bCha
=
pcBufr
[
i
];

105 
pSn
[
iPrtOfft
].
bAribu
=
CONSOLE_DEFAULTTEXTCOLOR
;

106 
iPrtOfft
++;

110 if(
iPrtOfft
>=(
CONSOLE_HEIGHT
*
CONSOLE_WIDTH
))

113 
	`kMemCpy
(
CONSOLE_VIDEOMEMORYADDRESS
,CONSOLE_VIDEOMEMORYADDRESS+
CONSOLE_WIDTH
*(
CHARACTER
),(
CONSOLE_HEIGHT
-1)*CONSOLE_WIDTH*(CHARACTER));

116 
j
=(
CONSOLE_WIDTH
*(
CONSOLE_HEIGHT
-1));j<(CONSOLE_WIDTH*CONSOLE_HEIGHT);j++)

119 
pSn
[
j
].
bCha
=' ';

120 
pSn
[
j
].
bAribu
=
CONSOLE_DEFAULTTEXTCOLOR
;

124 
iPrtOfft
=(
CONSOLE_HEIGHT
-1)*
CONSOLE_WIDTH
;

128  
iPrtOfft
;

129 
	}
}

132 
	$kCˬSn
()

134 
CHARACTER
* 
pSn
=(CHARACTER*)
CONSOLE_VIDEOMEMORYADDRESS
;

135 
i
;

137 
i
=0;i<
CONSOLE_WIDTH
*
CONSOLE_HEIGHT
;i++)

139 
pSn
[
i
].
bCha
=' ';

140 
pSn
[
i
].
bAribu
=
CONSOLE_DEFAULTTEXTCOLOR
;

144 
	`kSCurs
(0,0);

145 
	}
}

148 
BYTE
 
	$kGCh
()

150 
KEYDATA
 
Da
;

156 
	`kGKeyFromKeyQueue
(&
Da
)==
FALSE
)

158 
	`kSchedu
();

163 if(
Da
.
bFgs
&
KEY_FLAGS_DOWN
)

165  
Da
.
bASCIICode
;

168 
	}
}

171 
	$kPrtSgXY
(
iX
,
iY
,cڡ * 
pcSg
)

173 
CHARACTER
* 
pSn
 = (CHARACTER*)
CONSOLE_VIDEOMEMORYADDRESS
;

174 
i
;

177 
pSn
+=(
iY
*80)+
iX
;

180 
i
=0;
pcSg
[i]!=0;i++)

182 
pSn
[
i
].
bCha
=
pcSg
[i];

183 
pSn
[
i
].
bAribu
=
CONSOLE_DEFAULTTEXTCOLOR
;

185 
	}
}

	@/home/jk/os/MINT64/save/02.Kernel64/Source/Console.h

1 #ide
__CONSOLE_H__


2 
	#__CONSOLE_H__


	)

4 
	~"Tys.h
"

8 
	#CONSOLE_BACKGROUND_BLACK
 0x00

	)

9 
	#CONSOLE_BACKGROUND_BLUE
 0x10

	)

10 
	#CONSOLE_BACKGROUND_GREEN
 0x20

	)

11 
	#CONSOLE_BACKGROUND_CYAN
 0x30

	)

12 
	#CONSOLE_BACKGROUND_RED
 0x40

	)

13 
	#CONSOLE_BACKGROUND_MAGENTA
 0x50

	)

14 
	#CONSOLE_BACKGROUND_BROWN
 0x60

	)

15 
	#CONSOLE_BACKGROUND_WHITE
 0x70

	)

16 
	#CONSOLE_BACKGROUND_BLINK
 0x80

	)

17 
	#CONSOLE_FOREGROUND_DARKBLACK
 0x00

	)

18 
	#CONSOLE_FOREGROUND_DARKBLUE
 0x01

	)

19 
	#CONSOLE_FOREGROUND_DARKGREEN
 0x02

	)

20 
	#CONSOLE_FOREGROUND_DARKCYAN
 0x03

	)

21 
	#CONSOLE_FOREGROUND_DARKRED
 0x04

	)

22 
	#CONSOLE_FOREGROUND_DARKMAGENTA
 0x05

	)

23 
	#CONSOLE_FOREGROUND_DARKBROWN
 0x06

	)

24 
	#CONSOLE_FOREGROUND_DARKWHITE
 0x07

	)

25 
	#CONSOLE_FOREGROUND_BRIGHTBLACK
 0x08

	)

26 
	#CONSOLE_FOREGROUND_BRIGHTBLUE
 0x09

	)

27 
	#CONSOLE_FOREGROUND_BRIGHTGREEN
 0x0A

	)

28 
	#CONSOLE_FOREGROUND_BRIGHTCYAN
 0x0B

	)

29 
	#CONSOLE_FOREGROUND_BRIGHTRED
 0x0C

	)

30 
	#CONSOLE_FOREGROUND_BRIGHTMAGENTA
 0x0D

	)

31 
	#CONSOLE_FOREGROUND_BRIGHTYELLOW
 0x0E

	)

32 
	#CONSOLE_FOREGROUND_BRIGHTWHITE
 0x0F

	)

35 
	#CONSOLE_DEFAULTTEXTCOLOR
 ( 
CONSOLE_BACKGROUND_BLACK
 | \

36 
CONSOLE_FOREGROUND_BRIGHTBLUE
 )

	)

39 
	#CONSOLE_WIDTH
 80

	)

40 
	#CONSOLE_HEIGHT
 25

	)

41 
	#CONSOLE_VIDEOMEMORYADDRESS
 0xB8000

	)

44 
	#VGA_PORT_INDEX
 0x3D4

	)

45 
	#VGA_PORT_DATA
 0x3D5

	)

46 
	#VGA_INDEX_UPPERCURSOR
 0x0E

	)

47 
	#VGA_INDEX_LOWERCURSOR
 0x0F

	)

51 #agm
ck

push
, 1 )

54 
	skCseMagSu


57 
	miCutPrtOfft
;

58 } 
	tCONSOLEMANAGER
;

60 #agm
ck

p
 )

63 
kInlizeCse
(
iX
,
iY
);

64 
kSCurs

iX
, 
iY
 );

65 
kGCurs
*
piX
, *
piY
 );

66 
kPrtf
cڡ * 
pcFmSg
, ... );

67 
kCsePrtSg
cڡ * 
pcBufr
 );

68 
kCˬSn
( );

69 
BYTE
 
kGCh
( );

70 
kPrtSgXY

iX
, 
iY
, cڡ * 
pcSg
 );

	@/home/jk/os/MINT64/save/02.Kernel64/Source/ConsoleShell.c

1 
	~"CseShl.h
"

2 
	~"Cse.h
"

3 
	~"Keybrd.h
"

4 
	~"Uty.h
"

5 
	~"PIT.h
"

6 
	~"RTC.h
"

7 
	~"AsmblyUty.h
"

8 
	~"Task.h
"

9 
	~"Synchrizi.h
"

10 
	~"DymicMemy.h
"

11 
	~"HdDisk.h
"

12 
	~"FeSyem.h
"

13 
	~"SlPt.h
"

14 
	~"MPCfigutiTab.h
"

15 
	~"LolAPIC.h
"

16 
	~"MuiPross.h
"

19 
MUTEX
 
	ggs_Mux
;

20 vީ
QWORD
 
	ggs_qwAdd
;

24 
kHp
(cڡ * 
pcPamBufr
);

25 
kCls
(cڡ * 
pcPamBufr
);

26 
kShowTٮRAMSize
(cڡ * 
pcPamBufr
);

27 
kSgToDecimHexText
(cڡ * 
pcPamBufr
);

28 
kShutdown
(cڡ * 
pcPamBufr
);

29 
kSTim
(cڡ * 
pcPamBufr
);

30 
kWaUsgPIT
(cڡ * 
pcPamBufr
);

31 
kRdTimeSmpCou
(cڡ * 
pcPamBufr
);

32 
kMsurPssSed
(cڡ * 
pcPamBufr
);

33 
kShowDeAndTime
(cڡ * 
pcPamBufr
);

34 
kCeTeTask
(cڡ * 
pcPamBufr
);

35 
kChgeTaskPriܙy
(cڡ * 
pcPamBufr
);

36 
kShowTaskLi
(cڡ * 
pcPamBufr
);

37 
kKlTask
(cڡ * 
pcPamBufr
);

38 
kCPULd
(cڡ * 
pcPamBufr
);

39 
kTeMux
(cڡ * 
pcPamBufr
);

40 
kTeThad
(cڡ * 
pcPamBufr
);

41 
kShowMrix
(cڡ * 
pcPamBufr
);

42 
kTePIE
(cڡ * 
pcPamBufr
);

43 
kTeSequtlAoti
(cڡ * 
pcPamBufr
);

44 
kTeRdomAoti
(cڡ * 
pcPamBufr
);

45 
kShowDymicMemyInfmi
(cڡ * 
pcPamBufr
);

46 
kShowHDDInfmi
(cڡ * 
pcPamBufr
);

47 
kRdSe
(cڡ * 
pcPamBufr
);

48 
kWreSe
(cڡ * 
pcPamBufr
);

49 
kMouHDD
(cڡ * 
pcPamBufr
);

50 
kFmHDD
(cڡ * 
pcPamBufr
);

51 
kShowFeSyemInfmi
(cڡ * 
pcPamBufr
);

52 
kCeFeInRoDey
(cڡ * 
pcPamBufr
);

53 
kDeFeInRoDey
(cڡ * 
pcPamBufr
);

54 
kShowRoDey
(cڡ * 
pcPamBufr
);

55 
kWreDaToFe
(cڡ * 
pcPamBufr
);

56 
kRdDaFromFe
(cڡ * 
pcPamBufr
);

57 
kTeFeIO
(cڡ * 
pcPamBufr
);

58 
kFlushCache
(cڡ * 
pcPamBufr
);

59 
kDowdFe
(cڡ * 
pcPamBufr
);

60 
kShowMPCfigutiTab
(cڡ * 
pcPamBufr
);

61 
kSAlitiPross
(cڡ * 
pcPamBufr
);

64 
kTeTask1
();

65 
kTeTask2
();

66 
kPrtNumbTask
();

67 
kCeThadTask
();

68 
QWORD
 
kRdom
();

69 
kDrChaThad
();

70 
kMrixPross
();

71 
kFPUTeTask
();

72 
kRdomAotiTask
();

75 
SHELLCOMMANDENTRY
 
	ggs_vCommdTab
[] =

77 {"hp","Show Hp",
kHp
},

78 {"s","Cˬ Sn",
kCls
},

79 {"tٮm","Show TٮRAM Size",
kShowTٮRAMSize
},

80 {"od","SgDecim/Hex cvt,x衹od 1000(decim衹od 0x10(hex)",
kSgToDecimHexText
},

81 {"shutdown","ShutdowAnd Rebo OS",
kShutdown
},

82 {"im","S PIT Cڌ˸Cou0,x)im 10(ms1Քiodiue(1)/l(0))",
kSTim
},

83 {"wa","Wa mUsg PIT,x)wa 100(ms)",
kWaUsgPIT
},

84 {"rdtsc","Rd TimSmCou",
kRdTimeSmpCou
},

85 {"ud","Msu Pross Sed",
kMsurPssSed
},

86 {"de","Show Dd Time",
kShowDeAndTime
},

87 {"sk","CTaskx)sk 1y10(cou)",
kCeTeTask
},

88 {"chgriܙy","ChgTask Priܙy,x)chgriܙy 1(ID2(Priܙy)",
kChgeTaskPriܙy
},

89 {"skli","Show Task Li",
kShowTaskLi
},

90 {"kask","End Task,x)kask 1(ID 0xffffffff(A Task)",
kKlTask
},

91 {"uld","Show Pross Ld",
kCPULd
},

92 {"mux","Te Mux Funi",
kTeMux
},

93 {"thad","Te Thad And ProsFuni",
kTeThad
},

94 {"showmrix","Show Mrix Sn",
kShowMrix
},

95 {"p","Te PIE Ccuti",
kTePIE
},

96 {"dymicmemfo","Show DymiMemy Infmi",
kShowDymicMemyInfmi
},

97 {"qloc","Te SequtAoti & Fe",
kTeSequtlAoti
},

98 {"oc","Te Rdom Aoti & Fe",
kTeRdomAoti
},

99 {"hddfo","Show HDD Infmi",
kShowHDDInfmi
},

100 {"ad","Rd HDD Se܃xd 0(LBA10(cou)",
kRdSe
},

101 {"wre","WrHDD Se܃x)wre 0(LBA10(cou)",
kWreSe
},

102 {"mouhdd","Mou HDD",
kMouHDD
},

103 {"fmhdd","Fm HDD",
kFmHDD
},

104 {"fesyemfo","Show FSyem Infmi",
kShowFeSyemInfmi
},

105 {"fe","CFe,x)fa.txt",
kCeFeInRoDey
},

106 {"defe","DFe,x)defa.txt",
kDeFeInRoDey
},

107 {"d","Show Dey",
kShowRoDey
},

108 {"wrefe","WrDTFe,x)wrefa.txt",
kWreDaToFe
},

109 {"adfe","Rd DFrom Fe,xdfa.txt",
kRdDaFromFe
},

110 {"feio","Te FI/O Funi",
kTeFeIO
},

111 {"ush","Flush FSyem Cache",
kFlushCache
},

112 {"dowd","Dowd DFrom Sex)dowd.txt",
kDowdFe
},

113 {"showmpfo","Show MP Cfiguti Tab Infmi",
kShowMPCfigutiTab
},

114 {"p","S Aliti Pross",
kSAlitiPross
},

118 vީ
QWORD
 
	ggs_qwRdomVue
 = 0;

122 
	$kSCseShl
()

124 
vcCommBufr
[
CONSOLESHELL_MAXCOMMANDBUFFERCOUNT
];

125 
iCommBufrIndex
=0;

126 
BYTE
 
bKey
;

127 
iCursX
, 
iCursY
;

130 
	`kPrtf
(
CONSOLESHELL_PROMPRTMESSAGE
);

135 
bKey
=
	`kGCh
();

137 if(
bKey
==
KEY_BACKSPACE
)

139 if(
iCommBufrIndex
>0)

142 
	`kGCurs
(&
iCursX
,&
iCursY
);

143 
	`kPrtSgXY
(
iCursX
-1,
iCursY
," ");

144 
	`kSCurs
(
iCursX
-1,
iCursY
);

145 
iCommBufrIndex
--;

149 if(
bKey
 =
KEY_ENTER
)

151 
	`kPrtf
("\n");

153 if(
iCommBufrIndex
>0)

156 
vcCommBufr
[
iCommBufrIndex
]='\0';

157 
	`kExecuCommd
(
vcCommBufr
);

161 
	`kPrtf
("%s",
CONSOLESHELL_PROMPRTMESSAGE
);

162 
	`kMemS
(
vcCommBufr
,'\0',
CONSOLESHELL_MAXCOMMANDBUFFERCOUNT
);

163 
iCommBufrIndex
=0;

166 if((
bKey
==
KEY_LSHIFT
)||(bKey==
KEY_RSHIFT
)||(bKey==
KEY_CAPSLOCK
)||(bKey==
KEY_NUMLOCK
)||(bKey==
KEY_SCROLLLOCK
))

173 if(
bKey
==
KEY_TAB
)

175 
bKey
=' ';

179 if(
iCommBufrIndex
<
CONSOLESHELL_MAXCOMMANDBUFFERCOUNT
)

181 
vcCommBufr
[
iCommBufrIndex
++]=
bKey
;

182 
	`kPrtf
("%c",
bKey
);

186 
	}
}

189 
	$kExecuCommd
(cڡ * 
pcCommdBufr
)

191 
i
, 
iSIndex
;

192 
iCommdBufrLgth
,
iCommdLgth
;

193 
iCou
;

196 
iCommdBufrLgth
=
	`kSL
(
pcCommdBufr
);

197 
iSIndex
=0;iSIndex<
iCommdBufrLgth
;iSpaceIndex++)

199 if(
pcCommdBufr
[
iSIndex
]==' ')

206 
iCou
=(
gs_vCommdTab
)/(
SHELLCOMMANDENTRY
);

208 
i
=0;i<
iCou
;i++)

210 
iCommdLgth
=
	`kSL
(
gs_vCommdTab
[
i
].
pcCommd
);

212 if((
iCommdLgth
==
iSIndex
)&&(
	`kMemCmp
(
gs_vCommdTab
[
i
].
pcCommd
,
pcCommdBufr
,iSpaceIndex)==0))

215 
gs_vCommdTab
[
i
].
	`pfFuni
(
pcCommdBufr
+
iSIndex
+1);

221 if(
i
>=
iCou
)

223 
	`kPrtf
("'%s',in found.\n",
pcCommdBufr
);

225 
	}
}

228 
	$kInlizePam
(
PARAMETERLIST
* 
pLi
,cڡ * 
pcPam
)

230 
pLi
->
pcBufr
=
pcPam
;

231 
pLi
->
iLgth
=
	`kSL
(
pcPam
);

232 
pLi
->
iCutPosi
=0;

233 
	}
}

236 
	$kGNextPam
(
PARAMETERLIST
* 
pLi
,* 
pcPam
)

238 
i
;

239 
iLgth
;

242 if(
pLi
->
iLgth
<Li->
iCutPosi
)

248 
i
=
pLi
->
iCutPosi
;i<pLi->
iLgth
;i++)

250 if(
pLi
->
pcBufr
[
i
]==' ')

257 
	`kMemCpy
(
pcPam
,
pLi
->
pcBufr
+pLi->
iCutPosi
,
i
);

258 
iLgth
=
i
-
pLi
->
iCutPosi
;

259 
pcPam
[
iLgth
]='\0';

262 
pLi
->
iCutPosi
+=
iLgth
+1;

263  
iLgth
;

264 
	}
}

268 
	$kHp
(cڡ * 
pcPamBufr
)

270 
i
;

271 
iCou
;

272 
iCursX
,
iCursY
;

273 
iLgth
,
iMaxcommdLgth
=0;

275 
	`kPrtf
("========================================================================\n");

276 
	`kPrtf
(" jk64 Shell Help \n");

277 
	`kPrtf
("========================================================================\n");

279 
iCou
=(
gs_vCommdTab
)/(
SHELLCOMMANDENTRY
);

282 
i
=0;i<
iCou
;i++)

284 
iLgth
=
	`kSL
(
gs_vCommdTab
[
i
].
pcCommd
);

285 if(
iLgth
>
iMaxcommdLgth
)

287 
iMaxcommdLgth
=
iLgth
;

292 
i
=0;i<
iCou
;i++)

294 
	`kPrtf
("%s",
gs_vCommdTab
[
i
].
pcCommd
);

295 
	`kGCurs
(&
iCursX
,&
iCursY
);

296 
	`kSCurs
(
iMaxcommdLgth
,
iCursY
);

297 
	`kPrtf
(" - %s\n",
gs_vCommdTab
[
i
].
pcHp
);

300 if((
i
!=0)&&((i%20)==0))

302 
	`kPrtf
("Preeny Keyo continue... ('q' isxit) :");

303 if(
	`kGCh
()=='q')

305 
	`kPrtf
("\n");

308 
	`kPrtf
("\n");

311 
	}
}

314 
	$kCls
(cڡ * 
pcPamBufr
)

317 
	`kCˬSn
();

318 
	`kSCurs
(0,1);

319 
	}
}

322 
	$kShowTٮRAMSize
(cڡ * 
pcPamBufr
)

324 
	`kPrtf
("Tٮ RAM Size=%d MB\n",
	`kGTٮRAMSize
());

325 
	}
}

328 
	$kSgToDecimHexText
(cڡ * 
pcPamBufr
)

330 
vcPam
[100];

331 
iLgth
;

332 
PARAMETERLIST
 
Li
;

333 
iCou
=0;

334 
iVue
;

337 
	`kInlizePam
(&
Li
,
pcPamBufr
);

342 
iLgth
=
	`kGNextPam
(&
Li
,
vcPam
);

343 if(
iLgth
==0)

349 
	`kPrtf
("Pam %d = '%s', Lgth = %d, ",
iCou
+1,
vcPam
,
iLgth
);

352 if(
	`kMemCmp
(
vcPam
,"0x",2)==0)

355 
iVue
=
	`kAToI
(
vcPam
+2,16);

356 
	`kPrtf
("HEX vu%q\n",
iVue
);

360 
iVue
=
	`kAToI
(
vcPam
,10);

361 
	`kPrtf
("Decim vu%d\n",
iVue
);

364 
iCou
++;

366 
	}
}

369 
	$kShutdown
(cڡ * 
pcPamBufr
)

371 
	`kPrtf
("System Shutdown Start...\n");

374 
	`kPrtf
("Cache Flush... ");

375 if(
	`kFlushFeSyemCache
()==
TRUE
)

377 
	`kPrtf
("Pass\n");

381 
	`kPrtf
("Fail\n");

385 
	`kPrtf
("Press Any Keyo Reboot PC...");

386 
	`kGCh
();

387 
	`kRebo
();

388 
	}
}

391 
	$kSTim
(cڡ * 
pcPamBufr
)

393 
vcPam
[100];

394 
PARAMETERLIST
 
Li
;

395 
lVue
;

396 
BOOL
 
bPiodic
;

399 
	`kInlizePam
(&
Li
,
pcPamBufr
);

402 if(
	`kGNextPam
(&
Li
,
vcPam
)==0)

404 
	`kPrtf
("ex)settimer 10(ms) 1(periodic)\n");

407 
lVue
=
	`kAToI
(
vcPam
,10);

410 if(
	`kGNextPam
(&
Li
,
vcPam
)==0)

412 
	`kPrtf
("ex)settimer 10(ms) 1(periodic)\n");

416 
bPiodic
 = 
	`kAToI
(
vcPam
,10);

418 
	`kInlizePIT
(
	`MSTOCOUNT
(
lVue
),
bPiodic
);

419 
	`kPrtf
("Tim%d ms, Piodi%d ChgCome\n",
lVue
,
bPiodic
);

420 
	}
}

423 
	$kWaUsgPIT
(cڡ * 
pcPamBufr
)

425 
vcPam
[100];

426 
iLgth
;

427 
PARAMETERLIST
 
Li
;

428 
lMicd
;

429 
i
;

432 
	`kInlizePam
(&
Li
,
pcPamBufr
);

433 if(
	`kGNextPam
(&
Li
,
vcPam
)==0)

435 
	`kPrtf
("ex)wait 100(ms)\n");

439 
lMicd
 = 
	`kAToI
(
vcPam
,10);

440 
	`kPrtf
("%d mS˕ S...\n",
lMicd
);

443 
	`kDibIru
();

444 
i
=0;i<
lMicd
/30;i++)

446 
	`kWaUsgDePIT
(
	`MSTOCOUNT
(30));

448 
	`kWaUsgDePIT
(
	`MSTOCOUNT
(
lMicd
%30));

449 
	`kEbIru
();

450 
	`kPrtf
("%d mS˕ Come\n",
lMicd
);

453 
	`kInlizePIT
(
	`MSTOCOUNT
(1),
TRUE
);

454 
	}
}

457 
	$kRdTimeSmpCou
(cڡ * 
pcPamBufr
)

459 
QWORD
 
qwTSC
;

461 
qwTSC
 = 
	`kRdTSC
();

462 
	`kPrtf
("TimSmCou = %q\n",
qwTSC
);

463 
	}
}

466 
	$kMsurPssSed
(cڡ * 
pcPamBufr
)

468 
i
;

469 
QWORD
 
qwLaTSC
, 
qwTٮTSC
=0;

471 
	`kPrtf
("Now Measuring");

474 
	`kDibIru
();

475 
i
=0;i<200;i++)

477 
qwLaTSC
=
	`kRdTSC
();

478 
	`kWaUsgDePIT
(
	`MSTOCOUNT
(50));

479 
qwTٮTSC
+=
	`kRdTSC
()-
qwLaTSC
;

481 
	`kPrtf
(".");

485 
	`kInlizePIT
(
	`MSTOCOUNT
(1),
TRUE
);

486 
	`kEbIru
();

488 
	`kPrtf
("\nCPU Sed = %d MHz\n",
qwTٮTSC
/10/1000/1000);

489 
	}
}

492 
	$kShowDeAndTime
(cڡ * 
pcPamBufr
)

494 
BYTE
 
bSecd
, 
bMu
,
bHour
;

495 
BYTE
 
bDayOFWk
,
bDayOfMth
,
bMth
;

496 
WORD
 
wYr
;

499 
	`kRdRTCTime
(&
bHour
,&
bMu
,&
bSecd
);

500 
	`kRdRTCDa
(&
wYr
,&
bMth
,&
bDayOfMth
,&
bDayOFWk
);

502 
	`kPrtf
("D: %d/%d/%d %s",
wYr
,
bMth
,
bDayOfMth
,
	`kCvtDayOfWkToSg
(
bDayOFWk
));

503 
	`kPrtf
("Tim: %d:%d:%d\n",
bHour
,
bMu
,
bSecd
);

504 
	}
}

509 
	$kTeTask1
()

511 
BYTE
 
bDa
;

512 
i
=0,
iX
=0,
iY
=0,
iMg
,
j
;

513 
CHARACTER
* 
pSn
 = (CHARACTER*
CONSOLE_VIDEOMEMORYADDRESS
;

514 
TCB
* 
pRugTask
;

518 
pRugTask
 = 
	`kGRugTask
();

519 
iMg
 = (
pRugTask
->
Lk
.
qwID
&0xFFFFFFFF)%10+1;

522 
j
=0;j<20000;j++)

524 
i
)

527 
iX
++;

528 if(
iX
>=(
CONSOLE_WIDTH
-
iMg
))

530 
i
=1;

535 
iY
++;

536 if(
iY
>=(
CONSOLE_HEIGHT
-
iMg
))

538 
i
=2;

543 
iX
--;

544 if(
iX
<
iMg
)

546 
i
=3;

551 
iY
--;

552 if(
iY
<
iMg
)

554 
i
=0;

561 
pSn
[
iY
*
CONSOLE_WIDTH
+
iX
].
bCha
=
bDa
;

562 
pSn
[
iY
*
CONSOLE_WIDTH
+
iX
].
bAribu
=
bDa
&0x0F;

563 
bDa
++;

570 
	`kExTask
();

572 
	}
}

576 
	$kTeTask2
()

578 
i
=0,
iOfft
;

579 
CHARACTER
* 
pSn
 = (CHARACTER*)
CONSOLE_VIDEOMEMORYADDRESS
;

580 
TCB
* 
pRugTask
;

581 
vcDa
[4]={'-','\\','|','/'};

584 
pRugTask
 = 
	`kGRugTask
();

585 
iOfft
 = (
pRugTask
->
Lk
.
qwID
&0xFFFFFFFF)*2;

586 
iOfft
 = 
CONSOLE_WIDTH
*
CONSOLE_HEIGHT
-(iOffset%(CONSOLE_WIDTH*CONSOLE_HEIGHT));

591 
pSn
[
iOfft
].
bCha
 = 
vcDa
[
i
%4];

593 
pSn
[
iOfft
].
bAribu
 = (iOffset%15)+1;

594 
i
++;

599 
	}
}

602 
	$kCeTeTask
(cڡ * 
pcPamBufr
)

604 
PARAMETERLIST
 
Li
;

605 
vcTy
[30];

606 
vcCou
[30];

607 
i
;

610 
	`kInlizePam
(&
Li
,
pcPamBufr
);

611 
	`kGNextPam
(&
Li
,
vcTy
);

612 
	`kGNextPam
(&
Li
,
vcCou
);

614 
	`kAToI
(
vcTy
,10))

618 
i
=0;i<
	`kAToI
(
vcCou
,10);i++)

620 if(
	`kCeTask
(
TASK_FLAGS_LOW
|
TASK_FLAGS_THREAD
,0,0,(
QWORD
)
kTeTask1
)==
NULL
)

626 
	`kPrtf
("Task1 %d Ced\n",
i
);

631 
i
=0;i<
	`kAToI
(
vcCou
,10);i++)

633 if(
	`kCeTask
(
TASK_FLAGS_LOW
|
TASK_FLAGS_THREAD
,0,0,(
QWORD
)
kTeTask2
)==
NULL
)

639 
	`kPrtf
("Task2 %d ced\n",
i
);

643 
	}
}

646 
	$kChgeTaskPriܙy
(cڡ * 
pcPamBufr
)

648 
PARAMETERLIST
 
Li
;

649 
vcID
[30];

650 
vcPriܙy
[30];

651 
QWORD
 
qwID
;

652 
BYTE
 
bPriܙy
;

655 
	`kInlizePam
(&
Li
,
pcPamBufr
);

656 
	`kGNextPam
(&
Li
,
vcID
);

657 
	`kGNextPam
(&
Li
,
vcPriܙy
);

660 if(
	`kMemCmp
(
vcID
,"0x",2)==0)

662 
qwID
 = 
	`kAToI
(
vcID
+2,16);

666 
qwID
 = 
	`kAToI
(
vcID
,10);

669 
bPriܙy
 = 
	`kAToI
(
vcPriܙy
,10);

671 
	`kPrtf
("ChgTask Priܙy ID [0x%q] Priܙy[%d]",
qwID
,
bPriܙy
);

672 if(
	`kChgePriܙy
(
qwID
,
bPriܙy
)==
TRUE
)

674 
	`kPrtf
("Success\n");

678 
	`kPrtf
("Fail\n");

680 
	}
}

683 
	$kShowTaskLi
(cڡ * 
pcPamBufr
)

685 
i
;

686 
TCB
* 
pTCB
;

687 
iCou
=0;

689 
	`kPrtf
("============Task Tٮ Cou [%d] ===========\n",
	`kGTaskCou
());

690 
i
=0;i<
TASK_MAXCOUNT
;i++)

693 
pTCB
 = 
	`kGTCBInTCBPo
(
i
);

694 if((
pTCB
->
Lk
.
qwID
>>32)!=0)

697 if((
iCou
!=0)&&((iCount%10)==0))

699 
	`kPrtf
("Pressny keyo continue... ('q' isxit) : ");

700 if(
	`kGCh
()=='q')

702 
	`kPrtf
("\n");

705 
	`kPrtf
("\n");

708 
	`kPrtf
("[%d] Task ID[0x%Q], Priܙy[%d], Fgs[0x%Q], Thad[%d]\n",1+
iCou
++,
pTCB
->
Lk
.
qwID
,
	`GETPRIORITY
աTCB->
qwFgs
),pTCB->qwFgs,
	`kGLiCou
(&աTCB->
ChdThadLi
)));

709 
	`kPrtf
(" PPID[0x%Q], Memy Addss[0x%Q], Size[0x%Q]\n",
pTCB
->
qwPtProssID
,pTCB->
pvMemyAddss
,pTCB->
qwMemySize
);

714 
	}
}

717 
	$kKlTask
(cڡ * 
pcPamBufr
)

719 
PARAMETERLIST
 
Li
;

720 
vcID
[30];

721 
QWORD
 
qwID
;

722 
TCB
* 
pTCB
;

723 
i
;

726 
	`kInlizePam
(&
Li
,
pcPamBufr
);

727 
	`kGNextPam
(&
Li
,
vcID
);

730 if(
	`kMemCmp
(
vcID
,"0x",2)==0)

732 
qwID
 = 
	`kAToI
(
vcID
+2,16);

736 
qwID
 = 
	`kAToI
(
vcID
,10);

740 if(
qwID
!=0xFFFFFFFF)

742 
pTCB
 = 
	`kGTCBInTCBPo
(
	`GETTCBOFFSET
(
qwID
));

743 
qwID
 = 
pTCB
->
Lk
.qwID;

746 if(((
qwID
>>32)!=0)&&((
pTCB
->
qwFgs
&
TASK_FLAGS_SYSTEM
)==0x00))

748 
	`kPrtf
("KTask ID [0x%q]",
qwID
);

749 if(
	`kEndTask
(
qwID
)==
TRUE
)

751 
	`kPrtf
("Success\n");

755 
	`kPrtf
("Fail\n");

760 
	`kPrtf
("Task doesotxist orask is systemask\n");

767 
i
=0;i<
TASK_MAXCOUNT
;i++)

769 
pTCB
 = 
	`kGTCBInTCBPo
(
i
);

770 
qwID
 = 
pTCB
->
Lk
.qwID;

773 if(((
qwID
>>32)!=0)&&((
pTCB
->
qwFgs
&
TASK_FLAGS_SYSTEM
)==0x00))

775 
	`kPrtf
("KTask ID [0x%q]",
qwID
);

776 if(
	`kEndTask
(
qwID
)==
TRUE
)

778 
	`kPrtf
("Success\n");

782 
	`kPrtf
("Fail\n");

787 
	}
}

790 
	$kCPULd
(cڡ * 
pcPamBufr
)

792 
	`kPrtf
("Pross Ld : %d%%\n",
	`kGProssLd
());

794 
	}
}

798 
	$kPrtNumbTask
()

800 
i
;

801 
j
;

802 
QWORD
 
qwTickCou
;

806 
qwTickCou
 = 
	`kGTickCou
();

807 (
	`kGTickCou
()-
qwTickCou
)<50)

809 
	`kSchedu
();

813 
i
=0;i<5;i++)

815 
	`kLock
(&(
gs_Mux
));

816 
	`kPrtf
("Task ID [0x%Q] Vue[%d]\n",
	`kGRugTask
()->
Lk
.
qwID
,
gs_qwAdd
);

817 
gs_qwAdd
+=1;

818 
	`kUock
(&(
gs_Mux
));

821 
j
=0;j<30000;j++);

825 
qwTickCou
 = 
	`kGTickCou
();

826 (
	`kGTickCou
()-
qwTickCou
)<1000)

828 
	`kSchedu
();

832 
	`kExTask
();

833 
	}
}

836 
	$kTeMux
(cڡ * 
pcPamBufr
)

838 
i
;

840 
gs_qwAdd
=1;

843 
	`kInlizeMux
(&(
gs_Mux
));

845 
i
=0;i<3;i++)

848 
	`kCeTask
(
TASK_FLAGS_LOW
|
TASK_FLAGS_THREAD
,0,0,(
QWORD
)
kPrtNumbTask
);

850 
	`kPrtf
("Wa Ut %d Task End...\n",
i
);

851 
	`kGCh
();

852 
	}
}

855 
	$kCeThadTask
()

857 
i
;

859 
i
=0;i<3;i++)

861 
	`kCeTask
(
TASK_FLAGS_LOW
|
TASK_FLAGS_THREAD
,0,0,(
QWORD
)
kTeTask2
);

866 
	`kS˕
(1);

868 
	}
}

871 
	$kTeThad
(cڡ * 
pcPamBufr
)

873 
TCB
* 
pPross
;

875 
pPross
 = 
	`kCeTask
(
TASK_FLAGS_LOW
|
TASK_FLAGS_PROCESS
,(*)0xEEEEEEEE,0x1000,(
QWORD
)
kCeThadTask
);

877 if(
pPross
!=
NULL
)

879 
	`kPrtf
("Pros[0x%Q] CSucss\n",
pPross
->
Lk
.
qwID
);

883 
	`kPrtf
("Process Create Fail\n");

885 
	}
}

888 
QWORD
 
	$kRdom
()

890 
gs_qwRdomVue
 = (gs_qwRandomValue*412153 + 5571031)>>16;

891  
gs_qwRdomVue
;

892 
	}
}

895 
	$kDrChaThad
()

897 
iX
;

898 
i
;

899 
vcText
[2] = {0,};

901 
iX
 = 
	`kRdom
()%
CONSOLE_WIDTH
;

906 
	`kS˕
(
	`kRdom
()%20);

908 if((
	`kRdom
()%20)<15)

910 
vcText
[0]=' ';

911 
i
=0;i<
CONSOLE_HEIGHT
-1;i++)

913 
	`kPrtSgXY
(
iX
,
i
,
vcText
);

914 
	`kS˕
(50);

919 
i
=0;i<
CONSOLE_HEIGHT
-1;i++)

921 
vcText
[0]=
i
+
	`kRdom
();

922 
	`kPrtSgXY
(
iX
,
i
,
vcText
);

923 
	`kS˕
(50);

927 
	}
}

930 
	$kMrixPross
()

932 
i
;

934 
i
=0;i<300;i++)

936 if(
	`kCeTask
(
TASK_FLAGS_THREAD
|
TASK_FLAGS_LOW
,0,0,(
QWORD
)
kDrChaThad
)==
NULL
)

941 
	`kS˕
(
	`kRdom
()%5+5);

944 
	`kPrtf
("%d Thad id\n",
i
);

947 
	`kGCh
();

948 
	}
}

951 
	$kShowMrix
(cڡ * 
pcPamBufr
)

953 
TCB
* 
pPross
;

955 
pPross
 = 
	`kCeTask
(
TASK_FLAGS_PROCESS
|
TASK_FLAGS_LOW
,(*)0xE00000,0xE00000,(
QWORD
)
kMrixPross
);

957 if(
pPross
!=
NULL
)

959 
	`kPrtf
("Mrix Pros[0x%Q] CeSucss\n",
pPross
->
Lk
.
qwID
);

962 (
pPross
->
Lk
.
qwID
>>32)!=0)

964 
	`kS˕
(100);

969 
	`kPrtf
("Matrix Process Create Fail\n");

971 
	}
}

973 
	$kFPUTeTask
()

975 
dVue1
;

976 
dVue2
;

977 
TCB
* 
pRugTask
;

978 
QWORD
 
qwCou
=0;

979 
QWORD
 
qwRdomVue
;

980 
i
;

981 
iOfft
;

982 
vcDa
[4]={'-','\\','|','/'};

983 
CHARACTER
* 
pSn
 = (CHARACTER*)
CONSOLE_VIDEOMEMORYADDRESS
;

985 
pRugTask
 = 
	`kGRugTask
();

988 
iOfft
 = (
pRugTask
->
Lk
.
qwID
&0xFFFFFFFF)*2;

989 
iOfft
 = 
CONSOLE_WIDTH
*
CONSOLE_HEIGHT
-(iOffset%(CONSOLE_WIDTH*CONSOLE_HEIGHT));

994 
dVue1
=1;

995 
dVue2
=1;

998 
i
=0;i<10;i++)

1000 
qwRdomVue
 = 
	`kRdom
();

1001 
dVue1
*=()
qwRdomVue
;

1002 
dVue2
*=()
qwRdomVue
;

1004 
	`kS˕
(1);

1006 
qwRdomVue
=
	`kRdom
();

1007 
dVue1
/=()
qwRdomVue
;

1008 
dVue2
/=()
qwRdomVue
;

1011 if(
dVue1
!=
dVue2
)

1013 
	`kPrtf
("Vuin same~!!! [%f] ![%f]\n",
dVue1
,
dVue2
);

1017 
qwCou
++;

1020 
pSn
[
iOfft
].
bCha
 = 
vcDa
[
qwCou
%4];

1023 
pSn
[
iOfft
].
bAribu
 = (iOffset%15)+1;

1025 
	}
}

1028 
	$kTePIE
(cڡ * 
pcPamBufr
)

1030 
dResu
;

1031 
i
;

1033 
	`kPrtf
("PIE Calculation Test\n");

1034 
	`kPrtf
("Result:355/133=");

1035 
dResu
 =()355/133;

1036 
	`kPrtf
("%d%d%d\n",(
QWORD
)
dResu
,((QWORD)(dResult*10)%10),((QWORD)(dResult*100)%10));

1039 
i
=0;i<100;i++)

1041 
	`kCeTask
(
TASK_FLAGS_LOW
|
TASK_FLAGS_THREAD
,0,0,(
QWORD
)
kFPUTeTask
);

1043 
	}
}

1046 
	$kShowDymicMemyInfmi
(cڡ * 
pcPamBufr
)

1048 
QWORD
 
qwSAddss
,
qwTٮSize
,
qwMaSize
,
qwUdSize
;

1050 
	`kGDymicMemyInfmi
(&
qwSAddss
,&
qwTٮSize
,&
qwMaSize
,&
qwUdSize
);

1052 
	`kPrtf
("================ Dynamic Memory Information =============\n");

1053 
	`kPrtf
("S Adds: [0x%Q]\n",
qwSAddss
);

1054 
	`kPrtf
("Tٮ Siz: [0x%Q]by, [%d]MB\n",
qwTٮSize
,qwTotalSize/1024/1024);

1055 
	`kPrtf
("MSize: [0x%Q]by, [%d]KB\n",
qwMaSize
,qwMetaSize/1024);

1056 
	`kPrtf
("Ud Size: [0x%Q]by, [%d]KB\n",
qwUdSize
,qwUsedSize/1024);

1057 
	}
}

1060 
	$kTeSequtlAoti
(cڡ * 
pcPamBufr
)

1062 
DYNAMICMEMORY
* 
pMemy
;

1063 
i
,
j
,
k
;

1064 
QWORD
* 
pqwBufr
;

1066 
	`kPrtf
("=============== Dynamic Memory Test =================\n");

1067 
pMemy
 = 
	`kGDymicMemyMag
();

1069 
i
=0;i<
pMemy
->
iMaxLevCou
;i++)

1071 
	`kPrtf
("Block Li [%d] Te S\n",
i
);

1072 
	`kPrtf
("Allocation And Compare: ");

1075 
j
=0;j<(
pMemy
->
iBlockCouOfSmˡBlock
>>
i
);j++)

1077 
pqwBufr
 = 
	`kAoMemy
(
DYNAMICMEMORY_MIN_SIZE
<<
i
);

1078 if(
pqwBufr
==
NULL
)

1080 
	`kPrtf
("\nAllocation Fail\n");

1085 
k
=0;k<(
DYNAMICMEMORY_MIN_SIZE
<<
i
)/8;k++)

1087 
pqwBufr
[
k
]=k;

1090 
k
=0;k<(
DYNAMICMEMORY_MIN_SIZE
<<
i
)/8;k++)

1092 if(
pqwBufr
[
k
]!=k)

1094 
	`kPrtf
("\nCompare Fail\n");

1100 
	`kPrtf
(".");

1103 
	`kPrtf
("\nFree: ");

1105 
j
=0;j<(
pMemy
->
iBlockCouOfSmˡBlock
>>
i
);j++)

1107 if(
	`kFeMemy
((*)(
pMemy
->
qwSAddss
+(
DYNAMICMEMORY_MIN_SIZE
<<
i
)*
j
))==
FALSE
)

1109 
	`kPrtf
("\n Free Fail\n");

1114 
	`kPrtf
(".");

1116 
	`kPrtf
("\n");

1118 
	}
}

1121 
	$kRdomAotiTask
()

1123 
TCB
* 
pTask
;

1124 
QWORD
 
qwMemySize
;

1125 
vcBufr
[200];

1126 
BYTE
* 
pbAotiBufr
;

1127 
i
,
j
;

1128 
iY
;

1130 
pTask
 = 
	`kGRugTask
();

1131 
iY
 = (
pTask
->
Lk
.
qwID
)%15+9;

1133 
j
=0;j<10;j++)

1138 
qwMemySize
 = ((
	`kRdom
()%(32*1024))+1)*1024;

1139 
pbAotiBufr
 = 
	`kAoMemy
(
qwMemySize
);

1143 if(
pbAotiBufr
==0)

1145 
	`kS˕
(1);

1147 } 
pbAotiBufr
==0);

1149 
	`kSPrtf
(
vcBufr
,"|Addss: [0x%Q] Size: [0x%Q] Aoti Sucss",
pbAotiBufr
,
qwMemySize
);

1151 
	`kPrtSgXY
(20,
iY
,
vcBufr
);

1152 
	`kS˕
(200);

1155 
	`kSPrtf
(
vcBufr
,"|Addss: [0x%Q] Size: [0x%Q] DWre...",
pbAotiBufr
,
qwMemySize
);

1156 
	`kPrtSgXY
(20,
iY
,
vcBufr
);

1157 
i
=0;i<
qwMemySize
/2;i++)

1159 
pbAotiBufr
[
i
] = 
	`kRdom
()&0xFF;

1160 
pbAotiBufr
[
i
+(
qwMemySize
/2)]=pbAllocationBuffer[i];

1163 
	`kS˕
(200);

1166 
	`kSPrtf
(
vcBufr
,"|Addss: [0x%Q] Size: [0x%Q] DVify...",
pbAotiBufr
,
qwMemySize
);

1167 
	`kPrtSgXY
(20,
iY
,
vcBufr
);

1168 
i
=0;i<
qwMemySize
/2;i++)

1170 if(
pbAotiBufr
[
i
]!bAotiBufr[i+(
qwMemySize
/2)])

1172 
	`kPrtf
("Task ID[0x%Q] Vify Fa\n",
pTask
->
Lk
.
qwID
);

1173 
	`kExTask
();

1176 
	`kFeMemy
(
pbAotiBufr
);

1177 
	`kS˕
(200);

1180 
	`kExTask
();

1181 
	}
}

1184 
	$kTeRdomAoti
(cڡ * 
pcPamBufr
)

1186 
i
;

1188 
i
=0;i<100;i++)

1190 
	`kCeTask
(
TASK_FLAGS_LOWEST
|
TASK_FLAGS_THREAD
,0,0,(
QWORD
)
kRdomAotiTask
);

1192 
	}
}

1195 
	$kShowHDDInfmi
(cڡ * 
pcPamBufr
)

1197 
HDDINFORMATION
 
HDD
;

1198 
vcBufr
[100];

1201 if(
	`kGHDDInfmi
(&
HDD
)==
FALSE
)

1203 
	`kPrtf
("HDD Information Read Fail\n");

1207 
	`kPrtf
("===================== Primary Master HDD Information ====================\n");

1210 
	`kMemCpy
(
vcBufr
,
HDD
.
vwModNumb
,(stHDD.vwModelNumber));

1211 
vcBufr
[(
HDD
.
vwModNumb
)-1]='\0';

1212 
	`kPrtf
("Mod Numb:\%s\n",
vcBufr
);

1215 
	`kMemCpy
(
vcBufr
,
HDD
.
vwSlNumb
,(stHDD.vwSerialNumber));

1216 
vcBufr
[(
HDD
.
vwSlNumb
)-1]='\0';

1217 
	`kPrtf
("SNumb:\%s\n",
vcBufr
);

1220 
	`kPrtf
("Hd Cou:\%d\n",
HDD
.
wNumbOfHd
);

1221 
	`kPrtf
("Cyld Cou:\%d\n",
HDD
.
wNumbOfCyld
);

1222 
	`kPrtf
("Se Cou:\%d\n",
HDD
.
wNumbOfSePCyld
);

1225 
	`kPrtf
("Tٮ Se:\%d Se, %dMB\n",
HDD
.
dwTٮSes
,stHDD.dwTotalSectors/2/1024);

1226 
	}
}

1229 
	$kRdSe
(cڡ * 
pcPamBufr
)

1231 
PARAMETERLIST
 
Li
;

1232 
vcLBA
[50],
vcSeCou
[50];

1233 
DWORD
 
dwLBA
;

1234 
iSeCou
;

1235 * 
pcBufr
;

1236 
i
,
j
;

1237 
BYTE
 
bDa
;

1238 
BOOL
 
bEx
=
FALSE
;

1241 
	`kInlizePam
(&
Li
,
pcPamBufr
);

1242 if((
	`kGNextPam
(&
Li
,
vcLBA
)==0)||(kGNextPam(&Li,
vcSeCou
)==0))

1244 
	`kPrtf
("ex)readsector 0(LBA) 10(count)\n");

1247 
dwLBA
 = 
	`kAToI
(
vcLBA
,10);

1248 
iSeCou
 = 
	`kAToI
(
vcSeCou
,10);

1251 
pcBufr
 = 
	`kAoMemy
(
iSeCou
*512);

1252 if(
	`kRdHDDSe
(
TRUE
,TRUE,
dwLBA
,
iSeCou
,
pcBufr
)==iSectorCount)

1254 
	`kPrtf
("LBA [%d] [%d] Se Rd Sucss~!!",
dwLBA
,
iSeCou
);

1256 
j
=0;j<
iSeCou
;j++)

1258 
i
=0;i<512;i++)

1260 if(!((
j
==0)&&(
i
==0))&&((i%256)==0))

1262 
	`kPrtf
("\nPressny keyo continue... ('q' isxit) : ");

1263 if(
	`kGCh
()=='q')

1265 
bEx
=
TRUE
;

1270 if((
i
%16)==0)

1272 
	`kPrtf
("\n[LBA:%d, Offt:%d]\t| ",
dwLBA
+
j
,
i
);

1276 
bDa
 = 
pcBufr
[
j
*512+
i
]&0xFF;

1277 if(
bDa
<16)

1279 
	`kPrtf
("0");

1281 
	`kPrtf
("%X ",
bDa
);

1284 if(
bEx
==
TRUE
)

1290 
	`kPrtf
("\n");

1294 
	`kPrtf
("Read Fail\n");

1297 
	`kFeMemy
(
pcBufr
);

1298 
	}
}

1301 
	$kWreSe
(cڡ * 
pcPamBufr
)

1303 
PARAMETERLIST
 
Li
;

1304 
vcLBA
[50],
vcSeCou
[50];

1305 
DWORD
 
dwLBA
;

1306 
iSeCou
;

1307 * 
pcBufr
;

1308 
i
,
j
;

1309 
BOOL
 
bEx
=
FALSE
;

1310 
BYTE
 
bDa
;

1311 
DWORD
 
s_dwWreCou
=0;

1314 
	`kInlizePam
(&
Li
,
pcPamBufr
);

1315 if((
	`kGNextPam
(&
Li
,
vcLBA
)==0)||(kGNextPam(&Li,
vcSeCou
)==0))

1317 
	`kPrtf
("ex)writesector 0(LBA) 10(count)\n");

1321 
dwLBA
 = 
	`kAToI
(
vcLBA
,10);

1322 
iSeCou
 = 
	`kAToI
(
vcSeCou
,10);

1324 
s_dwWreCou
++;

1327 
pcBufr
 = 
	`kAoMemy
(
iSeCou
*512);

1328 
j
=0;j<
iSeCou
;j++)

1330 
i
=0;i<512;i+=8)

1332 *(
DWORD
*)&(
pcBufr
[
j
*512+
i
])=
dwLBA
+j;

1333 *(
DWORD
*)&(
pcBufr
[
j
*512+
i
+4])=
s_dwWreCou
;

1338 if(
	`kWreHDDSe
(
TRUE
,TRUE,
dwLBA
,
iSeCou
,
pcBufr
)!=iSectorCount)

1340 
	`kPrtf
("Write Fail\n");

1343 
	`kPrtf
("LBA [%d], [%d] Se WrSucss~!!",
dwLBA
,
iSeCou
);

1346 
j
=0;j<
iSeCou
;j++)

1348 
i
=0;i<512;i++)

1350 if(!((
j
==0)&&(
i
==0))&&((i%256)==0))

1352 
	`kPrtf
("\nPressny keyo continue... ('q' isxit) : ");

1353 if(
	`kGCh
()=='q')

1355 
bEx
=
TRUE
;

1360 if((
i
%16)==0)

1362 
	`kPrtf
("\n[LBA:%d, Offt:%d]\t| ",
dwLBA
+
j
,
i
);

1366 
bDa
 = 
pcBufr
[
j
*512+
i
]&0xFF;

1367 if(
bDa
<16)

1369 
	`kPrtf
("0");

1371 
	`kPrtf
("%X ",
bDa
);

1374 if(
bEx
==
TRUE
)

1380 
	`kPrtf
("\n");

1381 
	`kFeMemy
(
pcBufr
);

1382 
	}
}

1385 
	$kMouHDD
(cڡ * 
pcPamBufr
)

1387 if(
	`kMou
()==
FALSE
)

1389 
	`kPrtf
("HDD Mount Fail\n");

1392 
	`kPrtf
("Hdd Mount Success\n");

1393 
	}
}

1396 
	$kFmHDD
(cڡ * 
pcPamBufr
)

1398 if(
	`kFm
()==
FALSE
)

1400 
	`kPrtf
("HDD Format Fail\n");

1404 
	`kPrtf
("HDD Format Success\n");

1405 
	}
}

1408 
	$kShowFeSyemInfmi
(cڡ * 
pcPamBufr
)

1410 
FILESYSTEMMANAGER
 
Mag
;

1412 
	`kGFeSyemInfmi
(&
Mag
);

1414 
	`kPrtf
("==================================== File System Information =================================\n");

1415 
	`kPrtf
("Moued:\t\t\t\t\%d\n",
Mag
.
bMoued
);

1416 
	`kPrtf
("Rerved Se Cou:\t\t\%d Se\n",
Mag
.
dwRervedSeCou
);

1417 
	`kPrtf
("Clu Lk Tab S Addss:\%d Se\n",
Mag
.
dwCluLkAaSAddss
);

1418 
	`kPrtf
("Clu Lk Tab Size:\t\%d Se\n",
Mag
.
dwCluLkAaSize
);

1419 
	`kPrtf
("DAS Addss:\t\%d Se\n",
Mag
.
dwDaAaSAddss
);

1420 
	`kPrtf
("Tٮ Clu Cou:\t\t\%d Clu\n",
Mag
.
dwTٮCluCou
);

1421 
	}
}

1424 
	$kCeFeInRoDey
(cڡ * 
pcPamBufr
)

1426 
PARAMETERLIST
 
Li
;

1427 
vcFeName
[50];

1428 
iLgth
;

1429 
DWORD
 
dwClu
;

1430 
DIRECTORYENTRY
 
Ery
;

1431 
i
;

1432 
FILE
* 
pFe
;

1435 
	`kInlizePam
(&
Li
,
pcPamBufr
);

1436 
iLgth
 = 
	`kGNextPam
(&
Li
,
vcFeName
);

1437 
vcFeName
[
iLgth
]='\0';

1438 if((
iLgth
>((
Ery
.
vcFeName
)-1))||(iLength==0))

1440 
	`kPrtf
("Tooong or Too short File Name\n");

1444 
pFe
 = 
	`fݒ
(
vcFeName
,"w");

1445 if(
pFe
==
NULL
)

1447 
	`kPrtf
("File Create Fail\n");

1450 
	`fo
(
pFe
);

1451 
	`kPrtf
("File Create Success\n");

1452 
	}
}

1455 
	$kDeFeInRoDey
(cڡ * 
pcPamBufr
)

1457 
PARAMETERLIST
 
Li
;

1458 
vcFeName
[50];

1459 
iLgth
;

1460 
DIRECTORYENTRY
 
Ery
;

1461 
iOfft
;

1464 
	`kInlizePam
(&
Li
,
pcPamBufr
);

1465 
iLgth
 = 
	`kGNextPam
(&
Li
,
vcFeName
);

1466 
vcFeName
[
iLgth
]='\0';

1468 if((
iLgth
>(
FILESYSTEM_MAXFILENAMELENGTH
-1))||(iLength==0))

1470 
	`kPrtf
("Too Long or Too Short File Name\n");

1474 if(
	`move
(
vcFeName
)!=0)

1476 
	`kPrtf
("File Not Found or File Opened\n");

1480 
	`kPrtf
("File Delete Success\n");

1481 
	}
}

1484 
	$kShowRoDey
(cڡ * 
pcPamBufr
)

1486 
DIR
* 
pDey
;

1487 
i
,
iTٮCou
,
iCou
;

1488 
dt
* 
pEry
;

1489 
vcBufr
[400];

1490 
vcTempVue
[50];

1491 
DWORD
 
dwTٮBy
;

1492 
DWORD
 
dwUdCluCou
;

1493 
FILESYSTEMMANAGER
 
Mag
;

1496 
	`kGFeSyemInfmi
(&
Mag
);

1499 
pDey
 = 
	`ݒd
("/");

1500 if(
pDey
==
NULL
)

1502 
	`kPrtf
("Root Directory Open Fail\n");

1507 
iTٮCou
=0;

1508 
dwTٮBy
=0;

1509 
dwUdCluCou
=0;

1514 
pEry
 = 
	`add
(
pDey
);

1516 if(
pEry
==
NULL
)

1520 
iTٮCou
++;

1521 
dwTٮBy
+=
pEry
->
dwFeSize
;

1524 if(
pEry
->
dwFeSize
==0)

1527 
dwUdCluCou
++;

1532 
dwUdCluCou
 +=(
pEry
->
dwFeSize
+
FILESYSTEM_CLUSTERSIZE
-1)/FILESYSTEM_CLUSTERSIZE;

1537 
	`wdd
(
pDey
);

1538 
iCou
=0;

1542 
pEry
 = 
	`add
(
pDey
);

1544 if(
pEry
==
NULL
)

1550 
	`kMemS
(
vcBufr
,' ',(vcBuffer)-1);

1551 
vcBufr
[(vcBuffer)-1]='\0';

1554 
	`kMemCpy
(
vcBufr
,
pEry
->
d_me
,
	`kSL
(pstEntry->d_name));

1557 
	`kSPrtf
(
vcTempVue
,"%d By",
pEry
->
dwFeSize
);

1558 
	`kMemCpy
(
vcBufr
+30,
vcTempVue
,
	`kSL
(vcTempValue));

1561 
	`kSPrtf
(
vcBufr
+55,"0x%X Clu",
pEry
->
dwSCluIndex
);

1562 
	`kPrtf
(" %s\n",
vcBufr
);

1564 if((
iCou
!=0)&&((iCount%20)==0))

1566 
	`kPrtf
("Preeny keyo continue... ('q' isxit) : ");

1567 if(
	`kGCh
()=='q')

1569 
	`kPrtf
("\n");

1573 
iCou
++;

1577 
	`kPrtf
("\t\tTٮ FCou: %d\n",
iTٮCou
);

1578 
	`kPrtf
("\t\tTٮ FSize: %d KBy (%d Clu)\n",
dwTٮBy
/1024,
dwUdCluCou
);

1581 
	`kPrtf
("\t\tFS: %d KBy (%d Clu)\n",(
Mag
.
dwTٮCluCou
-
dwUdCluCou
)*
FILESYSTEM_CLUSTERSIZE
/1024,stManager.dwTotalClusterCount-dwUsedClusterCount);

1584 
	`od
(
pDey
);

1585 
	}
}

1588 
	$kWreDaToFe
(cڡ * 
pcPamBufr
)

1590 
PARAMETERLIST
 
Li
;

1591 
vcFeName
[50];

1592 
iLgth
;

1593 
FILE
* 

;

1594 
iECou
;

1595 
BYTE
 
bKey
;

1598 
	`kInlizePam
(&
Li
,
pcPamBufr
);

1599 
iLgth
 = 
	`kGNextPam
(&
Li
,
vcFeName
);

1600 
vcFeName
[
iLgth
]='\0';

1601 if((
iLgth
>(
FILESYSTEM_MAXFILENAMELENGTH
-1))||(iLength==0))

1603 
	`kPrtf
("Too Long or Too Short File Name\n");

1608 

 = 
	`fݒ
(
vcFeName
,"w");

1609 if(

==
NULL
)

1611 
	`kPrtf
("%FOFa\n",
vcFeName
);

1616 
iECou
=0;

1619 
bKey
 = 
	`kGCh
();

1621 if(
bKey
==
KEY_ENTER
)

1623 
iECou
++;

1624 if(
iECou
>=3)

1632 
iECou
=0;

1635 
	`kPrtf
("%c",
bKey
);

1636 if(
	`fwre
(&
bKey
,1,1,

)!=1)

1638 
	`kPrtf
("File Write Fail\n");

1643 
	`kPrtf
("File Create Success\n");

1644 
	`fo
(

);

1645 
	}
}

1648 
	$kRdDaFromFe
(cڡ * 
pcPamBufr
)

1650 
PARAMETERLIST
 
Li
;

1651 
vcFeName
[50];

1652 
iLgth
;

1653 
FILE
* 

;

1654 
iECou
;

1655 
BYTE
 
bKey
;

1658 
	`kInlizePam
(&
Li
,
pcPamBufr
);

1659 
iLgth
 = 
	`kGNextPam
(&
Li
,
vcFeName
);

1660 
vcFeName
[
iLgth
]='\0';

1661 if((
iLgth
>(
FILESYSTEM_MAXFILENAMELENGTH
-1))||(iLength==0))

1663 
	`kPrtf
("Too Long or Too Short File Name\n");

1668 

 = 
	`fݒ
(
vcFeName
,"r");

1669 if(

==
NULL
)

1671 
	`kPrtf
("%FOFa\n",
vcFeName
);

1676 
iECou
=0;

1680 if(
	`d
(&
bKey
,1,1,

)!=1)

1685 
	`kPrtf
("%c",
bKey
);

1688 if(
bKey
==
KEY_ENTER
)

1690 
iECou
++;

1692 if((
iECou
!=0)&&((iEnterCount%20)==0))

1694 
	`kPrtf
("Pressny keto continue... ('q' isxit) :");

1695 if(
	`kGCh
()=='q')

1697 
	`kPrtf
("\n");

1700 
	`kPrtf
("\n");

1701 
iECou
=0;

1706 
	`fo
(

);

1707 
	}
}

1710 
	$kTeFeIO
(cڡ * 
pcPamBufr
)

1712 
FILE
* 
pFe
;

1713 
BYTE
* 
pbBufr
;

1714 
i
;

1715 
j
;

1716 
DWORD
 
dwRdomOfft
;

1717 
DWORD
 
dwByCou
;

1718 
BYTE
 
vbTempBufr
[1024];

1719 
DWORD
 
dwMaxFeSize
;

1721 
	`kPrtf
("============================== File I/O Function Test ===============================\n");

1724 
dwMaxFeSize
 = 4*1024*1024;

1725 
pbBufr
 = 
	`kAoMemy
(
dwMaxFeSize
);

1726 if(
pbBufr
==
NULL
)

1728 
	`kPrtf
("Memory Allocation Fail\n");

1733 
	`move
("testfileio.bin");

1738 
	`kPrtf
("1. File Open Fail Test...");

1740 
pFe
 = 
	`fݒ
("testfileio.bin","r");

1741 if(
pFe
==
NULL
)

1743 
	`kPrtf
("[Pass]\n");

1747 
	`kPrtf
("[Fail]\n");

1748 
	`fo
(
pFe
);

1754 
	`kPrtf
("2. File Create Test...");

1756 
pFe
 = 
	`fݒ
("testfileio.bin","w");

1757 if(
pFe
!=
NULL
)

1759 
	`kPrtf
("[Pass]\n");

1760 
	`kPrtf
(" FHd [0x%Q]\n",
pFe
);

1764 
	`kPrtf
("[Fail]\n");

1770 
	`kPrtf
("3. Sequential Write Test(Cluster Size)...");

1772 
i
=0;i<100;i++)

1774 
	`kMemS
(
pbBufr
,
i
,
FILESYSTEM_CLUSTERSIZE
);

1775 if(
	`fwre
(
pbBufr
,1,
FILESYSTEM_CLUSTERSIZE
,
pFe
)!=FILESYSTEM_CLUSTERSIZE)

1777 
	`kPrtf
("[Fail]\n");

1778 
	`kPrtf
(" %d Clu E\n",
i
);

1784 if(
i
>=100)

1786 
	`kPrtf
("[Pass]\n");

1792 
	`kPrtf
("4. Sequential Read And Verify Test(Cluster Size)...");

1794 
	`fek
(
pFe
,-100*
FILESYSTEM_CLUSTERSIZE
,
SEEK_END
);

1797 
i
=0;i<100;i++)

1800 if(
	`d
(
pbBufr
,1,
FILESYSTEM_CLUSTERSIZE
,
pFe
)!=FILESYSTEM_CLUSTERSIZE)

1802 
	`kPrtf
("[Fail]\n");

1807 
j
=0;j<
FILESYSTEM_CLUSTERSIZE
;j++)

1809 if(
pbBufr
[
j
]!=(
BYTE
)
i
)

1811 
	`kPrtf
("[Fail]\n");

1812 
	`kPrtf
(" %d Clu E. [%X] ![%X]\n",
i
,
pbBufr
[
j
],(
BYTE
)i);

1818 if(
i
>=100)

1820 
	`kPrtf
("[Pass]\n");

1826 
	`kPrtf
("5. Random Write Test...\n");

1829 
	`kMemS
(
pbBufr
,0,
dwMaxFeSize
);

1832 
	`fek
(
pFe
,-100*
FILESYSTEM_CLUSTERSIZE
,
SEEK_CUR
);

1833 
	`d
(
pbBufr
,1,
dwMaxFeSize
,
pFe
);

1836 
i
=0;i<100;i++)

1838 
dwByCou
 = (
	`kRdom
()%((
vbTempBufr
)-1))+1;

1839 
dwRdomOfft
 = 
	`kRdom
()%(
dwMaxFeSize
-
dwByCou
);

1841 
	`kPrtf
(" [%d] Off[%d] By [%d]...",
i
,
dwRdomOfft
,
dwByCou
);

1844 
	`fek
(
pFe
,
dwRdomOfft
,
SEEK_SET
);

1845 
	`kMemS
(
vbTempBufr
,
i
,
dwByCou
);

1848 if(
	`fwre
(
vbTempBufr
,1,
dwByCou
,
pFe
)!=dwByteCount)

1850 
	`kPrtf
("[Fail]\n");

1855 
	`kPrtf
("[Pass]\n");

1858 
	`kMemS
(
pbBufr
+
dwRdomOfft
,
i
,
dwByCou
);

1862 
	`fek
(
pFe
,
dwMaxFeSize
-1,
SEEK_SET
);

1863 
	`fwre
(&
i
,1,1,
pFe
);

1864 
pbBufr
[
dwMaxFeSize
-1]=(
BYTE
)
i
;

1870 
	`kPrtf
("6. Random Read And Verify Test...\n");

1872 
i
=0;i<100;i++)

1874 
dwByCou
 = (
	`kRdom
()%((
vbTempBufr
)-1))+1;

1875 
dwRdomOfft
 = 
	`kRdom
()%((
dwMaxFeSize
)-
dwByCou
);

1877 
	`kPrtf
(" [%d] Off[%d] By [%d]...",
i
,
dwRdomOfft
,
dwByCou
);

1880 
	`fek
(
pFe
,
dwRdomOfft
,
SEEK_SET
);

1883 if(
	`d
(
vbTempBufr
,1,
dwByCou
,
pFe
)!=dwByteCount)

1885 
	`kPrtf
("[Fail]\n");

1886 
	`kPrtf
(" Rd Fa\n",
dwRdomOfft
);

1891 if(
	`kMemCmp
(
pbBufr
+
dwRdomOfft
,
vbTempBufr
,
dwByCou
)!=0)

1893 
	`kPrtf
("[Fail]\n");

1894 
	`kPrtf
(" Com Fa\n",
dwRdomOfft
);

1898 
	`kPrtf
("[Pass]\n");

1904 
	`kPrtf
("7. Sequential Write, Read And Verify Test(1024 Byte)...\n");

1906 
	`fek
(
pFe
,-
dwMaxFeSize
,
SEEK_CUR
);

1909 
i
=0;i<(2*1024*1024/1024);i++)

1911 
	`kPrtf
(" [%d] Off[%d] By [%d] Wre...",
i
,i*1024,1024);

1914 if(
	`fwre
(
pbBufr
+(
i
*1024),1,1024,
pFe
)!=1024)

1916 
	`kPrtf
("[Fail]\n");

1921 
	`kPrtf
("[Pass]\n");

1926 
	`fek
(
pFe
,-
dwMaxFeSize
,
SEEK_SET
);

1930 
i
=0;i<(
dwMaxFeSize
/1024);i++)

1933 
	`kPrtf
(" [%d] Off[%d] By [%d] Rd And Vify...",
i
,i*1024,1024);

1936 if(
	`d
(
vbTempBufr
,1,1024,
pFe
)!=1024)

1938 
	`kPrtf
("[Fail]\n");

1942 if(
	`kMemCmp
(
pbBufr
+(
i
*1024),
vbTempBufr
,1024)!=0)

1944 
	`kPrtf
("[Fail]\n");

1949 
	`kPrtf
("[Pass]\n");

1956 
	`kPrtf
("8. File Delete Fail Test...");

1958 if(
	`move
("testfileio.bin")!=0)

1960 
	`kPrtf
("[Pass]\n");

1964 
	`kPrtf
("[Fail]\n");

1970 
	`kPrtf
("9. File Close Test...");

1972 if(
	`fo
(
pFe
)==0)

1974 
	`kPrtf
("[Pass]\n");

1978 
	`kPrtf
("[Fail]\n");

1984 
	`kPrtf
("10. File Delete Test...");

1986 if(
	`move
("testfileio.bin")==0)

1988 
	`kPrtf
("[Pass]\n");

1992 
	`kPrtf
("[Fail[\n");

1996 
	`kFeMemy
(
pbBufr
);

1997 
	}
}

2000 
	$kFlushCache
(cڡ * 
pcPamBufr
)

2002 
QWORD
 
qwTickCou
;

2004 
qwTickCou
 = 
	`kGTickCou
();

2005 
	`kPrtf
("Cache Flush...");

2006 if(
	`kFlushFeSyemCache
()==
TRUE
)

2008 
	`kPrtf
("pass\n");

2012 
	`kPrtf
("Fail\n");

2014 
	`kPrtf
("Tٮ Tim%d ms\n",
kGTickCou
-
qwTickCou
);

2015 
	}
}

2018 
	$kDowdFe
(cڡ * 
pcPamBufr
)

2020 
PARAMETERLIST
 
Li
;

2021 
vcFeName
[50];

2022 
iFeNameLgth
;

2023 
DWORD
 
dwDaLgth
;

2024 
FILE
* 

;

2025 
DWORD
 
dwReivedSize
;

2026 
DWORD
 
dwTempSize
;

2027 
BYTE
 
vbDaBufr
[
SERIAL_FIFOMAXSIZE
];

2028 
QWORD
 
qwLaReivedTickCou
;

2031 
	`kInlizePam
(&
Li
,
pcPamBufr
);

2032 
iFeNameLgth
 = 
	`kGNextPam
(&
Li
,
vcFeName
);

2033 
vcFeName
[
iFeNameLgth
]='\0';

2034 if((
iFeNameLgth
>(
FILESYSTEM_MAXFILENAMELENGTH
-1))||(iFileNameLength==0))

2036 
	`kPrtf
("Too Long or Too Short File Name\n");

2037 
	`kPrtf
("ex)download.txt\n");

2042 
	`kCˬSlFIFO
();

2047 
	`kPrtf
("Waiting For Data Length.....");

2048 
dwReivedSize
=0;

2049 
qwLaReivedTickCou
 = 
	`kGTickCou
();

2051 
dwReivedSize
<4)

2054 
dwTempSize
 = 
	`kReiveSlDa
(((
BYTE
*)&
dwDaLgth
)+
dwReivedSize
,4-dwReceivedSize);

2055 
dwReivedSize
 +
dwTempSize
;

2058 if(
dwTempSize
==0)

2060 
	`kS˕
(0);

2063 if((
	`kGTickCou
()-
qwLaReivedTickCou
)>30000)

2065 
	`kPrtf
("Time Out Occur~!!\n");

2071 
qwLaReivedTickCou
 = 
	`kGTickCou
();

2076 
	`kPrtf
("[%d] By\n",
dwDaLgth
);

2079 
	`kSdSlDa
("A",1);

2085 

 = 
	`fݒ
(
vcFeName
,"w");

2086 if(

==
NULL
)

2088 
	`kPrtf
("%FOFa\n",
vcFeName
);

2093 
	`kPrtf
("Data Receive Start: ");

2094 
dwReivedSize
=0;

2095 
qwLaReivedTickCou
 = 
	`kGTickCou
();

2096 
dwReivedSize
!=
dwDaLgth
)

2099 
dwTempSize
 = 
	`kReiveSlDa
(
vbDaBufr
,
SERIAL_FIFOMAXSIZE
);

2100 
dwReivedSize
+=
dwTempSize
;

2103 if(
dwTempSize
!=0)

2107 if(((
dwReivedSize
%
SERIAL_FIFOMAXSIZE
)==0)||((dwReivedSize==
dwDaLgth
)))

2109 
	`kSdSlDa
("A",1);

2110 
	`kPrtf
("#");

2114 if(
	`fwre
(
vbDaBufr
,1,
dwTempSize
,

)!=dwTempSize)

2116 
	`kPrtf
("File Write Error Occur\n");

2121 
qwLaReivedTickCou
 = 
	`kGTickCou
();

2126 
	`kS˕
(0);

2129 if((
	`kGTickCou
()-
qwLaReivedTickCou
)>10000)

2131 
	`kPrtf
("Time Out Occur~!!\n");

2143 if(
dwReivedSize
!=
dwDaLgth
)

2145 
	`kPrtf
("\E Occur. Tٮ Siz[%d] Reived Siz[%d]\n",
dwReivedSize
,
dwDaLgth
);

2149 
	`kPrtf
("\ReivCome. Tٮ Siz[%d] By\n",
dwReivedSize
);

2153 
	`fo
(

);

2154 
	`kFlushFeSyemCache
();

2155 
	}
}

2158 
	$kShowMPCfigutiTab
(cڡ * 
pcPamBufr
)

2160 
	`kPrtMPCfigutiTab
();

2161 
	}
}

2164 
	$kSAlitiPross
(cڡ * 
pcPamBufr
)

2167 if(
	`kSUpAlitiPross
()==
FALSE
)

2169 
	`kPrtf
("Application Processor Start Fail\n");

2173 
	`kPrtf
("Applicaton Processor Start Success\n");

2176 
	`kPrtf
("Bo١Pross[APIC ID: %d] S Aliti Pross\n",
	`kGAPICID
());

2177 
	}
}

	@/home/jk/os/MINT64/save/02.Kernel64/Source/ConsoleShell.h

1 #ide
__CONSOLESHELL_H__


2 
	#__CONSOLESHELL_H__


	)

4 
	~"Tys.h
"

7 
	#CONSOLESHELL_MAXCOMMANDBUFFERCOUNT
 300

	)

8 
	#CONSOLESHELL_PROMPRTMESSAGE
 "jk64>"

	)

11 (*
	tCommdFuni
)(cڡ * 
	tpcPam
);

15 #agm
	`ck
(
push
,1)

18 
	skShlCommdEryru


21 * 
pcCommd
;

23 * 
pcHp
;

25 
CommdFuni
 
pfFuni
;

26 } 
	tSHELLCOMMANDENTRY
;

29 
	skPamLiSu


32 cڡ * 
pcBufr
;

34 
iLgth
;

36 
iCutPosi
;

37 } 
	tPARAMETERLIST
;

39 #agm
	`ck
(
p
)

43 
	`kSCseShl
();

44 
	`kExecuCommd
(cڡ * 
pcCommdBufr
);

45 
	`kInlizePam
(
PARAMETERLIST
* 
pLi
,cڡ * 
pcPam
);

46 
	`kGNextPam
(
PARAMETERLIST
* 
pLi
,* 
pcPam
);

	@/home/jk/os/MINT64/save/02.Kernel64/Source/Descriptor.c

1 
	~"Dest.h
"

2 
	~"Uty.h
"

3 
	~"ISR.h
"

4 
	~"MuiPross.h
"

11 
	$kInlizeGDTTabAndTSS
 ()

13 
GDTR
* 
pGDTR
;

14 
GDTENTRY8
* 
pEry
;

15 
TSSSEGMENT
* 
pTSS
;

16 
i
;

19 
pGDTR
 = (
GDTR
*)
GDTR_STARTADDRESS
;

20 
pEry
 = (
GDTENTRY8
*)(
GDTR_STARTADDRESS
+(
GDTR
));

21 
pGDTR
->
wLim
 = 
GDT_TABLESIZE
-1;

22 
pGDTR
->
qwBaAddss
 = (
QWORD
)
pEry
;

25 
pTSS
 = (
TSSSEGMENT
*)((
QWORD
)
pEry
+
GDT_TABLESIZE
);

28 
	`kSGDTEry8
(&(
pEry
[0]),0,0,0,0,0);

29 
	`kSGDTEry8
(&(
pEry
[1]),0,0xFFFFF,
GDT_FLAGS_UPPER_CODE
,
GDT_FLAGS_LOWER_KERNELCODE
,
GDT_TYPE_CODE
);

30 
	`kSGDTEry8
(&(
pEry
[2]),0,0xFFFFF,
GDT_FLAGS_UPPER_DATA
,
GDT_FLAGS_LOWER_KERNELDATA
,
GDT_TYPE_DATA
);

33 
i
=0;i<
MAXPROCESSORCOUNT
;i++)

37 
	`kSGDTEry16
((
GDTENTRY16
*)&(
pEry
[
GDT_MAXENTRY8COUNT
+(
i
*2)]),(
QWORD
)
pTSS
+(i*(
TSSSEGMENT
)),(TSSSEGMENT)-1,
GDT_FLAGS_UPPER_TSS
,
GDT_FLAGS_LOWER_TSS
,
GDT_TYPE_TSS
);

42 
	`kInlizeTSSSegmt
(
pTSS
);

43 
	}
}

47 
	$kSGDTEry8
(
GDTENTRY8
* 
pEry
,
DWORD
 
dwBaAddss
,DWORD 
dwLim
,
BYTE
 
bUFgs
,BYTE 
bLowFgs
,BYTE 
bTy
)

49 
pEry
->
wLowLim
=
dwLim
&0xFFFF;

50 
pEry
->
wLowBaAddss
 = 
dwBaAddss
&0xFFFF;

51 
pEry
->
bUBaAddss1
 = (
dwBaAddss
>>16)&0xFF;

52 
pEry
->
bTyAndLowFg
 = 
bLowFgs
 | 
bTy
;

53 
pEry
->
bULimAndUFg
 = ((
dwLim
>>16)&0xFF)|
bUFgs
;

54 
pEry
->
bUBaAddss2
 = (
dwBaAddss
>>24)&0xFF;

55 
	}
}

59 
	$kSGDTEry16
(
GDTENTRY16
* 
pEry
,
QWORD
 
qwBaAddss
,
DWORD
 
dwLim
,
BYTE
 
bUFgs
,BYTE 
bLowFgs
,BYTE 
bTy
)

61 
pEry
->
wLowLim
 = 
dwLim
&0xFFFF;

62 
pEry
->
wLowBaAddss
 = 
qwBaAddss
&0xFFFF;

63 
pEry
->
bMiddBaAddss1
 = (
qwBaAddss
>>16)&0xFF;

64 
pEry
->
bTyAndLowFg
 = 
bLowFgs
 | 
bTy
;

65 
pEry
->
bULimAndUFg
 = ((
dwLim
>>16)&&0xFF)|
bUFgs
;

66 
pEry
->
bMiddBaAddss2
 = (
qwBaAddss
>>24)&0xFF;

67 
pEry
->
dwUBaAddss
 = 
qwBaAddss
 >> 32;

68 
pEry
->
dwRerved
=0;

69 
	}
}

72 
	$kInlizeTSSSegmt
(
TSSSEGMENT
* 
pTSS
)

74 
i
;

77 
i
=0;i<
MAXPROCESSORCOUNT
;i++)

80 
	`kMemS
(
pTSS
,0,(
TSSSEGMENT
));

83 
pTSS
->
qwIST
[0] = 
IST_STARTADDRESS
 + 
IST_SIZE
 - (IST_SIZE/
MAXPROCESSORCOUNT
*
i
);

87 
pTSS
->
wIOMBaAddss
 = 0xFFFF;

90 
pTSS
++;

93 
	}
}

100 
	$kInlizeIDTTabs
()

102 
IDTR
* 
pIDTR
;

103 
IDTENTRY
* 
pEry
;

104 
i
;

107 
pIDTR
 = (
IDTR
*)
IDTR_STARTADDRESS
;

109 
pEry
 = (
IDTENTRY
*)(
IDTR_STARTADDRESS
+(
IDTR
));

110 
pIDTR
->
qwBaAddss
 = (
QWORD
)
pEry
;

111 
pIDTR
->
wLim
 = 
IDT_TABLESIZE
-1;

116 
	`kSIDTEry
&
pEry
[ 0 ] ), 
kISRDivideE
, 0x08, 
IDT_FLAGS_IST1
,

117 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

118 
	`kSIDTEry
&
pEry
[ 1 ] ), 
kISRDebug
, 0x08, 
IDT_FLAGS_IST1
,

119 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

120 
	`kSIDTEry
&
pEry
[ 2 ] ), 
kISRNMI
, 0x08, 
IDT_FLAGS_IST1
,

121 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

122 
	`kSIDTEry
&
pEry
[ 3 ] ), 
kISRBakPot
, 0x08, 
IDT_FLAGS_IST1
,

123 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

124 
	`kSIDTEry
&
pEry
[ 4 ] ), 
kISROvow
, 0x08, 
IDT_FLAGS_IST1
,

125 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

126 
	`kSIDTEry
&
pEry
[ 5 ] ), 
kISRBoundRgeExeded
, 0x08, 
IDT_FLAGS_IST1
,

127 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

128 
	`kSIDTEry
&
pEry
[ 6 ] ), 
kISRInvidOpcode
, 0x08, 
IDT_FLAGS_IST1
,

129 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

130 
	`kSIDTEry
&
pEry
[ 7 ] ), 
kISRDeviNAvaab
, 0x08, 
IDT_FLAGS_IST1
,

131 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

132 
	`kSIDTEry
&
pEry
[ 8 ] ), 
kISRDoubFau
, 0x08, 
IDT_FLAGS_IST1
,

133 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

134 
	`kSIDTEry
&
pEry
[ 9 ] ), 
kISRCrossSegmtOvrun
, 0x08, 
IDT_FLAGS_IST1
,

135 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

136 
	`kSIDTEry
&
pEry
[ 10 ] ), 
kISRInvidTSS
, 0x08, 
IDT_FLAGS_IST1
,

137 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

138 
	`kSIDTEry
&
pEry
[ 11 ] ), 
kISRSegmtNP
, 0x08, 
IDT_FLAGS_IST1
,

139 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

140 
	`kSIDTEry
&
pEry
[ 12 ] ), 
kISRSckSegmtFau
, 0x08, 
IDT_FLAGS_IST1
,

141 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

142 
	`kSIDTEry
&
pEry
[ 13 ] ), 
kISRGPrei
, 0x08, 
IDT_FLAGS_IST1
,

143 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

144 
	`kSIDTEry
&
pEry
[ 14 ] ), 
kISRPageFau
, 0x08, 
IDT_FLAGS_IST1
,

145 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

146 
	`kSIDTEry
&
pEry
[ 15 ] ), 
kISR15
, 0x08, 
IDT_FLAGS_IST1
,

147 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

148 
	`kSIDTEry
&
pEry
[ 16 ] ), 
kISRFPUE
, 0x08, 
IDT_FLAGS_IST1
,

149 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

150 
	`kSIDTEry
&
pEry
[ 17 ] ), 
kISRAlignmtCheck
, 0x08, 
IDT_FLAGS_IST1
,

151 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

152 
	`kSIDTEry
&
pEry
[ 18 ] ), 
kISRMacheCheck
, 0x08, 
IDT_FLAGS_IST1
,

153 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

154 
	`kSIDTEry
&
pEry
[ 19 ] ), 
kISRSIMDE
, 0x08, 
IDT_FLAGS_IST1
,

155 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

156 
	`kSIDTEry
&
pEry
[ 20 ] ), 
kISRETCExi
, 0x08, 
IDT_FLAGS_IST1
,

157 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

159  
i
 = 21 ; i < 32 ; i++ )

161 
	`kSIDTEry
&
pEry
[ 
i
 ] ), 
kISRETCExi
, 0x08, 
IDT_FLAGS_IST1
,

162 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

167 
	`kSIDTEry
&
pEry
[ 32 ] ), 
kISRTim
, 0x08, 
IDT_FLAGS_IST1
,

168 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

169 
	`kSIDTEry
&
pEry
[ 33 ] ), 
kISRKeybrd
, 0x08, 
IDT_FLAGS_IST1
,

170 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

171 
	`kSIDTEry
&
pEry
[ 34 ] ), 
kISRSvePIC
, 0x08, 
IDT_FLAGS_IST1
,

172 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

173 
	`kSIDTEry
&
pEry
[ 35 ] ), 
kISRSl2
, 0x08, 
IDT_FLAGS_IST1
,

174 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

175 
	`kSIDTEry
&
pEry
[ 36 ] ), 
kISRSl1
, 0x08, 
IDT_FLAGS_IST1
,

176 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

177 
	`kSIDTEry
&
pEry
[ 37 ] ), 
kISRPl2
, 0x08, 
IDT_FLAGS_IST1
,

178 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

179 
	`kSIDTEry
&
pEry
[ 38 ] ), 
kISRFlpy
, 0x08, 
IDT_FLAGS_IST1
,

180 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

181 
	`kSIDTEry
&
pEry
[ 39 ] ), 
kISRPl1
, 0x08, 
IDT_FLAGS_IST1
,

182 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

183 
	`kSIDTEry
&
pEry
[ 40 ] ), 
kISRRTC
, 0x08, 
IDT_FLAGS_IST1
,

184 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

185 
	`kSIDTEry
&
pEry
[ 41 ] ), 
kISRRerved
, 0x08, 
IDT_FLAGS_IST1
,

186 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

187 
	`kSIDTEry
&
pEry
[ 42 ] ), 
kISRNUd1
, 0x08, 
IDT_FLAGS_IST1
,

188 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

189 
	`kSIDTEry
&
pEry
[ 43 ] ), 
kISRNUd2
, 0x08, 
IDT_FLAGS_IST1
,

190 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

191 
	`kSIDTEry
&
pEry
[ 44 ] ), 
kISRMou
, 0x08, 
IDT_FLAGS_IST1
,

192 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

193 
	`kSIDTEry
&
pEry
[ 45 ] ), 
kISRCross
, 0x08, 
IDT_FLAGS_IST1
,

194 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

195 
	`kSIDTEry
&
pEry
[ 46 ] ), 
kISRHDD1
, 0x08, 
IDT_FLAGS_IST1
,

196 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

197 
	`kSIDTEry
&
pEry
[ 47 ] ), 
kISRHDD2
, 0x08, 
IDT_FLAGS_IST1
,

198 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

200  
i
 = 48 ; i < 
IDT_MAXENTRYCOUNT
 ; i++ )

202 
	`kSIDTEry
&
pEry
[ 
i
 ] ), 
kISRETCIru
, 0x08, 
IDT_FLAGS_IST1
,

203 
IDT_FLAGS_KERNEL
, 
IDT_TYPE_INTERRUPT
 );

206 
	}
}

209 
	$kSIDTEry
(
IDTENTRY
* 
pEry
,* 
pvHdr
,
WORD
 
wSe
,
BYTE
 
bIST
,BYTE 
bFgs
,BYTE 
bTy
)

211 
pEry
->
wLowBaAddss
 = (
QWORD
)
pvHdr
&0xFFFF;

212 
pEry
->
wSegmtSe
 = 
wSe
;

213 
pEry
->
bIST
 = bIST&0x3;

214 
pEry
->
bTyAndFgs
 = 
bTy
|
bFgs
;

215 
pEry
->
wMiddBaAddss
=((
QWORD
)
pvHdr
>>16)&0xFFFF;

216 
pEry
->
dwUBaAddss
=(
QWORD
)
pvHdr
>>32;

217 
pEry
->
dwRerved
=0;

218 
	}
}

	@/home/jk/os/MINT64/save/02.Kernel64/Source/Descriptor.h

1 #ide
__DESCRIPTOR_H__


2 
	#__DESCRIPTOR_H__


	)

4 
	~"Tys.h
"

5 
	~"MuiPross.h
"

12 
	#GDT_TYPE_CODE
 0x0A

	)

13 
	#GDT_TYPE_DATA
 0x02

	)

14 
	#GDT_TYPE_TSS
 0x09

	)

15 
	#GDT_FLAGS_LOWER_S
 0x10

	)

16 
	#GDT_FLAGS_LOWER_DPL0
 0x00

	)

17 
	#GDT_FLAGS_LOWER_DPL1
 0x20

	)

18 
	#GDT_FLAGS_LOWER_DPL2
 0x40

	)

19 
	#GDT_FLAGS_LOWER_DPL3
 0x60

	)

20 
	#GDT_FLAGS_LOWER_P
 0x80

	)

21 
	#GDT_FLAGS_UPPER_L
 0x20

	)

22 
	#GDT_FLAGS_UPPER_DB
 0x40

	)

23 
	#GDT_FLAGS_UPPER_G
 0x80

	)

27 
	#GDT_FLAGS_LOWER_KERNELCODE
 (
GDT_TYPE_CODE
 | 
GDT_FLAGS_LOWER_S
 | 
GDT_FLAGS_LOWER_DPL0
 | 
GDT_FLAGS_LOWER_P
)

	)

28 
	#GDT_FLAGS_LOWER_KERNELDATA
 (
GDT_TYPE_DATA
 | 
GDT_FLAGS_LOWER_S
 | 
GDT_FLAGS_LOWER_DPL0
 | 
GDT_FLAGS_LOWER_P
)

	)

29 
	#GDT_FLAGS_LOWER_TSS
 (
GDT_FLAGS_LOWER_DPL0
 | 
GDT_FLAGS_LOWER_P
)

	)

30 
	#GDT_FLAGS_LOWER_USERCODE
 (
GDT_TYPE_CODE
 | 
GDT_FLAGS_LOWER_S
 | 
GDT_FLAGS_LOWER_DPL3
 | 
GDT_FLAGS_LOWER_P
)

	)

31 
	#GDT_FLAGS_LOWER_USERDATA
 (
GDT_TYPE_DATA
 | 
GDT_FLAGS_LOWER_S
 | 
GDT_FLAGS_LOWER_DPL3
 | 
GDT_FLAGS_LOWER_P
)

	)

34 
	#GDT_FLAGS_UPPER_CODE
 (
GDT_FLAGS_UPPER_G
 | 
GDT_FLAGS_UPPER_L
)

	)

35 
	#GDT_FLAGS_UPPER_DATA
 (
GDT_FLAGS_UPPER_G
 | 
GDT_FLAGS_UPPER_L
)

	)

36 
	#GDT_FLAGS_UPPER_TSS
 (
GDT_FLAGS_UPPER_G
)

	)

39 
	#GDT_KERNELCODESEGMENT
 0x08

	)

40 
	#GDT_KERNELDATASEGMENT
 0x10

	)

41 
	#GDT_TSSSEGMENT
 0x18

	)

45 
	#GDTR_STARTADDRESS
 0x142000

	)

47 
	#GDT_MAXENTRY8COUNT
 3

	)

49 
	#GDT_MAXENTRY16COUNT
 (
MAXPROCESSORCOUNT
)

	)

51 
	#GDT_TABLESIZE
 (((
GDTENTRY8
)*
GDT_MAXENTRY8COUNT
+ ((
GDTENTRY16
)*
GDT_MAXENTRY16COUNT
))

	)

52 
	#TSS_SEGMENTSIZE
 ((
TSSSEGMENT
)*
MAXPROCESSORCOUNT
)

	)

59 
	#IDT_TYPE_INTERRUPT
 0x0E

	)

60 
	#IDT_TYPE_TRAP
 0x0F

	)

61 
	#IDT_FLAGS_DPL0
 0x00

	)

62 
	#IDT_FLAGS_DPL1
 0x20

	)

63 
	#IDT_FLAGS_DPL2
 0x40

	)

64 
	#IDT_FLAGS_DPL3
 0x60

	)

65 
	#IDT_FLAGS_P
 0x80

	)

66 
	#IDT_FLAGS_IST0
 0

	)

67 
	#IDT_FLAGS_IST1
 1

	)

71 
	#IDT_FLAGS_KERNEL
 (
IDT_FLAGS_DPL0
 | 
IDT_FLAGS_P
)

	)

72 
	#IDT_FLAGS_USER
 (
IDT_FLAGS_DPL3
 | 
IDT_FLAGS_P
)

	)

76 
	#IDT_MAXENTRYCOUNT
 100

	)

78 
	#IDTR_STARTADDRESS
 (
GDTR_STARTADDRESS
+(
GDTR
)+
GDT_TABLESIZE
+
TSS_SEGMENTSIZE
)

	)

80 
	#IDT_STARTADDRESS
 (
IDTR_STARTADDRESS
+(
IDTR
))

	)

82 
	#IDT_TABLESIZE
 (
IDT_MAXENTRYCOUNT
*(
IDTENTRY
))

	)

86 
	#IST_STARTADDRESS
 0x700000

	)

88 
	#IST_SIZE
 0x100000

	)

92 #agm
ck
(
push
,1)

95 
	skGDTRSu


97 
WORD
 
	mwLim
;

98 
QWORD
 
	mqwBaAddss
;

100 
WORD
 
	mwPadg
;

101 
DWORD
 
	mdwPadg
;

102 } 
	tGDTR
,
	tIDTR
;

105 
	skGDTEry8Su


107 
WORD
 
	mwLowLim
;

108 
WORD
 
	mwLowBaAddss
;

109 
BYTE
 
	mbUBaAddss1
;

111 
BYTE
 
	mbTyAndLowFg
;

113 
BYTE
 
	mbULimAndUFg
;

114 
BYTE
 
	mbUBaAddss2
;

115 } 
	tGDTENTRY8
;

118 
	skGDTEry16ru


120 
WORD
 
	mwLowLim
;

121 
WORD
 
	mwLowBaAddss
;

122 
BYTE
 
	mbMiddBaAddss1
;

124 
BYTE
 
	mbTyAndLowFg
;

126 
BYTE
 
	mbULimAndUFg
;

127 
BYTE
 
	mbMiddBaAddss2
;

128 
DWORD
 
	mdwUBaAddss
;

129 
DWORD
 
	mdwRerved
;

130 } 
	tGDTENTRY16
;

133 
	skTSSDaSu


135 
DWORD
 
	mdwRerved1
;

136 
QWORD
 
	mqwR
[3];

137 
QWORD
 
	mqwRerved2
;

138 
QWORD
 
	mqwIST
[7];

139 
QWORD
 
	mqwRerved3
;

140 
WORD
 
	mwRerved
;

141 
WORD
 
	mwIOMBaAddss
;

142 } 
	tTSSSEGMENT
;

145 
	skIDTErySu


147 
WORD
 
	mwLowBaAddss
;

148 
WORD
 
	mwSegmtSe
;

150 
BYTE
 
	mbIST
;

152 
BYTE
 
	mbTyAndFgs
;

153 
WORD
 
	mwMiddBaAddss
;

154 
DWORD
 
	mdwUBaAddss
;

155 
DWORD
 
	mdwRerved
;

156 } 
	tIDTENTRY
;

158 #agm
ck
(
p
)

161 
kInlizeGDTTabAndTSS
 ();

162 
kSGDTEry8
 (
GDTENTRY8
* 
pEry
,
DWORD
 
dwBaAddss
,DWORD 
dwLim
,
BYTE
 
bUFgs
,BYTE 
bLowFgs
,BYTE 
bTy
);

163 
kSGDTEry16
 (
GDTENTRY16
* 
pEry
,
QWORD
 
qwBaAddss
,
DWORD
 
dwLim
,
BYTE
 
bUFgs
,BYTE 
bLowFgs
,BYTE 
bTy
);

164 
kInlizeTSSSegmt
 (
TSSSEGMENT
* 
pTSS
);

166 
kInlizeIDTTabs
 ();

167 
kSIDTEry
(
IDTENTRY
* 
pEry
,* 
pvHdr
,
WORD
 
wSe
,
BYTE
 
bIST
,BYTE 
bFgs
,BYTE 
bTy
);

168 
kDummyHdr
 ();

	@/home/jk/os/MINT64/save/02.Kernel64/Source/DynamicMemory.c

1 
	~"DymicMemy.h
"

2 
	~"Uty.h
"

3 
	~"Task.h
"

5 
DYNAMICMEMORY
 
	ggs_DymicMemy
;

8 
QWORD
 
kCcuϋDymicMemySize
();

9 
kCcuϋMaBlockCou
(
QWORD
 
qwDymicRAMSize
);

10 
kAotiBuddyBlock
(
QWORD
 
qwAligdSize
);

11 
QWORD
 
kGBuddyBlockSize
(QWORD 
qwSize
);

12 
kGBlockLiIndexOfMchSize
(
QWORD
 
qwAligdSize
);

13 
kFdFeBlockInBm
(
iBlockLiIndex
);

14 
kSFgInBm
(
iBlockLiIndex
,
iOfft
,
BYTE
 
bFg
);

15 
BOOL
 
kFeBuddyBlock
(
iBlockLiIndex
,
iBlockOfft
);

16 
BYTE
 
kGFgInBm
(
iBlockLiIndex
,
iOfft
);

23 
	$kInlizeDymicMemy
()

25 
QWORD
 
qwDymicMemySize
;

26 
i
,
j
;

27 
BYTE
* 
pbCutBmPosi
;

28 
iBlockCouOfLev
, 
iMaBlockCoou
;

32 
qwDymicMemySize
 = 
	`kCcuϋDymicMemySize
();

33 
iMaBlockCoou
 = 
	`kCcuϋMaBlockCou
(
qwDymicMemySize
);

37 
gs_DymicMemy
.
iBlockCouOfSmˡBlock
 = (
qwDymicMemySize
/
DYNAMICMEMORY_MIN_SIZE
)-
iMaBlockCoou
;

40 
i
=0;(
gs_DymicMemy
.
iBlockCouOfSmˡBlock
>>i)>0;i++)

44 
gs_DymicMemy
.
iMaxLevCou
=
i
;

47 
gs_DymicMemy
.
pbAodBlockLiIndex
 = (
BYTE
*)
DYNAMICMEMORY_START_ADDRESS
;

48 
i
=0;i<
gs_DymicMemy
.
iBlockCouOfSmˡBlock
;i++)

50 
gs_DymicMemy
.
pbAodBlockLiIndex
[
i
]=0xFF;

54 
gs_DymicMemy
.
pBmOfLev
 = (
BITMAP
*)(
DYNAMICMEMORY_START_ADDRESS
+((
BYTE
)*gs_DymicMemy.
iBlockCouOfSmˡBlock
));

56 
pbCutBmPosi
 = ((
BYTE
*)
gs_DymicMemy
.
pBmOfLev
)+((
BITMAP
)*gs_DymicMemy.
iMaxLevCou
);

60 
j
=0;j<
gs_DymicMemy
.
iMaxLevCou
;j++)

62 
gs_DymicMemy
.
pBmOfLev
[
j
].
pbBm
 = 
pbCutBmPosi
;

63 
gs_DymicMemy
.
pBmOfLev
[
j
].
qwExiBCou
 = 0;

64 
iBlockCouOfLev
 = 
gs_DymicMemy
.
iBlockCouOfSmˡBlock
>>
j
;

68 
i
=0;i<
iBlockCouOfLev
/8;i++)

70 *
pbCutBmPosi
 = 0x00;

71 
pbCutBmPosi
++;

75 if((
iBlockCouOfLev
%8)!=0)

77 *
pbCutBmPosi
=0x00;

80 
i
 = 
iBlockCouOfLev
%8;

81 if((
i
%2)==1)

83 *
pbCutBmPosi
 |=(
DYNAMICMEMORY_EXIST
<<(
i
-1));

84 
gs_DymicMemy
.
pBmOfLev
[
j
].
qwExiBCou
=1;

86 
pbCutBmPosi
++;

91 
gs_DymicMemy
.
qwSAddss
 = 
DYNAMICMEMORY_START_ADDRESS
+
iMaBlockCoou
*
DYNAMICMEMORY_MIN_SIZE
;

92 
gs_DymicMemy
.
qwEndAddss
 = 
	`kCcuϋDymicMemySize
()+
DYNAMICMEMORY_START_ADDRESS
;

93 
gs_DymicMemy
.
qwUdSize
=0;

94 
	}
}

97 
QWORD
 
	$kCcuϋDymicMemySize
()

99 
QWORD
 
qwRAMSize
;

102 
qwRAMSize
 = (
	`kGTٮRAMSize
()*1024*1024);

103 if(
qwRAMSize
>(
QWORD
)3*1024*1024*1024)

105 
qwRAMSize
 = (
QWORD
)3*1024*1024*1024;

108  
qwRAMSize
 - 
DYNAMICMEMORY_START_ADDRESS
;

109 
	}
}

113 
	$kCcuϋMaBlockCou
(
QWORD
 
qwDymicRAMSize
)

115 
lBlockCouOfSmˡBlock
;

116 
DWORD
 
dwSizeOfAodBlockLiIndex
;

117 
DWORD
 
dwSizeOfBm
;

118 
i
;

121 
lBlockCouOfSmˡBlock
 = 
qwDymicRAMSize
/
DYNAMICMEMORY_MIN_SIZE
;

123 
dwSizeOfAodBlockLiIndex
 = 
lBlockCouOfSmˡBlock
*(
BYTE
);

126 
dwSizeOfBm
=0;

127 
i
=0;(
lBlockCouOfSmˡBlock
>>i)>0;i++)

130 
dwSizeOfBm
 +=(
BITMAP
);

132 
dwSizeOfBm
 +=((
lBlockCouOfSmˡBlock
>>
i
)+7)/8;

136  (
dwSizeOfAodBlockLiIndex
+
dwSizeOfBm
+
DYNAMICMEMORY_MIN_SIZE
-1)/DYNAMICMEMORY_MIN_SIZE;

137 
	}
}

140 * 
	$kAoMemy
(
QWORD
 
qwSize
)

142 
QWORD
 
qwAligdSize
;

143 
QWORD
 
qwRiveAddss
;

144 
lOfft
;

145 
iSizeAayOfft
;

146 
iIndexOfBlockLi
;

149 
qwAligdSize
 = 
	`kGBuddyBlockSize
(
qwSize
);

150 if(
qwAligdSize
 == 0)

153  
NULL
;

157 if(
gs_DymicMemy
.
qwSAddss
+gs_DymicMemy.
qwUdSize
+
qwAligdSize
>gs_DymicMemy.
qwEndAddss
)

160  
NULL
;

164 
lOfft
 = 
	`kAotiBuddyBlock
(
qwAligdSize
);

165 if(
lOfft
==-1)

168  
NULL
;

171 
iIndexOfBlockLi
 = 
	`kGBlockLiIndexOfMchSize
(
qwAligdSize
);

175 
qwRiveAddss
 = 
qwAligdSize
*
lOfft
;

176 
iSizeAayOfft
 = 
qwRiveAddss
/
DYNAMICMEMORY_MIN_SIZE
;

177 
gs_DymicMemy
.
pbAodBlockLiIndex
[
iSizeAayOfft
] = (
BYTE
)
iIndexOfBlockLi
;

178 
gs_DymicMemy
.
qwUdSize
 +=
qwAligdSize
;

180  (*)(
qwRiveAddss
+
gs_DymicMemy
.
qwSAddss
);

181 
	}
}

184 
QWORD
 
	$kGBuddyBlockSize
(
QWORD
 
qwSize
)

186 
i
;

188 
i
=0;i<
gs_DymicMemy
.
iMaxLevCou
;i++)

190 if(
qwSize
<=(
DYNAMICMEMORY_MIN_SIZE
<<
i
))

192  (
DYNAMICMEMORY_MIN_SIZE
<<
i
);

197 
	}
}

201 
	$kAotiBuddyBlock
(
QWORD
 
qwAligdSize
)

203 
iBlockLiIndex
,
iFeOfft
;

204 
i
;

205 
BOOL
 
bPviousIruFg
;

208 
iBlockLiIndex
 = 
	`kGBlockLiIndexOfMchSize
(
qwAligdSize
);

209 if(
iBlockLiIndex
==-1)

216 
bPviousIruFg
 = 
	`kLockFSyemDa
();

219 
i
=
iBlockLiIndex
;i<
gs_DymicMemy
.
iMaxLevCou
;i++)

222 
iFeOfft
 = 
	`kFdFeBlockInBm
(
i
);

223 if(
iFeOfft
!=-1)

230 if(
iFeOfft
==-1)

233 
	`kUockFSyemDa
(
bPviousIruFg
);

238 
	`kSFgInBm
(
i
,
iFeOfft
,
DYNAMICMEMORY_EMPTY
);

241 if(
i
>
iBlockLiIndex
)

245 
i
=i-1;i>=
iBlockLiIndex
;i--)

248 
	`kSFgInBm
(
i
,
iFeOfft
*2,
DYNAMICMEMORY_EMPTY
);

250 
	`kSFgInBm
(
i
,
iFeOfft
*2+1,
DYNAMICMEMORY_EXIST
);

252 
iFeOfft
 = iFreeOffset*2;

255 
	`kUockFSyemDa
(
bPviousIruFg
);

257  
iFeOfft
;

258 
	}
}

261 
	$kGBlockLiIndexOfMchSize
(
QWORD
 
qwAligdSize
)

263 
i
;

265 
i
=0;i<
gs_DymicMemy
.
iMaxLevCou
;i++)

267 if(
qwAligdSize
<=(
DYNAMICMEMORY_MIN_SIZE
<<
i
))

269  
i
;

273 
	}
}

276 
	$kFdFeBlockInBm
(
iBlockLiIndex
)

278 
i
,
iMaxCou
;

279 
BYTE
* 
pbBm
;

280 
QWORD
* 
pqwBm
;

283 if(
gs_DymicMemy
.
pBmOfLev
[
iBlockLiIndex
].
qwExiBCou
==0)

289 
iMaxCou
 = 
gs_DymicMemy
.
iBlockCouOfSmˡBlock
>>
iBlockLiIndex
;

290 
pbBm
 = 
gs_DymicMemy
.
pBmOfLev
[
iBlockLiIndex
].pbBitmap;

291 
i
=0;i<
iMaxCou
;)

294 if(((
iMaxCou
-
i
)/64)>0)

296 
pqwBm
 =(
QWORD
*)&(
pbBm
[
i
/8]);

298 if(*
pqwBm
==0)

300 
i
+=64;

305 if((
pbBm
[
i
/8]&(
DYNAMICMEMORY_EXIST
<<(i%8)))!=0)

307  
i
;

309 
i
++;

313 
	}
}

316 
	$kSFgInBm
(
iBlockLiIndex
,
iOfft
,
BYTE
 
bFg
)

318 
BYTE
* 
pbBm
;

319 
pbBm
 = 
gs_DymicMemy
.
pBmOfLev
[
iBlockLiIndex
].pbBitmap;

321 if(
bFg
==
DYNAMICMEMORY_EXIST
)

324 if((
pbBm
[
iOfft
/8]&(0x01<<(iOffset%8)))==0)

326 
gs_DymicMemy
.
pBmOfLev
[
iBlockLiIndex
].
qwExiBCou
++;

328 
pbBm
[
iOfft
/8]|=(0x01<<(iOffset%8));

333 if((
pbBm
[
iOfft
/8]&(0x01<<(iOffset%8)))!=0)

335 
gs_DymicMemy
.
pBmOfLev
[
iBlockLiIndex
].
qwExiBCou
--;

337 
pbBm
[
iOfft
/8]&=~(0x01<<(iOffset%8));

339 
	}
}

342 
BOOL
 
	$kFeMemy
(* 
pvAddss
)

344 
QWORD
 
qwRiveAddss
;

345 
iSizeAayOfft
;

346 
QWORD
 
qwBlockSize
;

347 
iBlockLiIndex
;

348 
iBmOfft
;

350 if(
pvAddss
==
NULL
)

352  
FALSE
;

356 
qwRiveAddss
 = ((
QWORD
)
pvAddss
)-
gs_DymicMemy
.
qwSAddss
;

357 
iSizeAayOfft
 = 
qwRiveAddss
/
DYNAMICMEMORY_MIN_SIZE
;

360 if(
gs_DymicMemy
.
pbAodBlockLiIndex
[
iSizeAayOfft
]==0xFF)

362  
FALSE
;

367 
iBlockLiIndex
 = ()
gs_DymicMemy
.
pbAodBlockLiIndex
[
iSizeAayOfft
];

368 
gs_DymicMemy
.
pbAodBlockLiIndex
[
iSizeAayOfft
]=0xFF;

370 
qwBlockSize
 = 
DYNAMICMEMORY_MIN_SIZE
<<
iBlockLiIndex
;

373 
iBmOfft
 = 
qwRiveAddss
/
qwBlockSize
;

374 if(
	`kFeBuddyBlock
(
iBlockLiIndex
,
iBmOfft
)==
TRUE
)

376 
gs_DymicMemy
.
qwUdSize
 -
qwBlockSize
;

377  
TRUE
;

380  
FALSE
;

381 
	}
}

384 
BOOL
 
	$kFeBuddyBlock
(
iBlockLiIndex
,
iBlockOfft
)

386 
iBuddyBlockOfft
;

387 
i
;

388 
BOOL
 
bFg
;

389 
BOOL
 
bPviousIruFg
;

392 
bPviousIruFg
 = 
	`kLockFSyemDa
();

395 
i
=
iBlockLiIndex
;i<
gs_DymicMemy
.
iMaxLevCou
;i++)

398 
	`kSFgInBm
(
i
,
iBlockOfft
,
DYNAMICMEMORY_EXIST
);

402 if((
iBlockOfft
%2)==0)

404 
iBuddyBlockOfft
 = 
iBlockOfft
+1;

408 
iBuddyBlockOfft
 = 
iBlockOfft
-1;

411 
bFg
 = 
	`kGFgInBm
(
i
,
iBuddyBlockOfft
);

414 if(
bFg
 =
DYNAMICMEMORY_EMPTY
)

421 
	`kSFgInBm
(
i
,
iBuddyBlockOfft
,
DYNAMICMEMORY_EMPTY
);

422 
	`kSFgInBm
(
i
,
iBlockOfft
,
DYNAMICMEMORY_EMPTY
);

425 
iBlockOfft
 = iBlockOffset/2;

428 
	`kUockFSyemDa
(
bPviousIruFg
);

429  
TRUE
;

430 
	}
}

433 
BYTE
 
	$kGFgInBm
(
iBlockLiIndex
,
iOfft
)

435 
BYTE
* 
pbBm
;

437 
pbBm
 = 
gs_DymicMemy
.
pBmOfLev
[
iBlockLiIndex
].pbBitmap;

438 if((
pbBm
[
iOfft
/8]&(0x01<<(iOffset%8)))!=0x00)

440  
DYNAMICMEMORY_EXIST
;

443  
DYNAMICMEMORY_EMPTY
;

444 
	}
}

447 
	$kGDymicMemyInfmi
(
QWORD
* 
pqwDymicMemySAddss
,QWORD* 
pqwDymicMemyTٮSize
,QWORD* 
pqwMaDaSize
,QWORD* 
pqwUdMemySize
)

449 *
pqwDymicMemySAddss
 = 
DYNAMICMEMORY_START_ADDRESS
;

450 *
pqwDymicMemyTٮSize
 = 
	`kCcuϋDymicMemySize
();

451 *
pqwMaDaSize
 = 
	`kCcuϋMaBlockCou
(*
pqwDymicMemyTٮSize
)*
DYNAMICMEMORY_MIN_SIZE
;

452 *
pqwUdMemySize
 = 
gs_DymicMemy
.
qwUdSize
;

453 
	}
}

456 
DYNAMICMEMORY
* 
	$kGDymicMemyMag
()

458  &
gs_DymicMemy
;

459 
	}
}

	@/home/jk/os/MINT64/save/02.Kernel64/Source/DynamicMemory.h

1 #ide
__DYNAMICMEMORY_H__


2 
	#__DYNAMICMEMORY_H__


	)

4 
	~"Tys.h
"

8 
	#DYNAMICMEMORY_START_ADDRESS
 ((
TASK_STACKPOOLADDRESS
+(
TASK_STACKSIZE
*
TASK_MAXCOUNT
)+0xfffff)&0xfffffffffff00000)

	)

12 
	#DYNAMICMEMORY_MIN_SIZE
 (1*1024)

	)

15 
	#DYNAMICMEMORY_EXIST
 0x01

	)

16 
	#DYNAMICMEMORY_EMPTY
 0x00

	)

20 
	skBmSu


22 
BYTE
* 
	mpbBm
;

23 
QWORD
 
	mqwExiBCou
;

24 } 
	tBITMAP
;

27 
	skDymicMemyMagSu


30 
	miMaxLevCou
;

31 
	miBlockCouOfSmˡBlock
;

32 
QWORD
 
	mqwUdSize
;

35 
QWORD
 
	mqwSAddss
;

36 
QWORD
 
	mqwEndAddss
;

39 
BYTE
* 
	mpbAodBlockLiIndex
;

40 
BITMAP
* 
	mpBmOfLev
;

41 } 
	tDYNAMICMEMORY
;

44 
kInlizeDymicMemy
();

45 * 
kAoMemy
(
QWORD
 
qwSize
);

46 
BOOL
 
kFeMemy
(* 
pvAddss
);

47 
kGDymicMemyInfmi
(
QWORD
* 
pqwDymicMemySAddss
,QWORD* 
pqwDymicMemyTٮSize
,QWORD* 
pqwMaDaSize
,QWORD* 
pqwUdMemySize
);

48 
DYNAMICMEMORY
* 
kGDymicMemyMag
();

	@/home/jk/os/MINT64/save/02.Kernel64/Source/EntryPoint.s

1 [
BITS
 64] ; 이하의 코드는 64비트 코드로 설정

3 
	gSECTION
 .
	gxt
 ; .text 섹션(세그먼트)을 정의

5 ; 외부에서 정의된 함수를 쓸 수 있도록 선언함(
	gimpt
)

6 
ma


7 ; 
APIC
 
	gID
 레지스터의 어드레스와 깨어난 코어의 개수

8 
g_qwAPICIDAddss
, 
g_iWakeUpAlitiProssCou


14 
	gSTART
:

15 
mov
 
ax
, 0x10 ; 
	gIA
-32모드 커널용 데이터 세그먼트 디스크립터를 
	gAX
 레지스터에 저장

16 
mov
 
	gds
, 
	gax
 ; 
	gDS
 세그먼트 셀렉터에 설정

17 
mov
 
	ges
, 
	gax
 ; 
	gES
 세그먼트 셀렉터에 설정

18 
mov
 
	gfs
, 
	gax
 ; 
	gFS
 세그먼트 셀렉터에 설정

19 
mov
 
	ggs
, 
	gax
 ; 
	gGS
 세그먼트 셀렉터에 설정

21 ; 스택을 0x600000 ~ 0x6FFFFFF 영역에 1
	gMB
 크기로 생성

22 
mov
 
	gss
, 
	gax
 ; ss 세그먼트 셀렉터에 설정

23 
mov
 
	gr
, 0x700000 ; 
	gRSP
 레지스터의 어드레스를 0x6FFFF8로 설정

24 
mov
 
	grbp
, 0x700000 ; 
	gRBP
 레지스터의 어드레스를 0x6FFFF8로 설정

26 ; 부트 로더 영역의 
Bo١p
 
	gPross
 플래그를 확인하여, Bootstrap Processor이면

27 ; 바로 
	gma
 함수로 이동

28 
cmp
 
	gby
[0x7C09],0x01

29 
	gje
 .
	gBOOTSTRAPPROCESSORSTARTPOINT


32 ; 
Aliti
 
	gPross
만 실행하는 영역

34 ; 스택의 꼭대기(
	gT
)는 
APIC
 
	gID
를 이용해서 0x700000 이하로 이동

35 ; 최대 16개의 코어까지 지원 가능하므로 스택 영역인 1
	gM
를 16으로 나눈 값인

36 ; 64
Kby
(0x10000)만큼식 아래로 이동하면서 설정

37 ; 로컬 
	gAPIC
의 
APIC
 
	gID
 레지스터에서 ID를 추출, ID는 
	gB
 24-31에 위치함

38 
mov
 
	gx
,0 ; 
	gRAX
 레지스터 초기화

39 
mov
 
	grbx
, 
	gqwd
[
g_qwAPICIDAddss
] ; 
APIC
 
	gID
 레지스터의 어드레스를 읽음

40 
mov
 
	gx
, 
	gdwd
[
rbx
] ; 
APIC
 
	gID
 레지스터에서 APIC ID를 읽음 (비트 24-31)

41 
shr
 
	gx
, 24 ; 비트 24-31에 존재하는 
APIC
 
	gID
를 시프트 시켜서 비트 0-7로 이동

43 ; 추출한 
APIC
 
	gID
에 64
Kby
(0x10000)을 곱하여 스택의 꼭대기에 이동시킬 거리를 계산

44 
mov
 
	grbx
, 0x10000 ; 
	gRBX
 레지스터에 스택의 크기(64
	gKby
)를 저장

45 
mul
 
	grbx
 ; 
	gRAX
 레지스터에 저장된 
APIC
 
	gID
와 
	gRBX
 레지스터의 스택 값을 곱함

47 
sub
 
	gr
, 
	gx
 ; 
	gRSP
와 
	gRBP
 레지스터에서 
	gRAX
 레지스터에 저장된 값(스택의 꼭대기를 이동시킬 거리)을

48 
sub
 
	grbp
, 
	gx
 ; 빼서 각 코어 별 스택을 할당해줌

50 ; 깨어난 
Aliti
 
	gPross
 수를 1 증가시킴, 
	glock
 명령어를 사용하여 변수에

51 ; 배타적(
	gexusive
) 접근이 가능하도록 함

52 
lock
 
c
 
	gdwd
 [
g_iWakeUpAlitiProssCou
]

55 ; 
Bo١p
 
	gPross
와 
Aliti
 Processor가 공통으로 실행하는 영역

57 .
	gBOOTSTRAPPROCESSORSTARTPOINT
:

58 

 
ma
 ; 
	gC
 언어 엔트리 포인트 함수(
	gma
) 호출

60 
jmp
 
	g$


	@/home/jk/os/MINT64/save/02.Kernel64/Source/FileSystem.c

1 
	~"FeSyem.h
"

2 
	~"HdDisk.h
"

3 
	~"DymicMemy.h
"

4 
	~"Task.h
"

5 
	~"Uty.h
"

6 
	~"CacheMag.h
"

7 
	~"RAMDisk.h
"

10 
FILESYSTEMMANAGER
 
	ggs_FeSyemMag
;

12 
BYTE
 
	ggs_vbTempBufr
[
FILESYSTEM_SECTORPERCLUSTER
*512];

15 
fRdHDDInfmi
 
	ggs_pfRdHDDInfmi
 = 
NULL
;

16 
fRdHDDSe
 
	ggs_pfRdHDDSe
 =
NULL
;

17 
fWreHDDSe
 
	ggs_pfWreHDDSe
 =
NULL
;

20 
BOOL
 
kRdCluLkTab
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
);

21 
BOOL
 
kWreCluLkTab
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
);

22 
BOOL
 
kRdClu
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
);

23 
BOOL
 
kWreClu
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
);

24 
DWORD
 
kFdFeClu
();

25 
BOOL
 
kSCluLkDa
(
DWORD
 
dwCluIndex
,DWORD 
dwDa
);

26 
BOOL
 
kGCluLkDa
(
DWORD
 
dwCluIndex
,DWORD* 
pdwDa
);

27 
kFdFeDeyEry
();

28 
BOOL
 
kSDeyEryDa
(
iIndex
,
DIRECTORYENTRY
* 
pEry
);

29 
BOOL
 
kGDeyEryDa
(
iIndex
,
DIRECTORYENTRY
* 
pEry
);

30 
kFdDeyEry
(cڡ * 
pcFeName
,
DIRECTORYENTRY
* 
pEry
);

33 * 
kAoFeDeyHd
();

34 
kFeFeDeyHd
(
FILE
* 
pFe
);

35 
BOOL
 
kCeFe
(cڡ * 
pcFeName
,
DIRECTORYENTRY
* 
pEry
,* 
piDeyEryIndex
);

36 
BOOL
 
kFeCluUtEnd
(
DWORD
 
dwCluIndex
);

37 
BOOL
 
kUpdeDeyEry
(
FILEHANDLE
* 
pFeHd
);

40 
BOOL
 
kIlRdCluLkTabWhoutCache
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
);

41 
BOOL
 
kIlRdCluLkTabWhCache
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
);

42 
BOOL
 
kIlWreCluLkTabWhoutCache
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
);

43 
BOOL
 
kIlWreCluLkTabWhCache
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
);

44 
BOOL
 
kIlRdCluWhoutCache
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
);

45 
BOOL
 
kIlRdCluWhCache
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
);

46 
BOOL
 
kIlWreCluWhoutCache
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
);

47 
BOOL
 
kIlWreCluWhCache
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
);

49 
CACHEBUFFER
* 
kAoCacheBufrWhFlush
(
iCacheTabIndex
);

52 
BOOL
 
	$kInlizeFeSyem
()

54 
BOOL
 
bCacheEb
 = 
FALSE
;

57 
	`kMemS
(&
gs_FeSyemMag
,0,(gs_stFileSystemManager));

58 
	`kInlizeMux
(&(
gs_FeSyemMag
.
Mux
));

72  if(
	`kInlizeRDD
(
RDD_TOTALSECTORCOUNT
)==
TRUE
)

75 
gs_pfRdHDDInfmi
 = 
kRdRDDInfmi
;

76 
gs_pfRdHDDSe
 = 
kRdRDDSe
;

77 
gs_pfWreHDDSe
 = 
kWreRDDSe
;

80 if(
	`kFm
(=
FALSE
)

82  
FALSE
;

87  
FALSE
;

91 if(
	`kMou
()==
FALSE
)

93  
FALSE
;

97 
gs_FeSyemMag
.
pHdPo
 = (
FILE
*
	`kAoMemy
(
FILESYSTEM_HANDLE_MAXCOUNT
*(FILE));

100 if(
gs_FeSyemMag
.
pHdPo
 =
NULL
)

102 
gs_FeSyemMag
.
bMoued
 = 
FALSE
;

103  
FALSE
;

107 
	`kMemS
(
gs_FeSyemMag
.
pHdPo
,0,
FILESYSTEM_HANDLE_MAXCOUNT
*(
FILE
));

109 if(
bCacheEb
==
TRUE
)

111 
gs_FeSyemMag
.
bCacheEb
=
	`kInlizeCacheMag
();

114  
TRUE
;

115 
	}
}

122 
BOOL
 
	$kMou
()

124 
MBR
* 
pMBR
;

127 
	`kLock
(&(
gs_FeSyemMag
.
Mux
));

130 if(
	`gs_pfRdHDDSe
(
TRUE
,TRUE,0,1,
gs_vbTempBufr
)==
FALSE
)

133 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

134  
FALSE
;

138 
pMBR
 = (
MBR
*)
gs_vbTempBufr
;

140 if(
pMBR
->
dwSigtu
 !
FILESYSTEM_SIGNATUR
)

143 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

144  
FALSE
;

148 
gs_FeSyemMag
.
bMoued
 = 
TRUE
;

151 
gs_FeSyemMag
.
dwRervedSeCou
 = 
pMBR
->dwReservedSectorCount;

152 
gs_FeSyemMag
.
dwCluLkAaSAddss
 = 
pMBR
->
dwRervedSeCou
+1;

153 
gs_FeSyemMag
.
dwCluLkAaSize
 = 
pMBR
->
dwCluLkSeCou
;

154 
gs_FeSyemMag
.
dwDaAaSAddss
 = 
pMBR
->
dwRervedSeCou
 +MBR->
dwCluLkSeCou
+1;

155 
gs_FeSyemMag
.
dwTٮCluCou
 = 
pMBR
->dwTotalClusterCount;

158 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

159  
TRUE
;

160 
	}
}

163 
BOOL
 
	$kFm
()

165 
HDDINFORMATION
* 
pHDD
;

166 
MBR
* 
pMBR
;

167 
DWORD
 
dwTٮSeCou
,
dwRemaSeCou
;

168 
DWORD
 
dwMaxCluCou
,
dwCluCou
;

169 
DWORD
 
dwCluLkSeCou
;

170 
DWORD
 
i
;

173 
	`kLock
(&(
gs_FeSyemMag
.
Mux
));

178 
pHDD
 = (
HDDINFORMATION
*)
gs_vbTempBufr
;

179 if(
	`gs_pfRdHDDInfmi
(
TRUE
,TRUE,
pHDD
)==
FALSE
)

182 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

183  
FALSE
;

186 
dwTٮSeCou
 = 
pHDD
->
dwTٮSes
;

189 
dwMaxCluCou
 = 
dwTٮSeCou
 / 
FILESYSTEM_SECTORPERCLUSTER
;

194 
dwCluLkSeCou
 = (
dwMaxCluCou
+127)/128;

199 
dwRemaSeCou
 = 
dwTٮSeCou
 - 
dwCluLkSeCou
 -1;

200 
dwCluCou
 = 
dwRemaSeCou
/
FILESYSTEM_SECTORPERCLUSTER
;

203 
dwCluLkSeCou
 = (
dwCluCou
+127)/128;

210 if(
	`gs_pfRdHDDSe
(
TRUE
,TRUE,0,1,
gs_vbTempBufr
)==
FALSE
)

213 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

214  
FALSE
;

218 
pMBR
 = (
MBR
*)
gs_vbTempBufr
;

219 
	`kMemS
(
pMBR
->
vPt
,0,(pstMBR->vstPartiton));

220 
pMBR
->
dwSigtu
 = 
FILESYSTEM_SIGNATUR
;

221 
pMBR
->
dwRervedSeCou
 = 0;

222 
pMBR
->
dwCluLkSeCou
 = dwClusterLinkSectorCount;

223 
pMBR
->
dwTٮCluCou
 = 
dwCluCou
;

226 if(
	`gs_pfWreHDDSe
(
TRUE
,TRUE,0,1,
gs_vbTempBufr
)==
FALSE
)

229 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

230  
FALSE
;

234 
	`kMemS
(
gs_vbTempBufr
,0,512);

235 
i
=0;i<(
dwCluLkSeCou
+
FILESYSTEM_SECTORPERCLUSTER
);i++)

238 if(
i
==0)

240 ((
DWORD
*)(
gs_vbTempBufr
))[0]=
FILESYSTEM_LASTCLUSTER
;

244 ((
DWORD
*)(
gs_vbTempBufr
))[0]=
FILESYSTEM_FREECLUSTER
;

248 if(
	`gs_pfWreHDDSe
(
TRUE
,TRUE,
i
+1,1,
gs_vbTempBufr
)==
FALSE
)

251 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

252  
FALSE
;

257 if(
gs_FeSyemMag
.
bCacheEb
==
TRUE
)

259 
	`kDisrdACacheBufr
(
CACHE_CLUSTERLINKTABLEAREA
);

260 
	`kDisrdACacheBufr
(
CACHE_DATAAREA
);

264 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

265  
TRUE
;

266 
	}
}

269 
BOOL
 
	$kGHDDInfmi
(
HDDINFORMATION
* 
pInfmi
)

271 
BOOL
 
bResu
;

274 
	`kLock
(&(
gs_FeSyemMag
.
Mux
));

276 
bResu
 = 
	`gs_pfRdHDDInfmi
(
TRUE
,TRUE,
pInfmi
);

279 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

281  
bResu
;

282 
	}
}

285 
BOOL
 
	$kRdCluLkTab
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
)

288 if(
gs_FeSyemMag
.
bCacheEb
==
FALSE
)

290 
	`kIlRdCluLkTabWhoutCache
(
dwOfft
,
pbBufr
);

294 
	`kIlRdCluLkTabWhCache
(
dwOfft
,
pbBufr
);

296 
	}
}

300 
BOOL
 
	$kIlRdCluLkTabWhoutCache
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
)

303  
	`gs_pfRdHDDSe
(
TRUE
,TRUE,
dwOfft
+
gs_FeSyemMag
.
dwCluLkAaSAddss
,1,
pbBufr
);

304 
	}
}

308 
BOOL
 
	$kIlRdCluLkTabWhCache
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
)

310 
CACHEBUFFER
* 
pCacheBufr
;

313 
pCacheBufr
 = 
	`kFdCacheBufr
(
CACHE_CLUSTERLINKTABLEAREA
,
dwOfft
);

316 if(
pCacheBufr
!=
NULL
)

318 
	`kMemCpy
(
pbBufr
,
pCacheBufr
->pbBuffer,512);

319  
TRUE
;

323 if(
	`kIlRdCluLkTabWhoutCache
(
dwOfft
,
pbBufr
)==
FALSE
)

325  
FALSE
;

329 
pCacheBufr
 = 
	`kAoCacheBufrWhFlush
(
CACHE_CLUSTERLINKTABLEAREA
);

330 if(
pCacheBufr
==
NULL
)

332  
FALSE
;

336 
	`kMemCpy
(
pCacheBufr
->
pbBufr
,pbBuffer,512);

337 
pCacheBufr
->
dwTag
 = 
dwOfft
;

340 
pCacheBufr
->
bChged
 = 
FALSE
;

341  
TRUE
;

342 
	}
}

346 
CACHEBUFFER
* 
	$kAoCacheBufrWhFlush
(
iCacheTabIndex
)

348 
CACHEBUFFER
* 
pCacheBufr
;

351 
pCacheBufr
 = 
	`kAoCacheBufr
(
iCacheTabIndex
);

353 if(
pCacheBufr
 =
NULL
)

355 
pCacheBufr
 = 
	`kGViimInCacheBufr
(
iCacheTabIndex
);

357 if(
pCacheBufr
==
NULL
)

359 
	`kPrtf
("Cache Allocate Fail~!!!!\n");

360  
NULL
;

364 if(
pCacheBufr
->
bChged
 ==
TRUE
)

366 
iCacheTabIndex
)

369 
CACHE_CLUSTERLINKTABLEAREA
:

371 if(
	`kIlWreCluLkTabWhoutCache
(
pCacheBufr
->
dwTag
,pCacheBufr->
pbBufr
)==
FALSE
)

373 
	`kPrtf
("Cache Buffer Write Fail~!!!!\n");

374  
NULL
;

379 
CACHE_DATAAREA
:

381 if(
	`kIlWreCluWhoutCache
(
pCacheBufr
->
dwTag
,pCacheBufr->
pbBufr
)==
FALSE
)

383 
	`kPrtf
("Cache Buffer Write Fail~!!!!\n");

384  
NULL
;

390 
	`kPrtf
("kAllocateCacheBufferWithFlush Fail\n");

391  
NULL
;

397  
pCacheBufr
;

398 
	}
}

402 
BOOL
 
	$kWreCluLkTab
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
)

405 if(
gs_FeSyemMag
.
bCacheEb
==
FALSE
)

407  
	`kIlWreCluLkTabWhoutCache
(
dwOfft
,
pbBufr
);

411  
	`kIlWreCluLkTabWhCache
(
dwOfft
,
pbBufr
);

413 
	}
}

417 
BOOL
 
	$kIlWreCluLkTabWhoutCache
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
)

420  
	`gs_pfWreHDDSe
(
TRUE
,TRUE,
dwOfft
+
gs_FeSyemMag
.
dwCluLkAaSAddss
,1,
pbBufr
);

421 
	}
}

425 
BOOL
 
	$kIlWreCluLkTabWhCache
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
)

427 
CACHEBUFFER
* 
pCacheBufr
;

430 
pCacheBufr
 = 
	`kFdCacheBufr
(
CACHE_CLUSTERLINKTABLEAREA
,
dwOfft
);

433 if(
pCacheBufr
!=
NULL
)

435 
	`kMemCpy
(
pCacheBufr
->
pbBufr
,pbBuffer,512);

438 
pCacheBufr
->
bChged
 = 
TRUE
;

439  
TRUE
;

443 
pCacheBufr
 = 
	`kAoCacheBufrWhFlush
(
CACHE_CLUSTERLINKTABLEAREA
);

444 if(
pCacheBufr
==
NULL
)

446  
FALSE
;

450 
	`kMemCpy
(
pCacheBufr
->
pbBufr
,pbBuffer,512);

451 
pCacheBufr
->
dwTag
 = 
dwOfft
;

454 
pCacheBufr
->
bChged
 = 
TRUE
;

456  
TRUE
;

457 
	}
}

460 
BOOL
 
	$kRdClu
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
)

463 if(
gs_FeSyemMag
.
bCacheEb
==
FALSE
)

465 
	`kIlRdCluWhoutCache
(
dwOfft
,
pbBufr
);

469 
	`kIlRdCluWhCache
(
dwOfft
,
pbBufr
);

471 
	}
}

475 
BOOL
 
	$kIlRdCluWhoutCache
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
)

478  
	`gs_pfRdHDDSe
(
TRUE
,TRUE,(
dwOfft
*
FILESYSTEM_SECTORPERCLUSTER
)+
gs_FeSyemMag
.
dwDaAaSAddss
,FILESYSTEM_SECTORPERCLUSTER,
pbBufr
);

479 
	}
}

483 
BOOL
 
	$kIlRdCluWhCache
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
)

485 
CACHEBUFFER
* 
pCacheBufr
;

488 
pCacheBufr
 = 
	`kFdCacheBufr
(
CACHE_DATAAREA
,
dwOfft
);

491 if(
pCacheBufr
!=
NULL
)

493 
	`kMemCpy
(
pbBufr
,
pCacheBufr
->pbBufr,
FILESYSTEM_CLUSTERSIZE
);

494  
TRUE
;

498 if(
	`kIlRdCluWhoutCache
(
dwOfft
,
pbBufr
)==
FALSE
)

500  
FALSE
;

504 
pCacheBufr
 = 
	`kAoCacheBufrWhFlush
(
CACHE_DATAAREA
);

505 if(
pCacheBufr
==
NULL
)

507  
FALSE
;

511 
	`kMemCpy
(
pCacheBufr
->
pbBufr
,pbBufr,
FILESYSTEM_CLUSTERSIZE
);

512 
pCacheBufr
->
dwTag
 = 
dwOfft
;

515 
pCacheBufr
->
bChged
 = 
FALSE
;

516  
TRUE
;

517 
	}
}

520 
BOOL
 
	$kWreClu
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
)

523 if(
gs_FeSyemMag
.
bCacheEb
==
FALSE
)

525 
	`kIlWreCluWhoutCache
(
dwOfft
,
pbBufr
);

529 
	`kIlWreCluWhCache
(
dwOfft
,
pbBufr
);

531 
	}
}

535 
BOOL
 
	$kIlWreCluWhoutCache
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
)

538  
	`gs_pfWreHDDSe
(
TRUE
,TRUE,(
dwOfft
*
FILESYSTEM_SECTORPERCLUSTER
)+
gs_FeSyemMag
.
dwDaAaSAddss
,FILESYSTEM_SECTORPERCLUSTER,
pbBufr
);

539 
	}
}

543 
BOOL
 
	$kIlWreCluWhCache
(
DWORD
 
dwOfft
,
BYTE
* 
pbBufr
)

545 
CACHEBUFFER
* 
pCacheBufr
;

548 
pCacheBufr
 = 
	`kFdCacheBufr
(
CACHE_DATAAREA
,
dwOfft
);

551 if(
pCacheBufr
!=
NULL
)

553 
	`kMemCpy
(
pCacheBufr
->
pbBufr
,pbBufr,
FILESYSTEM_CLUSTERSIZE
);

556 
pCacheBufr
->
bChged
 = 
TRUE
;

558  
TRUE
;

562 
pCacheBufr
 = 
	`kAoCacheBufrWhFlush
(
CACHE_DATAAREA
);

563 if(
pCacheBufr
==
NULL
)

565  
FALSE
;

569 
	`kMemCpy
(
pCacheBufr
->
pbBufr
,pbBufr,
FILESYSTEM_CLUSTERSIZE
);

570 
pCacheBufr
->
dwTag
 = 
dwOfft
;

573 
pCacheBufr
->
bChged
 = 
TRUE
;

575  
TRUE
;

576 
	}
}

579 
DWORD
 
	$kFdFeClu
()

581 
DWORD
 
dwLkCouInSe
;

582 
DWORD
 
dwLaSeOfft
,
dwCutSeOfft
;

583 
DWORD
 
i
,
j
;

586 if(
gs_FeSyemMag
.
bMoued
==
FALSE
)

588  
FILESYSTEM_LASTCLUSTER
;

592 
dwLaSeOfft
 = 
gs_FeSyemMag
.
dwLaAoduLkSeOfft
;

595 
i
=0;i<
gs_FeSyemMag
.
dwCluLkAaSize
;i++)

599 if((
dwLaSeOfft
+
i
)==(
gs_FeSyemMag
.
dwCluLkAaSize
-1))

601 
dwLkCouInSe
 = 
gs_FeSyemMag
.
dwTٮCluCou
%128;

605 
dwLkCouInSe
 = 128;

609 
dwCutSeOfft
 = (
dwLaSeOfft
+
i
)%
gs_FeSyemMag
.
dwCluLkAaSize
;

610 if(
	`kRdCluLkTab
(
dwCutSeOfft
,
gs_vbTempBufr
)==
FALSE
)

612  
FILESYSTEM_LASTCLUSTER
;

616 
j
=0;j<
dwLkCouInSe
;j++)

618 if(((
DWORD
*)
gs_vbTempBufr
)[
j
]==
FILESYSTEM_FREECLUSTER
)

625 if(
j
!=
dwLkCouInSe
)

628 
gs_FeSyemMag
.
dwLaAoduLkSeOfft
 = 
dwCutSeOfft
;

631  (
dwCutSeOfft
*128)+
j
;

635  
FILESYSTEM_LASTCLUSTER
;

636 
	}
}

639 
BOOL
 
	$kSCluLkDa
(
DWORD
 
dwCluIndex
,DWORD 
dwDa
)

641 
DWORD
 
dwSeOfft
;

644 if(
gs_FeSyemMag
.
bMoued
==
FALSE
)

646 
	`kPrtf
("FileSystemot mounted\n");

647  
FALSE
;

651 
dwSeOfft
 = 
dwCluIndex
/128;

654 if(
	`kRdCluLkTab
(
dwSeOfft
,
gs_vbTempBufr
)==
FALSE
)

656 
	`kPrtf
("kReadClusterLinkTablerror\n");

657  
FALSE
;

660 ((
DWORD
*)
gs_vbTempBufr
)[
dwCluIndex
%128]=
dwDa
;

662 if(
	`kWreCluLkTab
(
dwSeOfft
,
gs_vbTempBufr
)==
FALSE
)

664 
	`kPrtf
("kWriteClusterLinkTablerror\n");

665  
FALSE
;

668  
TRUE
;

669 
	}
}

672 
BOOL
 
	$kGCluLkDa
(
DWORD
 
dwCluIndex
,DWORD* 
pdwDa
)

674 
DWORD
 
dwSeOfft
;

677 if(
gs_FeSyemMag
.
bMoued
==
FALSE
)

679  
FALSE
;

683 
dwSeOfft
 = 
dwCluIndex
/128;

685 if(
dwSeOfft
>
gs_FeSyemMag
.
dwCluLkAaSize
)

687  
FALSE
;

691 if(
	`kRdCluLkTab
(
dwSeOfft
,
gs_vbTempBufr
)==
FALSE
)

693  
FALSE
;

696 *
pdwDa
 = ((
DWORD
*)
gs_vbTempBufr
)[
dwCluIndex
%128];

697  
TRUE
;

698 
	}
}

701 
	$kFdFeDeyEry
()

703 
DIRECTORYENTRY
* 
pEry
;

704 
i
;

707 if(
gs_FeSyemMag
.
bMoued
==
FALSE
)

713 if(
	`kRdClu
(0,
gs_vbTempBufr
)==
FALSE
)

719 
pEry
 = (
DIRECTORYENTRY
*)
gs_vbTempBufr
;

720 
i
=0;i<
FILESYSTEM_MAXDIRECTORYENTRYCOUNT
;i++)

722 if(
pEry
[
i
].
dwSCluIndex
==0)

724  
i
;

729 
	}
}

732 
BOOL
 
	$kSDeyEryDa
(
iIndex
,
DIRECTORYENTRY
* 
pEry
)

734 
DIRECTORYENTRY
* 
pRoEry
;

737 if((
gs_FeSyemMag
.
bMoued
==
FALSE
)||(
iIndex
<0)||(iIndex>=
FILESYSTEM_MAXDIRECTORYENTRYCOUNT
))

739 
	`kPrtf
("FeSyem moued (Index=%d)\n",
iIndex
);

740  
FALSE
;

744 if(
	`kRdClu
(0,
gs_vbTempBufr
)==
FALSE
)

746 
	`kPrtf
("kReadClusterrror\n");

747  
FALSE
;

751 
pRoEry
 = (
DIRECTORYENTRY
*)
gs_vbTempBufr
;

752 
	`kMemCpy
(
pRoEry
+
iIndex
,
pEry
,(
DIRECTORYENTRY
));

755 if(
	`kWreClu
(0,
gs_vbTempBufr
)==
FALSE
)

757 
	`kPrtf
("kWriteClusterrror\n");

758  
FALSE
;

761  
TRUE
;

762 
	}
}

765 
BOOL
 
	$kGDeyEryDa
(
iIndex
,
DIRECTORYENTRY
* 
pEry
)

767 
DIRECTORYENTRY
* 
pRoEry
;

770 if((
gs_FeSyemMag
.
bMoued
==
FALSE
)||(
iIndex
<0)||(iIndex>=
FILESYSTEM_MAXDIRECTORYENTRYCOUNT
))

772  
FALSE
;

776 if(
	`kRdClu
(0,
gs_vbTempBufr
)==
FALSE
)

778  
FALSE
;

782 
pRoEry
 = (
DIRECTORYENTRY
*)
gs_vbTempBufr
;

783 
	`kMemCpy
(
pEry
,
pRoEry
+
iIndex
,(
DIRECTORYENTRY
));

784  
TRUE
;

785 
	}
}

788 
	$kFdDeyEry
(cڡ * 
pcFeName
,
DIRECTORYENTRY
* 
pEry
)

790 
DIRECTORYENTRY
* 
pRoEry
;

791 
i
;

792 
iLgth
;

795 if(
gs_FeSyemMag
.
bMoued
==
FALSE
)

801 if(
	`kRdClu
(0,
gs_vbTempBufr
)==
FALSE
)

806 
iLgth
 = 
	`kSL
(
pcFeName
);

808 
pRoEry
 = (
DIRECTORYENTRY
*)
gs_vbTempBufr
;

809 
i
=0;i<
FILESYSTEM_MAXDIRECTORYENTRYCOUNT
;i++)

811 if(
	`kMemCmp
(
pRoEry
[
i
].
vcFeName
,
pcFeName
,
iLgth
)==0)

813 
	`kMemCpy
(
pEry
,
pRoEry
+
i
,(
DIRECTORYENTRY
));

814  
i
;

819 
	}
}

822 
	$kGFeSyemInfmi
(
FILESYSTEMMANAGER
* 
pMag
)

824 
	`kMemCpy
(
pMag
,&
gs_FeSyemMag
,(gs_stFileSystemManager));

825 
	}
}

831 * 
	$kAoFeDeyHd
()

833 
i
;

834 
FILE
* 
pFe
;

837 
pFe
 = 
gs_FeSyemMag
.
pHdPo
;

838 
i
=0;i<
FILESYSTEM_HANDLE_MAXCOUNT
;i++)

841 if(
pFe
->
bTy
 =
FILESYSTEM_TYPE_FREE
)

843 
pFe
->
bTy
 = 
FILESYSTEM_TYPE_FILE
;

844  
pFe
;

848 
pFe
++;

851  
NULL
;

852 
	}
}

855 
	$kFeFeDeyHd
(
FILE
* 
pFe
)

858 
	`kMemS
(
pFe
,0,(
FILE
));

861 
pFe
->
bTy
 = 
FILESYSTEM_TYPE_FREE
;

862 
	}
}

865 
BOOL
 
	$kCeFe
(cڡ * 
pcFeName
,
DIRECTORYENTRY
* 
pEry
,* 
piDeyEryIndex
)

867 
DWORD
 
dwClu
;

870 
dwClu
 = 
	`kFdFeClu
();

871 if((
dwClu
==
FILESYSTEM_LASTCLUSTER
)||(
	`kSCluLkDa
(dwClu,FILESYSTEM_LASTCLUSTER)==
FALSE
))

873  
FALSE
;

877 *
piDeyEryIndex
 = 
	`kFdFeDeyEry
();

878 if(*
piDeyEryIndex
==-1)

881 
	`kSCluLkDa
(
dwClu
,
FILESYSTEM_FREECLUSTER
);

882  
FALSE
;

886 
	`kMemCpy
(
pEry
->
vcFeName
,
pcFeName
,
	`kSL
(pcFileName)+1);

887 
pEry
->
dwSCluIndex
 = 
dwClu
;

888 
pEry
->
dwFeSize
 = 0;

891 if(
	`kSDeyEryDa
(*
piDeyEryIndex
,
pEry
)==
FALSE
)

894 
	`kSCluLkDa
(
dwClu
,
FILESYSTEM_FREECLUSTER
);

895  
FALSE
;

898  
TRUE
;

899 
	}
}

902 
BOOL
 
	$kFeCluUtEnd
(
DWORD
 
dwCluIndex
)

904 
DWORD
 
dwCutCluIndex
;

905 
DWORD
 
dwNextCluIndex
;

908 
dwCutCluIndex
 = 
dwCluIndex
;

910 
dwCutCluIndex
!=
FILESYSTEM_LASTCLUSTER
)

913 if(
	`kGCluLkDa
(
dwCutCluIndex
,&
dwNextCluIndex
)==
FALSE
)

915  
FALSE
;

919 if(
	`kSCluLkDa
(
dwCutCluIndex
,
FILESYSTEM_FREECLUSTER
)==
FALSE
)

921  
FALSE
;

925 
dwCutCluIndex
 = 
dwNextCluIndex
;

928  
TRUE
;

929 
	}
}

932 
FILE
* 
	$kOnFe
(cڡ * 
pcFeName
,cڡ * 
pcMode
)

934 
DIRECTORYENTRY
 
Ery
;

935 
iDeyEryOfft
;

936 
iFeNameLgth
;

937 
DWORD
 
dwSecdClu
;

938 
FILE
* 
pFe
;

941 
iFeNameLgth
 = 
	`kSL
(
pcFeName
);

942 if((
iFeNameLgth
>((
Ery
.
vcFeName
)-1))||(iFileNameLength==0))

944  
NULL
;

948 
	`kLock
(&(
gs_FeSyemMag
.
Mux
));

953 
iDeyEryOfft
 = 
	`kFdDeyEry
(
pcFeName
,&
Ery
);

954 if(
iDeyEryOfft
==-1)

957 if(
pcMode
[0]=='r')

960 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

961  
NULL
;

965 if(
	`kCeFe
(
pcFeName
,&
Ery
,&
iDeyEryOfft
)==
FALSE
)

968 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

969  
NULL
;

975 if(
pcMode
[0]=='w')

978 if(
	`kGCluLkDa
(
Ery
.
dwSCluIndex
,&
dwSecdClu
)==
FALSE
)

981 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

982  
NULL
;

986 if(
	`kSCluLkDa
(
Ery
.
dwSCluIndex
,
FILESYSTEM_LASTCLUSTER
)==
FALSE
)

989 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

990  
NULL
;

994 if(
	`kFeCluUtEnd
(
dwSecdClu
)==
FALSE
)

997 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

998  
NULL
;

1002 
Ery
.
dwFeSize
 = 0;

1003 if(
	`kSDeyEryDa
(
iDeyEryOfft
,&
Ery
)==
FALSE
)

1006 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1007  
NULL
;

1015 
pFe
 = 
	`kAoFeDeyHd
();

1016 if(
pFe
==
NULL
)

1019 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1020  
NULL
;

1024 
pFe
->
bTy
 = 
FILESYSTEM_TYPE_FILE
;

1025 
pFe
->
FeHd
.
iDeyEryOfft
 = iDirectoryEntryOffset;

1026 
pFe
->
FeHd
.
dwFeSize
 = 
Ery
.dwFileSize;

1027 
pFe
->
FeHd
.
dwSCluIndex
 = 
Ery
.dwStartClusterIndex;

1028 
pFe
->
FeHd
.
dwCutCluIndex
 = 
Ery
.
dwSCluIndex
;

1029 
pFe
->
FeHd
.
dwPviousCluIndex

Ery
.
dwSCluIndex
;

1030 
pFe
->
FeHd
.
dwCutOfft
 =0;

1033 if(
pcMode
[0]=='a')

1035 
	`kSkFe
(
pFe
,0,
FILESYSTEM_SEEK_END
);

1039 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1040  
pFe
;

1041 
	}
}

1044 
DWORD
 
	$kRdFe
(* 
pvBufr
,
DWORD
 
dwSize
,DWORD 
dwCou
,
FILE
* 
pFe
)

1046 
DWORD
 
dwTٮCou
;

1047 
DWORD
 
dwRdCou
;

1048 
DWORD
 
dwOfftInClu
;

1049 
DWORD
 
dwCySize
;

1050 
FILEHANDLE
* 
pFeHd
;

1051 
DWORD
 
dwNextCluIndex
;

1054 if((
pFe
==
NULL
)||աFe->
bTy
!=
FILESYSTEM_TYPE_FILE
))

1059 
pFeHd
 = &(
pFe
->
FeHd
);

1062 if((
pFeHd
->
dwCutOfft
=FeHd->
dwFeSize
)||աFeHd->
dwCutCluIndex
==
FILESYSTEM_LASTCLUSTER
))

1068 
dwTٮCou
 = 
	`MIN
(
dwSize
*
dwCou
,
pFeHd
->
dwFeSize
-pFeHd->
dwCutOfft
);

1071 
	`kLock
(&(
gs_FeSyemMag
.
Mux
));

1074 
dwRdCou
=0;

1075 
dwRdCou
!=
dwTٮCou
)

1081 if(
	`kRdClu
(
pFeHd
->
dwCutCluIndex
,
gs_vbTempBufr
)==
FALSE
)

1087 
dwOfftInClu
 = 
pFeHd
->
dwCutOfft
%
FILESYSTEM_CLUSTERSIZE
;

1090 
dwCySize
 = 
	`MIN
(
FILESYSTEM_CLUSTERSIZE
-
dwOfftInClu
,
dwTٮCou
-
dwRdCou
);

1092 
	`kMemCpy
((*)
pvBufr
+
dwRdCou
,
gs_vbTempBufr
+
dwOfftInClu
,
dwCySize
);

1095 
dwRdCou
 +=
dwCySize
;

1096 
pFeHd
->
dwCutOfft
 +=
dwCySize
;

1101 if((
pFeHd
->
dwCutOfft
%
FILESYSTEM_CLUSTERSIZE
)==0)

1104 if(
	`kGCluLkDa
(
pFeHd
->
dwCutCluIndex
,&
dwNextCluIndex
)==
FALSE
)

1110 
pFeHd
->
dwPviousCluIndex
FeHd->
dwCutCluIndex
;

1111 
pFeHd
->
dwCutCluIndex
=
dwNextCluIndex
;

1116 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1119  
dwRdCou
;

1120 
	}
}

1123 
BOOL
 
	$kUpdeDeyEry
(
FILEHANDLE
* 
pFeHd
)

1125 
DIRECTORYENTRY
 
Ery
;

1128 if((
pFeHd
==
NULL
)||(
	`kGDeyEryDa
աFeHd->
iDeyEryOfft
,&
Ery
)==
FALSE
))

1130  
FALSE
;

1134 
Ery
.
dwFeSize
 = 
pFeHd
->dwFileSize;

1135 
Ery
.
dwSCluIndex
 = 
pFeHd
->dwStartClusterIndex;

1138 if(
	`kSDeyEryDa
(
pFeHd
->
iDeyEryOfft
,&
Ery
)==
FALSE
)

1140  
FALSE
;

1143  
TRUE
;

1144 
	}
}

1147 
DWORD
 
	$kWreFe
(cڡ * 
pvBufr
,
DWORD
 
dwSize
,DWORD 
dwCou
,
FILE
* 
pFe
)

1149 
DWORD
 
dwWreCou
;

1150 
DWORD
 
dwTٮCou
;

1151 
DWORD
 
dwOfftInClu
;

1152 
DWORD
 
dwCySize
;

1153 
DWORD
 
dwAodCluIndex
;

1154 
DWORD
 
dwNextCluIndex
;

1155 
DWORD
 
dwUFeSize
;

1156 
FILEHANDLE
* 
pFeHd
;

1159 if((
pFe
==
NULL
)||աFe->
bTy
!=
FILESYSTEM_TYPE_FILE
))

1164 
pFeHd
 = &(
pFe
->
FeHd
);

1167 
dwUFeSize
 = ((
pFeHd
->
dwFeSize
+
FILESYSTEM_CLUSTERSIZE
)/FILESYSTEM_CLUSTERSIZE)*FILESYSTEM_CLUSTERSIZE;

1170 
dwTٮCou
 = 
dwSize
*
dwCou
;

1173 
	`kLock
(&(
gs_FeSyemMag
.
Mux
));

1176 
dwWreCou
=0;

1177 
dwWreCou
!=
dwTٮCou
)

1181 
dwOfftInClu
 = 
pFeHd
->
dwCutOfft
%
FILESYSTEM_CLUSTERSIZE
;

1182 
dwCySize
 = 
	`MIN
(
FILESYSTEM_CLUSTERSIZE
-
dwOfftInClu
,
dwTٮCou
-
dwWreCou
);

1185 
dwAodCluIndex
=-1;

1188 if(
dwUFeSize
<=(
pFeHd
->
dwCutOfft
+
dwCySize
))

1191 
dwAodCluIndex
 = 
	`kFdFeClu
();

1192 if(
dwAodCluIndex
==
FILESYSTEM_LASTCLUSTER
)

1198 if(
	`kSCluLkDa
(
dwAodCluIndex
,
FILESYSTEM_LASTCLUSTER
)==
FALSE
)

1205 if(
pFeHd
->
dwCutOfft
%
FILESYSTEM_CLUSTERSIZE
!=0)

1207 if(
pFeHd
->
dwCutCluIndex
==
FILESYSTEM_LASTCLUSTER
)

1209 if(
	`kRdClu
(
pFeHd
->
dwPviousCluIndex
,
gs_vbTempBufr
)==
FALSE
)

1218 if(
	`kRdClu
(
pFeHd
->
dwCutCluIndex
,
gs_vbTempBufr
)==
FALSE
)

1228 
	`kMemCpy
(
gs_vbTempBufr
+
dwOfftInClu
,(*)
pvBufr
+
dwWreCou
,
dwCySize
);

1231 if(
pFeHd
->
dwCutCluIndex
==
FILESYSTEM_LASTCLUSTER
)

1233 if(
	`kWreClu
(
pFeHd
->
dwPviousCluIndex
,
gs_vbTempBufr
)==
FALSE
)

1240 if(
	`kWreClu
(
pFeHd
->
dwCutCluIndex
,
gs_vbTempBufr
)==
FALSE
)

1248 
dwWreCou
+=
dwCySize
;

1249 
pFeHd
->
dwCutOfft
+=
dwCySize
;

1252 if(
dwOfftInClu
+
dwCySize
==
FILESYSTEM_CLUSTERSIZE
)

1254 if(
dwAodCluIndex
!=-1)

1256 if(
	`kSCluLkDa
(
pFeHd
->
dwCutCluIndex
,
dwAodCluIndex
)==
FALSE
)

1261 
pFeHd
->
dwPviousCluIndex
 =FeHd->
dwCutCluIndex
;

1262 
pFeHd
->
dwCutCluIndex
 = 
dwAodCluIndex
;

1267 if(
	`kGCluLkDa
(
pFeHd
->
dwCutCluIndex
,&
dwNextCluIndex
)==
FALSE
)

1273 
pFeHd
->
dwPviousCluIndex
 =FeHd->
dwCutCluIndex
;

1274 
pFeHd
->
dwCutCluIndex
 = 
dwNextCluIndex
;

1286 if(
pFeHd
->
dwFeSize
<pFeHd->
dwCutOfft
)

1288 
pFeHd
->
dwFeSize
FeHd->
dwCutOfft
;

1289 
	`kUpdeDeyEry
(
pFeHd
);

1293 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1294  
dwWreCou
;

1295 
	}
}

1298 
BOOL
 
	$kWreZo
(
FILE
* 
pFe
,
DWORD
 
dwCou
)

1300 
BYTE
* 
pbBufr
;

1301 
DWORD
 
dwRemaCou
;

1302 
DWORD
 
dwWreCou
;

1305 if(
pFe
==
NULL
)

1307  
FALSE
;

1311 
pbBufr
 = (
BYTE
*)
	`kAoMemy
(
FILESYSTEM_CLUSTERSIZE
);

1312 if(
pbBufr
==
NULL
)

1314  
FALSE
;

1318 
	`kMemS
(
pbBufr
,0,
FILESYSTEM_CLUSTERSIZE
);

1319 
dwRemaCou
 = 
dwCou
;

1322 
dwRemaCou
!=0)

1324 
dwWreCou
 = 
	`MIN
(
dwRemaCou
,
FILESYSTEM_CLUSTERSIZE
);

1325 if(
	`kWreFe
(
pbBufr
,1,
dwWreCou
,
pFe
)!=dwWriteCount)

1327 
	`kFeMemy
(
pbBufr
);

1328  
FALSE
;

1331 
dwRemaCou
 ==
dwWreCou
;

1334 
	`kFeMemy
(
pbBufr
);

1335  
TRUE
;

1336 
	}
}

1339 
	$kSkFe
(
FILE
* 
pFe
,
iOfft
,
iOrig
)

1341 
DWORD
 
dwRlOfft
;

1342 
DWORD
 
dwCluOfftToMove
;

1343 
DWORD
 
dwCutCluOfft
;

1344 
DWORD
 
dwLaCluOfft
;

1345 
DWORD
 
dwMoveCou
;

1346 
DWORD
 
i
;

1347 
DWORD
 
dwSCluIndex
;

1348 
DWORD
 
dwPviousCluIndex
;

1349 
DWORD
 
dwCutCluIndex
;

1350 
FILEHANDLE
* 
pFeHd
;

1353 if((
pFe
==
NULL
)||աFe->
bTy
!=
FILESYSTEM_TYPE_FILE
))

1358 
pFeHd
 = &(
pFe
->
FeHd
);

1365 
iOrig
)

1368 
FILESYSTEM_SEEK_SET
:

1370 if(
iOfft
<=0)

1372 
dwRlOfft
=0;

1376 
dwRlOfft
=
iOfft
;

1381 
FILESYSTEM_SEEK_CUR
:

1384 if((
iOfft
<=0)&&(
pFeHd
->
dwCutOfft
<=(
DWORD
)-iOffset))

1386 
dwRlOfft
=0;

1390 
dwRlOfft
 = 
pFeHd
->
dwCutOfft
+
iOfft
;

1395 
FILESYSTEM_SEEK_END
:

1398 if((
iOfft
<0)&&(
pFeHd
->
dwFeSize
<=(
DWORD
)-iOffset))

1400 
dwRlOfft
=0;

1404 
dwRlOfft
 = 
pFeHd
->
dwFeSize
+
iOfft
;

1414 
dwLaCluOfft
 = 
pFeHd
->
dwFeSize
/
FILESYSTEM_CLUSTERSIZE
;

1416 
dwCluOfftToMove
 = 
dwRlOfft
/
FILESYSTEM_CLUSTERSIZE
;

1418 
dwCutCluOfft
 = 
pFeHd
->
dwCutOfft
/
FILESYSTEM_CLUSTERSIZE
;

1422 if(
dwLaCluOfft
<
dwCluOfftToMove
)

1424 
dwMoveCou
 = 
dwLaCluOfft
-
dwCutCluOfft
;

1425 
dwSCluIndex
 = 
pFeHd
->
dwCutCluIndex
;

1429 if(
dwCutCluOfft
<=
dwCluOfftToMove
)

1431 
dwMoveCou
 = 
dwCluOfftToMove
-
dwCutCluOfft
;

1432 
dwSCluIndex
 = 
pFeHd
->
dwCutCluIndex
;

1437 
dwMoveCou
 = 
dwCluOfftToMove
;

1438 
dwSCluIndex
 = 
pFeHd
->dwStartClusterIndex;

1442 
	`kLock
(&(
gs_FeSyemMag
.
Mux
));

1445 
dwCutCluIndex
 = 
dwSCluIndex
;

1446 
i
=0;i<
dwMoveCou
;i++)

1449 
dwPviousCluIndex
 = 
dwCutCluIndex
;

1452 if(
	`kGCluLkDa
(
dwPviousCluIndex
,&
dwCutCluIndex
)==
FALSE
)

1455 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1461 if(
dwMoveCou
>0)

1463 
pFeHd
->
dwPviousCluIndex
 = dwPreviousClusterIndex;

1464 
pFeHd
->
dwCutCluIndex
 = dwCurrentClusterIndex;

1467 if(
dwSCluIndex
==
pFeHd
->dwStartClusterIndex)

1469 
pFeHd
->
dwPviousCluIndex
 =FeHd->
dwSCluIndex
;

1470 
pFeHd
->
dwCutCluIndex
 =FeHd->
dwSCluIndex
;

1478 if(
dwLaCluOfft
<
dwCluOfftToMove
)

1480 
pFeHd
->
dwCutOfft
 =FeHd->
dwFeSize
;

1482 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1485 if(
	`kWreZo
(
pFe
,
dwRlOfft
-
pFeHd
->
dwFeSize
)==
FALSE
)

1491 
pFeHd
->
dwCutOfft
 = 
dwRlOfft
;

1494 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1497 
	}
}

1500 
	$kCloFe
(
FILE
* 
pFe
)

1503 if((
pFe
==
NULL
)||աFe->
bTy
!=
FILESYSTEM_TYPE_FILE
))

1509 
	`kFeFeDeyHd
(
pFe
);

1511 
	}
}

1514 
BOOL
 
	$kIsFeOd
(cڡ 
DIRECTORYENTRY
* 
pEry
)

1516 
i
;

1517 
FILE
* 
pFe
;

1520 
pFe
 = 
gs_FeSyemMag
.
pHdPo
;

1521 
i
=0;i<
FILESYSTEM_HANDLE_MAXCOUNT
;i++)

1524 if((
pFe
[
i
].
bTy
==
FILESYSTEM_TYPE_FILE
)&&աFe[i].
FeHd
.
dwSCluIndex
==
pEry
->dwStartClusterIndex))

1526  
TRUE
;

1530  
FALSE
;

1531 
	}
}

1534 
	$kRemoveFe
(cڡ * 
pcFeName
)

1536 
DIRECTORYENTRY
 
Ery
;

1537 
iDeyEryOfft
;

1538 
iFeNameLgth
;

1541 
iFeNameLgth
 = 
	`kSL
(
pcFeName
);

1542 if((
iFeNameLgth
>((
Ery
.
vcFeName
)-1))||(iFileNameLength==0))

1544  
NULL
;

1548 
	`kLock
(&(
gs_FeSyemMag
.
Mux
));

1551 
iDeyEryOfft
 = 
	`kFdDeyEry
(
pcFeName
,&
Ery
);

1552 if(
iDeyEryOfft
==-1)

1555 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1560 if(
	`kIsFeOd
(&
Ery
)==
TRUE
)

1563 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1568 if(
	`kFeCluUtEnd
(
Ery
.
dwSCluIndex
)==
FALSE
)

1571 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1576 
	`kMemS
(&
Ery
,0,(stEntry));

1577 if(
	`kSDeyEryDa
(
iDeyEryOfft
,&
Ery
)==
FALSE
)

1580 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1585 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1587 
	}
}

1590 
DIR
* 
	$kOnDey
(cڡ * 
pcDeyName
)

1592 
DIR
* 
pDey
;

1593 
DIRECTORYENTRY
* 
pDeyBufr
;

1596 
	`kLock
(&(
gs_FeSyemMag
.
Mux
));

1599 
pDey
 = 
	`kAoFeDeyHd
();

1600 if(
pDey
==
NULL
)

1603 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1604  
NULL
;

1608 
pDeyBufr
 = (
DIRECTORYENTRY
*)
	`kAoMemy
(
FILESYSTEM_CLUSTERSIZE
);

1609 if(
pDeyBufr
==
NULL
)

1612 
	`kFeFeDeyHd
(
pDey
);

1614 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1615  
NULL
;

1619 if(
	`kRdClu
(0,(
BYTE
*)
pDeyBufr
)==
FALSE
)

1622 
	`kFeFeDeyHd
(
pDey
);

1623 
	`kFeMemy
(
pDeyBufr
);

1626 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1627  
NULL
;

1631 
pDey
->
bTy
 = 
FILESYSTEM_TYPE_DIRECTORY
;

1632 
pDey
->
DeyHd
.
iCutOfft
 = 0;

1633 
pDey
->
DeyHd
.
pDeyBufr
 =stDirectoryBuffer;

1636 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1637  
pDey
;

1638 
	}
}

1641 
kDeyErySu
* 
	$kRdDey
(
DIR
* 
pDey
)

1643 
DIRECTORYHANDLE
* 
pDeyHd
;

1644 
DIRECTORYENTRY
* 
pEry
;

1647 if((
pDey
==
NULL
)||աDey->
bTy
!=
FILESYSTEM_TYPE_DIRECTORY
))

1649  
NULL
;

1652 
pDeyHd
 = &(
pDey
->
DeyHd
);

1655 if((
pDeyHd
->
iCutOfft
<0)||աDeyHd->iCutOfft>=
FILESYSTEM_MAXDIRECTORYENTRYCOUNT
))

1657  
NULL
;

1661 
	`kLock
(&(
gs_FeSyemMag
.
Mux
));

1664 
pEry
 = 
pDeyHd
->
pDeyBufr
;

1665 
pDeyHd
->
iCutOfft
<
FILESYSTEM_MAXDIRECTORYENTRYCOUNT
)

1668 if(
pEry
[
pDeyHd
->
iCutOfft
].
dwSCluIndex
!=0)

1671 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1672  &(
pEry
[
pDeyHd
->
iCutOfft
++]);

1675 
pDeyHd
->
iCutOfft
++;

1679 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1680  
NULL
;

1681 
	}
}

1684 
	$kRewdDey
(
DIR
* 
pDey
)

1686 
DIRECTORYHANDLE
* 
pDeyHd
;

1689 if((
pDey
==
NULL
)||աDey->
bTy
!=
FILESYSTEM_TYPE_DIRECTORY
))

1694 
pDeyHd
=&(
pDey
->
DeyHd
);

1697 
	`kLock
(&(
gs_FeSyemMag
.
Mux
));

1700 
pDeyHd
->
iCutOfft
=0;

1703 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1704 
	}
}

1707 
	$kCloDey
(
DIR
* 
pDey
)

1709 
DIRECTORYHANDLE
* 
pDeyHd
;

1712 if((
pDey
==
NULL
)||աDey->
bTy
!=
FILESYSTEM_TYPE_DIRECTORY
))

1717 
pDeyHd
 = &(
pDey
->
DeyHd
);

1720 
	`kLock
(&(
gs_FeSyemMag
.
Mux
));

1723 
	`kFeMemy
(
pDeyHd
->
pDeyBufr
);

1724 
	`kFeFeDeyHd
(
pDey
);

1727 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1730 
	}
}

1733 
BOOL
 
	$kFlushFeSyemCache
()

1735 
CACHEBUFFER
* 
pCacheBufr
;

1736 
iCacheCou
;

1737 
i
;

1740 if(
gs_FeSyemMag
.
bCacheEb
==
FALSE
)

1742  
TRUE
;

1746 
	`kLock
(&(
gs_FeSyemMag
.
Mux
));

1749 
	`kGCacheBufrAndCou
(
CACHE_CLUSTERLINKTABLEAREA
,&
pCacheBufr
,&
iCacheCou
);

1751 
i
=0;i<
iCacheCou
;i++)

1754 if(
pCacheBufr
[
i
].
bChged
==
TRUE
)

1756 if(
	`kIlWreCluLkTabWhoutCache
(
pCacheBufr
[
i
].
dwTag
,pCacheBufr[i].
pbBufr
)==
FALSE
)

1758  
FALSE
;

1762 
pCacheBufr
[
i
].
bChged
 = 
FALSE
;

1767 
	`kGCacheBufrAndCou
(
CACHE_DATAAREA
,&
pCacheBufr
,&
iCacheCou
);

1768 
i
=0;i<
iCacheCou
;i++)

1771 if(
pCacheBufr
[
i
].
bChged
==
TRUE
)

1773 if(
	`kIlWreCluWhoutCache
(
pCacheBufr
[
i
].
dwTag
,pCacheBufr[i].
pbBufr
)==
FALSE
)

1775  
FALSE
;

1779 
pCacheBufr
[
i
].
bChged
 = 
FALSE
;

1784 
	`kUock
(&(
gs_FeSyemMag
.
Mux
));

1785  
TRUE
;

1786 
	}
}

	@/home/jk/os/MINT64/save/02.Kernel64/Source/FileSystem.h

1 #ide
__FILESYSTEM_H__


2 
	#__FILESYSTEM_H__


	)

4 
	~"Tys.h
"

5 
	~"Synchrizi.h
"

6 
	~"HdDisk.h
"

7 
	~"CacheMag.h
"

11 
	#FILESYSTEM_SIGNATUR
 0x7E38CF10

	)

13 
	#FILESYSTEM_SECTORPERCLUSTER
 8

	)

15 
	#FILESYSTEM_LASTCLUSTER
 0xFFFFFFFF

	)

17 
	#FILESYSTEM_FREECLUSTER
 0x00

	)

19 
	#FILESYSTEM_MAXDIRECTORYENTRYCOUNT
 ((
FILESYSTEM_SECTORPERCLUSTER
*512)/(
DIRECTORYENTRY
))

	)

21 
	#FILESYSTEM_CLUSTERSIZE
 (
FILESYSTEM_SECTORPERCLUSTER
*512)

	)

24 
	#FILESYSTEM_HANDLE_MAXCOUNT
 (
TASK_MAXCOUNT
*3)

	)

27 
	#FILESYSTEM_MAXFILENAMELENGTH
 24

	)

30 
	#FILESYSTEM_TYPE_FREE
 0

	)

31 
	#FILESYSTEM_TYPE_FILE
 1

	)

32 
	#FILESYSTEM_TYPE_DIRECTORY
 2

	)

35 
	#FILESYSTEM_SEEK_SET
 0

	)

36 
	#FILESYSTEM_SEEK_CUR
 1

	)

37 
	#FILESYSTEM_SEEK_END
 2

	)

40 
	$BOOL
 (*
	tfRdHDDInfmi
(
	tBOOL
 
	tbPrimy
,BOOL 
	tbMa
,
	tHDDINFORMATION
* 
	tpHDDInfmi
);

41 (*
	tfRdHDDSe
(
	tBOOL
 
	tbPrimy
,BOOL 
	tbMa
,
	tDWORD
 
	tdwLBA
,
	tiSeCou
,* 
	tpcBufr
);

42 (*
	tfWreHDDSe
(
	tBOOL
 
	tbPrimy
,BOOL 
	tbMa
,
	tDWORD
 
	tdwLBA
,
	tiSeCou
,* 
	tpcBufr
);

45 
	#fݒ
 
kOnFe


	)

46 
	#d
 
kRdFe


	)

47 
	#fwre
 
kWreFe


	)

48 
	#fek
 
kSkFe


	)

49 
	#fo
 
kCloFe


	)

50 
	#move
 
kRemoveFe


	)

51 
	#ݒd
 
kOnDey


	)

52 
	#add
 
kRdDey


	)

53 
	#wdd
 
kRewdDey


	)

54 
	#od
 
kCloDey


	)

57 
	#SEEK_SET
 
FILESYSTEM_SEEK_SET


	)

58 
	#SEEK_CUR
 
FILESYSTEM_SEEK_CUR


	)

59 
	#SEEK_END
 
FILESYSTEM_SEEK_END


	)

62 
	#size_t
 
DWORD


	)

63 
	#dt
 
kDeyErySu


	)

64 
	#d_me
 
vcFeName


	)

68 #agm
	`ck
(
push
,1)

71 
	skPtiSu


74 
BYTE
 
bBoabFg
;

76 
BYTE
 
vbSgCHSAddss
[3];

78 
BYTE
 
bPtiTy
;

80 
BYTE
 
vbEndgCHSAddss
[3];

82 
DWORD
 
dwSgLBAAddss
;

84 
DWORD
 
dwSizeInSe
;

85 } 
	tPARTITION
;

88 
	skMBRSu


91 
BYTE
 
vbBoCode
[430];

94 
DWORD
 
dwSigtu
;

96 
DWORD
 
dwRervedSeCou
;

98 
DWORD
 
dwCluLkSeCou
;

100 
DWORD
 
dwTٮCluCou
;

103 
PARTITION
 
vPt
[4];

106 
BYTE
 
vbBoLdSigtu
[2];

107 } 
	tMBR
;

110 
	skDeyErySu


113 
vcFeName
[
FILESYSTEM_MAXFILENAMELENGTH
];

115 
DWORD
 
dwFeSize
;

117 
DWORD
 
dwSCluIndex
;

118 } 
	tDIRECTORYENTRY
;

121 
	skFeHdSu


124 
iDeyEryOfft
;

126 
DWORD
 
dwFeSize
;

128 
DWORD
 
dwSCluIndex
;

130 
DWORD
 
dwCutCluIndex
;

132 
DWORD
 
dwPviousCluIndex
;

134 
DWORD
 
dwCutOfft
;

135 } 
	tFILEHANDLE
;

138 
	skDeyHdSu


141 
DIRECTORYENTRY
* 
pDeyBufr
;

144 
iCutOfft
;

145 } 
	tDIRECTORYHANDLE
;

148 
	skFeDeyHdSu


151 
BYTE
 
bTy
;

157 
FILEHANDLE
 
FeHd
;

159 
DIRECTORYHANDLE
 
DeyHd
;

161 } 
	tFILE
, 
	tDIR
;

165 
	skFeSyemMagSu


168 
BOOL
 
bMoued
;

171 
DWORD
 
dwRervedSeCou
;

172 
DWORD
 
dwCluLkAaSAddss
;

173 
DWORD
 
dwCluLkAaSize
;

174 
DWORD
 
dwDaAaSAddss
;

176 
DWORD
 
dwTٮCluCou
;

179 
DWORD
 
dwLaAoduLkSeOfft
;

182 
MUTEX
 
Mux
;

185 
FILE
* 
pHdPo
;

188 
BOOL
 
bCacheEb
;

189 } 
	tFILESYSTEMMANAGER
;

191 #agm
	`ck
(
p
)

194 
BOOL
 
	`kInlizeFeSyem
();

195 
BOOL
 
	`kFm
();

196 
BOOL
 
	`kMou
();

197 
BOOL
 
	`kGHDDInfmi
(
HDDINFORMATION
* 
pInfmi
);

200 
	`kGFeSyemInfmi
(
FILESYSTEMMANAGER
* 
pMag
);

203 
FILE
* 
	`kOnFe
(cڡ * 
pcFeName
,cڡ * 
pcMode
);

204 
DWORD
 
	`kRdFe
(* 
pvBufr
,DWORD 
dwSize
,DWORD 
dwCou
,
FILE
* 
pFe
);

205 
DWORD
 
	`kWreFe
(cڡ * 
pvBufr
,DWORD 
dwSize
,DWORD 
dwCou
,
FILE
* 
pFe
);

206 
	`kSkFe
(
FILE
* 
pFe
,
iOfft
,
iOrig
);

207 
	`kCloFe
(
FILE
* 
pFe
);

208 
	`kRemoveFe
(cڡ * 
pcFeName
);

209 
DIR
* 
	`kOnDey
(cڡ * 
pcDeyName
);

210 
kDeyErySu
* 
	`kRdDey
(
DIR
* 
pDey
);

211 
	`kRewdDey
(
DIR
* 
pDey
);

212 
	`kCloDey
(
DIR
* 
pDey
);

213 
BOOL
 
	`kWreZo
(
FILE
* 
pFe
,
DWORD
 
dwCou
);

214 
BOOL
 
	`kIsFeOd
(cڡ 
DIRECTORYENTRY
* 
pEry
);

217 
BOOL
 
	`kFlushFeSyemCache
();

	@/home/jk/os/MINT64/save/02.Kernel64/Source/HardDisk.c

1 
	~"HdDisk.h
"

4 
HDDMANAGER
 
	ggs_HDDMag
;

7 
kSwByInWd
(
WORD
* 
pwDa
,
iWdCou
);

8 
BYTE
 
kRdHDDStus
(
BOOL
 
bPrimy
);

9 
BOOL
 
kIsHDDBusy
(BOOL 
bPrimy
);

10 
BOOL
 
kISHDDRdy
(BOOL 
bPrimy
);

11 
BOOL
 
kWaFHDDNoBusy
(BOOL 
bPrimy
);

12 
BOOL
 
kWaFHDDIru
(BOOL 
bPrimy
);

15 
BOOL
 
	$kInlizeHDD
()

18 
	`kInlizeMux
(&(
gs_HDDMag
.
Mux
));

21 
gs_HDDMag
.
bPrimyIruOccur
 = 
FALSE
;

22 
gs_HDDMag
.
bSecdyIruOccur
 = 
FALSE
;

26 
	`kOutPtBy
(
HDD_PORT_PRIMARYBASE
+
HDD_PORT_INDEX_DIGITALOUTPUT
,0);

27 
	`kOutPtBy
(
HDD_PORT_SECONDARYBASE
+
HDD_PORT_INDEX_DIGITALOUTPUT
,0);

30 if(
	`kRdHDDInfmi
(
TRUE
,TRUE,&(
gs_HDDMag
.
HDDInfmi
))==
FALSE
)

32 
gs_HDDMag
.
bHDDDeed
 = 
FALSE
;

33 
gs_HDDMag
.
bCWre
 = 
FALSE
;

34  
FALSE
;

38 
gs_HDDMag
.
bHDDDeed
 = 
TRUE
;

39 if(
	`kMemCmp
(
gs_HDDMag
.
HDDInfmi
.
vwModNumb
,"QEMU",4)==0)

41 
gs_HDDMag
.
bCWre
 = 
TRUE
;

45 
gs_HDDMag
.
bCWre
 = 
FALSE
;

48  
TRUE
;

49 
	}
}

52 
BYTE
 
	$kRdHDDStus
(
BOOL
 
bPrimy
)

54 if(
bPrimy
 =
TRUE
)

57  
	`kInPtBy
(
HDD_PORT_PRIMARYBASE
+
HDD_PORT_INDEX_STATUS
);

60  
	`kInPtBy
(
HDD_PORT_SECONDARYBASE
+
HDD_PORT_INDEX_STATUS
);

61 
	}
}

64 
BOOL
 
	$kWaFHDDNoBusy
(
BOOL
 
bPrimy
)

66 
QWORD
 
qwSTickCou
;

67 
BYTE
 
bStus
;

70 
qwSTickCou
 = 
	`kGTickCou
();

73 (
	`kGTickCou
()-
qwSTickCou
)<=
HDD_WAITTIME
)

76 
bStus
 = 
	`kRdHDDStus
(
bPrimy
);

79 if((
bStus
&
HDD_STATUS_BUSY
)!=HDD_STATUS_BUSY)

81  
TRUE
;

84 
	`kS˕
(1);

87  
FALSE
;

88 
	}
}

91 
BOOL
 
	$kWaFHDDRdy
(
BOOL
 
bPrimy
)

93 
QWORD
 
qwSTickCou
;

94 
BYTE
 
bStus
;

97 
qwSTickCou
 = 
	`kGTickCou
();

100 (
	`kGTickCou
()-
qwSTickCou
)<=
HDD_WAITTIME
)

103 
bStus
 = 
	`kRdHDDStus
(
bPrimy
);

106 if((
bStus
&
HDD_STATUS_READY
)==HDD_STATUS_READY)

108  
TRUE
;

111 
	`kS˕
(1);

114  
FALSE
;

115 
	}
}

118 
	$kSHDDIruFg
(
BOOL
 
bPrimy
,BOOL 
bFg
)

120 if(
bPrimy
==
TRUE
)

122 
gs_HDDMag
.
bPrimyIruOccur
 = 
bFg
;

126 
gs_HDDMag
.
bSecdyIruOccur
 = 
bFg
;

128 
	}
}

131 
BOOL
 
	$kWaFHDDIru
(
BOOL
 
bPrimy
)

133 
QWORD
 
qwTickCou
;

136 
qwTickCou
 = 
	`kGTickCou
();

139 (
	`kGTickCou
()-
qwTickCou
)<=
HDD_WAITTIME
)

142 if((
bPrimy
==
TRUE
)&&(
gs_HDDMag
.
bPrimyIruOccur
==TRUE))

144  
TRUE
;

146 if((
bPrimy
==
FALSE
)&&(
gs_HDDMag
.
bSecdyIruOccur
==
TRUE
))

148  
TRUE
;

153  
FALSE
;

154 
	}
}

157 
BOOL
 
	$kRdHDDInfmi
(
BOOL
 
bPrimy
,BOOL 
bMa
,
HDDINFORMATION
* 
pHDDInfmi
)

159 
WORD
 
wPtBa
;

160 
QWORD
 
qwLaTickCou
;

161 
BYTE
 
bStus
;

162 
BYTE
 
bDriveFg
;

163 
i
;

164 
WORD
 
wTemp
;

165 
BOOL
 
bWaResu
;

168 if(
bPrimy
==
TRUE
)

171 
wPtBa
 = 
HDD_PORT_PRIMARYBASE
;

176 
wPtBa
 = 
HDD_PORT_SECONDARYBASE
;

180 
	`kLock
(&(
gs_HDDMag
.
Mux
));

183 if(
	`kWaFHDDNoBusy
(
bPrimy
)==
FALSE
)

186 
	`kUock
(&(
gs_HDDMag
.
Mux
));

187  
FALSE
;

195 if(
bMa
==
TRUE
)

198 
bDriveFg
 = 
HDD_DRIVEANDHEAD_LBA
;

203 
bDriveFg
 = 
HDD_DRIVEANDHEAD_LBA
 | 
HDD_DRIVEANDHEAD_SLAVE
;

207 
	`kOutPtBy
(
wPtBa
+
HDD_PORT_INDEX_DRIVEANDHEAD
,
bDriveFg
);

213 if(
	`kWaFHDDRdy
(
bPrimy
)==
FALSE
)

216 
	`kUock
(&(
gs_HDDMag
.
Mux
));

217  
FALSE
;

221 
	`kSHDDIruFg
(
bPrimy
,
FALSE
);

224 
	`kOutPtBy
(
wPtBa
+
HDD_PORT_INDEX_COMMAND
,
HDD_COMMAND_IDENTIFY
);

227 
bWaResu
 = 
	`kWaFHDDIru
(
bPrimy
);

229 
bStus
 = 
	`kRdHDDStus
(
bPrimy
);

230 if((
bWaResu
==
FALSE
)||((
bStus
&
HDD_STATUS_ERROR
)==HDD_STATUS_ERROR))

233 
	`kUock
(&(
gs_HDDMag
.
Mux
));

234  
FALSE
;

241 
i
=0;i<512/2;i++)

243 ((
WORD
*)
pHDDInfmi
)[
i
]=
	`kInPtWd
(
wPtBa
+
HDD_PORT_INDEX_DATA
);

247 
	`kSwByInWd
(
pHDDInfmi
->
vwModNumb
,(pstHDDInformation->vwModelNumber)/2);

248 
	`kSwByInWd
(
pHDDInfmi
->
vwSlNumb
,(pstHDDInformation->vwSerialNumber)/2);

251 
	`kUock
(&(
gs_HDDMag
.
Mux
));

252  
TRUE
;

253 
	}
}

256 
	$kSwByInWd
(
WORD
* 
pwDa
,
iWdCou
)

258 
i
;

259 
WORD
 
wTemp
;

261 
i
=0;i<
iWdCou
;i++)

263 
wTemp
 = 
pwDa
[
i
];

264 
pwDa
[
i
]=(
wTemp
>>8)|(wTemp<<8);

266 
	}
}

271 
	$kRdHDDSe
(
BOOL
 
bPrimy
,BOOL 
bMa
,
DWORD
 
dwLBA
,
iSeCou
,* 
pcBufr
)

273 
WORD
 
wPtBa
;

274 
i
,
j
;

275 
BYTE
 
bDriveFg
;

276 
BYTE
 
bStus
;

277 
lRdCou
=0;

278 
BOOL
 
bWaResu
;

281 if((
gs_HDDMag
.
bHDDDeed
==
FALSE
)||(
iSeCou
<=0)||(256<iSeCou)||((
dwLBA
+iSeCou)>=gs_HDDMag.
HDDInfmi
.
dwTٮSes
))

287 if(
bPrimy
==
TRUE
)

290 
wPtBa
 = 
HDD_PORT_PRIMARYBASE
;

295 
wPtBa
 = 
HDD_PORT_SECONDARYBASE
;

299 
	`kLock
(&(
gs_HDDMag
.
Mux
));

302 if(
	`kWaFHDDNoBusy
(
bPrimy
)==
FALSE
)

305 
	`kUock
(&(
gs_HDDMag
.
Mux
));

306  
FALSE
;

314 
	`kOutPtBy
(
wPtBa
+
HDD_PORT_INDEX_SECTORCOUNT
,
iSeCou
);

316 
	`kOutPtBy
(
wPtBa
+
HDD_PORT_INDEX_SECTORNUMBER
,
dwLBA
);

318 
	`kOutPtBy
(
wPtBa
+
HDD_PORT_INDEX_CYLINDERLSB
,
dwLBA
>>8);

320 
	`kOutPtBy
(
wPtBa
+
HDD_PORT_INDEX_CYLINDERMSB
,
dwLBA
>>16);

322 if(
bMa
==
TRUE
)

324 
bDriveFg
 = 
HDD_DRIVEANDHEAD_LBA
;

328 
bDriveFg
 = 
HDD_DRIVEANDHEAD_LBA
|
HDD_DRIVEANDHEAD_SLAVE
;

332 
	`kOutPtBy
(
wPtBa
+
HDD_PORT_INDEX_DRIVEANDHEAD
,
bDriveFg
|((
dwLBA
>>24)&0x0F));

338 if(
	`kWaFHDDRdy
(
bPrimy
)==
FALSE
)

341 
	`kUock
(&(
gs_HDDMag
.
Mux
));

342  
FALSE
;

346 
	`kSHDDIruFg
(
bPrimy
,
FALSE
);

349 
	`kOutPtBy
(
wPtBa
+
HDD_PORT_INDEX_COMMAND
,
HDD_COMMAND_READ
);

355 
i
=0;i<
iSeCou
;i++)

358 
bStus
 = 
	`kRdHDDStus
(
bPrimy
);

359 if((
bStus
&
HDD_STATUS_ERROR
)==HDD_STATUS_ERROR)

361 
	`kPrtf
("Error Occur\n");

363 
	`kUock
(&(
gs_HDDMag
.
Mux
));

364  
i
;

368 if((
bStus
&
HDD_STATUS_DATAREQUEST
)!=HDD_STATUS_DATAREQUEST)

371 
bWaResu
 = 
	`kWaFHDDIru
(
bPrimy
);

372 
	`kSHDDIruFg
(
bPrimy
,
FALSE
);

374 if(
bWaResu
==
FALSE
)

377 if((
bStus
&
HDD_STATUS_DATAREQUEST
)!=HDD_STATUS_DATAREQUEST)

379 
	`kPrtf
("Interrupt Not Occur\n");

381 
	`kUock
(&(
gs_HDDMag
.
Mux
));

382  
FALSE
;

388 
j
=0;j<512/2;j++)

390 ((
WORD
*)
pcBufr
)[
lRdCou
++]=
	`kInPtWd
(
wPtBa
+
HDD_PORT_INDEX_DATA
);

395 
	`kUock
(&(
gs_HDDMag
.
Mux
));

396  
i
;

397 
	}
}

402 
	$kWreHDDSe
(
BOOL
 
bPrimy
,BOOL 
bMa
,
DWORD
 
dwLBA
,
iSeCou
,* 
pcBufr
)

404 
WORD
 
wPtBa
;

405 
WORD
 
WTemp
;

406 
i
,
j
;

407 
BYTE
 
bDriveFg
;

408 
BYTE
 
bStus
;

409 
lRdCou
=0;

410 
BOOL
 
bWaResu
;

413 if((
gs_HDDMag
.
bCWre
==
FALSE
)||(
iSeCou
<=0)||(256<iSeCou)||((
dwLBA
+iSeCou)>=gs_HDDMag.
HDDInfmi
.
dwTٮSes
))

419 if(
bPrimy
==
TRUE
)

422 
wPtBa
 = 
HDD_PORT_PRIMARYBASE
;

427 
wPtBa
 = 
HDD_PORT_SECONDARYBASE
;

431 if(
	`kWaFHDDNoBusy
(
bPrimy
)==
FALSE
)

433  
FALSE
;

437 
	`kLock
(&(
gs_HDDMag
.
Mux
));

443 
	`kOutPtBy
(
wPtBa
+
HDD_PORT_INDEX_SECTORCOUNT
,
iSeCou
);

445 
	`kOutPtBy
(
wPtBa
+
HDD_PORT_INDEX_SECTORNUMBER
,
dwLBA
);

447 
	`kOutPtBy
(
wPtBa
+
HDD_PORT_INDEX_CYLINDERLSB
,
dwLBA
>>8);

449 
	`kOutPtBy
(
wPtBa
+
HDD_PORT_INDEX_CYLINDERMSB
,
dwLBA
>>16);

451 if(
bMa
==
TRUE
)

453 
bDriveFg
 = 
HDD_DRIVEANDHEAD_LBA
;

457 
bDriveFg
 = 
HDD_DRIVEANDHEAD_LBA
|
HDD_DRIVEANDHEAD_SLAVE
;

461 
	`kOutPtBy
(
wPtBa
+
HDD_PORT_INDEX_DRIVEANDHEAD
,
bDriveFg
|((
dwLBA
>>24)&0x0F));

467 if(
	`kWaFHDDRdy
(
bPrimy
)==
FALSE
)

470 
	`kUock
(&(
gs_HDDMag
.
Mux
));

471  
FALSE
;

476 
	`kOutPtBy
(
wPtBa
+
HDD_PORT_INDEX_COMMAND
,
HDD_COMMAND_WRITE
);

481 
bStus
 = 
	`kRdHDDStus
(
bPrimy
);

483 if((
bStus
&
HDD_STATUS_ERROR
)==HDD_STATUS_ERROR)

486 
	`kUock
(&(
gs_HDDMag
.
Mux
));

491 if((
bStus
&
HDD_STATUS_DATAREQUEST
)==HDD_STATUS_DATAREQUEST)

496 
	`kS˕
(1);

503 
i
=0;i<
iSeCou
;i++)

506 
	`kSHDDIruFg
(
bPrimy
,
FALSE
);

507 
j
=0;j<512/2;j++)

509 
	`kOutPtWd
(
wPtBa
+
HDD_PORT_INDEX_DATA
,((
WORD
*)
pcBufr
)[
lRdCou
++]);

513 
bStus
 = 
	`kRdHDDStus
(
bPrimy
);

514 if((
bStus
&
HDD_STATUS_ERROR
)==HDD_STATUS_ERROR)

517 
	`kUock
(&(
gs_HDDMag
.
Mux
));

518  
i
;

522 if((
bStus
&
HDD_STATUS_DATAREQUEST
)!=HDD_STATUS_DATAREQUEST)

525 
bWaResu
 = 
	`kWaFHDDIru
(
bPrimy
);

526 
	`kSHDDIruFg
(
bPrimy
,
FALSE
);

528 if(
bWaResu
==
FALSE
)

530 if((
bStus
&
HDD_STATUS_DATAREQUEST
)!=HDD_STATUS_DATAREQUEST)

533 
	`kPrtf
("Interrupt Not Occur\n");

534 
	`kUock
(&(
gs_HDDMag
.
Mux
));

535  
FALSE
;

543 
	`kUock
(&(
gs_HDDMag
.
Mux
));

544  
i
;

545 
	}
}

	@/home/jk/os/MINT64/save/02.Kernel64/Source/HardDisk.h

1 #ide
__HARDDISK_H__


2 
	#__HARDDISK_H__


	)

4 
	~"Tys.h
"

5 
	~"Synchrizi.h
"

9 
	#HDD_PORT_PRIMARYBASE
 0x1F0

	)

10 
	#HDD_PORT_SECONDARYBASE
 0x170

	)

13 
	#HDD_PORT_INDEX_DATA
 0x00

	)

14 
	#HDD_PORT_INDEX_SECTORCOUNT
 0x02

	)

15 
	#HDD_PORT_INDEX_SECTORNUMBER
 0x03

	)

16 
	#HDD_PORT_INDEX_CYLINDERLSB
 0x04

	)

17 
	#HDD_PORT_INDEX_CYLINDERMSB
 0x05

	)

18 
	#HDD_PORT_INDEX_DRIVEANDHEAD
 0x06

	)

19 
	#HDD_PORT_INDEX_STATUS
 0x07

	)

20 
	#HDD_PORT_INDEX_COMMAND
 0x07

	)

21 
	#HDD_PORT_INDEX_DIGITALOUTPUT
 0x206

	)

24 
	#HDD_COMMAND_READ
 0x20

	)

25 
	#HDD_COMMAND_WRITE
 0x30

	)

26 
	#HDD_COMMAND_IDENTIFY
 0xEC

	)

29 
	#HDD_STATUS_ERROR
 0x01

	)

30 
	#HDD_STATUS_INDEX
 0x02

	)

31 
	#HDD_STATUS_CORRECTEDDATA
 0x04

	)

32 
	#HDD_STATUS_DATAREQUEST
 0x08

	)

33 
	#HDD_STATUS_SEEKCOMPLETE
 0x10

	)

34 
	#HDD_STATUS_WRITEFAULT
 0x20

	)

35 
	#HDD_STATUS_READY
 0x40

	)

36 
	#HDD_STATUS_BUSY
 0x80

	)

39 
	#HDD_DRIVEANDHEAD_LBA
 0xE0

	)

40 
	#HDD_DRIVEANDHEAD_SLAVE
 0x10

	)

43 
	#HDD_DIGITALOUTPUT_RESET
 0x04

	)

44 
	#HDD_DIGITALOUTPUT_DISABLEINTERRUPT
 0x01

	)

47 
	#HDD_WAITTIME
 500

	)

49 
	#HDD_MAXBULKSECTORCOUNT
 256

	)

53 #agm
ck
(
push
,1)

55 
	skHDDInfmiSu


58 
WORD
 
	mwCfigui
;

61 
WORD
 
	mwNumbOfCyld
;

62 
WORD
 
	mwRerved1
;

65 
WORD
 
	mwNumbOfHd
;

66 
WORD
 
	mwUnfmdByPTck
;

67 
WORD
 
	mwUnfmdByPSe
;

70 
WORD
 
	mwNumbOfSePCyld
;

71 
WORD
 
	mwISeG
;

72 
WORD
 
	mwBysInPhaLock
;

73 
WORD
 
	mwNumbOfVdUniqueStusWd
;

76 
WORD
 
	mvwSlNumb
[10];

77 
WORD
 
	mwCڌrTy
;

78 
WORD
 
	mwBufrSize
;

79 
WORD
 
	mwNumbOfECCBys
;

80 
WORD
 
	mvwFmweRevisi
[4];

83 
WORD
 
	mvwModNumb
[20];

84 
WORD
 
	mvwRerved2
[13];

87 
DWORD
 
	mdwTٮSes
;

88 
WORD
 
	mvwRerved3
[196];

89 } 
	tHDDINFORMATION
;

91 #agm
ck
(
p
)

94 
	skHDDMagSu


97 
BOOL
 
	mbHDDDeed
;

98 
BOOL
 
	mbCWre
;

101 vީ
BOOL
 
	mbPrimyIruOccur
;

102 vީ
BOOL
 
	mbSecdyIruOccur
;

103 
MUTEX
 
	mMux
;

106 
HDDINFORMATION
 
	mHDDInfmi
;

107 } 
	tHDDMANAGER
;

109 
BOOL
 
kInlizeHDD
();

110 
BOOL
 
kRdHDDInfmi
(BOOL 
bPrimy
,BOOL 
bMa
,
HDDINFORMATION
* 
pHDDInfmi
);

111 
kRdHDDSe
(
BOOL
 
bPrimy
,BOOL 
bMa
,
DWORD
 
dwLBA
,
iSeCou
,* 
pcBufr
);

112 
kWreHDDSe
(
BOOL
 
bPrimy
,BOOL 
bMa
,
DWORD
 
dwLBA
,
iSeCou
,* 
pcBufr
);

113 
kSHDDIruFg
(
BOOL
 
bPrimy
,BOOL 
bFg
);

	@/home/jk/os/MINT64/save/02.Kernel64/Source/ISR.asm

1 [
BITS
 64] ; 이하의 코드는 64비트 코드로 설정

3 
	gSECTION
 .
	gxt
 ;ext 섹션(세그먼트)을 정의

5 ; 외부에서 정의된 함수를 쓸 수 있도록 선엄함(
	gImpt
)

6 
kCommExiHdr
, 
kCommIruHdr
, 
kKeybrdHdr


7 
kTimHdr
, 
kDeviNAvaabHdr
, 
kHDDHdr


9 ; 
	gC
 언어에서 호출할 수 있도록 이름을 노출함(
	gExpt
)

10 ; 예외(
	gExi
처리를 위한 
ISR


11 
glob
 
	gkISRDivideE
, 
	gkISRDebug
, 
	gkISRNMI
, 
	gkISRBakPot
, 
kISROvow


12 
glob
 
	gkISRBoundRgeExeded
, 
	gkISRInvidOpcode
, 
	gkISRDeviNAvaab
, 
	gkISRDoubFau
,

13 
glob
 
	gkISRCrossSegmtOvrun
, 
	gkISRInvidTSS
, 
kISRSegmtNP


14 
glob
 
	gkISRSckSegmtFau
, 
	gkISRGPrei
, 
	gkISRPageFau
, 
kISR15


15 
glob
 
	gkISRFPUE
, 
	gkISRAlignmtCheck
, 
	gkISRMacheCheck
, 
	gkISRSIMDE
, 
	gkISRETCExi


17 ; 인터럽트(
	gIru
처리를 위한 
ISR


18 
glob
 
	gkISRTim
, 
	gkISRKeybrd
, 
	gkISRSvePIC
, 
	gkISRSl2
, 
	gkISRSl1
, 
kISRPl2


19 
glob
 
	gkISRFlpy
, 
	gkISRPl1
, 
	gkISRRTC
, 
	gkISRRerved
, 
	gkISRNUd1
, 
kISRNUd2


20 
glob
 
	gkISRMou
, 
	gkISRCross
, 
	gkISRHDD1
, 
	gkISRHDD2
, 
	gkISRETCIru


22 ; 
	gcڋxt
를 저장하고 셀렉터를 교체하는 매크로

23 %
mao
 
	gKSAVECONTEXT
 0 ; 파라미터를 전달받지 않는 KSAVECONTEXT 매크로 정의

24 ; 
	gRBP
 레지스터부터 
	gGS
 세그먼트 셀렉터까지 모두 스택에 삽입

25 
push
 
rbp


26 
mov
 
	grbp
, 
r


27 
push
 
x


28 
push
 
rbx


29 
push
 
rcx


30 
push
 
rdx


31 
push
 
rdi


32 
push
 
rsi


33 
push
 
r8


34 
push
 
r9


35 
push
 
r10


36 
push
 
r11


37 
push
 
r12


38 
push
 
r13


39 
push
 
r14


40 
push
 
r15


42 
mov
 
	gax
, 
	gds
 ; 
	gDS
 세그먼트 셀렉터와 
	gES
 세그먼트 셀렉터는 스택에 직접 삽입할 수 없으므로 
	gRAX
 레지스터에 저장한 후 스택에 삽입

43 
push
 
x


44 
mov
 
	gax
, 
es


45 
push
 
x


46 
push
 
fs


47 
push
 
	ggs


50 
mov
 
	gax
, 0x10 ; 
	gAX
 레지스터에 커널 데이터 세그먼트 디스크립터 저장

51 
mov
 
	gds
, 
	gax
 ; 
	gDS
 세그먼트 셀렉터부터 
	gFS
 세그먼트 셀렉터까지 모두 커널 데이터 세그먼트로 교체

52 
mov
 
	ges
, 
ax


53 
mov
 
	ggs
, 
ax


54 
mov
 
	gfs
, 
	gax


55 %
	gdmao
 ; 매크로 끝

58 ; 
	gcڋxt
를 복원하는 매크로

59 %
mao
 
	gKLOADCONTEXT
 0 ; 파라미터를 전달받지 않는 KLOADCONTEXT 매크로 정의

60 ; 
	gGS
 세그먼트 셀렉터부터 
	gRBP
 레지스터까지 모두 스택에서 꺼내 복원

61 
p
 
gs


62 
p
 
fs


63 
p
 
x


64 
mov
 
	ges
, 
	gax
 ; 
	gES
 세그먼트 셀렉터와 
	gDS
 세그먼트 셀렉터는 스택에 직접 꺼내 복원할 수 없으므로 
	gRAX
 레지스터에 저장한 뒤에 복원

65 
p
 
x


66 
mov
 
	gds
, 
ax


68 
p
 
r15


69 
p
 
r14


70 
p
 
r13


71 
p
 
r12


72 
p
 
r11


73 
p
 
r10


74 
p
 
r9


75 
p
 
r8


76 
p
 
rsi


77 
p
 
rdi


78 
p
 
rdx


79 
p
 
rcx


80 
p
 
rbx


81 
p
 
x


82 
p
 
	grbp


83 %
	gdmao
 ; 매크로 끝

90 ; #0, 
Divide
 
E
 
ISR


91 
	gkISRDivideE
:

92 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

95 
mov
 
	grdi
, 0

96 

 
kCommExiHdr


98 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

99 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

101 ; #1, 
Debug
 
ISR


102 
	gkISRDebug
:

103 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

106 
mov
 
	grdi
, 1

107 

 
kCommExiHdr


109 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

110 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

112 ; #2, 
NMI
 
ISR


113 
	gkISRNMI
:

114 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

117 
mov
 
	grdi
, 2

118 

 
kCommExiHdr


120 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

121 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

123 ; #3, 
BakPot
 
ISR


124 
	gkISRBakPot
:

125 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

128 
mov
 
	grdi
, 3

129 

 
kCommExiHdr


131 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

132 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

134 ; #4, 
Ovow
 
ISR


135 
	gkISROvow
:

136 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

139 
mov
 
	grdi
, 4

140 

 
kCommExiHdr


142 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

143 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

145 ; #5, 
Bound
 
Rge
 
Exeded
 
ISR


146 
	gkISRBoundRgeExeded
:

147 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

150 
mov
 
	grdi
, 5

151 

 
kCommExiHdr


153 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

154 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

156 ; #6, 
Invid
 
Opcode
 
ISR


157 
	gkISRInvidOpcode
:

158 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

161 
mov
 
	grdi
, 6

162 

 
kCommExiHdr


164 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

165 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

167 ; #7, 
Devi
 
N
 
Avaab
 
ISR


168 
	gkISRDeviNAvaab
:

169 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

172 
mov
 
	grdi
, 7

173 

 
kDeviNAvaabHdr


175 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

176 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

178 ; #8, 
Doub
 
Fau
 
ISR


179 
	gkISRDoubFau
:

180 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

183 
mov
 
	grdi
, 8

184 
mov
 
	grsi
,
	gqwd
[
rbp
+8]

185 

 
kCommExiHdr


187 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

188 
add
 
	gr
,8 ; 에러 코드를 스택에서 제거

189 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

191 ; #9, 
Cross
 
Segmt
 
Ovrun
 
ISR


192 
	gkISRCrossSegmtOvrun
:

193 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

196 
mov
 
	grdi
, 9

197 

 
kCommExiHdr


199 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

200 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

202 ; #10, 
Invid
 
TSS
 
ISR


203 
	gkISRInvidTSS
:

204 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

207 
mov
 
	grdi
, 10

208 
mov
 
	grsi
, 
	gqwd
[
rbp
+8]

209 

 
kCommExiHdr


211 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

212 
add
 
	gr
, 8 ; 에러 코드를 스택에서 제거

213 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

215 ; #11, 
Segmt
 
N
 
P
 
ISR


216 
	gkISRSegmtNP
:

217 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

220 
mov
 
	grdi
, 11

221 
mov
 
	grsi
, 
	gqwd
[
rbp
+8]

222 

 
kCommExiHdr


224 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

225 
add
 
	gr
, 8 ; 에러 코드를 스택에서 제거

226 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

228 ; #12, 
Sck
 
Segmt
 
Fau
 
ISR


229 
	gkISRSckSegmtFau
:

230 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

233 
mov
 
	grdi
, 12

234 
mov
 
	grsi
, 
	gqwd
[
rbp
+8]

235 

 
kCommExiHdr


237 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

238 
add
 
	gr
, 8 ; 에러 코드를 스택에서 제거

239 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

241 ; #13, 
G
 
Prei
 
ISR


242 
	gkISRGPrei
:

243 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

246 
mov
 
	grdi
, 13

247 
mov
 
	grsi
, 
	gqwd
[
rbp
+8]

248 

 
kCommExiHdr


250 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

251 
add
 
	gr
, 8 ; 에러 코드를 스택에서 제거

252 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

254 ; #14, 
Page
 
Fau
 
ISR


255 
	gkISRPageFau
:

256 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

259 
mov
 
	grdi
, 14

260 
mov
 
	grsi
, 
	gqwd
[
rbp
+8]

261 

 
kCommExiHdr


263 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

264 
add
 
	gr
, 8 ; 에러 코드를 스택에서 제거

265 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

267 ; #15, 
Rerved
 
ISR


268 
	gkISR15
:

269 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

272 
mov
 
	grdi
, 15

273 

 
kCommExiHdr


275 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

276 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

278 ; #16, 
FPU
 
E
 
ISR


279 
	gkISRFPUE
:

280 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

283 
mov
 
	grdi
, 16

284 

 
kCommExiHdr


286 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

287 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

289 ; #17, 
Alignmt
 
Check
 
ISR


290 
	gkISRAlignmtCheck
:

291 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

294 
mov
 
	grdi
, 17

295 
mov
 
	grsi
, 
	gqwd
[
rbp
+8]

296 

 
kCommExiHdr


298 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

299 
add
 
	gr
, 8 ; 에러 코드를 스택에서 제거

300 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

302 ; #18, 
Mache
 
Check
 
ISR


303 
	gkISRMacheCheck
:

304 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

307 
mov
 
	grdi
, 18

308 

 
kCommExiHdr


310 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

311 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

313 ; #19, 
SIME
 
Fltg
 
Pot
 
Exi
 
ISR


314 
	gkISRSIMDE
:

315 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

318 
mov
 
	grdi
, 19

319 

 
kCommExiHdr


321 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

322 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

324 ; #20~#31, 
Rerved
 
ISR


325 
	gkISRETCExi
:

326 
KSAVECONTEXT
 ; 콘텍스트를 젖아한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

329 
mov
 
	grdi
, 20

330 

 
kCommExiHdr


332 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

333 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행되던 코드로 복원

341 ; #32, 타이머 
ISR


342 
	gkISRTim
:

343 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

346 
mov
 
	grdi
, 32

347 

 
kTimHdr


349 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

350 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

352 ; #33, 키보드 
ISR


353 
	gkISRKeybrd
:

354 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

357 
mov
 
	grdi
, 33

358 

 
kKeybrdHdr


360 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

361 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

363 ; #34, 슬레이브 
PIC
 
ISR


364 
	gkISRSvePIC
:

365 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

368 
mov
 
	grdi
, 34

369 

 
kCommIruHdr


371 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

372 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

374 ; #35, 시리얼 포트 2 
ISR


375 
	gkISRSl2
:

376 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

379 
mov
 
	grdi
, 35

380 

 
kCommIruHdr


382 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

383 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

385 ; #36, 시리얼 포트 1 
ISR


386 
	gkISRSl1
:

387 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

390 
mov
 
	grdi
, 36

391 

 
kCommIruHdr


393 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

394 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

396 ; #37, 패러렐 포트 2 
ISR


397 
	gkISRPl2
:

398 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

401 
mov
 
	grdi
, 37

402 

 
kCommIruHdr


404 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

405 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

407 ; #38, 플로피 디스크 컨트롤러 
ISR


408 
	gkISRFlpy
:

409 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

412 
mov
 
	grdi
, 38

413 

 
kCommIruHdr


415 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

416 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

418 ; #39, 패러렐 포트 1 
ISR


419 
	gkISRPl1
:

420 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

423 
mov
 
	grdi
, 39

424 

 
kCommIruHdr


426 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

427 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

429 ; #40, 
RTC
 
ISR


430 
	gkISRRTC
:

431 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

434 
mov
 
	grdi
, 40

435 

 
kCommIruHdr


437 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

438 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

440 ; #41, 예약된 인터럽트의 
ISR


441 
	gkISRRerved
:

442 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

445 
mov
 
	grdi
, 41

446 

 
kCommIruHdr


448 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

449 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

452 
	gkISRNUd1
:

453 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

456 
mov
 
	grdi
, 42

457 

 
kCommIruHdr


459 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

460 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

463 
	gkISRNUd2
:

464 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

467 
mov
 
	grdi
, 43

468 

 
kCommIruHdr


470 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

471 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

473 ; #44, 마우스 
ISR


474 
	gkISRMou
:

475 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

478 
mov
 
	grdi
, 44

479 

 
kCommIruHdr


481 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

482 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

484 ; #45, 코프로세서 
ISR


485 
	gkISRCross
:

486 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

489 
mov
 
	grdi
, 45

490 

 
kCommIruHdr


492 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

493 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

495 ; #46, 하드 디스크 1 
ISR


496 
	gkISRHDD1
:

497 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

500 
mov
 
	grdi
, 46

501 

 
kHDDHdr


503 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

504 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

506 ; #47, 하드 디스크 2 
ISR


507 
	gkISRHDD2
:

508 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

511 
mov
 
	grdi
, 47

512 

 
kHDDHdr


514 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

515 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

517 ; #48, 이외의 모든 인터럽트에 대한 
ISR


518 
	gkISRETCIru
:

519 
KSAVECONTEXT
 ; 콘텍스트를 저장한 뒤 셀렉터를 커널 데이터 디스크립터로 교체

522 
mov
 
	grdi
, 48

523 

 
kCommIruHdr


525 
	gKLOADCONTEXT
 ; 콘텍스트를 복원

526 
	gq
 ; 인터럽트 처리를 완료하고 이전에 수행하던 코드로 복원

	@/home/jk/os/MINT64/save/02.Kernel64/Source/ISR.h

1 #ide
__ISR_H__


2 
	#__ISR_H__


	)

6 
kISRDivideE
( );

7 
kISRDebug
( );

8 
kISRNMI
( );

9 
kISRBakPot
( );

10 
kISROvow
( );

11 
kISRBoundRgeExeded
( );

12 
kISRInvidOpcode
();

13 
kISRDeviNAvaab
( );

14 
kISRDoubFau
( );

15 
kISRCrossSegmtOvrun
( );

16 
kISRInvidTSS
( );

17 
kISRSegmtNP
( );

18 
kISRSckSegmtFau
( );

19 
kISRGPrei
( );

20 
kISRPageFau
( );

21 
kISR15
( );

22 
kISRFPUE
( );

23 
kISRAlignmtCheck
( );

24 
kISRMacheCheck
( );

25 
kISRSIMDE
( );

26 
kISRETCExi
( );

29 
kISRTim
( );

30 
kISRKeybrd
( );

31 
kISRSvePIC
( );

32 
kISRSl2
( );

33 
kISRSl1
( );

34 
kISRPl2
( );

35 
kISRFlpy
( );

36 
kISRPl1
( );

37 
kISRRTC
( );

38 
kISRRerved
( );

39 
kISRNUd1
( );

40 
kISRNUd2
( );

41 
kISRMou
( );

42 
kISRCross
( );

43 
kISRHDD1
( );

44 
kISRHDD2
( );

45 
kISRETCIru
( );

	@/home/jk/os/MINT64/save/02.Kernel64/Source/InterruptHandler.c

1 
	~"IruHdr.h
"

2 
	~"PIC.h
"

3 
	~"Keybrd.h
"

4 
	~"Cse.h
"

5 
	~"Uty.h
"

6 
	~"Task.h
"

7 
	~"Dest.h
"

8 
	~"AsmblyUty.h
"

9 
	~"HdDisk.h
"

12 
	$kCommExiHdr
(
iVeNumb
,
QWORD
 
qwECode
)

14 
vcBufr
[3]={0,};

17 
vcBufr
[0] = '0'+
iVeNumb
/10;

18 
vcBufr
[1] = '0'+
iVeNumb
%10;

20 
	`kPrtSgXY
( 0, 0, "====================================================" );

21 
	`kPrtSgXY
( 0, 1, " Exception Occur~!!!! " );

22 
	`kPrtSgXY
( 0, 2, " Vector: " );

23 
	`kPrtSgXY
27,2,
vcBufr
);

24 
	`kPrtSgXY
( 0, 3, "====================================================" );

27 
	}
}

30 
	$kCommIruHdr
(
iVeNumb
)

32 
vcBufr
[] ="[INT: , ]";

33 
g_iCommIruCou
=0;

37 
vcBufr
[5]='0'+
iVeNumb
/10;

38 
vcBufr
[6]='0'+
iVeNumb
%10;

40 
vcBufr
[8]='0'+
g_iCommIruCou
;

41 
g_iCommIruCou
=(g_iCommonInterruptCount+1)%10;

42 
	`kPrtSgXY
(70,0,
vcBufr
);

45 
	`kSdEOIToPIC
(
iVeNumb
-
PIC_IRQSTARTVECTOR
);

46 
	}
}

49 
	$kKeybrdHdr
(
iVeNumb
)

52 
vcBufr
[] ="[INT: , ]";

53 
g_iKeybrdIruCou
=0;

54 
BYTE
 
bTemp
;

58 
vcBufr
[5]='0'+
iVeNumb
/10;

59 
vcBufr
[6]='0'+
iVeNumb
%10;

61 
vcBufr
[8]='0'+
g_iKeybrdIruCou
;

62 
g_iKeybrdIruCou
=(g_iKeyboardInterruptCount+1)%10;

63 
	`kPrtSgXY
(0,0,
vcBufr
);

66 if(
	`kIsOuutBufrFu
()==
TRUE
)

68 
bTemp
=
	`kGKeybrdSnCode
();

69 
	`kCvtSnCodeAndPutQueue
(
bTemp
);

73 
	`kSdEOIToPIC
(
iVeNumb
-
PIC_IRQSTARTVECTOR
);

75 
	}
}

78 
	$kTimHdr
(
iVeNumb
)

80 
vcBufr
[] ="[INT: , ]";

81 
g_iTimIruCou
=0;

82 
i
=0;

86 
vcBufr
[5]='0'+
iVeNumb
/10;

87 
vcBufr
[6]='0'+
iVeNumb
%10;

89 
vcBufr
[8]='0'+
g_iTimIruCou
;

90 
g_iTimIruCou
=(g_iTimerInterruptCount+1)%10;

91 
	`kPrtSgXY
(70,0,
vcBufr
);

94 
	`kSdEOIToPIC
(
iVeNumb
-
PIC_IRQSTARTVECTOR
);

97 
g_qwTickCou
++;

101 
	`kDeProssTime
();

103 if(
	`kIsProssTimeExped
()==
TRUE
)

105 
	`kScheduInIru
();

107 
	}
}

111 
	$kDeviNAvaabHdr
(
iVeNumb
)

113 
TCB
* 
pFPUTask
,* 
pCutTask
;

114 
QWORD
 
qwLaFPUTaskID
;

118 
vcBufr
[] = "[EXC: , ]";

119 
g_iFPUIruCou
=0;

122 
vcBufr
[5] = '0' + 
iVeNumb
/10;

123 
vcBufr
[7] = '0' + 
iVeNumb
%10;

125 
vcBufr
[8] = '0' + 
g_iFPUIruCou
;

126 
g_iFPUIruCou
 = (g_iFPUInterruptCount+1)%10;

127 
	`kPrtSgXY
(0,0,
vcBufr
);

131 
	`kCˬTS
();

134 
qwLaFPUTaskID
 = 
	`kGLaFPUUdTaskID
();

135 
pCutTask
 = 
	`kGRugTask
();

138 if
qwLaFPUTaskID
 =
pCutTask
->
Lk
.
qwID
)

143 if(
qwLaFPUTaskID
!=
TASK_INVALIDID
)

145 
pFPUTask
 = 
	`kGTCBInTCBPo
(
	`GETTCBOFFSET
(
qwLaFPUTaskID
));

146 if((
pFPUTask
!=
NULL
)&&աFPUTask->
Lk
.
qwID
==
qwLaFPUTaskID
))

148 
	`kSaveFPUCڋxt
(
pFPUTask
->
vqwFPUCڋxt
);

154 if(
pCutTask
->
bFPUUd
 ==
FALSE
)

156 
	`kInlizeFPU
();

157 
pCutTask
->
bFPUUd
 = 
TRUE
;

161 
	`kLdFPUCڋxt
(
pCutTask
->
vqwFPUCڋxt
);

165 
	`kSLaFPUUdTaskID
(
pCutTask
->
Lk
.
qwID
);

166 
	}
}

169 
	$kHDDHdr
(
iVeNumb
)

171 
vcBufr
[]="[INT: , ]";

172 
g_iHDDIruCou
=0;

173 
BYTE
 
bTemp
;

178 
vcBufr
[5] = '0' + 
iVeNumb
/10;

179 
vcBufr
[6] = '0' + 
iVeNumb
%10;

181 
vcBufr
[8] = '0' + 
g_iHDDIruCou
;

182 
g_iHDDIruCou
 = (g_iHDDInterruptCount+1)%10;

184 
	`kPrtSgXY
(10,0,
vcBufr
);

188 if(
iVeNumb
 - 
PIC_IRQSTARTVECTOR
 == 14)

191 
	`kSHDDIruFg
(
TRUE
,TRUE);

197 
	`kSHDDIruFg
(
FALSE
,
TRUE
);

201 
	`kSdEOIToPIC
(
iVeNumb
-
PIC_IRQSTARTVECTOR
);

202 
	}
}

	@/home/jk/os/MINT64/save/02.Kernel64/Source/InterruptHandler.h

1 #ide
__INTERRUPTHANDLER_H__


2 
	#__INTERRUPTHANDLER_H__


	)

4 
	~"Tys.h
"

7 
kCommExiHdr
(
iVeNumb
,
QWORD
 
qwECode
);

8 
kCommIruHdr
(
iVeNumb
);

9 
kKeybrdHdr
(
iVeNumb
);

10 
kTimHdr
(
iVeNumb
);

11 
kDeviNAvaabHdr
(
iVeNumb
);

12 
kHDDHdr
(
iVeNumb
);

	@/home/jk/os/MINT64/save/02.Kernel64/Source/Keyboard.c

1 
	~"Tys.h
"

2 
	~"AsmblyUty.h
"

3 
	~"Keybrd.h
"

4 
	~"Queue.h
"

5 
	~"Synchrizi.h
"

11 
BOOL
 
	$kIsOuutBufrFu
()

15 if(
	`kInPtBy
(0x64)&0x01)

17  
TRUE
;

19  
FALSE
;

20 
	}
}

23 
BOOL
 
	$kIsIutBufrFu
()

27 if(
	`kInPtBy
(0x64)&0x02)

29  
TRUE
;

31  
FALSE
;

32 
	}
}

35 
BOOL
 
	$kAiveKeybrd
()

37 
i
;

38 
j
;

42 
	`kOutPtBy
(0x64,0xAE);

47 
i
=0;i<0xFFFF;i++)

50 if(
	`kIsIutBufrFu
()==
FALSE
)

58 
	`kOutPtBy
(0x60,0xF4);

63 
j
=0;j<100;j++)

68 
i
=0;i<0xFFFF;i++)

70 if(
	`kIsOuutBufrFu
()==
TRUE
)

77 if(
	`kInPtBy
(0x60)==0xFA)

79  
TRUE
;

84  
FALSE
;

85 
	}
}

89 
BYTE
 
	$kGKeybrdSnCode
()

92 
	`kIsOuutBufrFu
()==
FALSE
)

97  
	`kInPtBy
(0x60);

98 
	}
}

101 
BOOL
 
	$kChgeKeybrdLED
(
BOOL
 
bCsLockOn
,BOOL 
bNumLockOn
,BOOL 
bSlLockOn
)

103 
i
,
j
;

105 
i
=0;i<0xFFFF;i++)

108 if(
	`kIsIutBufrFu
()==
FALSE
)

115 
	`kOutPtBy
(0x60,0xED);

116 
i
=0;i<0xFFFF;i++)

119 if(
	`kIsIutBufrFu
()==
FALSE
)

126 
j
=0;j<100;j++)

131 
i
=0;i<0xFFFF;i++)

133 if(
	`kIsOuutBufrFu
()==
TRUE
)

140 if(
	`kInPtBy
(0x60)==0xFA)

148 if(
j
>=100)

150  
FALSE
;

154 
	`kOutPtBy
(0x60,(
bCsLockOn
<<2)|(
bNumLockOn
<<1)|
bSlLockOn
);

155 
i
=0;i<0xFFFF;i++)

158 if(
	`kIsIutBufrFu
()==
FALSE
)

165 
j
=0;j<100;j++)

170 
i
=0;i<0xFFFF;i++)

172 if(
	`kIsOuutBufrFu
()==
TRUE
)

179 if(
	`kInPtBy
(0x60)==0xFA)

186 if(
j
>=100)

188  
FALSE
;

191  
TRUE
;

192 
	}
}

195 
	$kEbA20Ge
()

197 
BYTE
 
bOuutPtDa
;

198 
i
;

201 
	`kOutPtBy
(0x64,0xD0);

204 
i
=0;i<0xFFFF;i++)

208 if(
	`kIsOuutBufrFu
()==
TRUE
)

215 
bOuutPtDa
 = 
	`kInPtBy
(0x60);

218 
bOuutPtDa
 |=0x01;

221 
i
=0;i<0xFFFF;i++)

224 if(
	`kIsIutBufrFu
()==
FALSE
)

231 
	`kOutPtBy
(0x64,0xD1);

234 
	`kOutPtBy
(0x60,
bOuutPtDa
);

235 
	}
}

238 
	$kRebo
()

240 
i
;

243 
i
=0;i<0xFFFF;i++)

246 if(
	`kIsIutBufrFu
()==
FALSE
)

253 
	`kOutPtBy
(0x64,0xD1);

256 
	`kOutPtBy
(0x60,0x00);

262 
	}
}

269 
KEYBOARDMANAGER
 
	ggs_KeybrdMag
={0,};

272 
QUEUE
 
	ggs_KeyQueue
;

273 
KEYDATA
 
	ggs_vKeyQueueBufr
[
KEY_MAXQUEUECOUNT
];

276 
KEYMAPPINGENTRY
 
	ggs_vKeyMpgTab
[
KEY_MAPPINGTABLEMAXCOUNT
]=

277 { { 
KEY_NONE
 , KEY_NONE },

278  { 
KEY_ESC
 , KEY_ESC },

291  { 
KEY_BACKSPACE
 , KEY_BACKSPACE },

292  { 
KEY_TAB
 , KEY_TAB },

306  { 
KEY_CTRL
 , KEY_CTRL },

319  { 
KEY_LSHIFT
 , KEY_LSHIFT },

331  { 
KEY_RSHIFT
 , KEY_RSHIFT },

333  { 
KEY_LALT
 , KEY_LALT },

335  { 
KEY_CAPSLOCK
 , KEY_CAPSLOCK },

336  { 
KEY_F1
 , KEY_F1 },

337  { 
KEY_F2
 , KEY_F2 },

338  { 
KEY_F3
 , KEY_F3 },

339  { 
KEY_F4
 , KEY_F4 },

340  { 
KEY_F5
 , KEY_F5 },

341  { 
KEY_F6
 , KEY_F6 },

342  { 
KEY_F7
 , KEY_F7 },

343  { 
KEY_F8
 , KEY_F8 },

344  { 
KEY_F9
 , KEY_F9 },

345  { 
KEY_F10
 , KEY_F10 },

346  { 
KEY_NUMLOCK
 , KEY_NUMLOCK },

347  { 
KEY_SCROLLLOCK
 , KEY_SCROLLLOCK },

349  { 
KEY_HOME
 , '7' },

350  { 
KEY_UP
 , '8' },

351  { 
KEY_PAGEUP
 , '9' },

353  { 
KEY_LEFT
 , '4' },

354  { 
KEY_CENTER
 , '5' },

355  { 
KEY_RIGHT
 , '6' },

357  { 
KEY_END
 , '1' },

358  { 
KEY_DOWN
 , '2' },

359  { 
KEY_PAGEDOWN
 , '3' },

360  { 
KEY_INS
 , '0' },

361  { 
KEY_DEL
 , '.' },

362  { 
KEY_NONE
 , KEY_NONE },

363  { 
KEY_NONE
 , KEY_NONE },

364  { 
KEY_NONE
 , KEY_NONE },

365  { 
KEY_F11
 , KEY_F11 },

366  { 
KEY_F12
 , KEY_F12 }

370 
BOOL
 
	$kIsAhabSnCode
(
BYTE
 
bSnCode
)

373 if(('a'<=
gs_vKeyMpgTab
[
bSnCode
].
bNmCode
)&&(gs_vstKeyMappingTable[bScanCode].bNormalCode<='z'))

375  
TRUE
;

378  
FALSE
;

379 
	}
}

382 
BOOL
 
	$kIsNumbOrSymbSnCode
(
BYTE
 
bSnCode
)

385 if((2<=
bSnCode
)&&(bSnCode<=53)&&(
	`kIsAhabSnCode
(bSnCode)==
FALSE
))

387  
TRUE
;

390  
FALSE
;

391 
	}
}

394 
BOOL
 
	$kIsNumbPadSnCode
(
BYTE
 
bSnCode
)

397 if((71<=
bSnCode
)&&(bScanCode<=83))

399  
TRUE
;

402  
FALSE
;

403 
	}
}

406 
BOOL
 
	$kIsUCombedCode
(
BYTE
 
bSnCode
)

408 
BYTE
 
bDownSnCode
;

409 
BOOL
 
bUCombedKey
=
FALSE
;

411 
bDownSnCode
 = 
bSnCode
&0x7F;

414 if(
	`kIsAhabSnCode
(
bDownSnCode
)==
TRUE
)

417 if(
gs_KeybrdMag
.
bShiDown
^gs_KeybrdMag.
bCsLockOn
)

419 
bUCombedKey
=
TRUE
;

423 
bUCombedKey
=
FALSE
;

427 if(
	`kIsNumbOrSymbSnCode
(
bDownSnCode
)==
TRUE
)

430 if(
gs_KeybrdMag
.
bShiDown
==
TRUE
)

432 
bUCombedKey
=
TRUE
;

436 
bUCombedKey
=
FALSE
;

441 if((
	`kIsNumbPadSnCode
(
bDownSnCode
)==
TRUE
)&&(
gs_KeybrdMag
.
bExndedCodeIn
==
FALSE
))

444 if(
gs_KeybrdMag
.
bNumLockOn
==
TRUE
)

446 
bUCombedKey
=
TRUE
;

450 
bUCombedKey
=
FALSE
;

454  
bUCombedKey
;

455 
	}
}

458 
	$UpdeCombiKeyStusAndLED
(
BYTE
 
bSnCode
)

460 
BOOL
 
bDown
;

461 
BYTE
 
bDownSnCode
;

462 
BOOL
 
bLEDStusChged
=
FALSE
;

465 if(
bSnCode
&0x80)

467 
bDown
=
FALSE
;

468 
bDownSnCode
=
bSnCode
&0x7F;

472 
bDown
=
TRUE
;

473 
bDownSnCode
=
bSnCode
;

478 if((
bDownSnCode
==42)||(bDownScanCode==54))

480 
gs_KeybrdMag
.
bShiDown
=
bDown
;

483 if((
bDownSnCode
==58)&&(
bDown
==
TRUE
))

485 
gs_KeybrdMag
.
bCsLockOn
^=
TRUE
;

486 
bLEDStusChged
=
TRUE
;

489 if((
bDownSnCode
==69)&&(
bDown
==
TRUE
))

491 
gs_KeybrdMag
.
bNumLockOn
^=
TRUE
;

492 
bLEDStusChged
=
TRUE
;

495 if((
bDownSnCode
==70)&&(
bDown
==
TRUE
))

497 
gs_KeybrdMag
.
bSlLockOn
^=
TRUE
;

498 
bLEDStusChged
=
TRUE
;

503 if(
bLEDStusChged
==
TRUE
)

505 
	`kChgeKeybrdLED
(
gs_KeybrdMag
.
bCsLockOn
,gs_KeybrdMag.
bNumLockOn
,gs_KeybrdMag.
bSlLockOn
);

507 
	}
}

510 
BOOL
 
	$kCvtSnCodeToASCIICode
(
BYTE
 
bSnCode
,BYTE* 
pbASCIICODE
,
BOOL
* 
pbFgs
)

512 
BOOL
 
bUCombedKey
;

515 if(
gs_KeybrdMag
.
iSkCouFPau
>0)

517 
gs_KeybrdMag
.
iSkCouFPau
--;

518  
FALSE
;

522 if(
bSnCode
==0xE1)

524 *
pbASCIICODE
==
KEY_PAUSE
;

525 *
pbFgs
=
KEY_FLAGS_DOWN
;

526 
gs_KeybrdMag
.
iSkCouFPau
=
KEY_SKIPCOUNTFORPAUSE
;

527  
TRUE
;

530 if(
bSnCode
==0xE0)

532 
gs_KeybrdMag
.
bExndedCodeIn
=
TRUE
;

533  
FALSE
;

537 
bUCombedKey
=
	`kIsUCombedCode
(
bSnCode
);

540 if(
bUCombedKey
==
TRUE
)

542 *
pbASCIICODE
=
gs_vKeyMpgTab
[
bSnCode
&0x7F].
bCombedCode
;

546 *
pbASCIICODE
=
gs_vKeyMpgTab
[
bSnCode
&0x7F].
bNmCode
;

550 if(
gs_KeybrdMag
.
bExndedCodeIn
==
TRUE
)

552 *
pbFgs
=
KEY_FLAGS_EXTENDEDKEY
;

553 
gs_KeybrdMag
.
bExndedCodeIn
=
FALSE
;

557 *
pbFgs
=0;

560 if((
bSnCode
&0x80)==0)

562 *
pbFgs
|=
KEY_FLAGS_DOWN
;

566 
	`UpdeCombiKeyStusAndLED
(
bSnCode
);

567  
TRUE
;

568 
	}
}

571 
BOOL
 
	$kInlizeKeybrd
()

574 
	`kInlizeQueue
(&
gs_KeyQueue
,
gs_vKeyQueueBufr
,
KEY_MAXQUEUECOUNT
,(
KEYDATA
));

577  
	`kAiveKeybrd
();

578 
	}
}

583 
BOOL
 
	$kCvtSnCodeAndPutQueue
(
BYTE
 
bSnCode
)

585 
KEYDATA
 
Da
;

586 
BOOL
 
bResu
 = 
FALSE
;

587 
BOOL
 
bPviousIru
;

590 
Da
.
bSnCode
 = bScanCode;

593 if(
	`kCvtSnCodeToASCIICode
(
bSnCode
,&(
Da
.
bASCIICode
),&(Da.
bFgs
))==
TRUE
)

596 
bPviousIru
 = 
	`kLockFSyemDa
();

598 
bResu
=
	`kPutQueue
(&
gs_KeyQueue
,&
Da
);

601 
	`kUockFSyemDa
(
bPviousIru
);

604  
bResu
;

605 
	}
}

608 
BOOL
 
	$kGKeyFromKeyQueue
(
KEYDATA
* 
pDa
)

610 
BOOL
 
bResu
;

611 
BOOL
 
bPviousIru
;

614 
bPviousIru
 = 
	`kLockFSyemDa
();

617 
bResu
 = 
	`kGQueue
(&
gs_KeyQueue
,
pDa
);

620 
	`kUockFSyemDa
(
bPviousIru
);

621  
bResu
;

622 
	}
}

	@/home/jk/os/MINT64/save/02.Kernel64/Source/Keyboard.h

1 #ide
__KEYBOARD_H__


2 
	#__KEYBOARD_H__


	)

4 
	~"Tys.h
"

8 
	#KEY_SKIPCOUNTFORPAUSE
 2

	)

11 
	#KEY_FLAGS_UP
 0x00

	)

12 
	#KEY_FLAGS_DOWN
 0x01

	)

13 
	#KEY_FLAGS_EXTENDEDKEY
 0x02

	)

16 
	#KEY_MAPPINGTABLEMAXCOUNT
 89

	)

18 
	#KEY_NONE
 0x00

	)

19 
	#KEY_ENTER
 '\n'

	)

20 
	#KEY_TAB
 '\t'

	)

21 
	#KEY_ESC
 0x1B

	)

22 
	#KEY_BACKSPACE
 0x08

	)

24 
	#KEY_CTRL
 0x81

	)

25 
	#KEY_LSHIFT
 0x82

	)

26 
	#KEY_RSHIFT
 0x83

	)

27 
	#KEY_PRINTSCREEN
 0x84

	)

28 
	#KEY_LALT
 0x85

	)

29 
	#KEY_CAPSLOCK
 0x86

	)

30 
	#KEY_F1
 0x87

	)

31 
	#KEY_F2
 0x88

	)

32 
	#KEY_F3
 0x89

	)

33 
	#KEY_F4
 0x8A

	)

34 
	#KEY_F5
 0x8B

	)

35 
	#KEY_F6
 0x8C

	)

36 
	#KEY_F7
 0x8D

	)

37 
	#KEY_F8
 0x8E

	)

38 
	#KEY_F9
 0x8F

	)

39 
	#KEY_F10
 0x90

	)

40 
	#KEY_NUMLOCK
 0x91

	)

41 
	#KEY_SCROLLLOCK
 0x92

	)

42 
	#KEY_HOME
 0x93

	)

43 
	#KEY_UP
 0x94

	)

44 
	#KEY_PAGEUP
 0x95

	)

45 
	#KEY_LEFT
 0x96

	)

46 
	#KEY_CENTER
 0x97

	)

47 
	#KEY_RIGHT
 0x98

	)

48 
	#KEY_END
 0x99

	)

49 
	#KEY_DOWN
 0x9A

	)

50 
	#KEY_PAGEDOWN
 0x9B

	)

51 
	#KEY_INS
 0x9C

	)

52 
	#KEY_DEL
 0x9D

	)

53 
	#KEY_F11
 0x9E

	)

54 
	#KEY_F12
 0x9F

	)

55 
	#KEY_PAUSE
 0xA0

	)

58 
	#KEY_MAXQUEUECOUNT
 100

	)

61 #agm
ck

push
, 1 )

64 
	skKeyMpgErySu


67 
BYTE
 
	mbNmCode
;

70 
BYTE
 
	mbCombedCode
;

71 } 
	tKEYMAPPINGENTRY
;

74 
	skKeybrdMagSu


77 
BOOL
 
	mbShiDown
;

78 
BOOL
 
	mbCsLockOn
;

79 
BOOL
 
	mbNumLockOn
;

80 
BOOL
 
	mbSlLockOn
;

83 
BOOL
 
	mbExndedCodeIn
;

84 
	miSkCouFPau
;

85 } 
	tKEYBOARDMANAGER
;

88 
	skKeyDaSu


91 
BYTE
 
	mbSnCode
;

93 
BYTE
 
	mbASCIICode
;

95 
BYTE
 
	mbFgs
;

96 } 
	tKEYDATA
;

98 #agm
ck

p
 )

101 
BOOL
 
kIsOuutBufrFu
( );

102 
BOOL
 
kIsIutBufrFu
( );

103 
BOOL
 
kAiveKeybrd
( );

104 
BYTE
 
kGKeybrdSnCode
( );

105 
BOOL
 
kChgeKeybrdLED
BOOL 
bCsLockOn
, BOOL 
bNumLockOn
, BOOL 
bSlLockOn
 );

106 
kEbA20Ge
( );

107 
kRebo
( );

108 
BOOL
 
kIsAhabSnCode

BYTE
 
bSnCode
 );

109 
BOOL
 
kIsNumbOrSymbSnCode

BYTE
 
bSnCode
 );

110 
BOOL
 
kIsNumbPadSnCode

BYTE
 
bSnCode
 );

111 
BOOL
 
kIsUCombedCode

BYTE
 
bSnCode
 );

112 
UpdeCombiKeyStusAndLED

BYTE
 
bSnCode
 );

113 
BOOL
 
kCvtSnCodeToASCIICode

BYTE
 
bSnCode
, BYTE* 
pbASCIICode
, BOOL* 
pbFgs
 );

114 
BOOL
 
kInlizeKeybrd
();

115 
BOOL
 
kCvtSnCodeAndPutQueue
(
BYTE
 
bSnCode
);

116 
BOOL
 
kGKeyFromKeyQueue
(
KEYDATA
* 
pDa
);

	@/home/jk/os/MINT64/save/02.Kernel64/Source/List.c

1 
	~"Li.h
"

4 
	$kInlizeLi
(
LIST
* 
pLi
)

6 
pLi
->
iImCou
 = 0;

7 
pLi
->
pvHd
 = 
NULL
;

8 
pLi
->
pvTa
 = 
NULL
;

9 
	}
}

12 
	$kGLiCou
(cڡ 
LIST
* 
pLi
)

14  
pLi
->
iImCou
;

15 
	}
}

18 
	$kAddLiToTa
(
LIST
* 
pLi
,* 
pvIm
)

20 
LISTLINK
* 
pLk
;

23 
pLk
 = (
LISTLINK
*)
pvIm
;

24 
pLk
->
pvNext
=
NULL
;

25 
pLk
->
pvPvious
=
pLi
->
pvTa
;

28 if(
pLi
->
pvHd
==
NULL
)

30 
pLi
->
pvHd
=
pvIm
;

31 
pLi
->
pvTa
=
pvIm
;

32 
pLi
->
iImCou
=1;

37 ((
LISTLINK
*)
pLi
->
pvTa
)->
pvNext
=
pLk
;

40 
pLi
->
pvTa
=
pvIm
;

41 
pLi
->
iImCou
++;

42 
	}
}

45 
	$kAddLiToHd
(
LIST
* 
pLi
,* 
pvIm
)

47 
LISTLINK
* 
pLk
;

50 
pLk
=(
LISTLINK
*)
pvIm
;

51 
pLk
->
pvNext
=
pLi
->
pvHd
;

52 
pLk
->
pvPvious
=
NULL
;

55 if(
pLi
->
pvHd
==
NULL
)

57 
pLi
->
pvHd
=
pvIm
;

58 
pLi
->
pvTa
=
pvIm
;

59 
pLi
->
iImCou
=1;

64 ((
LISTLINK
*)
pLi
->
pvHd
)->
pvPvious
=
pLk
;

65 
pLi
->
pvHd
=
pvIm
;

66 
pLi
->
iImCou
++;

67 
	}
}

70 * 
	$kRemoveLi
(
LIST
* 
pLi
,
QWORD
 
qwID
)

72 
LISTLINK
* 
pLk
;

73 
pLk
=
	`kFdLi
(
pLi
,
qwID
);

75 if(
pLk
!=
NULL
)

78 if((
pLk
==
pLi
->
pvHd
)&&աLk=Li->
pvTa
))

80 
pLi
->
pvHd
=
NULL
;

81 
pLi
->
pvTa
=
NULL
;

84 if(
pLk
==
pLi
->
pvHd
)

86 
pLi
->
pvHd
=
pLk
->
pvNext
;

87 ((
LISTLINK
*)
pLi
->
pvHd
)->
pvPvious
=
NULL
;

90 if(
pLk
==
pLi
->
pvTa
)

92 
pLi
->
pvTa
=
pLk
->
pvPvious
;

93 ((
LISTLINK
*)
pLi
->
pvTa
)->
pvNext
=
NULL
;

97 ((
LISTLINK
*)
pLk
->
pvPvious
)->
pvNext
=pstLink->pvNext;

98 ((
LISTLINK
*)
pLk
->
pvNext
)->
pvPvious
=pstLink->pvPrevious;

100 
pLi
->
iImCou
--;

101  
pLk
;

104  
NULL
;

105 
	}
}

108 * 
	$kRemoveLiFromHd
(
LIST
* 
pLi
)

110 
LISTLINK
* 
pLk
;

111 if(
pLi
->
iImCou
==0)

113  
NULL
;

117 
pLk
=(
LISTLINK
*)
pLi
->
pvHd
;

118  
	`kRemoveLi
(
pLi
,
pLk
->
qwID
);

119 
	}
}

122 * 
	$kRemoveLiFromTa
(
LIST
* 
pLi
)

124 
LISTLINK
* 
pLk
;

125 if(
pLi
->
iImCou
==0)

127  
NULL
;

131 
pLk
=(
LISTLINK
*)
pLi
->
pvTa
;

132  
	`kRemoveLi
(
pLi
,
pLk
->
qwID
);

133 
	}
}

137 * 
	$kFdLi
(cڡ 
LIST
* 
pLi
,
QWORD
 
qwID
)

139 
LISTLINK
* 
pLk
;

141 
pLk
=(
LISTLINK
*)
pLi
->
pvHd
;pLk!=
NULL
;pLkLk->
pvNext
)

144 if(
pLk
->
qwID
==qwID)

146  
pLk
;

149  
NULL
;

150 
	}
}

153 * 
	$kGHdFromLi
(cڡ 
LIST
* 
pLi
)

155  
pLi
->
pvHd
;

156 
	}
}

159 * 
	$kGTaFromLi
(cڡ 
LIST
* 
pLi
)

161  
pLi
->
pvTa
;

162 
	}
}

165 * 
	$kGNextFromLi
(cڡ 
LIST
* 
pLi
,* 
pCut
)

167 
LISTLINK
* 
pLk
;

168 
pLk
=(
LISTLINK
*)
pCut
;

169  
pLk
->
pvNext
;

170 
	}
}

173 * 
	$kGPviousFromLi
(cڡ 
LIST
* 
pLi
,* 
pCut
)

175 
LISTLINK
* 
pLk
;

176 
pLk
=(
LISTLINK
*)
pCut
;

177  
pLk
->
pvPvious
;

178 
	}
}

	@/home/jk/os/MINT64/save/02.Kernel64/Source/List.h

1 #ide
__LIST_H__


2 
	#__LIST_H__


	)

4 
	~"Tys.h
"

8 #agm
ck
(
push
,1)

12 
	skLiLkSu


15 * 
	mpvNext
;

16 * 
	mpvPvious
;

17 
QWORD
 
	mqwID
;

18 } 
	tLISTLINK
;

35 
	skLiMagSu


38 
	miImCou
;

41 * 
	mpvHd
;

42 * 
	mpvTa
;

43 } 
	tLIST
;

45 #agm
ck
(
p
)

48 
kInlizeLi
(
LIST
* 
pLi
);

49 
kGLiCou
(cڡ 
LIST
* 
pLi
);

50 
kAddLiToTa
(
LIST
* 
pLi
,* 
pvIm
);

51 
kAddLiToHd
(
LIST
* 
pLi
,* 
pvIm
);

52 * 
kRemoveLi
(
LIST
* 
pLi
,
QWORD
 
qwID
);

53 * 
kRemoveLiFromHd
(
LIST
* 
pLi
);

54 * 
kRemoveLiFromTa
(
LIST
* 
pLi
);

55 * 
kFdLi
(cڡ 
LIST
* 
pLi
,
QWORD
 
qwID
);

56 * 
kGHdFromLi
(cڡ 
LIST
* 
pLi
);

57 * 
kGTaFromLi
(cڡ 
LIST
* 
pLi
);

58 * 
kGNextFromLi
(cڡ 
LIST
* 
pLi
,* 
pCut
);

59 * 
kGPviousFromLi
(cڡ 
LIST
* 
pLi
,* 
pCut
);

	@/home/jk/os/MINT64/save/02.Kernel64/Source/LocalAPIC.c

1 
	~"LolAPIC.h
"

2 
	~"MPCfigutiTab.h
"

5 
QWORD
 
	$kGLolAPICBaAddss
()

7 
MPCONFIGURATIONTABLEHEADER
* 
pMPHd
;

10 
pMPHd
 = 
	`kGMPCfigutiMag
()->
pMPCfigutiTabHd
;

11  
pMPHd
->
dwMemyMIOAddssOfLolAPIC
;

12 
	}
}

16 
	$kEbSoweLolAPIC
()

18 
QWORD
 
qwLolAPICBaAddss
;

21 
qwLolAPICBaAddss
 = 
	`kGLolAPICBaAddss
();

25 *(
DWORD
*)(
qwLolAPICBaAddss
+
APIC_REGISTER_SVR
)|=0x100;

26 
	}
}

	@/home/jk/os/MINT64/save/02.Kernel64/Source/LocalAPIC.h

1 #ide
__LOCALAPIC_H__


2 
	#__LOCALAPIC_H__


	)

4 
	~"Tys.h
"

8 
	#APIC_REGISTER_EOI
 0x0000B0

	)

9 
	#APIC_REGISTER_SVR
 0x0000F0

	)

10 
	#APIC_REGISTER_APICID
 0x000020

	)

11 
	#APIC_REGISTER_TASKPRIORITY
 0x000080

	)

12 
	#APIC_REGISTER_TIMER
 0x000320

	)

13 
	#APIC_REGISTER_THERMALSENSOR
 0x000330

	)

14 
	#APIC_REGISTER_PERFORMANCEMONITORINGCOUNTER
 0x000340

	)

15 
	#APIC_REGISTER_LINT0
 0x000350

	)

16 
	#APIC_REGISTER_LINT1
 0x000360

	)

17 
	#APIC_REGISTER_ERROR
 0x000370

	)

18 
	#APIC_REGISTER_ICR_LOWER
 0x000300

	)

19 
	#APIC_REGISTER_ICR_UPPER
 0x000310

	)

22 
	#APIC_DELIVERYMODE_FIXED
 0x000000

	)

23 
	#APIC_DELIVERYMODE_LOWESTPRIORITY
 0x000100

	)

24 
	#APIC_DELIVERYMODE_SMI
 0x000200

	)

25 
	#APIC_DELIVERYMODE_NMI
 0x000400

	)

26 
	#APIC_DELIVERYMODE_INIT
 0x000500

	)

27 
	#APIC_DELIVERYMODE_STARTUP
 0x000600

	)

28 
	#APIC_DELIVERYMODE_EXTINT
 0x000700

	)

31 
	#APIC_DESTINATIONMODE_PHYSICAL
 0x000000

	)

32 
	#APIC_DESTINATIONMODE_LOGICAL
 0x000800

	)

35 
	#APIC_DELIVERYSTATUS_IDLE
 0x000000

	)

36 
	#APIC_DELIVERYSTATUS_PENDING
 0x001000

	)

39 
	#APIC_LEVEL_DEASSERT
 0x000000

	)

40 
	#APIC_LEVEL_ASSET
 0x004000

	)

43 
	#APIC_TRIGGERMODE_EDGE
 0x000000

	)

44 
	#APIC_TRIGGERMODE_LEVEL
 0x008000

	)

47 
	#APIC_DESTINATIONSHORTHAND_NOSHORTHAND
 0x000000

	)

48 
	#APIC_DESTINATIONSHORTHAND_SELF
 0x040000

	)

49 
	#APIC_DESTINATIONSHORTHAND_ALLINCLUDINGSELF
 0x080000

	)

50 
	#APIC_DESTINATIONSHORTHAND_ALLEXCLUDINGSELF
 0x0C0000

	)

53 
QWORD
 
kGLolAPICBaAddss
();

54 
kEbSoweLolAPIC
();

	@/home/jk/os/MINT64/save/02.Kernel64/Source/MPConfigurationTable.c

1 
	~"MPCfigutiTab.h
"

2 
	~"Cse.h
"

5 
MPCONFIGURATIONMANAGER
 
	ggs_MPCfigutiMag
 = {0,};

8 
BOOL
 
	$kFdMPFltgPorAddss
(
QWORD
* 
pAddss
)

10 * 
pcMPFltgPor
;

11 
QWORD
 
qwEBDAddss
;

12 
QWORD
 
qwSyemBaMemy
;

15 
	`kPrtf
("Exnded BIOS DA[0x%x]\n",(
DWORD
)(*(
WORD
*)0x040E)*16);

16 
	`kPrtf
("Syem Ba Adds[0x%x]\n",(
DWORD
)(*(
WORD
*)0x0413)*1024);

20 
qwEBDAddss
 = *(
WORD
*)(0x040E);

22 
qwEBDAddss
 *= 16;

24 
pcMPFltgPor
 = (*)
qwEBDAddss
;(
QWORD
)pcMPFloatingPointer<=(qwEBDAddress+1024);pcMPFloatingPointer++)

26 if(
	`kMemCmp
(
pcMPFltgPor
,"_MP_",4)==0)

28 
	`kPrtf
("MP Fltg PoIIEBDA, [0x%x] Addss\n",(
DWORD
)
pcMPFltgPor
);

29 *
pAddss
 = (
QWORD

pcMPFltgPor
;

30  
TRUE
;

38 
qwSyemBaMemy
 = *(
WORD
*)0x0413;

39 
qwSyemBaMemy
 *= 1024;

41 
pcMPFltgPor
 = (*(
qwSyemBaMemy
 - 1024);(
QWORD
)pcMPFloatingPointer <= qwSystemBaseMemory ;cMPFloatingPointer++)

43 if(
	`kMemCmp
(
pcMPFltgPor
,"_MP_",4)==0)

45 
	`kPrtf
("MP Fltg PoIISyem Ba Memy, [0x%x] Addss\n",(
DWORD
)
pcMPFltgPor
);

46 *
pAddss
 = (
QWORD
)
pcMPFltgPor
;

48  
TRUE
;

53 
pcMPFltgPor
 = (*)0x0F0000;(
QWORD
)pcMPFloatingPointer<0x0FFFFF;pcMPFloatingPointer++)

55 if(
	`kMemCmp
(
pcMPFltgPor
,"_MP_",4)==0)

57 
	`kPrtf
("MP Fltg PoIIROM, [0x%x] Addss\n",
pcMPFltgPor
);

58 *
pAddss
 = (
QWORD
)
pcMPFltgPor
;

59  
TRUE
;

63  
FALSE
;

64 
	}
}

67 
BOOL
 
	$kAlysisMPCfigutiTab
()

69 
QWORD
 
qwMPFltgPorAddss
;

70 
MPFLOATINGPOINTER
* 
pMPFltgPor
;

71 
MPCONFIGURATIONTABLEHEADER
* 
pMPCfigutiHd
;

72 
BYTE
 
bEryTy
;

73 
WORD
 
i
;

74 
QWORD
 
qwEryAddss
;

75 
PROCESSORENTRY
* 
pProssEry
;

76 
BUSENTRY
* 
pBusEry
;

79 
	`kMemS
(&
gs_MPCfigutiMag
,0,(
MPCONFIGURATIONMANAGER
));

80 
gs_MPCfigutiMag
.
bISABusID
 = 0xFF;

83 if(
	`kFdMPFltgPorAddss
(&
qwMPFltgPorAddss
)==
FALSE
)

85  
FALSE
;

89 
pMPFltgPor
 = (
MPFLOATINGPOINTER
*)
qwMPFltgPorAddss
;

90 
gs_MPCfigutiMag
.
pMPFltgPor
 =stMPFloatingPointer;

91 
pMPCfigutiHd
 = (
MPCONFIGURATIONTABLEHEADER
*)((
QWORD
)
pMPFltgPor
->
dwMPCfigutiTabAddss
&0xFFFFFFFF);

94 if(
pMPFltgPor
->
vbMPFtuBy
[1]&
MP_FLOATINGPOINTER_FEATUREBYTE2_PICMODE
)

96 
gs_MPCfigutiMag
.
bUPICMode
 = 
TRUE
;

100 
gs_MPCfigutiMag
.
pMPCfigutiTabHd
 = 
pMPCfigutiHd
;

101 
gs_MPCfigutiMag
.
qwBaErySAddss
 = 
pMPFltgPor
->
dwMPCfigutiTabAddss
 + (
MPCONFIGURATIONTABLEHEADER
);

104 
qwEryAddss
 = 
gs_MPCfigutiMag
.
qwBaErySAddss
;

105 
i
=0;i<
pMPCfigutiHd
->
wEryCou
;i++)

107 
bEryTy
 = *(
BYTE
*)
qwEryAddss
;

109 
bEryTy
)

112 
MP_ENTRYTYPE_PROCESSOR
:

113 
pProssEry
 = (
PROCESSORENTRY
*)
qwEryAddss
;

115 if(
pProssEry
->
bCPUFgs
&
MP_PROCESSOR_CPUFLAGS_ENABLE
)

117 
gs_MPCfigutiMag
.
iProssCou
++;

120 
qwEryAddss
 +=(
PROCESSORENTRY
);

123 
MP_ENTRYTYPE_BUS
:

124 
pBusEry
 = (
BUSENTRY
*)
qwEryAddss
;

125 if(
	`kMemCmp
(
pBusEry
->
vcBusTySg
,
MP_BUS_TYPESTRING_ISA
,
	`kSL
(MP_BUS_TYPESTRING_ISA))==0)

127 
gs_MPCfigutiMag
.
bISABusID
 = 
pBusEry
->
bBusID
;

129 
qwEryAddss
 +(
BUSENTRY
);

132 
MP_ENTRYTYPE_IOAPIC
:

133 
MP_ENTRYTYPE_IOINTERRUPTASSIGNMENT
:

134 
MP_ENTRYTYPE_LOCALINTERRUPTASSIGNMENT
:

136 
qwEryAddss
+=8;

141  
TRUE
;

142 
	}
}

145 
MPCONFIGURATIONMANAGER
* 
	$kGMPCfigutiMag
()

147  &
gs_MPCfigutiMag
;

148 
	}
}

151 
	$kPrtMPCfigutiTab
()

153 
MPCONFIGURATIONMANAGER
* 
pMPCfigutiMag
;

154 
QWORD
 
qwMPFltgPorAddss
;

155 
MPFLOATINGPOINTER
* 
pMPFltgPor
;

156 
MPCONFIGURATIONTABLEHEADER
* 
pMPTabHd
;

157 
PROCESSORENTRY
* 
pProssEry
;

158 
BUSENTRY
* 
pBusEry
;

159 
IOAPICENTRY
* 
pIOAPICEry
;

160 
IOINTERRUPTASSIGNMENTENTRY
* 
pIOAssignmtEry
;

161 
LOCALINTERRUPTASSIGNMENTENTRY
* 
pLolAssignmtEry
;

162 
QWORD
 
qwBaEryAddss
;

163 
vcSgBufr
[20];

164 
WORD
 
i
;

165 
BYTE
 
bEryTy
;

168 * 
vpcIruTy
[4] = {"INT","NMI","SMI","ExtINT"};

169 * 
vpcIruFgsPO
[4] = {"Conform","Active High","Reserved","Active Low"};

170 * 
vpcIruFgsEL
[4] = {"Conform","Edge-Trigger","Reserved","Level-Trigger"};

176 
	`kPrtf
("=========== MP Configuration Table Summary ===================\n");

177 
pMPCfigutiMag
 = 
	`kGMPCfigutiMag
();

179 if((
pMPCfigutiMag
->
qwBaErySAddss
==0)&&(
	`kAlysisMPCfigutiTab
()==
FALSE
))

181 
	`kPrtf
("MP configuration Table Analysis Fail\n");

184 
	`kPrtf
("MP Configuration Table Analysis Success\n");

186 
	`kPrtf
("MP Fltg PoAdds: 0x%q\n",
pMPCfigutiMag
->
pMPFltgPor
);

187 
	`kPrtf
("PIC ModSu܈: %d\n",
pMPCfigutiMag
->
bUPICMode
);

188 
	`kPrtf
("MP Cfiguti Tab Hd Adds: 0x%q\n",
pMPCfigutiMag
->
pMPCfigutiTabHd
);

189 
	`kPrtf
("Ba MP Cfiguti Tab Ery S Adds: 0x%q\n",
pMPCfigutiMag
->
qwBaErySAddss
);

190 
	`kPrtf
("Pross Cou : %d\n",
pMPCfigutiMag
->
iProssCou
);

191 
	`kPrtf
("ISA BUS ID : %d\n",
pMPCfigutiMag
->
bISABusID
);

193 
	`kPrtf
("Pressny keyo continue... ('q' isxit) : ");

195 if(
	`kGCh
()=='q')

197 
	`kPrtf
("\n");

201 
	`kPrtf
("\n");

206 
	`kPrtf
("======================= MP Floating Pointer ================\n");

207 
pMPFltgPor
 = 
pMPCfigutiMag
->pstMPFloatingPointer;

208 
	`kMemCpy
(
vcSgBufr
,
pMPFltgPor
->
vcSigtu
,4);

209 
vcSgBufr
[4] = '\0';

210 
	`kPrtf
("Sigtu : %s\n",
vcSgBufr
);

211 
	`kPrtf
("MP Cfiguti Tab Adds: 0x%q\n",
pMPFltgPor
->
dwMPCfigutiTabAddss
);

212 
	`kPrtf
("Lgth : %d*16 By\n",
pMPFltgPor
->
bLgth
);

213 
	`kPrtf
("Vsi : %d\n",
pMPFltgPor
->
bRevisi
);

214 
	`kPrtf
("CheckSum : 0x%x\n",
pMPFltgPor
->
bCheckSum
);

215 
	`kPrtf
("Ftu By 1 : 0x%x ",
pMPFltgPor
->
vbMPFtuBy
[0]);

218 if(
pMPFltgPor
->
vbMPFtuBy
[0]==0)

220 
	`kPrtf
("Use MP Configuration Table\n");

224 
	`kPrtf
("Use Default Configuration\n");

228 
	`kPrtf
("Ftu By 2 : 0x%x ",
pMPFltgPor
->
vbMPFtuBy
[1]);

229 if(
pMPFltgPor
->
vbMPFtuBy
[2]&
MP_FLOATINGPOINTER_FEATUREBYTE2_PICMODE
)

231 
	`kPrtf
("(PIC Mode Support\n");

235 
	`kPrtf
("(Virtual Wire Mode Support\n");

241 
	`kPrtf
("\n============================== MP Configuration Table Header ======================\n");

242 
pMPTabHd
 = 
pMPCfigutiMag
->
pMPCfigutiTabHd
;

244 
	`kMemCpy
(
vcSgBufr
, 
pMPTabHd
->
vcSigtu
,4);

245 
vcSgBufr
[4]='\0';

246 
	`kPrtf
("Sigtu : %s\n",
vcSgBufr
);

247 
	`kPrtf
("Lgth : %d By\n",
pMPTabHd
->
wBaTabLgth
);

248 
	`kPrtf
("vsi : %d\n",
pMPTabHd
->
bRevisi
);

249 
	`kPrtf
("CheckSum : 0x%x\n",
pMPTabHd
->
bCheckSum
);

250 
	`kMemCpy
(
vcSgBufr
,
pMPTabHd
->
vcOEMIDSg
,8);

251 
vcSgBufr
[8] = '\0';

252 
	`kPrtf
("OEM ID Sg : %s\n",
vcSgBufr
);

253 
	`kMemCpy
(
vcSgBufr
,
pMPTabHd
->
vcProduIDSg
,12);

254 
vcSgBufr
[12]='\0';

255 
	`kPrtf
("Produ ID Sg : %s\n",
vcSgBufr
);

256 
	`kPrtf
("OEM Tab Po: 0x%x\n",
pMPTabHd
->
dwOEMTabPorAddss
);

257 
	`kPrtf
("OEM Tab Siz: %d By\n",
pMPTabHd
->
wOEMTabSize
);

258 
	`kPrtf
("Ery Cou : %d\n",
pMPTabHd
->
wEryCou
);

259 
	`kPrtf
("Memy Md I/O AddsOLoAPIC : 0x%x\n",
pMPTabHd
->
dwMemyMIOAddssOfLolAPIC
);

260 
	`kPrtf
("Exnded Tab Lgth : %d By\n",
pMPTabHd
->
wExndedTabLgth
);

261 
	`kPrtf
("Exnded Tab CheckSum : 0x%x\n",
pMPTabHd
->
bExndedTabChecksum
);

263 
	`kPrtf
("Pressny keyo continue... ('q' isxit) : ");

264 if(
	`kGCh
()=='q')

266 
	`kPrtf
("\n");

270 
	`kPrtf
("\n");

275 
	`kPrtf
("\n========================== Base MP Configuration Table Entry =================\n");

276 
qwBaEryAddss
 = 
pMPFltgPor
->
dwMPCfigutiTabAddss
+(
MPCONFIGURATIONTABLEHEADER
);

278 
i
=0;i<
pMPTabHd
->
wEryCou
;i++)

280 
bEryTy
 = *(
BYTE
*)
qwBaEryAddss
;

282 
bEryTy
)

285 
MP_ENTRYTYPE_PROCESSOR
:

286 
pProssEry
 = ( 
PROCESSORENTRY
* ) 
qwBaEryAddss
;

287 
	`kPrtf
( "Entry Type : Processor\n" );

288 
	`kPrtf
"LoAPIC ID : %d\n", 
pProssEry
->
bLolAPICID
 );

289 
	`kPrtf
"LoAPIC Vsi : 0x%X\n", 
pProssEry
->
bLolAPICVsi
 );

290 
	`kPrtf
"CPU Fg: 0x%X ", 
pProssEry
->
bCPUFgs
 );

292 if
pProssEry
->
bCPUFgs
 & 
MP_PROCESSOR_CPUFLAGS_ENABLE
 )

294 
	`kPrtf
( "(Enable, " );

298 
	`kPrtf
( "(Disable, " );

301 if
pProssEry
->
bCPUFgs
 & 
MP_PROCESSOR_CPUFLAGS_BSP
 )

303 
	`kPrtf
( "BSP)\n" );

307 
	`kPrtf
( "AP)\n" );

309 
	`kPrtf
"CPU Sigtu : 0x%X\n", 
pProssEry
->
vbCPUSigtu
 );

310 
	`kPrtf
"Ftu Fg: 0x%X\n\n", 
pProssEry
->
dwFtuFgs
 );

313 
qwBaEryAddss
 +
PROCESSORENTRY
 );

317 
MP_ENTRYTYPE_BUS
:

318 
pBusEry
 = ( 
BUSENTRY
* ) 
qwBaEryAddss
;

319 
	`kPrtf
( "Entry Type : Bus\n" );

320 
	`kPrtf
"BuID : %d\n", 
pBusEry
->
bBusID
 );

321 
	`kMemCpy

vcSgBufr
, 
pBusEry
->
vcBusTySg
, 6 );

322 
vcSgBufr
[ 6 ] = '\0';

323 
	`kPrtf
"BuTy Sg : %s\n\n", 
vcSgBufr
 );

326 
qwBaEryAddss
 +
BUSENTRY
 );

330 
MP_ENTRYTYPE_IOAPIC
:

331 
pIOAPICEry
 = ( 
IOAPICENTRY
* ) 
qwBaEryAddss
;

332 
	`kPrtf
( "Entry Type : I/O APIC\n" );

333 
	`kPrtf
"I/O APIC ID : %d\n", 
pIOAPICEry
->
bIOAPICID
 );

334 
	`kPrtf
"I/O APIC Vsi : 0x%X\n", 
pIOAPICEry
->
bIOAPICVsi
 );

335 
	`kPrtf
"I/O APIC Fg: 0x%X ", 
pIOAPICEry
->
bIOAPICFgs
 );

337 if
pIOAPICEry
->
bIOAPICFgs
 == 1 )

339 
	`kPrtf
( "(Enable)\n" );

343 
	`kPrtf
( "(Disable)\n" );

345 
	`kPrtf
( "Memory Mapped I/O Address : 0x%X\n\n",

346 
pIOAPICEry
->
dwMemyMAddss
 );

349 
qwBaEryAddss
 +
IOAPICENTRY
 );

353 
MP_ENTRYTYPE_IOINTERRUPTASSIGNMENT
:

354 
pIOAssignmtEry
 = ( 
IOINTERRUPTASSIGNMENTENTRY
* )

355 
qwBaEryAddss
;

356 
	`kPrtf
( "Entry Type : I/O Interrupt Assignment\n" );

357 
	`kPrtf
"Iru Ty : 0x%X ", 
pIOAssignmtEry
->
bIruTy
 );

359 
	`kPrtf
"(%s)\n", 
vpcIruTy
[ 
pIOAssignmtEry
->
bIruTy
 ] );

360 
	`kPrtf
"I/O Iru Fg: 0x%X ", 
pIOAssignmtEry
->
wIruFgs
 );

362 
	`kPrtf
"(%s, %s)\n", 
vpcIruFgsPO
[ 
pIOAssignmtEry
->
wIruFgs
 & 0x03 ],

363 
vpcIruFgsEL
[ ( 
pIOAssignmtEry
->
wIruFgs
 >> 2 ) & 0x03 ] );

364 
	`kPrtf
"Sour BUS ID : %d\n", 
pIOAssignmtEry
->
bSourBUSID
 );

365 
	`kPrtf
"Sour BUS IRQ : %d\n", 
pIOAssignmtEry
->
bSourBUSIRQ
 );

366 
	`kPrtf
( "Destination I/O APIC ID : %d\n",

367 
pIOAssignmtEry
->
bDeiIOAPICID
 );

368 
	`kPrtf
( "Destination I/O APIC INTIN : %d\n\n",

369 
pIOAssignmtEry
->
bDeiIOAPICINTIN
 );

372 
qwBaEryAddss
 +
IOINTERRUPTASSIGNMENTENTRY
 );

376 
MP_ENTRYTYPE_LOCALINTERRUPTASSIGNMENT
:

377 
pLolAssignmtEry
 = ( 
LOCALINTERRUPTASSIGNMENTENTRY
* )

378 
qwBaEryAddss
;

379 
	`kPrtf
( "Entry Type : Local Interrupt Assignment\n" );

380 
	`kPrtf
"Iru Ty : 0x%X ", 
pLolAssignmtEry
->
bIruTy
 );

382 
	`kPrtf
"(%s)\n", 
vpcIruTy
[ 
pLolAssignmtEry
->
bIruTy
 ] );

383 
	`kPrtf
"I/O Iru Fg: 0x%X ", 
pLolAssignmtEry
->
wIruFgs
 );

385 
	`kPrtf
"(%s, %s)\n", 
vpcIruFgsPO
[ 
pLolAssignmtEry
->
wIruFgs
 & 0x03 ],

386 
vpcIruFgsEL
[ ( 
pLolAssignmtEry
->
wIruFgs
 >> 2 ) & 0x03 ] );

387 
	`kPrtf
"Sour BUS ID : %d\n", 
pLolAssignmtEry
->
bSourBUSID
 );

388 
	`kPrtf
"Sour BUS IRQ : %d\n", 
pLolAssignmtEry
->
bSourBUSIRQ
 );

389 
	`kPrtf
( "Destination Local APIC ID : %d\n",

390 
pLolAssignmtEry
->
bDeiLolAPICID
 );

391 
	`kPrtf
( "Destination Local APIC LINTIN : %d\n\n",

392 
pLolAssignmtEry
->
bDeiLolAPICINTIN
 );

395 
qwBaEryAddss
 +
LOCALINTERRUPTASSIGNMENTENTRY
 );

399 
	`kPrtf
"UnknowEry Ty. %d\n", 
bEryTy
 );

404 if
i
 != 0 ) && ( ( ( i + 1 ) % 3 ) == 0 ) )

406 
	`kPrtf
( "Pressny keyo continue... ('q' isxit) : " );

407 if
	`kGCh
() == 'q' )

409 
	`kPrtf
( "\n" );

412 
	`kPrtf
( "\n" );

415 
	}
}

418 
	$kGProssCou
( )

421 if
gs_MPCfigutiMag
.
iProssCou
 == 0 )

425  
gs_MPCfigutiMag
.
iProssCou
;

426 
	}
}

	@/home/jk/os/MINT64/save/02.Kernel64/Source/MPConfigurationTable.h

1 #ide
__MPCONFIGURATIONTABLE__


2 
	#__MPCONFIGURATIONTABLE__


	)

4 
	~"Tys.h
"

8 
	#MP_FLOATINGPOINTER_FEATUREBYTE1_USEMPTABLE
 0x00

	)

9 
	#MP_FLOATINGPOINTER_FEATUREBYTE2_PICMODE
 0x80

	)

12 
	#MP_ENTRYTYPE_PROCESSOR
 0

	)

13 
	#MP_ENTRYTYPE_BUS
 1

	)

14 
	#MP_ENTRYTYPE_IOAPIC
 2

	)

15 
	#MP_ENTRYTYPE_IOINTERRUPTASSIGNMENT
 3

	)

16 
	#MP_ENTRYTYPE_LOCALINTERRUPTASSIGNMENT
 4

	)

19 
	#MP_PROCESSOR_CPUFLAGS_ENABLE
 0x01

	)

20 
	#MP_PROCESSOR_CPUFLAGS_BSP
 0x02

	)

23 
	#MP_BUS_TYPESTRING_ISA
 "ISA"

	)

24 
	#MP_BUS_TYPESTRING_PCI
 "PCI"

	)

25 
	#MP_BUS_TYPESTRING_PCMCIA
 "PCMCIA"

	)

26 
	#MP_BUS_TYPESTRING_VESALOCALBUS
 "VL"

	)

29 
	#MP_INTERRUPTTYPE_INT
 0

	)

30 
	#MP_INTERRUPTTYPE_NMI
 1

	)

31 
	#MP_INTERRUPTTYPE_SMI
 2

	)

32 
	#MP_INTERRUPTTYPE_EXITINT
 3

	)

35 
	#MP_INTERRUPT_FLAGS_CONFORMPOLARITY
 0x00

	)

36 
	#MP_INTERRUPT_FLAGS_ACTIVVEHIGH
 0x01

	)

37 
	#MP_INTERRUPT_FLAGS_ACTIVELOW
 0x03

	)

38 
	#MP_INTERRUPT_FLAGS_CONFORMTRIGGER
 0x00

	)

39 
	#MP_INTERRUPT_FLAGS_EDGETRIGGERED
 0x04

	)

40 
	#MP_INTERRUPT_FLAGS_LEVELTRIGGERED
 0x0c

	)

44 #agm
ck
(
push
,1)

47 
	skMPFltgPorSu


50 
	mvcSigtu
[4];

52 
DWORD
 
	mdwMPCfigutiTabAddss
;

54 
BYTE
 
	mbLgth
;

56 
BYTE
 
	mbRevisi
;

58 
BYTE
 
	mbCheckSum
;

60 
BYTE
 
	mvbMPFtuBy
[5];

61 } 
	tMPFLOATINGPOINTER
;

64 
	skMPCfigutiTabHdSu


67 
	mvcSigtu
[4];

69 
WORD
 
	mwBaTabLgth
;

71 
BYTE
 
	mbRevisi
;

73 
BYTE
 
	mbCheckSum
;

75 
	mvcOEMIDSg
[8];

77 
	mvcProduIDSg
[12];

79 
DWORD
 
	mdwOEMTabPorAddss
;

81 
WORD
 
	mwOEMTabSize
;

83 
WORD
 
	mwEryCou
;

85 
DWORD
 
	mdwMemyMIOAddssOfLolAPIC
;

87 
WORD
 
	mwExndedTabLgth
;

89 
BYTE
 
	mbExndedTabChecksum
;

91 
BYTE
 
	mbRerved
;

92 } 
	tMPCONFIGURATIONTABLEHEADER
;

95 
	skProssErySu


98 
BYTE
 
	mbEryTy
;

100 
BYTE
 
	mbLolAPICID
;

102 
BYTE
 
	mbLolAPICVsi
;

104 
BYTE
 
	mbCPUFgs
;

106 
BYTE
 
	mvbCPUSigtu
[4];

108 
DWORD
 
	mdwFtuFgs
;

110 
DWORD
 
	mvdwRerved
[2];

111 } 
	tPROCESSORENTRY
;

114 
	skBusErySu


117 
BYTE
 
	mbEryTy
;

119 
BYTE
 
	mbBusID
;

121 
	mvcBusTySg
[6];

122 } 
	tBUSENTRY
;

125 
	skIOAPICErySu


128 
BYTE
 
	mbEryTy
;

130 
BYTE
 
	mbIOAPICID
;

132 
BYTE
 
	mbIOAPICVsi
;

134 
BYTE
 
	mbIOAPICFgs
;

136 
DWORD
 
	mdwMemyMAddss
;

137 } 
	tIOAPICENTRY
;

140 
	skIOIruAssignmtErySu


143 
BYTE
 
	mbEryTy
;

145 
BYTE
 
	mbIruTy
;

147 
WORD
 
	mwIruFgs
;

149 
BYTE
 
	mbSourBUSID
;

151 
BYTE
 
	mbSourBUSIRQ
;

153 
BYTE
 
	mbDeiIOAPICID
;

155 
BYTE
 
	mbDeiIOAPICINTIN
;

156 } 
	tIOINTERRUPTASSIGNMENTENTRY
;

159 
	skLolIruErySu


162 
BYTE
 
	mbEryTy
;

164 
BYTE
 
	mbIruTy
;

166 
WORD
 
	mwIruFgs
;

168 
BYTE
 
	mbSourBUSID
;

170 
BYTE
 
	mbSourBUSIRQ
;

172 
BYTE
 
	mbDeiLolAPICID
;

174 
BYTE
 
	mbDeiLolAPICINTIN
;

175 } 
	tLOCALINTERRUPTASSIGNMENTENTRY
;

177 #agm
ck
(
p
)

180 
	skMPCfigutiMagSu


183 
MPFLOATINGPOINTER
* 
	mpMPFltgPor
;

185 
MPCONFIGURATIONTABLEHEADER
* 
	mpMPCfigutiTabHd
;

187 
QWORD
 
	mqwBaErySAddss
;

189 
	miProssCou
;

191 
BOOL
 
	mbUPICMode
;

193 
BYTE
 
	mbISABusID
;

194 } 
	tMPCONFIGURATIONMANAGER
;

197 
BOOL
 
kFdMPFltgPorAddss
(
QWORD
* 
pAddss
);

198 
BOOL
 
kAlysisMPCfigutiTab
();

199 
MPCONFIGURATIONMANAGER
* 
kGMPCfigutiMag
(
voic
);

200 
kPrtMPCfigutiTab
();

201 
kGProssCou
();

	@/home/jk/os/MINT64/save/02.Kernel64/Source/MultiProcessor.c

1 
	~"MuiPross.h
"

2 
	~"MPCfigutiTab.h
"

3 
	~"AsmblyUty.h
"

4 
	~"LolAPIC.h
"

5 
	~"PIT.h
"

7 
BOOL
 
kWakeUpAlitiPross
();

10 vީ
	gg_iWakeUpAlitiProssCou
 = 0;

12 vީ
QWORD
 
	gg_qwAPICIDAddss
 = 0;

15 
BOOL
 
	$kSUpAlitiPross
()

18 if(
	`kAlysisMPCfigutiTab
()==
FALSE
)

20  
FALSE
;

24 
	`kEbGlobLolAPIC
();

27 
	`kEbSoweLolAPIC
();

30 if(
	`kWakeUpAlitiPross
()==
FALSE
)

32  
FALSE
;

35  
TRUE
;

36 
	}
}

40 
BOOL
 
	$kWakeUpAlitiPross
()

42 
MPCONFIGURATIONMANAGER
* 
pMPMag
;

43 
MPCONFIGURATIONTABLEHEADER
* 
pMPHd
;

44 
QWORD
 
qwLolAPICBaAddss
;

45 
BOOL
 
bIruFg
;

46 
i
;

49 
bIruFg
 = 
	`kSIruFg
(
FALSE
);

52 
pMPMag
 = 
	`kGMPCfigutiMag
();

53 
pMPHd
 = 
pMPMag
->
pMPCfigutiTabHd
;

54 
qwLolAPICBaAddss
 =- 
pMPHd
->
dwMemyMIOAddssOfLolAPIC
;

58 
g_qwAPICIDAddss
 = 
qwLolAPICBaAddss
 + 
APIC_REGISTER_APICID
;

68 *(
DWORD
*)(
qwLolAPICBaAddss
+
APIC_REGISTER_ICR_LOWER
)=
APIC_DESTINATIONSHORTHAND_ALLEXCLUDINGSELF
 | 
APIC_TRIGGERMODE_EDGE
 | 
APIC_LEVEL_ASSET
 | 
APIC_DESTINATIONMODE_PHYSICAL
 | 
APIC_DELIVERYMODE_INIT
;

71 
	`kWaUsgDePIT
(
	`MSTOCOUNT
(10));

75 if(*(
DWORD
*)(
qwLolAPICBaAddss
+
APIC_REGISTER_ICR_LOWER
)&
APIC_DELIVERYSTATUS_PENDING
)

78 
	`kInlizePIT
(
	`MSTOCOUNT
(1),
TRUE
);

81 
	`kSIruFg
(
bIruFg
);

82  
FALSE
;

88 
i
=0;i<2;i++)

95 *(
DWORD
*)(
qwLolAPICBaAddss
+
APIC_REGISTER_ICR_LOWER

APIC_DESTINATIONSHORTHAND_ALLEXCLUDINGSELF
 | 
APIC_TRIGGERMODE_EDGE
 | 
APIC_LEVEL_ASSET
 | 
APIC_DESTINATIONMODE_PHYSICAL
 | 
APIC_DELIVERYMODE_STARTUP
 | 0x10;

98 
	`kWaUsgDePIT
(
	`USTOCOUNT
(200));

102 if(*(
DWORD
*)(
qwLolAPICBaAddss
+
APIC_REGISTER_ICR_LOWER
)&
APIC_DELIVERYSTATUS_PENDING
)

105 
	`kInlizePIT
(
	`MSTOCOUNT
(1),
TRUE
);

108 
	`kSIruFg
(
bIruFg
);

109  
FALSE
;

114 
	`kInlizePIT
(
	`MSTOCOUNT
(1),
TRUE
);

117 
	`kSIruFg
(
bIruFg
);

120 
g_iWakeUpAlitiProssCou
<(
pMPMag
->
iProssCou
-1))

122 
	`kS˕
(50);

125  
TRUE
;

126 
	}
}

129 
BYTE
 
	$kGAPICID
()

131 
MPCONFIGURATIONTABLEHEADER
* 
pMPHd
;

132 
QWORD
 
qwLolAPICBaAddss
;

135 if(
g_qwAPICIDAddss
==0)

138 
pMPHd
 = 
	`kGMPCfigutiMag
()->
pMPCfigutiTabHd
;

139 if(
pMPHd
==
NULL
)

145 
qwLolAPICBaAddss
 = 
pMPHd
->
dwMemyMIOAddssOfLolAPIC
;

146 
g_qwAPICIDAddss
 = 
qwLolAPICBaAddss
 + 
APIC_REGISTER_APICID
;

150  *((
DWORD
*)
g_qwAPICIDAddss
)>>24;

151 
	}
}

	@/home/jk/os/MINT64/save/02.Kernel64/Source/MultiProcessor.h

1 #ide
__MULTIPROCESSOR_H__


2 
	#__MULTIPROCESSOR_H__


	)

4 
	~"Tys.h
"

8 
	#BOOTSTRAPPROCESSOR_FLAGADDESS
 0x7C09

	)

10 
	#MAXPROCESSORCOUNT
 16

	)

13 
BOOL
 
kSUpAlitiPross
();

14 
BYTE
 
kGAPICID
();

	@/home/jk/os/MINT64/save/02.Kernel64/Source/PIC.c

1 
	~"PIC.h
"

4 
	$kInlizePIC
()

9 
	`kOutPtBy
(
PIC_MASTER_PORT1
,0x11);

12 
	`kOutPtBy
(
PIC_MASTER_PORT2
,
PIC_IRQSTARTVECTOR
);

16 
	`kOutPtBy
(
PIC_MASTER_PORT2
,0x04);

19 
	`kOutPtBy
(
PIC_MASTER_PORT2
,0x01);

24 
	`kOutPtBy
(
PIC_SLAVE_PORT1
,0x11);

27 
	`kOutPtBy
(
PIC_SLAVE_PORT2
,
PIC_IRQSTARTVECTOR
+8);

31 
	`kOutPtBy
(
PIC_SLAVE_PORT2
,0x02);

34 
	`kOutPtBy
(
PIC_SLAVE_PORT2
,0x01);

35 
	}
}

38 
	$kMaskPICIru
(
WORD
 
wIRQBmask
)

42 
	`kOutPtBy
(
PIC_MASTER_PORT2
,(
BYTE
)
wIRQBmask
);

46 
	`kOutPtBy
(
PIC_SLAVE_PORT2
,(
BYTE
)
wIRQBmask
>>8);

47 
	}
}

52 
	$kSdEOIToPIC
(
iIRQNumb
)

56 
	`kOutPtBy
(
PIC_MASTER_PORT1
,0x20);

59 if(
iIRQNumb
>=8)

62 
	`kOutPtBy
(
PIC_SLAVE_PORT1
,0x20);

64 
	}
}

	@/home/jk/os/MINT64/save/02.Kernel64/Source/PIC.h

1 #ide
__PIC_H__


2 
	#__PIC_H__


	)

4 
	~"Tys.h
"

8 
	#PIC_MASTER_PORT1
 0x20

	)

9 
	#PIC_MASTER_PORT2
 0x21

	)

10 
	#PIC_SLAVE_PORT1
 0xA0

	)

11 
	#PIC_SLAVE_PORT2
 0xA1

	)

14 
	#PIC_IRQSTARTVECTOR
 0x20

	)

17 
kInlizePIC
( );

18 
kMaskPICIru

WORD
 
wIRQBmask
 );

19 
kSdEOIToPIC

iIRQNumb
 );

	@/home/jk/os/MINT64/save/02.Kernel64/Source/PIT.c

1 
	~"PIT.h
"

2 
	~"AsmblyUty.h
"

5 
	$kInlizePIT
(
WORD
 
wCou
,
BOOL
 
bPiodic
)

9 if(
bPiodic
==
TRUE
)

12 
	`kOutPtBy
(
PIT_PORT_CONTROL
,
PIT_COUNTER0_PERIODIC
);

16 
	`kOutPtBy
(
PIT_PORT_CONTROL
,
PIT_COUNTER0_ONCE
);

20 
	`kOutPtBy
(
PIT_PORT_COUNTER0
,
wCou
);

21 
	`kOutPtBy
(
PIT_PORT_COUNTER0
,
wCou
>>8);

22 
	}
}

25 
WORD
 
	$kRdCou0
()

27 
BYTE
 
bHighBy
,
bLowBy
;

28 
WORD
 
wTemp
=0;

31 
	`kOutPtBy
(
PIT_PORT_CONTROL
,
PIT_CONTER0_LATCH
);

34 
bLowBy
 = 
	`kInPtBy
(
PIT_PORT_COUNTER0
);

35 
bHighBy
 = 
	`kInPtBy
(
PIT_PORT_COUNTER0
);

38 
wTemp
 = 
bHighBy
;

39 
wTemp
 = (wTemp<<8)|
bLowBy
;

40  
wTemp
;

41 
	}
}

47 
	$kWaUsgDePIT
(
WORD
 
wCou
)

49 
WORD
 
wLaCou0
;

50 
WORD
 
wCuCou0
;

53 
	`kInlizePIT
(0,
TRUE
);

56 
wLaCou0
 = 
	`kRdCou0
();

60 
wCuCou0
=
	`kRdCou0
();

61 if(((
wLaCou0
-
wCuCou0
)&0xFFFF)>=
wCou
)

66 
	}
}

	@/home/jk/os/MINT64/save/02.Kernel64/Source/PIT.h

1 #ide
__PIT_H__


2 
	#__PIT_H__


	)

4 
	~"Tys.h
"

7 
	#PIT_FREQUENCY
 1193182

	)

8 
	#MSTOCOUNT
(
x
(
PIT_FREQUENCY
*(x)/1000)

	)

9 
	#USTOCOUNT
(
x
(
PIT_FREQUENCY
*(x)/1000000)

	)

12 
	#PIT_PORT_CONTROL
 0x43

	)

13 
	#PIT_PORT_COUNTER0
 0x40

	)

14 
	#PIT_PORT_COUNTER1
 0x41

	)

15 
	#PIT_PORT_COUNTER2
 0x42

	)

18 
	#PIT_CONTROL_COUNTER0
 0x00

	)

19 
	#PIT_CONTROL_COUNTER1
 0x40

	)

20 
	#PIT_CONTROL_COUNTER2
 0x80

	)

21 
	#PIT_CONTROL_LSBMSBRW
 0x30

	)

22 
	#PIT_CONTROL_LATCH
 0x00

	)

23 
	#PIT_CONTROL_MODE0
 0x00

	)

24 
	#PIT_CONTROL_MODE2
 0x04

	)

27 
	#PIT_CONTROL_BINARYCOUNTER
 0x00

	)

28 
	#PIT_CONTROL_BCDCOUNTER
 0x01

	)

30 
	#PIT_COUNTER0_ONCE
 (
PIT_CONTROL_COUNTER0
|
PIT_CONTROL_LSBMSBRW
|
PIT_CONTROL_MODE0
|
PIT_CONTROL_BINARYCOUNTER
)

	)

31 
	#PIT_COUNTER0_PERIODIC
 (
PIT_CONTROL_COUNTER0
|
PIT_CONTROL_LSBMSBRW
|
PIT_CONTROL_MODE2
|
PIT_CONTROL_BINARYCOUNTER
)

	)

32 
	#PIT_CONTER0_LATCH
 (
PIT_CONTROL_COUNTER0
|
PIT_CONTROL_LATCH
)

	)

35 
kInlizePIT
(
WORD
 
wCou
,
BOOL
 
bPiodic
);

36 
WORD
 
kRdCou0
();

37 
kWaUsgDePIT
(
WORD
 
wCou
);

	@/home/jk/os/MINT64/save/02.Kernel64/Source/Queue.c

1 
	~"Queue.h
"

2 
	~"Uty.h
"

5 
	$kInlizeQueue
(
QUEUE
* 
pQueue
,* 
pvQueueBufr
,
iMaxDaCou
,
iDaSize
)

8 
pQueue
->
iMaxDaCou
=iMaxDataCount;

9 
pQueue
->
iDaSize
=iDataSize;

10 
pQueue
->
pvQueueAay
=
pvQueueBufr
;

13 
pQueue
->
iPutIndex
=0;

14 
pQueue
->
iGdex
=0;

15 
pQueue
->
bLaOiPut
=
FALSE
;

16 
	}
}

19 
BOOL
 
	$kIsQueueFu
(cڡ 
QUEUE
* 
pQueue
)

22 if((
pQueue
->
iGdex
=Queue->
iPutIndex
)&&աQueue->
bLaOiPut
==
TRUE
))

24  
TRUE
;

26  
FALSE
;

27 
	}
}

30 
BOOL
 
	$kIsQueueEmy
(cڡ 
QUEUE
* 
pQueue
)

33 if((
pQueue
->
iGdex
=Queue->
iPutIndex
)&&աQueue->
bLaOiPut
==
FALSE
))

35  
TRUE
;

37  
FALSE
;

38 
	}
}

41 
BOOL
 
	$kPutQueue
(
QUEUE
* 
pQueue
,cڡ * 
pvDa
)

43 if(
	`kIsQueueFu
(
pQueue
)==
TRUE
)

45  
FALSE
;

49 
	`kMemCpy
((*)
pQueue
->
pvQueueAay
+աQueue->
iDaSize
*pQueue->
iPutIndex
),
pvDa
,pstQueue->iDataSize);

52 
pQueue
->
iPutIndex
=աQueue->iPutIndex+1)%pQueue->
iMaxDaCou
;

53 
pQueue
->
bLaOiPut
=
TRUE
;

54  
TRUE
;

55 
	}
}

58 
BOOL
 
	$kGQueue
(
QUEUE
* 
pQueue
,* 
pvDa
)

61 if(
	`kIsQueueEmy
(
pQueue
)==
TRUE
)

63  
FALSE
;

67 
	`kMemCpy
(
pvDa
,(*)
pQueue
->
pvQueueAay
+աQueue->
iDaSize
*pQueue->
iGdex
),pstQueue->iDataSize);

70 
pQueue
->
iGdex
=աQueue->iGdex+1)%pQueue->
iMaxDaCou
;

71 
pQueue
->
bLaOiPut
=
FALSE
;

72  
TRUE
;

73 
	}
}

	@/home/jk/os/MINT64/save/02.Kernel64/Source/Queue.h

1 #ide
__QUEUE_H__


2 
	#__QUEUE_H__


	)

4 
	~"Tys.h
"

8 #agm
ck
(
push
,1)

11 
	skQueueMagSu


14 
	miDaSize
;

15 
	miMaxDaCou
;

18 * 
	mpvQueueAay
;

19 
	miPutIndex
;

20 
	miGdex
;

23 
BOOL
 
	mbLaOiPut
;

24 } 
	tQUEUE
;

26 #agm
ck
(
p
)

29 
kInlizeQueue
(
QUEUE
* 
pQueue
,* 
pvQueueBufr
,
iMaxDaCou
,
iDaSize
);

30 
BOOL
 
kIsQueueFu
(cڡ 
QUEUE
* 
pQueue
);

31 
BOOL
 
kIsQueueEmy
(cڡ 
QUEUE
* 
pQueue
);

32 
BOOL
 
kPutQueue
(
QUEUE
* 
pQueue
,cڡ * 
pvDa
);

33 
BOOL
 
kGQueue
(
QUEUE
* 
pQueue
,* 
pvDa
);

	@/home/jk/os/MINT64/save/02.Kernel64/Source/RAMDisk.c

1 
	~"RAMDisk.h
"

2 
	~"Uty.h
"

3 
	~"DymicMemy.h
"

6 
RDDMANAGER
 
	ggs_RDDMag
;

9 
BOOL
 
	$kInlizeRDD
(
DWORD
 
dwTٮSeCou
)

12 
	`kMemS
(&
gs_RDDMag
,0,(gs_stRDDManager));

15 
gs_RDDMag
.
pbBufr
 = (
BYTE
*)
	`kAoMemy
(
dwTٮSeCou
*512);

16 if(
gs_RDDMag
.
pbBufr
==
NULL
)

18  
NULL
;

22 
gs_RDDMag
.
dwTٮSeCou
 = dwTotalSectorCount;

23 
	`kInlizeMux
(&(
gs_RDDMag
.
Mux
));

25  
TRUE
;

26 
	}
}

29 
BOOL
 
	$kRdRDDInfmi
(
BOOL
 
bPrimy
,BOOL 
bMa
,
HDDINFORMATION
* 
pHDDInfmi
)

32 
	`kMemS
(
pHDDInfmi
,0,(
HDDINFORMATION
));

35 
pHDDInfmi
->
dwTٮSes
 = 
gs_RDDMag
.
dwTٮSeCou
;

36 
	`kMemCpy
(
pHDDInfmi
->
vwSlNumb
,"0000-0000",9);

37 
	`kMemCpy
(
pHDDInfmi
->
vwModNumb
,"MINT RAM Disk v1.0",18);

39  
TRUE
;

40 
	}
}

43 
	$kRdRDDSe
(
BOOL
 
bPrimy
,BOOL 
bMa
,
DWORD
 
dwLBA
,
iSeCou
,* 
pcBufr
)

45 
iRlRdCou
;

49 
iRlRdCou
 = 
	`MIN
(
gs_RDDMag
.
dwTٮSeCou
-
dwLBA
,
iSeCou
);

52 
	`kMemCpy
(
pcBufr
,
gs_RDDMag
.
pbBufr
+(
dwLBA
*512),
iRlRdCou
*512);

54  
iRlRdCou
;

55 
	}
}

58 
	$kWreRDDSe
(
BOOL
 
bPrimy
,BOOL 
bMa
,
DWORD
 
dwLBA
,
iSeCou
,* 
pcBufr
)

60 
iRlWreCou
;

64 
iRlWreCou
 = 
	`MIN
(
gs_RDDMag
.
dwTٮSeCou
 - 
dwLBA
,
iSeCou
);

67 
	`kMemCpy
(
gs_RDDMag
.
pbBufr
+(
dwLBA
*512),
pcBufr
,
iRlWreCou
*512);

69  
iRlWreCou
;

70 
	}
}

	@/home/jk/os/MINT64/save/02.Kernel64/Source/RAMDisk.h

1 #ide
__RAMDISK_H__


2 
	#__RAMDISK_H__


	)

5 
	~"Tys.h
"

6 
	~"Synchrizi.h
"

7 
	~"HdDisk.h
"

11 
	#RDD_TOTALSECTORCOUNT
 (8*1024*1024/512)

	)

15 #agm
ck
(
push
,1)

18 
	skRDDMagSu


21 
BYTE
* 
	mpbBufr
;

24 
DWORD
 
	mdwTٮSeCou
;

27 
MUTEX
 
	mMux
;

28 } 
	tRDDMANAGER
;

30 #agm
ck
(
p
)

33 
BOOL
 
kInlizeRDD
(
DWORD
 
dwTٮSeCou
);

34 
BOOL
 
kRdRDDInfmi
(BOOL 
bPrimy
,BOOL 
bMa
,
HDDINFORMATION
* 
pHDDInfmi
);

35 
kRdRDDSe
(
BOOL
 
bPrimy
,BOOL 
bMa
,
DWORD
 
dwLBA
,
iSeCou
,* 
pcBufr
);

36 
kWreRDDSe
(
BOOL
 
bPrimy
,BOOL 
bMa
,
DWORD
 
dwLBA
,
iSeCou
,* 
pcBufr
);

	@/home/jk/os/MINT64/save/02.Kernel64/Source/RTC.c

1 
	~"RTC.h
"

2 
	~"AsmblyUty.h
"

5 
	$kRdRTCTime
(
BYTE
* 
pbHour
,BYTE* 
pbMu
,BYTE* 
pbSecd
)

7 
BYTE
 
bDa
;

10 
	`kOutPtBy
(
RTC_CMOSADDRESS
,
RTC_ADDRESS_HOUR
);

12 
bDa
 = 
	`kInPtBy
(
RTC_CMOSDATA
);

13 *
pbHour
 = 
	`RTC_BCDTOBINARY
(
bDa
);

16 
	`kOutPtBy
(
RTC_CMOSADDRESS
,
RTC_ADDRESS_MINUTE
);

18 
bDa
 = 
	`kInPtBy
(
RTC_CMOSDATA
);

19 *
pbMu
 = 
	`RTC_BCDTOBINARY
(
bDa
);

22 
	`kOutPtBy
(
RTC_CMOSADDRESS
,
RTC_ADDRESS_SECOND
);

24 
bDa
 = 
	`kInPtBy
(
RTC_CMOSDATA
);

25 *
pbSecd
 = 
	`RTC_BCDTOBINARY
(
bDa
);

26 
	}
}

29 
	$kRdRTCDa
(
WORD
* 
pwYr
,
BYTE
* 
pbMth
,BYTE* 
pbDayOfMth
,BYTE* 
pbDayOfWk
)

31 
BYTE
 
bDa
;

34 
	`kOutPtBy
(
RTC_CMOSADDRESS
,
RTC_ADDRESS_YEAR
);

36 
bDa
 = 
	`kInPtBy
(
RTC_CMOSDATA
);

37 *
pwYr
 = 
	`RTC_BCDTOBINARY
(
bDa
)+2000;

40 
	`kOutPtBy
(
RTC_CMOSADDRESS
,
RTC_ADDRESS_MONTH
);

42 
bDa
 = 
	`kInPtBy
(
RTC_CMOSDATA
);

43 *
pbMth
 = 
	`RTC_BCDTOBINARY
(
bDa
);

46 
	`kOutPtBy
(
RTC_CMOSADDRESS
,
RTC_ADDRESS_DAYOFMONTH
);

48 
bDa
 = 
	`kInPtBy
(
RTC_CMOSDATA
);

49 *
pbDayOfMth
 = 
	`RTC_BCDTOBINARY
(
bDa
);

52 
	`kOutPtBy
(
RTC_CMOSADDRESS
,
RTC_ADDRESS_DAYOFWEEK
);

54 
bDa
 = 
	`kInPtBy
(
RTC_CMOSDATA
);

55 *
pbDayOfWk
 = 
	`RTC_BCDTOBINARY
(
bDa
);

56 
	}
}

59 * 
	$kCvtDayOfWkToSg
(
BYTE
 
bDayOfWk
)

61 * 
vpcDayOfWkSg
[8] = {"Error","Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"};

64 if(
bDayOfWk
>=8)

66  
vpcDayOfWkSg
[0];

70  
vpcDayOfWkSg
[
bDayOfWk
];

71 
	}
}

	@/home/jk/os/MINT64/save/02.Kernel64/Source/RTC.h

1 #ide
__RTC_H__


2 
	#__RTC_H__


	)

4 
	~"Tys.h
"

8 
	#RTC_CMOSADDRESS
 0x70

	)

9 
	#RTC_CMOSDATA
 0x71

	)

12 
	#RTC_ADDRESS_SECOND
 0x00

	)

13 
	#RTC_ADDRESS_MINUTE
 0x02

	)

14 
	#RTC_ADDRESS_HOUR
 0x04

	)

15 
	#RTC_ADDRESS_DAYOFWEEK
 0x06

	)

16 
	#RTC_ADDRESS_DAYOFMONTH
 0x07

	)

17 
	#RTC_ADDRESS_MONTH
 0x08

	)

18 
	#RTC_ADDRESS_YEAR
 0x09

	)

21 
	#RTC_BCDTOBINARY
(
x
((((x)>>4)*10)+((x)&0x0F))

	)

24 
kRdRTCTime
(
BYTE
* 
pbHour
,BYTE* 
pbMu
,BYTE* 
pbSecd
);

25 
kRdRTCDa
(
WORD
* 
pwYr
,
BYTE
* 
pbMth
,BYTE* 
pbDayOfMth
,BYTE* 
pbDayOfWk
);

26 * 
kCvtDayOfWkToSg
(
BYTE
 
bDayOfWk
);

	@/home/jk/os/MINT64/save/02.Kernel64/Source/SerialPort.c

1 
	~"SlPt.h
"

2 
	~"Uty.h
"

5 
SERIALMANAGER
 
	ggs_SlMag
;

8 
BOOL
 
kIsSlTnsmrBufrEmy
();

9 
BOOL
 
kIsSlReiveBufrFu
();

12 
	$kInlizeSlPt
()

14 
WORD
 
wPtBaAddss
;

17 
	`kInlizeMux
(&(
gs_SlMag
.
Lock
));

20 
wPtBaAddss
 = 
SERIAL_PORT_COM1
;

23 
	`kOutPtBy
(
wPtBaAddss
+
SERIAL_PORT_INDEX_INTERRUPTENABLE
,0);

27 
	`kOutPtBy
(
wPtBaAddss
+
SERIAL_PORT_INDEX_LINECONTROL
,
SERIAL_LINECONTROL_DLAB
);

29 
	`kOutPtBy
(
wPtBaAddss
+
SERIAL_PORT_INDEX_DIVISORLATCHLSB
,
SERIAL_DIVISORLATCH_115200
);

31 
	`kOutPtBy
(
wPtBaAddss
+
SERIAL_PORT_INDEX_DIVISORLATCHMSB
,
SERIAL_DIVISORLATCH_115200
>>8);

36 
	`kOutPtBy
(
wPtBaAddss
+
SERIAL_PORT_INDEX_LINECONTROL
,
SERIAL_LINECONTROL_8BIT
|
SERIAL_LINECONTROL_NOPARITY
|
SERIAL_LINECONTROL_1BITSTOP
);

39 
	`kOutPtBy
(
wPtBaAddss
+
SERIAL_PORT_INDEX_FIFOCONTROL
,
SERIAL_FIFOCONTROL_FIFOENABLE
|
SERIAL_FIFOCONTROL_14BYTEFIFO
);

40 
	}
}

43 
BOOL
 
	$kIsSlTnsmrBufrEmy
()

45 
BYTE
 
bDa
;

49 
bDa
 = 
	`kInPtBy
(
SERIAL_PORT_COM1
+
SERIAL_PORT_INDEX_LINESTATUS
);

50 if((
bDa
&
SERIAL_LINESTATUS_TRANSMITBUFFEREMPTY
)==SERIAL_LINESTATUS_TRANSMITBUFFEREMPTY)

52  
TRUE
;

55  
FALSE
;

56 
	}
}

59 
	$kSdSlDa
(
BYTE
* 
pbBufr
,
iSize
)

61 
iStBy
;

62 
iTempSize
;

63 
j
;

66 
	`kLock
(&(
gs_SlMag
.
Lock
));

69 
iStBy
!=
iSize
)

72 
	`kIsSlTnsmrBufrEmy
()==
FALSE
)

74 
	`kS˕
(0);

79 
iTempSize
 = 
	`MIN
(
iSize
-
iStBy
,
SERIAL_FIFOMAXSIZE
);

81 
j
=0;j<
iTempSize
;j++)

84 
	`kOutPtBy
(
SERIAL_PORT_COM1
+
SERIAL_PORT_INDEX_TRANSMITBUFFER
,
pbBufr
[
iStBy
+
j
]);

87 
iStBy
 +
iTempSize
;

91 
	`kUock
(&(
gs_SlMag
.
Lock
));

92 
	}
}

95 
BOOL
 
	$kIsSlReiveBufrFu
()

97 
BYTE
 
bDa
;

101 
bDa
 = 
	`kInPtBy
(
SERIAL_PORT_COM1
+
SERIAL_PORT_INDEX_LINESTATUS
);

102 if((
bDa
&
SERIAL_LINESTATUS_RECEIVEDDATAREADY
)==SERIAL_LINESTATUS_RECEIVEDDATAREADY)

104  
TRUE
;

107  
FALSE
;

108 
	}
}

111 
	$kReiveSlDa
(
BYTE
* 
pbBufr
,
iSize
)

113 
i
;

116 
	`kLock
(&(
gs_SlMag
.
Lock
));

119 
i
=0;i<
iSize
;i++)

122 if(
	`kIsSlReiveBufrFu
()==
FALSE
)

128 
pbBufr
[
i
] = 
	`kInPtBy
(
SERIAL_PORT_COM1
+
SERIAL_PORT_INDEX_RECEIVERBUFFER
);

132 
	`kUock
(&(
gs_SlMag
.
Lock
));

135  
i
;

136 
	}
}

139 
	$kCˬSlFIFO
()

142 
	`kLock
(&(
gs_SlMag
.
Lock
));

146 
	`kOutPtBy
(
SERIAL_PORT_COM1
+
SERIAL_PORT_INDEX_FIFOCONTROL
,
SERIAL_FIFOCONTROL_FIFOENABLE
|
SERIAL_FIFOCONTROL_14BYTEFIFO
|
SERIAL_FIFOCONTROL_CLEARRECEIVEFIFO
|
SERIAL_FIFOCONTROL_CLEARTRANSMITFIFO
);

149 
	`kUock
(&(
gs_SlMag
.
Lock
));

150 
	}
}

	@/home/jk/os/MINT64/save/02.Kernel64/Source/SerialPort.h

1 #ide
__SERIALPORT_H__


2 
	#__SERIALPORT_H__


	)

4 
	~"Tys.h
"

5 
	~"Queue.h
"

6 
	~"Synchrizi.h
"

10 
	#SERIAL_PORT_COM1
 0x3F8

	)

11 
	#SERIAL_PORT_COM2
 0x2F8

	)

12 
	#SERIAL_PORT_COM3
 0x3E8

	)

13 
	#SERIAL_PORT_COM4
 0x2E8

	)

16 
	#SERIAL_PORT_INDEX_RECEIVERBUFFER
 0x00

	)

17 
	#SERIAL_PORT_INDEX_TRANSMITBUFFER
 0x00

	)

18 
	#SERIAL_PORT_INDEX_INTERRUPTENABLE
 0x01

	)

19 
	#SERIAL_PORT_INDEX_DIVISORLATCHLSB
 0x00

	)

20 
	#SERIAL_PORT_INDEX_DIVISORLATCHMSB
 0x01

	)

21 
	#SERIAL_PORT_INDEX_INTERRUPTIDENTIFICATION
 0x02

	)

22 
	#SERIAL_PORT_INDEX_FIFOCONTROL
 0x02

	)

23 
	#SERIAL_PORT_INDEX_LINECONTROL
 0x03

	)

24 
	#SERIAL_PORT_INDEX_MODEMCONTROL
 0x04

	)

25 
	#SERIAL_PORT_INDEX_LINESTATUS
 0x05

	)

26 
	#SERIAL_PORT_INDEX_MODEMSTATUS
 0x06

	)

29 
	#SERIAL_INTERRUPTENABLE_RECEIVEBUFFERFULL
 0x01

	)

30 
	#SERIAL_INTERRUPTENABLE_TRANSMITTERBUFFEREMPTY
 0x02

	)

31 
	#SERIAL_INTERRUPTENABLE_LINESTATUS
 0x04

	)

32 
	#SERIAL_INTERRUPTENABLE_DELTASTATUS
 0x08

	)

35 
	#SERIAL_FIFOCONTROL_FIFOENABLE
 0x01

	)

36 
	#SERIAL_FIFOCONTROL_CLEARRECEIVEFIFO
 0x02

	)

37 
	#SERIAL_FIFOCONTROL_CLEARTRANSMITFIFO
 0x04

	)

38 
	#SERIAL_FIFOCONTROL_ENABLEDMA
 0x08

	)

39 
	#SERIAL_FIFOCONTROL_1BYTEFIFO
 0x00

	)

40 
	#SERIAL_FIFOCONTROL_4BYTEFIFO
 0x40

	)

41 
	#SERIAL_FIFOCONTROL_8BYTEFIFO
 0x80

	)

42 
	#SERIAL_FIFOCONTROL_14BYTEFIFO
 0xC0

	)

45 
	#SERIAL_LINECONTROL_8BIT
 0x03

	)

46 
	#SERIAL_LINECONTROL_1BITSTOP
 0x00

	)

47 
	#SERIAL_LINECONTROL_NOPARITY
 0x00

	)

48 
	#SERIAL_LINECONTROL_ODDPARITY
 0x08

	)

49 
	#SERIAL_LINECONTROL_EVENPARITY
 0x18

	)

50 
	#SERIAL_LINECONTROL_MARKPARITY
 0x28

	)

51 
	#SERIAL_LINECONTROL_SPACEPARITY
 0x38

	)

52 
	#SERIAL_LINECONTROL_DLAB
 0x80

	)

55 
	#SERIAL_LINESTATUS_RECEIVEDDATAREADY
 0x01

	)

56 
	#SERIAL_LINESTATUS_OVERRUNERROR
 0x02

	)

57 
	#SERIAL_LINESTATUS_PARITYERROR
 0x04

	)

58 
	#SERIAL_LINESTATUS_FRAMINGERROR
 0x08

	)

59 
	#SERIAL_LINESTATUS_BREAKINDICATOR
 0x10

	)

60 
	#SERIAL_LINESTATUS_TRANSMITBUFFEREMPTY
 0x20

	)

61 
	#SERIAL_LINESTATUS_TRANSMITEMPTY
 0x40

	)

62 
	#SERIAL_LINESTATUS_RECEIVEDCHARACTORERROR
 0x80

	)

65 
	#SERIAL_DIVISORLATCH_115200
 1

	)

66 
	#SERIAL_DIVISORLATCH_57600
 2

	)

67 
	#SERIAL_DIVISORLATCH_38400
 3

	)

68 
	#SERIAL_DIVISORLATCH_19200
 6

	)

69 
	#SERIAL_DIVISORLATCH_9600
 12

	)

70 
	#SERIAL_DIVISORLATCH_4800
 24

	)

71 
	#SERIAL_DIVISORLATCH_2400
 48

	)

74 
	#SERIAL_FIFOMAXSIZE
 16

	)

78 
	skSlPtMag


81 
MUTEX
 
	mLock
;

82 } 
	tSERIALMANAGER
;

85 
kInlizeSlPt
();

86 
kSdSlDa
(
BYTE
* 
pbBufr
,
iSize
);

87 
kReiveSlDa
(
BYTE
* 
pbBufr
,
iSize
);

88 
kCˬSlFIFO
();

	@/home/jk/os/MINT64/save/02.Kernel64/Source/Synchronization.c

1 
	~"Synchrizi.h
"

2 
	~"Uty.h
"

3 
	~"Task.h
"

6 
BOOL
 
	$kLockFSyemDa
()

8  
	`kSIruFg
(
FALSE
);

9 
	}
}

12 
	$kUockFSyemDa
(
BOOL
 
bIruFg
)

14 
	`kSIruFg
(
bIruFg
);

15 
	}
}

18 
	$kInlizeMux
(
MUTEX
* 
pMux
)

21 
pMux
->
bLockFg
 = 
FALSE
;

22 
pMux
->
dwLockCou
=0;

23 
pMux
->
qwTaskID
=
TASK_INVALIDID
;

24 
	}
}

27 
	$kLock
(
MUTEX
* 
pMux
)

30 if(
	`kTeAndS
(&(
pMux
->
bLockFg
),0,1)==
FALSE
)

33 if(
pMux
->
qwTaskID
==
	`kGRugTask
()->
Lk
.
qwID
)

35 
pMux
->
dwLockCou
++;

40 
	`kTeAndS
(&(
pMux
->
bLockFg
),0,1)==
FALSE
)

42 
	`kSchedu
();

47 
pMux
->
dwLockCou
 =1;

48 
pMux
->
qwTaskID
=
	`kGRugTask
()->
Lk
.
qwID
;

50 
	}
}

53 
	$kUock
(
MUTEX
* 
pMux
)

56 if((
pMux
->
bLockFg
==
FALSE
)||աMux->
qwTaskID
!=
	`kGRugTask
()->
Lk
.
qwID
))

62 if(
pMux
->
dwLockCou
>1)

64 
pMux
->
dwLockCou
--;

69 
pMux
->
qwTaskID
 = 
TASK_INVALIDID
;

70 
pMux
->
dwLockCou
 = 0;

71 
pMux
->
bLockFg
=
FALSE
;

73 
	}
}

	@/home/jk/os/MINT64/save/02.Kernel64/Source/Synchronization.h

1 #ide
__SYNCHRONIZATION_H__


2 
	#__SYNCHRONIZATION_H__


	)

4 
	~"Tys.h
"

8 #agm
ck
(
push
,1)

11 
	skMuxtSu


14 vީ
QWORD
 
	mqwTaskID
;

15 vީ
DWORD
 
	mdwLockCou
;

18 vީ
BOOL
 
	mbLockFg
;

21 
BYTE
 
	mvbPaddg
[3];

22 } 
	tMUTEX
;

24 #agm
ck
(
p
)

27 
BOOL
 
kLockFSyemDa
();

28 
kUockFSyemDa
(
BOOL
 
bIruFg
);

30 
kInlizeMux
(
MUTEX
* 
pMux
);

31 
kLock
(
MUTEX
* 
pMux
);

32 
kUock
(
MUTEX
* 
pMux
);

	@/home/jk/os/MINT64/save/02.Kernel64/Source/Task.c

1 
	~"Task.h
"

2 
	~"Dest.h
"

3 
	~"Synchrizi.h
"

6 
SCHEDULER
 
	ggs_Schedur
;

7 
TCBPOOLMANAGER
 
	ggs_TCBPoMag
;

11 
kInlizeTCBPo
();

12 
TCB
* 
kAoTCB
();

13 
kFeTCB
(
QWORD
 
qwID
);

14 
kSUpTask
(
TCB
* 
pTCB
,
QWORD
 
qwFgs
,QWORD 
qwEryPotAddss
,* 
pvSckAddss
,QWORD 
qwSckSize
);

17 
TCB
* 
kGNextTaskToRun
();

18 
BOOL
 
kAddTaskToRdyLi
(
TCB
* 
pTask
);

19 
TCB
* 
kRemoveTaskFromRdyLi
(
QWORD
 
qwTaskID
);

20 
TCB
* 
kGProssByThad
(TCB* 
pThad
);

27 
	$kInlizeTCBPo
()

29 
i
;

31 
	`kMemS
(&(
gs_TCBPoMag
),0,(gs_stTCBPoolManager));

34 
gs_TCBPoMag
.
pSAddss
=(
TCB
*)
TASK_TCBPOOLADDRESS
;

35 
	`kMemS
(
TASK_TCBPOOLADDRESS
,0,(
TCB
)*
TASK_MAXCOUNT
);

38 
i
=0;i<
TASK_MAXCOUNT
;i++)

40 
gs_TCBPoMag
.
pSAddss
[
i
].
Lk
.
qwID
=i;

44 
gs_TCBPoMag
.
iMaxCou
=
TASK_MAXCOUNT
;

45 
gs_TCBPoMag
.
iAodCou
=1;

46 
gs_TCBPoMag
.
iUCou
=0;

47 
	}
}

50 
TCB
* 
	$kAoTCB
()

52 
TCB
* 
pEmyTCB
;

53 
i
;

55 if(
gs_TCBPoMag
.
iUCou
==gs_TCBPoMag.
iMaxCou
)

57  
NULL
;

60 
i
=0;i<
gs_TCBPoMag
.
iMaxCou
;i++)

63 if((
gs_TCBPoMag
.
pSAddss
[
i
].
Lk
.
qwID
>>32)==0)

65 
pEmyTCB
=&(
gs_TCBPoMag
.
pSAddss
[
i
]);

71 
pEmyTCB
->
Lk
.
qwID
=((
QWORD
)
gs_TCBPoMag
.
iAodCou
<<32)|
i
;

72 
gs_TCBPoMag
.
iUCou
++;

73 
gs_TCBPoMag
.
iAodCou
++;

74 if(
gs_TCBPoMag
.
iAodCou
==0)

76 
gs_TCBPoMag
.
iAodCou
=1;

78  
pEmyTCB
;

79 
	}
}

82 
	$kFeTCB
(
QWORD
 
qwID
)

84 
i
;

87 
i
 = 
	`GETTCBOFFSET
(
qwID
);

90 
	`kMemS
(&(
gs_TCBPoMag
.
pSAddss
[
i
].
Cڋxt
),0,(
CONTEXT
));

91 
gs_TCBPoMag
.
pSAddss
[
i
].
Lk
.
qwID
=i;

93 
gs_TCBPoMag
.
iUCou
--;

94 
	}
}

99 
TCB
* 
	$kCeTask
(
QWORD
 
qwFgs
,* 
pvMemyAddss
,QWORD 
qwMemySize
,QWORD 
qwEryPotAddss
)

101 
TCB
* 
pTask
,* 
pPross
;

102 * 
pvSckAddss
;

103 
BOOL
 
bPviousFg
;

106 
bPviousFg
 = 
	`kLockFSyemDa
();

107 
pTask
=
	`kAoTCB
();

108 if(
pTask
==
NULL
)

111 
	`kUockFSyemDa
(
bPviousFg
);

112  
NULL
;

116 
pPross
 = 
	`kGProssByThad
(
	`kGRugTask
());

118 if(
pPross
==
NULL
)

120 
	`kFeTCB
(
pTask
->
Lk
.
qwID
);

122 
	`kUockFSyemDa
(
bPviousFg
);

123  
NULL
;

127 if(
qwFgs
&
TASK_FLAGS_THREAD
)

130 
pTask
->
qwPtProssID
 = 
pPross
->
Lk
.
qwID
;

131 
pTask
->
pvMemyAddss
 = 
pPross
->pvMemoryAddress;

132 
pTask
->
qwMemySize
 = 
pPross
->qwMemorySize;

135 
	`kAddLiToTa
(&(
pPross
->
ChdThadLi
),&(
pTask
->
ThadLk
));

140 
pTask
->
qwPtProssID
 = 
pPross
->
Lk
.
qwID
;

141 
pTask
->
pvMemyAddss
 =vMemoryAddress;

142 
pTask
->
qwMemySize
 = qwMemorySize;

146 
pTask
->
ThadLk
.
qwID
 =Task->
Lk
.qwID;

149 
	`kUockFSyemDa
(
bPviousFg
);

152 
pvSckAddss
=(*)(
TASK_STACKPOOLADDRESS
+(
TASK_STACKSIZE
*
	`GETTCBOFFSET
(
pTask
->
Lk
.
qwID
)));

155 
	`kSUpTask
(
pTask
,
qwFgs
,
qwEryPotAddss
,
pvSckAddss
,
TASK_STACKSIZE
);

158 
	`kInlizeLi
(&(
pTask
->
ChdThadLi
));

161 
pTask
->
bFPUUd
 = 
FALSE
;

164 
bPviousFg
 = 
	`kLockFSyemDa
();

167 
	`kAddTaskToRdyLi
(
pTask
);

170 
	`kUockFSyemDa
(
bPviousFg
);

172  
pTask
;

173 
	}
}

176 
	$kSUpTask
(
TCB
* 
pTCB
,
QWORD
 
qwFgs
,QWORD 
qwEryPotAddss
,* 
pvSckAddss
,QWORD 
qwSckSize
)

179 
	`kMemS
(
pTCB
->
Cڋxt
.
vqRegi
,0,(pstTCB->stContext.vqRegister));

182 
pTCB
->
Cڋxt
.
vqRegi
[
TASK_RSPOFFSET
]=(
QWORD
)
pvSckAddss
+
qwSckSize
-8;

183 
pTCB
->
Cڋxt
.
vqRegi
[
TASK_RBPOFFSET
]=(
QWORD
)
pvSckAddss
+
qwSckSize
-8;

187 *(
QWORD
*)((QWORD)
pvSckAddss
+
qwSckSize
-8)=(QWORD)
kExTask
;

190 
pTCB
->
Cڋxt
.
vqRegi
[
TASK_CSOFFSET
]=
GDT_KERNELCODESEGMENT
;

191 
pTCB
->
Cڋxt
.
vqRegi
[
TASK_DSOFFSET
]=
GDT_KERNELDATASEGMENT
;

192 
pTCB
->
Cڋxt
.
vqRegi
[
TASK_ESOFFSET
]=
GDT_KERNELDATASEGMENT
;

193 
pTCB
->
Cڋxt
.
vqRegi
[
TASK_FSOFFSET
]=
GDT_KERNELDATASEGMENT
;

194 
pTCB
->
Cڋxt
.
vqRegi
[
TASK_GSOFFSET
]=
GDT_KERNELDATASEGMENT
;

195 
pTCB
->
Cڋxt
.
vqRegi
[
TASK_SSOFFSET
]=
GDT_KERNELDATASEGMENT
;

198 
pTCB
->
Cڋxt
.
vqRegi
[
TASK_RIPOFFSET
]=
qwEryPotAddss
;

201 
pTCB
->
Cڋxt
.
vqRegi
[
TASK_RFLAGSOFFSET
]|=0x0200;

204 
pTCB
->
pvSckAddss
=pvStackAddress;

205 
pTCB
->
qwSckSize
=qwStackSize;

206 
pTCB
->
qwFgs
=qwFlags;

207 
	}
}

214 
	$kInlizeSchedur
()

216 
i
;

217 
TCB
* 
pTask
;

220 
	`kInlizeTCBPo
();

223 
i
=0;i<
TASK_MAXREADYLISTCOUNT
;i++)

225 
	`kInlizeLi
(&(
gs_Schedur
.
vRdyLi
[
i
]));

226 
gs_Schedur
.
viExecuCou
[
i
]=0;

228 
	`kInlizeLi
(&(
gs_Schedur
.
WaLi
));

231 
pTask
 = 
	`kAoTCB
();

232 
gs_Schedur
.
pRugTask
 = 
pTask
;

233 
pTask
->
qwFgs
 = 
TASK_FLAGS_HIGHEST
 | 
TASK_FLAGS_PROCESS
 | 
TASK_FLAGS_SYSTEM
;

234 
pTask
->
qwPtProssID
 =Task->
Lk
.
qwID
;

235 
pTask
->
pvMemyAddss
 = (*)0x100000;

236 
pTask
->
qwMemySize
 = 0x500000;

237 
pTask
->
pvSckAddss
 = (*)0x600000;

238 
pTask
->
qwSckSize
 = 0x100000;

239 
	`kInlizeLi
(&(
pTask
->
ChdThadLi
));

242 
gs_Schedur
.
qwSndProssTimeInIdTask
=0;

243 
gs_Schedur
.
qwProssLd
=0;

246 
gs_Schedur
.
qwLaFPUUdTaskID
 = 
TASK_INVALIDID
;

248 
	}
}

252 
	$kSRugTask
(
TCB
* 
pTask
)

254 
BOOL
 
bPviousFg
;

257 
bPviousFg
 = 
	`kLockFSyemDa
();

259 
gs_Schedur
.
pRugTask
=
pTask
;

262 
	`kUockFSyemDa
(
bPviousFg
);

263 
	}
}

266 
TCB
* 
	$kGRugTask
()

268 
BOOL
 
bPviousFg
;

269 
TCB
* 
pRugTask
;

272 
bPviousFg
 = 
	`kLockFSyemDa
();

274 
pRugTask
 = 
gs_Schedur
.pstRunningTask;

277 
	`kUockFSyemDa
(
bPviousFg
);

279  
pRugTask
;

280 
	}
}

286 
	$kSchedu
()

288 
TCB
* 
pRugTask
, * 
pNextTask
;

289 
BOOL
 
bPviousFg
;

292 if(
	`kGRdyTaskCou
()<1)

299 
bPviousFg
=
	`kLockFSyemDa
();

302 
pNextTask
=
	`kGNextTaskToRun
();

303 if(
pNextTask
==
NULL
)

306 
	`kUockFSyemDa
(
bPviousFg
);

311 
pRugTask
=
gs_Schedur
.pstRunningTask;

312 
gs_Schedur
.
pRugTask
=
pNextTask
;

315 if((
pRugTask
->
qwFgs
&
TASK_FLAGS_IDLE
)==TASK_FLAGS_IDLE)

317 
gs_Schedur
.
qwSndProssTimeInIdTask
+=
TASK_PROCESSORTIME
-gs_Schedur.
iProssTime
;

321 if(
gs_Schedur
.
qwLaFPUUdTaskID
!=
pNextTask
->
Lk
.
qwID
)

323 
	`kSTS
();

327 
	`kCˬTS
();

336 
gs_Schedur
.
iProssTime
=
TASK_PROCESSORTIME
;

339 if(
pRugTask
->
qwFgs
&
TASK_FLAGS_ENDTASK
)

341 
	`kAddLiToTa
(&(
gs_Schedur
.
WaLi
),
pRugTask
);

342 
	`kSwchCڋxt
(
NULL
,&(
pNextTask
->
Cڋxt
));

346 
	`kAddTaskToRdyLi
(
pRugTask
);

347 
	`kSwchCڋxt
(&(
pRugTask
->
Cڋxt
),&(
pNextTask
->stContext));

353 
	`kUockFSyemDa
(
bPviousFg
);

354 
	}
}

365 
BOOL
 
	$kScheduInIru
()

367 
TCB
* 
pRugTask
, * 
pNextTask
;

368 * 
pcCڋxtAddss
;

369 
BOOL
 
bPviousFg
;

372 
bPviousFg
 = 
	`kLockFSyemDa
();

375 
pNextTask
=
	`kGNextTaskToRun
();

376 if(
pNextTask
==
NULL
)

379 
	`kUockFSyemDa
(
bPviousFg
);

380  
FALSE
;

387 
pcCڋxtAddss
=(*)
IST_STARTADDRESS
+
IST_SIZE
-(
CONTEXT
);

390 
pRugTask
 = 
gs_Schedur
.pstRunningTask;

391 
gs_Schedur
.
pRugTask
 = 
pNextTask
;

395 if((
pRugTask
->
qwFgs
&
TASK_FLAGS_IDLE
)==TASK_FLAGS_IDLE)

397 
gs_Schedur
.
qwSndProssTimeInIdTask
+=
TASK_PROCESSORTIME
-gs_Schedur.
iProssTime
;

401 if(
pRugTask
->
qwFgs
&
TASK_FLAGS_ENDTASK
)

403 
	`kAddLiToTa
(&(
gs_Schedur
.
WaLi
),
pRugTask
);

409 
	`kMemCpy
(&(
pRugTask
->
Cڋxt
),
pcCڋxtAddss
,(
CONTEXT
));

410 
	`kAddTaskToRdyLi
(
pRugTask
);

414 
	`kUockFSyemDa
(
bPviousFg
);

417 if(
gs_Schedur
.
qwLaFPUUdTaskID
!=
pNextTask
->
Lk
.
qwID
)

419 
	`kSTS
();

423 
	`kCˬTS
();

428 
	`kMemCpy
(
pcCڋxtAddss
,&(
pNextTask
->
Cڋxt
),(
CONTEXT
));

431 
gs_Schedur
.
iProssTime
=
TASK_PROCESSORTIME
;

432  
TRUE
;

433 
	}
}

436 
	$kDeProssTime
()

438 if(
gs_Schedur
.
iProssTime
>0)

440 
gs_Schedur
.
iProssTime
--;

442 
	}
}

445 
BOOL
 
	$kIsProssTimeExped
()

447 if(
gs_Schedur
.
iProssTime
<=0)

449  
TRUE
;

451  
FALSE
;

452 
	}
}

455 
TCB
* 
	$kGNextTaskToRun
()

457 
TCB
* 
pTg
=
NULL
;

458 
iTaskCou
,
i
,
j
;

462 
j
=0;j<2;j++)

465 
i
=0;i<
TASK_MAXREADYLISTCOUNT
;i++)

467 
iTaskCou
 = 
	`kGLiCou
(&(
gs_Schedur
.
vRdyLi
[
i
]));

470 if(
gs_Schedur
.
viExecuCou
[
i
]<
iTaskCou
)

472 
pTg
=(
TCB
*)
	`kRemoveLiFromHd
(&(
gs_Schedur
.
vRdyLi
[
i
]));

473 
gs_Schedur
.
viExecuCou
[
i
]++;

479 
gs_Schedur
.
viExecuCou
[
i
]=0;

484 if(
pTg
!=
NULL
)

490  
pTg
;

491 
	}
}

494 
BOOL
 
	$kAddTaskToRdyLi
(
TCB
* 
pTask
)

496 
BYTE
 
bPriܙy
;

498 
bPriܙy
 = 
	`GETPRIORITY
(
pTask
->
qwFgs
);

499 if(
bPriܙy
>=
TASK_MAXREADYLISTCOUNT
)

501  
FALSE
;

504 
	`kAddLiToTa
(&(
gs_Schedur
.
vRdyLi
[
bPriܙy
]),
pTask
);

505  
TRUE
;

506 
	}
}

509 
TCB
* 
	$kRemoveTaskFromRdyLi
(
QWORD
 
qwTaskID
)

511 
TCB
* 
pTg
;

512 
BYTE
 
bPriܙy
;

515 if(
	`GETTCBOFFSET
(
qwTaskID
)>=
TASK_MAXCOUNT
)

517  
NULL
;

521 
pTg
=&(
gs_TCBPoMag
.
pSAddss
[
	`GETTCBOFFSET
(
qwTaskID
)]);

522 if(
pTg
->
Lk
.
qwID
!=
qwTaskID
)

524  
NULL
;

528 
bPriܙy
 = 
	`GETPRIORITY
(
pTg
->
qwFgs
);

530 
pTg
 = 
	`kRemoveLi
(&(
gs_Schedur
.
vRdyLi
[
bPriܙy
]),
qwTaskID
);

531  
pTg
;

532 
	}
}

535 
BOOL
 
	$kChgePriܙy
(
QWORD
 
qwTaskID
,
BYTE
 
bPriܙy
)

537 
TCB
* 
pTg
;

538 
BOOL
 
bPviousFg
;

541 if(
bPriܙy
>
TASK_MAXREADYLISTCOUNT
)

543  
FALSE
;

547 
bPviousFg
 = 
	`kLockFSyemDa
();

552 
pTg
 = 
gs_Schedur
.
pRugTask
;

553 if(
pTg
->
Lk
.
qwID
 =
qwTaskID
)

555 
	`SETPRIORITY
(
pTg
->
qwFgs
,
bPriܙy
);

561 
pTg
 = 
	`kRemoveTaskFromRdyLi
(
qwTaskID
);

562 if(
pTg
==
NULL
)

567 
pTg
 = 
	`kGTCBInTCBPo
(
	`GETTCBOFFSET
(
qwTaskID
));

568 if((
pTg
!=
NULL
)&&(
qwTaskID
=Tg->
Lk
.
qwID
))

571 
	`SETPRIORITY
(
pTg
->
qwFgs
,
bPriܙy
);

573  
FALSE
;

578 
	`SETPRIORITY
(
pTg
->
qwFgs
,
bPriܙy
);

579 
	`kAddTaskToRdyLi
(
pTg
);

584 
	`kUockFSyemDa
(
bPviousFg
);

585  
TRUE
;

586 
	}
}

589 
BOOL
 
	$kEndTask
(
QWORD
 
qwTaskID
)

591 
TCB
* 
pTg
;

592 
BYTE
 
bPriܙy
;

593 
BOOL
 
bPviousFg
;

596 
bPviousFg
 = 
	`kLockFSyemDa
();

599 
pTg
 = 
gs_Schedur
.
pRugTask
;

600 if(
pTg
->
Lk
.
qwID
==
qwTaskID
)

602 
pTg
->
qwFgs
|=
TASK_FLAGS_ENDTASK
;

604 
	`SETPRIORITY
(
pTg
->
qwFgs
,
TASK_FLAGS_WAIT
);

607 
	`kUockFSyemDa
(
bPviousFg
);

609 
	`kSchedu
();

618 
pTg
=
	`kRemoveTaskFromRdyLi
(
qwTaskID
);

619 if(
pTg
==
NULL
)

626 
pTg
 = 
	`kGTCBInTCBPo
(
	`GETTCBOFFSET
(
qwTaskID
));

627 if((
pTg
!=
NULL
)&&աTg->
Lk
.
qwID
==
qwTaskID
))

629 
pTg
->
qwFgs
|=
TASK_FLAGS_ENDTASK
;

630 
	`SETPRIORITY
(
pTg
->
qwFgs
,
TASK_FLAGS_WAIT
);

634 
	`kUockFSyemDa
(
bPviousFg
);

635  
FALSE
;

638 
pTg
->
qwFgs
|=
TASK_FLAGS_ENDTASK
;

639 
	`SETPRIORITY
(
pTg
->
qwFgs
,
TASK_FLAGS_WAIT
);

640 
	`kAddLiToTa
(&(
gs_Schedur
.
WaLi
),
pTg
);

644 
	`kUockFSyemDa
(
bPviousFg
);

645  
TRUE
;

646 
	}
}

649 
	$kExTask
()

651 
	`kEndTask
(
gs_Schedur
.
pRugTask
->
Lk
.
qwID
);

652 
	}
}

655 
	$kGRdyTaskCou
()

657 
iTٮCou
=0;

658 
i
;

659 
BOOL
 
bPviousFg
;

662 
bPviousFg
 = 
	`kLockFSyemDa
();

665 
i
=0;i<
TASK_MAXREADYLISTCOUNT
;i++)

667 
iTٮCou
+=
	`kGLiCou
(&(
gs_Schedur
.
vRdyLi
[
i
]));

670 
	`kUockFSyemDa
(
bPviousFg
);

671  
iTٮCou
;

672 
	}
}

675 
	$kGTaskCou
()

677 
iTٮCou
;

678 
BOOL
 
bPviousFg
;

681 
iTٮCou
=
	`kGRdyTaskCou
();

684 
bPviousFg
 = 
	`kLockFSyemDa
();

686 
iTٮCou
+=
	`kGLiCou
(&(
gs_Schedur
.
WaLi
))+1;

689 
	`kUockFSyemDa
(
bPviousFg
);

690  
iTٮCou
;

691 
	}
}

694 
TCB
* 
	$kGTCBInTCBPo
(
iOfft
)

696 if((
iOfft
<-1)||(iOfft>
TASK_MAXCOUNT
))

698  
NULL
;

701  &(
gs_TCBPoMag
.
pSAddss
[
iOfft
]);

702 
	}
}

705 
BOOL
 
	$kIsTaskExi
(
QWORD
 
qwID
)

707 
TCB
* 
pTCB
;

710 
pTCB
 = 
	`kGTCBInTCBPo
(
	`GETTCBOFFSET
(
qwID
));

712 if((
pTCB
==
NULL
)||աTCB->
Lk
.
qwID
!=qwID))

714  
FALSE
;

717  
TRUE
;

718 
	}
}

721 
QWORD
 
	$kGProssLd
()

723  
gs_Schedur
.
qwProssLd
;

724 
	}
}

727 
TCB
* 
	$kGProssByThad
(
TCB
* 
pThad
)

729 
TCB
* 
pPross
;

732 if(
pThad
->
qwFgs
&
TASK_FLAGS_PROCESS
)

734  
pThad
;

739 
pPross
 = 
	`kGTCBInTCBPo
(
	`GETTCBOFFSET
(
pThad
->
qwPtProssID
));

742 if((
pPross
==
NULL
)||աPross->
Lk
.
qwID
!=
pThad
->
qwPtProssID
))

744  
NULL
;

747  
pPross
;

748 
	}
}

755 
	$kIdTask
()

757 
TCB
* 
pTask
,* 
pChdThad
,* 
pPross
;

758 
QWORD
 
qwLaMsuTickCou
,
qwLaSndTickInIdTask
;

759 
QWORD
 
qwCutMsuTickCou
,
qwCutSndTickInIdTask
;

760 
BOOL
 
bPviousFg
;

761 
i
, 
iCou
;

762 
QWORD
 
qwTaskID
;

763 * 
pThadLk
;

766 
qwLaSndTickInIdTask
 = 
gs_Schedur
.
qwSndProssTimeInIdTask
;

767 
qwLaMsuTickCou
 = 
	`kGTickCou
();

772 
qwCutMsuTickCou
 = 
	`kGTickCou
();

773 
qwCutSndTickInIdTask
 = 
gs_Schedur
.
qwSndProssTimeInIdTask
;

777 if(
qwCutMsuTickCou
-
qwLaMsuTickCou
==0)

779 
gs_Schedur
.
qwProssLd
=0;

783 
gs_Schedur
.
qwProssLd
=100-(
qwCutSndTickInIdTask
-
qwLaSndTickInIdTask
)*100/(
qwCutMsuTickCou
-
qwLaMsuTickCou
);

786 
qwLaMsuTickCou
 = 
qwCutMsuTickCou
;

787 
qwLaSndTickInIdTask
 = 
qwCutSndTickInIdTask
;

790 
	`kHtProssByLd
();

793 if(
	`kGLiCou
(&(
gs_Schedur
.
WaLi
))>=0)

798 
bPviousFg
 = 
	`kLockFSyemDa
();

799 
pTask
=
	`kRemoveLiFromHd
(&(
gs_Schedur
.
WaLi
));

800 if(
pTask
==
NULL
)

803 
	`kUockFSyemDa
(
bPviousFg
);

807 if(
pTask
->
qwFgs
&
TASK_FLAGS_PROCESS
)

818 
iCou
 = 
	`kGLiCou
(&(
pTask
->
ChdThadLi
));

819 
i
=0;i<
iCou
;i++)

822 
pThadLk
 = (
TCB
*)
	`kRemoveLiFromHd
(&(
pTask
->
ChdThadLi
));

823 if(
pThadLk
==
NULL
)

831 
pChdThad
 = 
	`GETTCBFROMTHREADLINK
(
pThadLk
);

832 
	`kAddLiToTa
(&(
pTask
->
ChdThadLi
),&(
pChdThad
->
ThadLk
));

835 
	`kEndTask
(
pChdThad
->
Lk
.
qwID
);

840 if(
	`kGLiCou
(&(
pTask
->
ChdThadLi
))>0)

842 
	`kAddLiToTa
(&(
gs_Schedur
.
WaLi
),
pTask
);

845 
	`kUockFSyemDa
(
bPviousFg
);

854 if(
pTask
->
qwFgs
&
TASK_FLAGS_THREAD
)

857 
pPross
 = 
	`kGProssByThad
(
pTask
);

858 if(
pPross
!=
NULL
)

860 
	`kRemoveLi
(&(
pPross
->
ChdThadLi
),
pTask
->
Lk
.
qwID
);

865 
qwTaskID
 = 
pTask
->
Lk
.
qwID
;

866 
	`kFeTCB
(
qwTaskID
);

868 
	`kUockFSyemDa
(
bPviousFg
);

869 
	`kPrtf
("IDLE: Task Id[0x%q] icomynded.\n",
qwTaskID
);

874 
	`kSchedu
();

876 
	}
}

879 
	$kHtProssByLd
()

881 if(
gs_Schedur
.
qwProssLd
<40)

883 
	`kH
();

884 
	`kH
();

885 
	`kH
();

887 if(
gs_Schedur
.
qwProssLd
<80)

889 
	`kH
();

890 
	`kH
();

892 if(
gs_Schedur
.
qwProssLd
<95)

894 
	`kH
();

896 
	}
}

902 
QWORD
 
	$kGLaFPUUdTaskID
()

904  
gs_Schedur
.
qwLaFPUUdTaskID
;

905 
	}
}

908 
	$kSLaFPUUdTaskID
(
QWORD
 
qwTaskID
)

910 
gs_Schedur
.
qwLaFPUUdTaskID
 = 
qwTaskID
;

911 
	}
}

	@/home/jk/os/MINT64/save/02.Kernel64/Source/Task.h

1 #ide
__TASK_H__


2 
	#__TASK_H__


	)

4 
	~"Tys.h
"

5 
	~"Li.h
"

9 
	#TASK_REGISTERCOUNT
 (5+19)

	)

10 
	#TASK_REGISTERSIZE
 8

	)

13 
	#TASK_GSOFFSET
 0

	)

14 
	#TASK_FSOFFSET
 1

	)

15 
	#TASK_ESOFFSET
 2

	)

16 
	#TASK_DSOFFSET
 3

	)

17 
	#TASK_R15OFFSET
 4

	)

18 
	#TASK_R14OFFSET
 5

	)

19 
	#TASK_R13OFFSET
 6

	)

20 
	#TASK_R12OFFSET
 7

	)

21 
	#TASK_R11OFFSET
 8

	)

22 
	#TASK_R10OFFSET
 9

	)

23 
	#TASK_R9OFFSET
 10

	)

24 
	#TASK_R8OFFSET
 11

	)

25 
	#TASK_RSIOFFSET
 12

	)

26 
	#TASK_RDIOFFSET
 13

	)

27 
	#TASK_RDXOFFSET
 14

	)

28 
	#TASK_RCXOFFSET
 15

	)

29 
	#TASK_RBXOFFSET
 16

	)

30 
	#TASK_RAXOFFSET
 17

	)

31 
	#TASK_RBPOFFSET
 18

	)

32 
	#TASK_RIPOFFSET
 19

	)

33 
	#TASK_CSOFFSET
 20

	)

34 
	#TASK_RFLAGSOFFSET
 21

	)

35 
	#TASK_RSPOFFSET
 22

	)

36 
	#TASK_SSOFFSET
 23

	)

39 
	#TASK_TCBPOOLADDRESS
 0x800000

	)

40 
	#TASK_MAXCOUNT
 1024

	)

43 
	#TASK_STACKPOOLADDRESS
 (
TASK_TCBPOOLADDRESS
+(
TCB
)*
TASK_MAXCOUNT
)

	)

44 
	#TASK_STACKSIZE
 8192

	)

47 
	#TASK_INVALIDID
 0xFFFFFFFFFFFFFFFF

	)

50 
	#TASK_PROCESSORTIME
 5

	)

53 
	#TASK_MAXREADYLISTCOUNT
 5

	)

56 
	#TASK_FLAGS_HIGHEST
 0

	)

57 
	#TASK_FLAGS_HIGH
 1

	)

58 
	#TASK_FLAGS_MEDIUM
 2

	)

59 
	#TASK_FLAGS_LOW
 3

	)

60 
	#TASK_FLAGS_LOWEST
 4

	)

61 
	#TASK_FLAGS_WAIT
 0xFF

	)

64 
	#TASK_FLAGS_ENDTASK
 0x8000000000000000

	)

65 
	#TASK_FLAGS_SYSTEM
 0x4000000000000000

	)

66 
	#TASK_FLAGS_PROCESS
 0x2000000000000000

	)

67 
	#TASK_FLAGS_THREAD
 0x1000000000000000

	)

68 
	#TASK_FLAGS_IDLE
 0x0800000000000000

	)

71 
	#GETPRIORITY
(
x
((x)&0xFF)

	)

72 
	#SETPRIORITY
(
x
,
iܙy
((x)=((x)&0xFFFFFFFFFFFFFF00)|riܙy))

	)

73 
	#GETTCBOFFSET
(
x
((x)&0xFFFFFFFF)

	)

76 
	#GETTCBFROMTHREADLINK
(
x
(
TCB
*)((
QWORD
)(x)-
	`offtof
(TCB,
ThadLk
))

	)

80 #agm
ck
(
push
,1)

83 
	skCڋxtSu


85 
QWORD
 
	mvqRegi
[
TASK_REGISTERCOUNT
];

86 } 
	tCONTEXT
;

90 
	skTaskCڌBlockSu


93 
LISTLINK
 
	mLk
;

96 
QWORD
 
	mqwFgs
;

99 * 
	mpvMemyAddss
;

100 
QWORD
 
	mqwMemySize
;

106 
LISTLINK
 
	mThadLk
;

109 
QWORD
 
	mqwPtProssID
;

112 
QWORD
 
	mvqwFPUCڋxt
[512/8];

115 
LIST
 
	mChdThadLi
;

118 
CONTEXT
 
	mCڋxt
;

121 * 
	mpvSckAddss
;

122 
QWORD
 
	mqwSckSize
;

125 
BOOL
 
	mbFPUUd
;

128 
	mvcPaddg
[11];

129 } 
	tTCB
;

132 
	skTCBPoMagSu


135 
TCB
* 
	mpSAddss
;

136 
	miMaxCou
;

137 
	miUCou
;

140 
	miAodCou
;

141 } 
	tTCBPOOLMANAGER
;

144 
	skSchedurSu


147 
TCB
* 
	mpRugTask
;

150 
	miProssTime
;

153 
LIST
 
	mvRdyLi
[
TASK_MAXREADYLISTCOUNT
];

156 
LIST
 
	mWaLi
;

159 
	mviExecuCou
[
TASK_MAXREADYLISTCOUNT
];

162 
QWORD
 
	mqwProssLd
;

165 
QWORD
 
	mqwSndProssTimeInIdTask
;

168 
QWORD
 
	mqwLaFPUUdTaskID
;

170 } 
	tSCHEDULER
;

173 #agm
ck
(
p
)

180 
TCB
* 
kCeTask
(
QWORD
 
qwFgs
,* 
pvMemyAddss
,QWORD 
qwMemySize
,QWORD 
qwEryPotAddss
);

186 
kInlizeSchedur
();

187 
kSRugTask
(
TCB
* 
pTask
);

188 
TCB
* 
kGRugTask
();

189 
kSchedu
();

190 
BOOL
 
kScheduInIru
();

191 
kDeProssTime
();

192 
BOOL
 
kIsProssTimeExped
();

193 
BOOL
 
kChgePriܙy
(
QWORD
 
qwID
,
BYTE
 
bPriܙy
);

194 
BOOL
 
kEndTask
(
QWORD
 
qwTaskID
);

195 
kExTask
();

196 
kGRdyTaskCou
();

197 
kGTaskCou
();

198 
TCB
* 
kGTCBInTCBPo
(
iOfft
);

199 
BOOL
 
kIsTaskExi
(
QWORD
 
qwID
);

200 
QWORD
 
kGProssLd
();

206 
kIdTask
();

207 
kHtProssByLd
();

212 
QWORD
 
kGLaFPUUdTaskID
();

213 
kSLaFPUUdTaskID
(
QWORD
 
qwTaskID
);

	@/home/jk/os/MINT64/save/02.Kernel64/Source/Types.h

1 #ide
__TYPES_H__


2 
	#__TYPES_H__


	)

4 
	#BYTE
 

	)

5 
	#WORD
 

	)

6 
	#DWORD
 

	)

7 
	#QWORD
 

	)

8 
	#BOOL
 

	)

10 
	#TRUE
 1

	)

11 
	#FALSE
 0

	)

12 
	#NULL
 0

	)

15 
	#offtof
(
TYPE
,
MEMBER

	`__but_offtof
(TYPE,MEMBER)

	)

17 #agm
ck
(
push
,1)

19 
	skChaSu


21 
BYTE
 
	mbCha
;

22 
BYTE
 
	mbAribu
;

23 } 
	tCHARACTER
;

25 #agm
ck
(
p
)

	@/home/jk/os/MINT64/save/02.Kernel64/Source/Utility.c

1 
	~"Uty.h
"

2 
	~"AsmblyUty.h
"

3 
	~<dg.h
>

6 vީ
QWORD
 
	gg_qwTickCou
=0;

9 
	$kMemS
(* 
pvDei
,
BYTE
 
bDa
,
iSize
)

11 
i
;

13 
i
=0;i<
iSize
;i++)

15 ((*)
pvDei
)[
i
]=
bDa
;

17 
	}
}

20 
	$kMemCpy
(* 
pvDei
,cڡ * 
pvSour
,
iSize
)

22 
i
;

24 
i
=0;i<
iSize
;i++)

26 ((*)
pvDei
)[
i
]=((*)
pvSour
)[i];

29  
iSize
;

30 
	}
}

33 
	$kMemCmp
(cڡ * 
pvDei
,cڡ * 
pvSour
,
iSize
)

35 
i
;

36 
cTemp
;

38 
i
=0;i<
iSize
;i++)

40 
cTemp
=((*)
pvDei
)[
i
]-((*)
pvSour
)[i];

42 if(
cTemp
!=0)

44  ()
cTemp
;

49 
	}
}

52 
BOOL
 
	$kSIruFg
(
BOOL
 
bEbIru
)

54 
QWORD
 
qwRFLAGS
;

57 
qwRFLAGS
=
	`kRdRFLAGS
();

58 if(
bEbIru
==
TRUE
)

60 
	`kEbIru
();

64 
	`kDibIru
();

68 if(
qwRFLAGS
&0x0200)

70  
TRUE
;

73  
FALSE
;

74 
	}
}

77 
	$kSL
(cڡ * 
pcBufr
)

79 
i
;

81 
i
=0;;i++)

83 if(
pcBufr
[
i
]=='\0')

89  
i
;

90 
	}
}

93 
	ggs_qwTٮRAMMBSize
=0;

96 
	$kCheckTٮRAMSize
()

98 
DWORD
* 
pdwCutAddss
;

99 
DWORD
 
dwPviousVue
;

102 
pdwCutAddss
 =(
DWORD
*)0x4000000;

106 
dwPviousVue
 = *
pdwCutAddss
;

108 *
pdwCutAddss
 = 0x12345678;

109 if(*
pdwCutAddss
!=0x12345678)

115 *
pdwCutAddss
=
dwPviousVue
;

117 
pdwCutAddss
+=(0x400000/4);

122 
gs_qwTٮRAMMBSize
 = (
QWORD
)
pdwCutAddss
/0x100000;

123 
	}
}

126 
QWORD
 
	$kGTٮRAMSize
()

128  
gs_qwTٮRAMMBSize
;

129 
	}
}

132 
	$kAToI
(cڡ * 
pcBufr
,
iRadix
)

134 
lRu
;

136 
iRadix
)

141 
lRu
 = 
	`kHexSgToQwd
(
pcBufr
);

147 
lRu
 = 
	`kDecimSgToLg
(
pcBufr
);

151  
lRu
;

152 
	}
}

155 
QWORD
 
	$kHexSgToQwd
(cڡ * 
pcBufr
)

157 
QWORD
 
qwVue
 = 0;

158 
i
;

161 
i
=0;
pcBufr
[i]!='\0';i++)

163 
qwVue
*=16;

164 if(('A'<=
pcBufr
[
i
])&&(pcBuffer[i]<='Z'))

166 
qwVue
+=((
pcBufr
[
i
]-'A')+10);

168 if(('a'<=
pcBufr
[
i
])&&(pcBuffer[i]<='z'))

170 
qwVue
+=((
pcBufr
[
i
]-'a')+10);

174 
qwVue
+=(
pcBufr
[
i
]-'0');

178  
qwVue
;

179 
	}
}

182 
	$kDecimSgToLg
(cڡ * 
pcBufr
)

184 
lVue
=0;

185 
i
;

188 if(
pcBufr
[0]=='-')

190 
i
=1;

194 
i
=0;

198 ;
pcBufr
[
i
]!='\0';i++)

200 
lVue
*=10;

201 
lVue
+=
pcBufr
[
i
]-'0';

205 if(
pcBufr
[0]=='-')

207 
lVue
=-lValue;

210  
lVue
;

211 
	}
}

214 
	$kIToA
(
lVue
,* 
pcBufr
,
iRadix
)

216 
iRu
;

218 
iRadix
)

223 
iRu
=
	`kHexToSg
(
lVue
,
pcBufr
);

229 
iRu
=
	`kDecimTorg
(
lVue
,
pcBufr
);

233  
iRu
;

234 
	}
}

237 
	$kHexToSg
(
QWORD
 
qwVue
,* 
pcBufr
)

239 
QWORD
 
i
;

240 
QWORD
 
qwCutVue
;

243 if(
qwVue
==0)

245 
pcBufr
[0]='0';

246 
pcBufr
[1]='\0';

251 
i
=0;
qwVue
>0;i++)

253 
qwCutVue
=
qwVue
%16;

254 if(
qwCutVue
>=10)

256 
pcBufr
[
i
]='A'+(
qwCutVue
-10);

260 
pcBufr
[
i
]='0'+
qwCutVue
;

263 
qwVue
=qwValue/16;

266 
pcBufr
[
i
]='\0';

269 
	`kRevSg
(
pcBufr
);

270  
i
;

271 
	}
}

274 
	$kDecimTorg
(
lVue
,* 
pcBufr
)

276 
i
;

279 if(
lVue
==0)

281 
pcBufr
[0]='0';

282 
pcBufr
[1]='\0';

287 if(
lVue
<0)

289 
i
=1;

290 
pcBufr
[0]='-';

291 
lVue
=-lValue;

295 
i
=0;

299 ;
lVue
>0;
i
++)

301 
pcBufr
[
i
]='0'+
lVue
%10;

302 
lVue
=lValue/10;

304 
pcBufr
[
i
]='\0';

307 if(
pcBufr
[0]=='-')

310 
	`kRevSg
(&(
pcBufr
[1]));

314 
	`kRevSg
(
pcBufr
);

317  
i
;

318 
	}
}

321 
	$kRevSg
(* 
pcBufr
)

323 
iLgth
;

324 
i
;

325 
cTemp
;

328 
iLgth
=
	`kSL
(
pcBufr
);

329 
i
=0;i<
iLgth
/2;i++)

331 
cTemp
=
pcBufr
[
i
];

332 
pcBufr
[
i
]cBufr[
iLgth
-1-i];

333 
pcBufr
[
iLgth
-1-
i
]=
cTemp
;

335 
	}
}

338 
	$kSPrtf
(* 
pcBufr
,cڡ * 
pcFmSg
,...)

340 
va_li
 

;

341 
iRu
;

344 
	`va_t
(

,
pcFmSg
);

345 
iRu
=
	`kVSPrtf
(
pcBufr
,
pcFmSg
,

);

346 
	`va_d
(

);

348  
iRu
;

349 
	}
}

353 
	$kVSPrtf
(* 
pcBufr
,cڡ * 
pcFmSg
,
va_li
 

)

355 
QWORD
 
i
,
j
,
k
;

356 
iBufrIndex
=0;

357 
iFmLgth
,
iCyLgth
;

358 * 
pcCySg
;

359 
QWORD
 
qwVue
;

360 
iVue
;

361 
dVue
;

364 
iFmLgth
=
	`kSL
(
pcFmSg
);

365 
i
=0;i<
iFmLgth
;i++)

368 if(
pcFmSg
[
i
]=='%')

371 
i
++;

372 
pcFmSg
[
i
])

377 
pcCySg
=(*)(
	`va_g
(

,*));

378 
iCyLgth
=
	`kSL
(
pcCySg
);

380 
	`kMemCpy
(
pcBufr
+
iBufrIndex
,
pcCySg
,
iCyLgth
);

381 
iBufrIndex
+=
iCyLgth
;

387 
pcBufr
[
iBufrIndex
]=()(
	`va_g
(

,));

388 
iBufrIndex
++;

396 
iVue
=()(
	`va_g
(

,));

397 
iBufrIndex
+=
	`kIToA
(
iVue
,
pcBufr
+iBufferIndex,10);

405 
qwVue
=(
DWORD
)(
	`va_g
(

,DWORD))&0xFFFFFFFF;

406 
iBufrIndex
+=
	`kIToA
(
qwVue
,
pcBufr
+iBufferIndex,16);

415 
qwVue
=(
QWORD
)(
	`va_g
(

,QWORD));

416 
iBufrIndex
+=
	`kIToA
(
qwVue
,
pcBufr
+iBufferIndex,16);

420 
dVue
 = ()(
	`va_g
(

,));

422 
dVue
 +=0.005;

424 
pcBufr
[
iBufrIndex
]='0'+(
QWORD
)(
dVue
*100)%10;

425 
pcBufr
[
iBufrIndex
+1]='0'+(
QWORD
)(
dVue
*10)%10;

426 
pcBufr
[
iBufrIndex
+2]='.';

428 
k
=0;;k++)

431 if(((
QWORD
)
dVue
==0)&&(
k
!=0))

435 
pcBufr
[
iBufrIndex
+3+
k
]='0'+((
QWORD
)
dVue
%10);

436 
dVue
=dValue/10;

438 
pcBufr
[
iBufrIndex
+3+
k
]='\0';

440 
	`kRevSg
(
pcBufr
+
iBufrIndex
);

441 
iBufrIndex
+=3+
k
;

446 
pcBufr
[
iBufrIndex
]=
pcFmSg
[
i
];

447 
iBufrIndex
++;

455 
pcBufr
[
iBufrIndex
] = 
pcFmSg
[
i
];

456 
iBufrIndex
++;

461 
pcBufr
[
iBufrIndex
]='\0';

462  
iBufrIndex
;

463 
	}
}

466 
QWORD
 
	$kGTickCou
()

468  
g_qwTickCou
;

469 
	}
}

472 
	$kS˕
(
QWORD
 
qwMlicd
)

474 
QWORD
 
qwLaTickCou
;

476 
qwLaTickCou
 = 
g_qwTickCou
;

478 (
g_qwTickCou
-
qwLaTickCou
)<=
qwMlicd
)

480 
	`kSchedu
();

482 
	}
}

	@/home/jk/os/MINT64/save/02.Kernel64/Source/Utility.h

1 #ide
__UTILITY_H__


2 
	#__UTILITY_H__


	)

4 
	~"/u/oss/lib/gcc/x86_64-pc-lux/4.8.2/ude/dg.h
"

5 
	~"Tys.h
"

8 
	#MIN
(
x
,
y
(((x)<(y))?(x):(y))

	)

9 
	#MAX
(
x
,
y
(((x)<(y))?(x):(y))

	)

12 
kMemS
(* 
pvDei
, 
BYTE
 
bDa
, 
iSize
);

13 
kMemCpy
(* 
pvDei
,cڡ * 
pvSour
,
iSize
);

14 
kMemCmp
(cڡ * 
pvDei
,cڡ * 
pvSour
,
iSize
);

15 
BOOL
 
kSIruFg
(BOOL 
bEbIru
);

16 
kCheckTٮRAMSize
();

17 
QWORD
 
kGTٮRAMSize
();

18 
kRevSg
(* 
pcBufr
);

19 
kAToI
(cڡ * 
pcBufr
,
iRadix
);

20 
QWORD
 
kHexSgToQwd
(cڡ * 
pcBufr
);

21 
kDecimSgToLg
(cڡ * 
pcBufr
);

22 
kIToA
(
lvue
,* 
pcBufr
,
iRadix
);

23 
kHexToSg
(
QWORD
 
qwVue
,* 
Bufr
);

24 
kDecimTorg
(
lVue
,* 
pcBufr
);

25 
kSPrtf
(* 
pcBufr
,cڡ * 
pcFmSg
,...);

26 
kVSPrtf
(* 
pcBufr
,cڡ * 
pcFmSg
,
va_li
 

);

27 
QWORD
 
kGTickCou
();

28 
kS˕
(
QWORD
 
qwMlicd
);

31 vީ
QWORD
 
g_qwTickCou
;

	@/home/jk/os/MINT64/save/02.Kernel64/Source/main.c

1 
	~"Tys.h
"

2 
	~"Keybrd.h
"

3 
	~"Dest.h
"

4 
	~"PIC.h
"

5 
	~"Cse.h
"

6 
	~"CseShl.h
"

7 
	~"Task.h
"

8 
	~"PIT.h
"

9 
	~"DymicMemy.h
"

10 
	~"HdDisk.h
"

11 
	~"FeSyem.h
"

12 
	~"SlPt.h
"

13 
	~"MuiPross.h
"

16 
maFAlitiPross
();

19 
	$ma
( )

21 
iCursX
, 
iCursY
;

25 if(*((
BYTE
*)
BOOTSTRAPPROCESSOR_FLAGADDESS
)==0)

27 
	`maFAlitiPross
();

32 *((
BYTE
*)
BOOTSTRAPPROCESSOR_FLAGADDESS
)=0;

35 
	`kInlizeCse
( 0, 10 );

36 
	`kPrtf
( "Switch To IA-32e Mode Success~!!\n" );

37 
	`kPrtf
( "IA-32e C Language Kernel Start..............[Pass]\n" );

38 
	`kPrtf
( "Initialize Console..........................[Pass]\n" );

41 
	`kGCurs
&
iCursX
, &
iCursY
 );

42 
	`kPrtf
( "GDT Initialize And Switch For IA-32e Mode...[ ]" );

43 
	`kInlizeGDTTabAndTSS
();

44 
	`kLdGDTR

GDTR_STARTADDRESS
 );

45 
	`kSCurs
45, 
iCursY
++ );

46 
	`kPrtf
( "Pass\n" );

48 
	`kPrtf
( "TSS Segment Load............................[ ]" );

49 
	`kLdTR

GDT_TSSSEGMENT
 );

50 
	`kSCurs
45, 
iCursY
++ );

51 
	`kPrtf
( "Pass\n" );

53 
	`kPrtf
( "IDT Initialize..............................[ ]" );

54 
	`kInlizeIDTTabs
();

55 
	`kLdIDTR

IDTR_STARTADDRESS
 );

56 
	`kSCurs
45, 
iCursY
++ );

57 
	`kPrtf
( "Pass\n" );

59 
	`kPrtf
( "Total RAM Size Check........................[ ]" );

60 
	`kCheckTٮRAMSize
();

61 
	`kSCurs
45, 
iCursY
++ );

62 
	`kPrtf
"Pass], Siz%d MB\n", 
	`kGTٮRAMSize
() );

64 
	`kPrtf
("TCB Poll And Scheduler Initialize...........[Pass]\n");

65 
iCursY
++;

66 
	`kInlizeSchedur
();

69 
	`kPrtf
("Dynamic Memory Initialize...................[Pass]\n");

70 
iCursY
++;

71 
	`kInlizeDymicMemy
();

74 
	`kInlizePIT
(
	`MSTOCOUNT
(1),1);

76 
	`kPrtf
( "Keyboard Activate And Queue Initialize......[ ]" );

78 if
	`kInlizeKeybrd
(=
TRUE
 )

80 
	`kSCurs
45, 
iCursY
++ );

81 
	`kPrtf
( "Pass\n" );

82 
	`kChgeKeybrdLED

FALSE
, FALSE, FALSE );

86 
	`kSCurs
45, 
iCursY
++ );

87 
	`kPrtf
( "Fail\n" );

91 
	`kPrtf
( "PIC Controller And Interrupt Initialize.....[ ]" );

93 
	`kInlizePIC
();

94 
	`kMaskPICIru
( 0 );

95 
	`kEbIru
();

96 
	`kSCurs
45, 
iCursY
++ );

97 
	`kPrtf
( "Pass\n" );

100 
	`kPrtf
("File System Initialize......................[ ]");

101 if(
	`kInlizeFeSyem
()==
TRUE
)

103 
	`kSCurs
(45,
iCursY
++);

104 
	`kPrtf
("Pass\n");

108 
	`kSCurs
(45,
iCursY
++);

109 
	`kPrtf
("Fail\n");

113 
	`kPrtf
("Serial Port Initialize......................[Pass]\n");

114 
iCursY
++;

115 
	`kInlizeSlPt
();

118 
	`kCeTask
(
TASK_FLAGS_LOWEST
 | 
TASK_FLAGS_THREAD
 | 
TASK_FLAGS_SYSTEM
 | 
TASK_FLAGS_IDLE
,0,0,(
QWORD
)
kIdTask
);

119 
	`kSCseShl
();

120 
	}
}

124 
	$maFAlitiPross
()

126 
QWORD
 
qwTickCou
;

129 
	`kLdGDTR
(
GDTR_STARTADDRESS
);

133 
	`kLdTR
(
GDT_TSSSEGMENT
+(
	`kGAPICID
()*(
GDTENTRY16
)));

136 
	`kLdIDTR
(
IDTR_STARTADDRESS
);

139 
qwTickCou
 = 
	`kGTickCou
();

143 if(
	`kGTickCou
()-
qwTickCou
>1000)

145 
qwTickCou
 = 
	`kGTickCou
();

147 
	`kPrtf
("Aliti Pross[APIC ID: %d] IAived\n",
	`kGAPICID
());

150 
	}
}

	@/home/jk/os/MINT64/testdata.c

1 
	~<dio.h
>

2 
	ga
;

3 
	gc
;

4 
	gd
=0;

5 
	gb
 =1;

7 
	$ma
()

9 
	`tf
("%d %d\n",
a
,
b
);

10  
a
+
b
;

11 
	}
}

	@/usr/cross/lib/gcc/x86_64-pc-linux/4.8.2/include/stdarg.h

28 #ide
_STDARG_H


29 #ide
_ANSI_STDARG_H_


30 #ide
__ed___va_li


31 
	#_STDARG_H


	)

32 
	#_ANSI_STDARG_H_


	)

34 #unde
__ed___va_li


38 #ide
__GNUC_VA_LIST


39 
	#__GNUC_VA_LIST


	)

40 
__but_va_li
 
	t__gnuc_va_li
;

45 #ifde
_STDARG_H


47 
	#va_t
(
v
,
l

	`__but_va_t
(v,l)

	)

48 
	#va_d
(
v

	`__but_va_d
(v)

	)

49 
	#va_g
(
v
,
l

	`__but_va_g
(v,l)

	)

50 #i!
defed
(
__STRICT_ANSI__
|| 
__STDC_VERSION__
 + 0 >199900L || defed(
__GXX_EXPERIMENTAL_CXX0X__
)

51 
	#va_cy
(
d
,
s

	`__but_va_cy
(d,s)

	)

53 
	#__va_cy
(
d
,
s

	`__but_va_cy
(d,s)

	)

62 #ifde
_BSD_VA_LIST


63 #unde
_BSD_VA_LIST


66 #i
defed
(
__svr4__
|| (defed(
_SCO_DS
&& !defed(
__VA_LIST
))

71 #ide
_VA_LIST_


72 
	#_VA_LIST_


	)

73 #ifde
__i860__


74 #ide
_VA_LIST


75 
	#_VA_LIST
 
va_li


	)

78 
__gnuc_va_li
 
	tva_li
;

79 #ifde
_SCO_DS


80 
	#__VA_LIST


	)

89 #i!
defed
 (
_VA_LIST_
|| defed (
__BSD_NET2__
|| defed (
____386BSD____
|| defed (
__bsdi__
|| defed (
__qut__
|| defed (
__FeBSD__
|| defed(
WINNT
)

91 #ide
_VA_LIST_DEFINED


93 #ide
_VA_LIST


95 #ide
_VA_LIST_T_H


97 #ide
__va_li__


98 
__gnuc_va_li
 
	tva_li
;

103 #i!(
defed
 (
__BSD_NET2__
|| defed (
____386BSD____
|| defed (
__bsdi__
|| defed (
__qut__
|| defed (
__FeBSD__
))

104 
	#_VA_LIST_


	)

106 #ide
_VA_LIST


107 
	#_VA_LIST


	)

109 #ide
_VA_LIST_DEFINED


110 
	#_VA_LIST_DEFINED


	)

112 #ide
_VA_LIST_T_H


113 
	#_VA_LIST_T_H


	)

115 #ide
__va_li__


116 
	#__va_li__


	)

	@/usr/include/errno.h

22 #idef 
_ERRNO_H


26 #idef 
__ed_Emh


27 
	#_ERRNO_H
 1

	)

28 
	~<us.h
>

31 
	g__BEGIN_DECLS


35 
	~<bs/o.h
>

36 #unde
__ed_Emh


38 #ifdef 
_ERRNO_H


45 #idef 
o


46 
o
;

49 #ifde
__USE_GNU


54 *
ogm_voti_me
, *
ogm_voti_sht_me
;

58 
	g__END_DECLS


66 #i
defed
 
__USE_GNU
 || defed 
__ed_r_t


67 #ide
__r_t_defed


68 
	tr_t
;

69 
	#__r_t_defed
 1

	)

71 #unde
__ed_r_t


	@/usr/include/fcntl.h

22 #idef 
_FCNTL_H


23 
	#_FCNTL_H
 1

	)

25 
	~<us.h
>

28 
	g__BEGIN_DECLS


31 
	~<bs/tys.h
>

35 
	~<bs/f.h
>

40 #ide
__mode_t_defed


41 
__mode_t
 
	tmode_t
;

42 
	#__mode_t_defed


	)

45 #ide
__off_t_defed


46 #ide
__USE_FILE_OFFSET64


47 
__off_t
 
	toff_t
;

49 
__off64_t
 
	toff_t
;

51 
	#__off_t_defed


	)

54 #i
defed
 
__USE_LARGEFILE64
 && !defed 
__off64_t_defed


55 
__off64_t
 
	toff64_t
;

56 
	#__off64_t_defed


	)

59 #ide
__pid_t_defed


60 
__pid_t
 
	tpid_t
;

61 
	#__pid_t_defed


	)

65 #i
defed
 
__USE_XOPEN
 || defed 
__USE_XOPEN2K8


66 
	#__ed_timeec


	)

67 
	~<time.h
>

68 
	~<bs/.h
>

70 
	#S_IFMT
 
__S_IFMT


	)

71 
	#S_IFDIR
 
__S_IFDIR


	)

72 
	#S_IFCHR
 
__S_IFCHR


	)

73 
	#S_IFBLK
 
__S_IFBLK


	)

74 
	#S_IFREG
 
__S_IFREG


	)

75 #ifde
__S_IFIFO


76 
	#S_IFIFO
 
__S_IFIFO


	)

78 #ifde
__S_IFLNK


79 
	#S_IFLNK
 
__S_IFLNK


	)

81 #i(
defed
 
__USE_UNIX98
 || defed 
__USE_XOPEN2K8
&& defed 
__S_IFSOCK


82 
	#S_IFSOCK
 
__S_IFSOCK


	)

87 
	#S_ISUID
 
__S_ISUID


	)

88 
	#S_ISGID
 
__S_ISGID


	)

90 #i
defed
 
__USE_BSD
 || defed 
__USE_MISC
 || defed 
__USE_XOPEN


92 
	#S_ISVTX
 
__S_ISVTX


	)

95 
	#S_IRUSR
 
__S_IREAD


	)

96 
	#S_IWUSR
 
__S_IWRITE


	)

97 
	#S_IXUSR
 
__S_IEXEC


	)

99 
	#S_IRWXU
 (
__S_IREAD
|
__S_IWRITE
|
__S_IEXEC
)

	)

101 
	#S_IRGRP
 (
S_IRUSR
 >> 3

	)

102 
	#S_IWGRP
 (
S_IWUSR
 >> 3

	)

103 
	#S_IXGRP
 (
S_IXUSR
 >> 3

	)

105 
	#S_IRWXG
 (
S_IRWXU
 >> 3)

	)

107 
	#S_IROTH
 (
S_IRGRP
 >> 3

	)

108 
	#S_IWOTH
 (
S_IWGRP
 >> 3

	)

109 
	#S_IXOTH
 (
S_IXGRP
 >> 3

	)

111 
	#S_IRWXO
 (
S_IRWXG
 >> 3)

	)

114 #ifdef 
__USE_MISC


115 #ide
R_OK


118 
	#R_OK
 4

	)

119 
	#W_OK
 2

	)

120 
	#X_OK
 1

	)

121 
	#F_OK
 0

	)

126 #i
defed
 
__USE_XOPEN
 || defed 
__USE_XOPEN2K8


127 
	#SEEK_SET
 0

	)

128 
	#SEEK_CUR
 1

	)

129 
	#SEEK_END
 2

	)

137 
f
 (
__fd
, 
__cmd
, ...);

145 #ide
__USE_FILE_OFFSET64


146 
	$ݒ
 (cڡ *
__fe
, 
__oag
, ...
	`__nnu
 ((1));

148 #ifde
__REDIRECT


149 
	`__REDIRECT
 (
ݒ
, (cڡ *
__fe
, 
__oag
, ...), 
ݒ64
)

150 
	`__nnu
 ((1));

152 
	#ݒ
 
ݒ64


	)

155 #ifde
__USE_LARGEFILE64


156 
	$ݒ64
 (cڡ *
__fe
, 
__oag
, ...
	`__nnu
 ((1));

159 #ifde
__USE_ATFILE


169 #ide
__USE_FILE_OFFSET64


170 
	$ݒ
 (
__fd
, cڡ *
__fe
, 
__oag
, ...)

171 
	`__nnu
 ((2));

173 #ifde
__REDIRECT


174 
	`__REDIRECT
 (
ݒ
, (
__fd
, cڡ *
__fe
, 
__oag
,

175 ...), 
ݒ64

	`__nnu
 ((2));

177 
	#ݒ
 
ݒ64


	)

180 #ifde
__USE_LARGEFILE64


181 
	$ݒ64
 (
__fd
, cڡ *
__fe
, 
__oag
, ...)

182 
	`__nnu
 ((2));

191 #ide
__USE_FILE_OFFSET64


192 
	$t
 (cڡ *
__fe
, 
mode_t
 
__mode

	`__nnu
 ((1));

194 #ifde
__REDIRECT


195 
	`__REDIRECT
 (
t
, (cڡ *
__fe
, 
mode_t
 
__mode
),

196 
t64

	`__nnu
 ((1));

198 
	#t
 
t64


	)

201 #ifde
__USE_LARGEFILE64


202 
	$t64
 (cڡ *
__fe
, 
mode_t
 
__mode

	`__nnu
 ((1));

205 #i!
defed
 
F_LOCK
 && (defed 
__USE_MISC
 || (defed 
__USE_XOPEN_EXTENDED
 \

206 && !
defed
 
__USE_POSIX
))

215 
	#F_ULOCK
 0

	)

216 
	#F_LOCK
 1

	)

217 
	#F_TLOCK
 2

	)

218 
	#F_TEST
 3

	)

220 #ide
__USE_FILE_OFFSET64


221 
	`lockf
 (
__fd
, 
__cmd
, 
off_t
 
__n
);

223 #ifde
__REDIRECT


224 
	`__REDIRECT
 (
lockf
, (
__fd
, 
__cmd
, 
__off64_t
 
__n
), 
lockf64
);

226 
	#lockf
 
lockf64


	)

229 #ifde
__USE_LARGEFILE64


230 
	`lockf64
 (
__fd
, 
__cmd
, 
off64_t
 
__n
);

234 #ifde
__USE_XOPEN2K


237 #ide
__USE_FILE_OFFSET64


238 
	$posix_dvi
 (
__fd
, 
off_t
 
__offt
, off_
__n
,

239 
__advi

__THROW
;

241 #ifde
__REDIRECT_NTH


242 
	`__REDIRECT_NTH
 (
posix_dvi
, (
__fd
, 
__off64_t
 
__offt
,

243 
__off64_t
 
__n
, 
__advi
),

244 
posix_dvi64
);

246 
	#posix_dvi
 
posix_dvi64


	)

249 #ifde
__USE_LARGEFILE64


250 
	$posix_dvi64
 (
__fd
, 
off64_t
 
__offt
, off64_
__n
,

251 
__advi

__THROW
;

259 #ide
__USE_FILE_OFFSET64


260 
	`posix_o
 (
__fd
, 
off_t
 
__offt
, off_
__n
);

262 #ifde
__REDIRECT


263 
	`__REDIRECT
 (
posix_o
, (
__fd
, 
__off64_t
 
__offt
,

264 
__off64_t
 
__n
),

265 
posix_o64
);

267 
	#posix_o
 
posix_o64


	)

270 #ifde
__USE_LARGEFILE64


271 
	`posix_o64
 (
__fd
, 
off64_t
 
__offt
, off64_
__n
);

277 #i
__USE_FORTIFY_LEVEL
 > 0 && 
defed
 
__ftify_funi
 \

278 && 
defed
 
__va_g_ck_n


279 
	~<bs/f2.h
>

282 
__END_DECLS


	@/usr/include/netinet/in.h

18 #idef 
_NETINET_IN_H


19 
	#_NETINET_IN_H
 1

	)

21 
	~<us.h
>

22 
	~<dt.h
>

23 
	~<sys/sock.h
>

24 
	~<bs/tys.h
>

27 
__BEGIN_DECLS


30 
ut32_t
 
	t_addr_t
;

31 
	s_addr


33 
_addr_t
 
	ms_addr
;

37 
	~<bs/.h
>

42 
	mIPPROTO_IP
 = 0,

43 
	#IPPROTO_IP
 
IPPROTO_IP


	)

44 
	mIPPROTO_ICMP
 = 1,

45 
	#IPPROTO_ICMP
 
IPPROTO_ICMP


	)

46 
	mIPPROTO_IGMP
 = 2,

47 
	#IPPROTO_IGMP
 
IPPROTO_IGMP


	)

48 
	mIPPROTO_IPIP
 = 4,

49 
	#IPPROTO_IPIP
 
IPPROTO_IPIP


	)

50 
	mIPPROTO_TCP
 = 6,

51 
	#IPPROTO_TCP
 
IPPROTO_TCP


	)

52 
	mIPPROTO_EGP
 = 8,

53 
	#IPPROTO_EGP
 
IPPROTO_EGP


	)

54 
	mIPPROTO_PUP
 = 12,

55 
	#IPPROTO_PUP
 
IPPROTO_PUP


	)

56 
	mIPPROTO_UDP
 = 17,

57 
	#IPPROTO_UDP
 
IPPROTO_UDP


	)

58 
	mIPPROTO_IDP
 = 22,

59 
	#IPPROTO_IDP
 
IPPROTO_IDP


	)

60 
	mIPPROTO_TP
 = 29,

61 
	#IPPROTO_TP
 
IPPROTO_TP


	)

62 
	mIPPROTO_DCCP
 = 33,

63 
	#IPPROTO_DCCP
 
IPPROTO_DCCP


	)

64 
	mIPPROTO_IPV6
 = 41,

65 
	#IPPROTO_IPV6
 
IPPROTO_IPV6


	)

66 
	mIPPROTO_RSVP
 = 46,

67 
	#IPPROTO_RSVP
 
IPPROTO_RSVP


	)

68 
	mIPPROTO_GRE
 = 47,

69 
	#IPPROTO_GRE
 
IPPROTO_GRE


	)

70 
	mIPPROTO_ESP
 = 50,

71 
	#IPPROTO_ESP
 
IPPROTO_ESP


	)

72 
	mIPPROTO_AH
 = 51,

73 
	#IPPROTO_AH
 
IPPROTO_AH


	)

74 
	mIPPROTO_MTP
 = 92,

75 
	#IPPROTO_MTP
 
IPPROTO_MTP


	)

76 
	mIPPROTO_BEETPH
 = 94,

77 
	#IPPROTO_BEETPH
 
IPPROTO_BEETPH


	)

78 
	mIPPROTO_ENCAP
 = 98,

79 
	#IPPROTO_ENCAP
 
IPPROTO_ENCAP


	)

80 
	mIPPROTO_PIM
 = 103,

81 
	#IPPROTO_PIM
 
IPPROTO_PIM


	)

82 
	mIPPROTO_COMP
 = 108,

83 
	#IPPROTO_COMP
 
IPPROTO_COMP


	)

84 
	mIPPROTO_SCTP
 = 132,

85 
	#IPPROTO_SCTP
 
IPPROTO_SCTP


	)

86 
	mIPPROTO_UDPLITE
 = 136,

87 
	#IPPROTO_UDPLITE
 
IPPROTO_UDPLITE


	)

88 
	mIPPROTO_RAW
 = 255,

89 
	#IPPROTO_RAW
 
IPPROTO_RAW


	)

90 
	mIPPROTO_MAX


96 #ide
__USE_KERNEL_IPV6_DEFS


99 
	mIPPROTO_HOPOPTS
 = 0,

100 
	#IPPROTO_HOPOPTS
 
IPPROTO_HOPOPTS


	)

101 
	mIPPROTO_ROUTING
 = 43,

102 
	#IPPROTO_ROUTING
 
IPPROTO_ROUTING


	)

103 
	mIPPROTO_FRAGMENT
 = 44,

104 
	#IPPROTO_FRAGMENT
 
IPPROTO_FRAGMENT


	)

105 
	mIPPROTO_ICMPV6
 = 58,

106 
	#IPPROTO_ICMPV6
 
IPPROTO_ICMPV6


	)

107 
	mIPPROTO_NONE
 = 59,

108 
	#IPPROTO_NONE
 
IPPROTO_NONE


	)

109 
	mIPPROTO_DSTOPTS
 = 60,

110 
	#IPPROTO_DSTOPTS
 
IPPROTO_DSTOPTS


	)

111 
	mIPPROTO_MH
 = 135

112 
	#IPPROTO_MH
 
IPPROTO_MH


	)

117 
ut16_t
 
	t_pt_t
;

122 
	mIPPORT_ECHO
 = 7,

123 
	mIPPORT_DISCARD
 = 9,

124 
	mIPPORT_SYSTAT
 = 11,

125 
	mIPPORT_DAYTIME
 = 13,

126 
	mIPPORT_NETSTAT
 = 15,

127 
	mIPPORT_FTP
 = 21,

128 
	mIPPORT_TELNET
 = 23,

129 
	mIPPORT_SMTP
 = 25,

130 
	mIPPORT_TIMESERVER
 = 37,

131 
	mIPPORT_NAMESERVER
 = 42,

132 
	mIPPORT_WHOIS
 = 43,

133 
	mIPPORT_MTP
 = 57,

135 
	mIPPORT_TFTP
 = 69,

136 
	mIPPORT_RJE
 = 77,

137 
	mIPPORT_FINGER
 = 79,

138 
	mIPPORT_TTYLINK
 = 87,

139 
	mIPPORT_SUPDUP
 = 95,

142 
	mIPPORT_EXECSERVER
 = 512,

143 
	mIPPORT_LOGINSERVER
 = 513,

144 
	mIPPORT_CMDSERVER
 = 514,

145 
	mIPPORT_EFSSERVER
 = 520,

148 
	mIPPORT_BIFFUDP
 = 512,

149 
	mIPPORT_WHOSERVER
 = 513,

150 
	mIPPORT_ROUTESERVER
 = 520,

153 
	mIPPORT_RESERVED
 = 1024,

156 
	mIPPORT_USERRESERVED
 = 5000

164 
	#IN_CLASSA
(
a
((((
_addr_t
))& 0x80000000=0)

	)

165 
	#IN_CLASSA_NET
 0xff000000

	)

166 
	#IN_CLASSA_NSHIFT
 24

	)

167 
	#IN_CLASSA_HOST
 (0xfffffff& ~
IN_CLASSA_NET
)

	)

168 
	#IN_CLASSA_MAX
 128

	)

170 
	#IN_CLASSB
(
a
((((
_addr_t
))& 0xc0000000=0x80000000)

	)

171 
	#IN_CLASSB_NET
 0xffff0000

	)

172 
	#IN_CLASSB_NSHIFT
 16

	)

173 
	#IN_CLASSB_HOST
 (0xfffffff& ~
IN_CLASSB_NET
)

	)

174 
	#IN_CLASSB_MAX
 65536

	)

176 
	#IN_CLASSC
(
a
((((
_addr_t
))& 0xe0000000=0xc0000000)

	)

177 
	#IN_CLASSC_NET
 0xffffff00

	)

178 
	#IN_CLASSC_NSHIFT
 8

	)

179 
	#IN_CLASSC_HOST
 (0xfffffff& ~
IN_CLASSC_NET
)

	)

181 
	#IN_CLASSD
(
a
((((
_addr_t
))& 0xf0000000=0xe0000000)

	)

182 
	#IN_MULTICAST
(
a

	`IN_CLASSD
)

	)

184 
	#IN_EXPERIMENTAL
(
a
((((
_addr_t
))& 0xe0000000=0xe0000000)

	)

185 
	#IN_BADCLASS
(
a
((((
_addr_t
))& 0xf0000000=0xf0000000)

	)

188 
	#INADDR_ANY
 ((
_addr_t
0x00000000)

	)

190 
	#INADDR_BROADCAST
 ((
_addr_t
0xffffffff)

	)

192 
	#INADDR_NONE
 ((
_addr_t
0xffffffff)

	)

195 
	#IN_LOOPBACKNET
 127

	)

197 #ide
INADDR_LOOPBACK


198 
	#INADDR_LOOPBACK
 ((
_addr_t
0x7f000001

	)

202 
	#INADDR_UNSPEC_GROUP
 ((
_addr_t
0xe0000000

	)

203 
	#INADDR_ALLHOSTS_GROUP
 ((
_addr_t
0xe0000001

	)

204 
	#INADDR_ALLRTRS_GROUP
 ((
_addr_t
0xe0000002

	)

205 
	#INADDR_MAX_LOCAL_GROUP
 ((
_addr_t
0xe00000ff

	)

207 #ide
__USE_KERNEL_IPV6_DEFS


209 
	s6_addr


213 
ut8_t
 
	m__u6_addr8
[16];

214 #i
defed
 
__USE_MISC
 || defed 
__USE_GNU


215 
ut16_t
 
	m__u6_addr16
[8];

216 
ut32_t
 
	m__u6_addr32
[4];

218 } 
	m__6_u
;

219 
	#s6_addr
 
__6_u
.
__u6_addr8


	)

220 #i
defed
 
__USE_MISC
 || defed 
__USE_GNU


221 
	#s6_addr16
 
__6_u
.
__u6_addr16


	)

222 
	#s6_addr32
 
__6_u
.
__u6_addr32


	)

227 cڡ 
6_addr
 
6addr_y
;

228 cڡ 
6_addr
 
6addr_loback
;

229 
	#IN6ADDR_ANY_INIT
 { { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } } }

	)

230 
	#IN6ADDR_LOOPBACK_INIT
 { { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 } } }

	)

232 
	#INET_ADDRSTRLEN
 16

	)

233 
	#INET6_ADDRSTRLEN
 46

	)

237 
	ssockaddr_


239 
__SOCKADDR_COMMON
 (
s_
);

240 
_pt_t
 
	ms_pt
;

241 
_addr
 
	ms_addr
;

244 
	ms_zo
[ (
sockaddr
) -

245 
__SOCKADDR_COMMON_SIZE
 -

246  (
_pt_t
) -

247  (
_addr
)];

250 #ide
__USE_KERNEL_IPV6_DEFS


252 
	ssockaddr_6


254 
__SOCKADDR_COMMON
 (
s6_
);

255 
_pt_t
 
	ms6_pt
;

256 
ut32_t
 
	ms6_owfo
;

257 
6_addr
 
	ms6_addr
;

258 
ut32_t
 
	ms6_sce_id
;

262 #i
defed
 
__USE_MISC
 || defed 
__USE_GNU


264 
	s_mq


267 
_addr
 
	mimr_muɟddr
;

270 
_addr
 
	mimr_r
;

273 
	s_mq_sour


276 
_addr
 
	mimr_muɟddr
;

279 
_addr
 
	mimr_r
;

282 
_addr
 
	mimr_souraddr
;

286 #ide
__USE_KERNEL_IPV6_DEFS


288 
	sv6_mq


291 
6_addr
 
	mv6mr_muɟddr
;

294 
	mv6mr_r
;

298 #i
defed
 
__USE_MISC
 || defed 
__USE_GNU


300 
	sgroup_q


303 
ut32_t
 
	mgr_r
;

306 
sockaddr_age
 
	mgr_group
;

309 
	sgroup_sour_q


312 
ut32_t
 
	mg_r
;

315 
sockaddr_age
 
	mg_group
;

318 
sockaddr_age
 
	mg_sour
;

323 
	s_msfr


326 
_addr
 
	mimsf_muɟddr
;

329 
_addr
 
	mimsf_r
;

332 
ut32_t
 
	mimsf_fmode
;

335 
ut32_t
 
	mimsf_numc
;

337 
_addr
 
	mimsf_i
[1];

340 
	#IP_MSFILTER_SIZE
(
numc
( (
_msfr
) \

341 -  (
_addr
) \

342 + (
numc
*  (
_addr
))

	)

344 
	sgroup_fr


347 
ut32_t
 
	mgf_r
;

350 
sockaddr_age
 
	mgf_group
;

353 
ut32_t
 
	mgf_fmode
;

356 
ut32_t
 
	mgf_numc
;

358 
sockaddr_age
 
	mgf_i
[1];

361 
	#GROUP_FILTER_SIZE
(
numc
( (
group_fr
) \

362 -  (
sockaddr_age
) \

363 + ((
numc
) \

364 *  (
sockaddr_age
)))

	)

374 
ut32_t
 
	$ohl
 (
ut32_t
 
__Îg

__THROW
 
	`__ibu__
 ((
__cڡ__
));

375 
ut16_t
 
	$ohs
 (
ut16_t
 
__tsht
)

376 
__THROW
 
	`__ibu__
 ((
__cڡ__
));

377 
ut32_t
 
	$htl
 (
ut32_t
 
__holg
)

378 
__THROW
 
	`__ibu__
 ((
__cڡ__
));

379 
ut16_t
 
	$hts
 (
ut16_t
 
__hosht
)

380 
__THROW
 
	`__ibu__
 ((
__cڡ__
));

382 
	~<dn.h
>

385 
	~<bs/bysw.h
>

387 #ifde
__OPTIMIZE__


391 #i
__BYTE_ORDER
 =
__BIG_ENDIAN


394 
	#ohl
(
x
(x)

	)

395 
	#ohs
(
x
(x)

	)

396 
	#htl
(
x
(x)

	)

397 
	#hts
(
x
(x)

	)

399 #i
__BYTE_ORDER
 =
__LITTLE_ENDIAN


400 
	#ohl
(
x

	`__bsw_32
 (x)

	)

401 
	#ohs
(
x

	`__bsw_16
 (x)

	)

402 
	#htl
(
x

	`__bsw_32
 (x)

	)

403 
	#hts
(
x

	`__bsw_16
 (x)

	)

408 #ifde
__GNUC__


409 
	#IN6_IS_ADDR_UNSPECIFIED
(
a
) \

410 (
__exnsi__
 \

411 ({ cڡ 
6_addr
 *
__a
 = (cڡ 6_add*(
a
); \

412 
__a
->
s6_addr32
[0] == 0 \

413 && 
__a
->
s6_addr32
[1] == 0 \

414 && 
__a
->
s6_addr32
[2] == 0 \

415 && 
__a
->
s6_addr32
[3] =0; 
	}
}))

	)

417 
	#IN6_IS_ADDR_LOOPBACK
(
a
) \

418 (
__exnsi__
 \

419 ({ cڡ 
6_addr
 *
__a
 = (cڡ 6_add*(
a
); \

420 
__a
->
s6_addr32
[0] == 0 \

421 && 
__a
->
s6_addr32
[1] == 0 \

422 && 
__a
->
s6_addr32
[2] == 0 \

423 && 
__a
->
s6_addr32
[3] =
	`htl
 (1); }))

	)

425 
	#IN6_IS_ADDR_LINKLOCAL
(
a
) \

426 (
__exnsi__
 \

427 ({ cڡ 
6_addr
 *
__a
 = (cڡ 6_add*(
a
); \

428 (
__a
->
s6_addr32
[0] & 
	`htl
 (0xffc00000)=ht(0x800000); }))

	)

430 
	#IN6_IS_ADDR_SITELOCAL
(
a
) \

431 (
__exnsi__
 \

432 ({ cڡ 
6_addr
 *
__a
 = (cڡ 6_add*(
a
); \

433 (
__a
->
s6_addr32
[0] & 
	`htl
 (0xffc00000)=ht(0xc00000); }))

	)

435 
	#IN6_IS_ADDR_V4MAPPED
(
a
) \

436 (
__exnsi__
 \

437 ({ cڡ 
6_addr
 *
__a
 = (cڡ 6_add*(
a
); \

438 
__a
->
s6_addr32
[0] == 0 \

439 && 
__a
->
s6_addr32
[1] == 0 \

440 && 
__a
->
s6_addr32
[2] =
	`htl
 (0xffff); }))

	)

442 
	#IN6_IS_ADDR_V4COMPAT
(
a
) \

443 (
__exnsi__
 \

444 ({ cڡ 
6_addr
 *
__a
 = (cڡ 6_add*(
a
); \

445 
__a
->
s6_addr32
[0] == 0 \

446 && 
__a
->
s6_addr32
[1] == 0 \

447 && 
__a
->
s6_addr32
[2] == 0 \

448 && 
	`ohl
 (
__a
->
s6_addr32
[3]> 1; }))

	)

450 
	#IN6_ARE_ADDR_EQUAL
(
a
,
b
) \

451 (
__exnsi__
 \

452 ({ cڡ 
6_addr
 *
__a
 = (cڡ 6_add*(
a
); \

453 cڡ 
6_addr
 *
__b
 = (cڡ 6_add*(
b
); \

454 
__a
->
s6_addr32
[0] =
__b
->s6_addr32[0] \

455 && 
__a
->
s6_addr32
[1] =
__b
->s6_addr32[1] \

456 && 
__a
->
s6_addr32
[2] =
__b
->s6_addr32[2] \

457 && 
__a
->
s6_addr32
[3] =
__b
->s6_addr32[3]; }))

	)

459 
	#IN6_IS_ADDR_UNSPECIFIED
(
a
) \

460 (((cڡ 
ut32_t
 *(
a
))[0] == 0 \

461 && ((cڡ 
ut32_t
 *(
a
))[1] == 0 \

462 && ((cڡ 
ut32_t
 *(
a
))[2] == 0 \

463 && ((cڡ 
ut32_t
 *(
a
))[3] =0)

	)

465 
	#IN6_IS_ADDR_LOOPBACK
(
a
) \

466 (((cڡ 
ut32_t
 *(
a
))[0] == 0 \

467 && ((cڡ 
ut32_t
 *(
a
))[1] == 0 \

468 && ((cڡ 
ut32_t
 *(
a
))[2] == 0 \

469 && ((cڡ 
ut32_t
 *(
a
))[3] =
	`htl
 (1))

	)

471 
	#IN6_IS_ADDR_LINKLOCAL
(
a
) \

472 ((((cڡ 
ut32_t
 *(
a
))[0] & 
	`htl
 (0xffc00000)) \

473 =
	`htl
 (0x800000))

	)

475 
	#IN6_IS_ADDR_SITELOCAL
(
a
) \

476 ((((cڡ 
ut32_t
 *(
a
))[0] & 
	`htl
 (0xffc00000)) \

477 =
	`htl
 (0xc00000))

	)

479 
	#IN6_IS_ADDR_V4MAPPED
(
a
) \

480 ((((cڡ 
ut32_t
 *(
a
))[0] == 0) \

481 && (((cڡ 
ut32_t
 *(
a
))[1] == 0) \

482 && (((cڡ 
ut32_t
 *(
a
))[2] =
	`htl
 (0xffff)))

	)

484 
	#IN6_IS_ADDR_V4COMPAT
(
a
) \

485 ((((cڡ 
ut32_t
 *(
a
))[0] == 0) \

486 && (((cڡ 
ut32_t
 *(
a
))[1] == 0) \

487 && (((cڡ 
ut32_t
 *(
a
))[2] == 0) \

488 && (
	`ohl
 (((cڡ 
ut32_t
 *(
a
))[3]> 1))

	)

490 
	#IN6_ARE_ADDR_EQUAL
(
a
,
b
) \

491 ((((cڡ 
ut32_t
 *(
a
))[0] =((cڡ ut32_*(
b
))[0]) \

492 && (((cڡ 
ut32_t
 *(
a
))[1] =((cڡ ut32_*(
b
))[1]) \

493 && (((cڡ 
ut32_t
 *(
a
))[2] =((cڡ ut32_*(
b
))[2]) \

494 && (((cڡ 
ut32_t
 *(
a
))[3] =((cڡ ut32_*(
b
))[3]))

	)

497 
	#IN6_IS_ADDR_MULTICAST
(
a
(((cڡ 
ut8_t
 *))[0] =0xff)

	)

499 #i
defed
 
__USE_MISC
 || defed 
__USE_GNU


501 
	$bdsvpt
 (
__sockfd
, 
sockaddr_
 *
__sock_

__THROW
;

504 
	$bdsvpt6
 (
__sockfd
, 
sockaddr_6
 *
__sock_
)

505 
__THROW
;

509 
	#IN6_IS_ADDR_MC_NODELOCAL
(
a
) \

510 (
	`IN6_IS_ADDR_MULTICAST
(
a
) \

511 && ((((cڡ 
ut8_t
 *(
a
))[1] & 0xf=0x1))

	)

513 
	#IN6_IS_ADDR_MC_LINKLOCAL
(
a
) \

514 (
	`IN6_IS_ADDR_MULTICAST
(
a
) \

515 && ((((cڡ 
ut8_t
 *(
a
))[1] & 0xf=0x2))

	)

517 
	#IN6_IS_ADDR_MC_SITELOCAL
(
a
) \

518 (
	`IN6_IS_ADDR_MULTICAST
(
a
) \

519 && ((((cڡ 
ut8_t
 *(
a
))[1] & 0xf=0x5))

	)

521 
	#IN6_IS_ADDR_MC_ORGLOCAL
(
a
) \

522 (
	`IN6_IS_ADDR_MULTICAST
(
a
) \

523 && ((((cڡ 
ut8_t
 *(
a
))[1] & 0xf=0x8))

	)

525 
	#IN6_IS_ADDR_MC_GLOBAL
(
a
) \

526 (
	`IN6_IS_ADDR_MULTICAST
(
a
) \

527 && ((((cڡ 
ut8_t
 *(
a
))[1] & 0xf=0xe))

	)

530 #ifde
__USE_GNU


531 
cmsghdr
;

534 
	s6_pktfo


536 
6_addr
 
i6_addr
;

537 
i6_ifdex
;

541 
	s6_mtufo


543 
sockaddr_6
 
6m_addr
;

544 
ut32_t
 
6m_mtu
;

549 
	$6_ti_a
 (
__nbys
)

550 
__THROW
 
__ibu_dd__
;

551 
	$6_ti_
 (*
__bp
, 
cmsghdr
 **
__cmsgp
,

552 
__ty

__THROW
 
__ibu_dd__
;

553 
	$6_ti_nd
 (
cmsghdr
 *
__cmsg
,

554 cڡ 
ut8_t
 *
__typ
, 
__mux
,

555 
__usy

__THROW
 
__ibu_dd__
;

556 
ut8_t
 *
	$6_ti_loc
 (
cmsghdr
 *
__cmsg
, 
__d
,

557 
__mux
, 
__usy
)

558 
__THROW
 
__ibu_dd__
;

559 
	$6_ti_xt
 (cڡ 
cmsghdr
 *
__cmsg
,

560 
ut8_t
 **
__p
)

561 
__THROW
 
__ibu_dd__
;

562 
	$6_ti_fd
 (cڡ 
cmsghdr
 *
__cmsg
,

563 
ut8_t
 **
__p
, 
__ty
)

564 
__THROW
 
__ibu_dd__
;

568 
	$6_t_
 (*
__extbuf
, 
sockn_t
 
__ex

__THROW
;

569 
	$6_t_nd
 (*
__extbuf
, 
sockn_t
 
__ex
, 
__offt
,

570 
ut8_t
 
__ty
, 
sockn_t
 
__n
, ut8_
__ign
,

571 **
__dabu

__THROW
;

572 
	$6_t_fish
 (*
__extbuf
, 
sockn_t
 
__ex
, 
__offt
)

573 
__THROW
;

574 
	$6_t_t_v
 (*
__dabuf
, 
__offt
, *
__v
,

575 
sockn_t
 
__vn

__THROW
;

576 
	$6_t_xt
 (*
__extbuf
, 
sockn_t
 
__ex
, 
__offt
,

577 
ut8_t
 *
__typ
, 
sockn_t
 *
__
,

578 **
__dabu

__THROW
;

579 
	$6_t_fd
 (*
__extbuf
, 
sockn_t
 
__ex
, 
__offt
,

580 
ut8_t
 
__ty
, 
sockn_t
 *
__
,

581 **
__dabu

__THROW
;

582 
	$6_t_g_v
 (*
__dabuf
, 
__offt
, *
__v
,

583 
sockn_t
 
__vn

__THROW
;

587 
sockn_t
 
	$6_h_a
 (
__ty
, 
__gmts

__THROW
;

588 *
	$6_h_
 (*
__bp
, 
sockn_t
 
__bp_n
, 
__ty
,

589 
__gmts

__THROW
;

590 
	$6_h_add
 (*
__bp
, cڡ 
6_addr
 *
__addr

__THROW
;

591 
	$6_h_v
 (cڡ *
__
, *
__out

__THROW
;

592 
	$6_h_gmts
 (cڡ *
__bp

__THROW
;

593 
6_addr
 *
	$6_h_gaddr
 (cڡ *
__bp
, 
__dex
)

594 
__THROW
;

600 
	$gv4sourfr
 (
__s
, 
_addr
 
__r_addr
,

601 
_addr
 
__group
, 
ut32_t
 *
__fmode
,

602 
ut32_t
 *
__numc
, 
_addr
 *
__i
)

603 
__THROW
;

606 
	$tv4sourfr
 (
__s
, 
_addr
 
__r_addr
,

607 
_addr
 
__group
, 
ut32_t
 
__fmode
,

608 
ut32_t
 
__numc
,

609 cڡ 
_addr
 *
__i
)

610 
__THROW
;

614 
	$gsourfr
 (
__s
, 
ut32_t
 
__r_addr
,

615 cڡ 
sockaddr
 *
__group
,

616 
sockn_t
 
__grou
, 
ut32_t
 *
__fmode
,

617 
ut32_t
 *
__numc
,

618 
sockaddr_age
 *
__i

__THROW
;

621 
	$tsourfr
 (
__s
, 
ut32_t
 
__r_addr
,

622 cڡ 
sockaddr
 *
__group
,

623 
sockn_t
 
__grou
, 
ut32_t
 
__fmode
,

624 
ut32_t
 
__numc
,

625 cڡ 
sockaddr_age
 *
__i

__THROW
;

628 
__END_DECLS


	@/usr/include/stdio.h

23 #ide
_STDIO_H


25 #i!
defed
 
__ed_FILE
 && !defed 
__ed___FILE


26 
	#_STDIO_H
 1

	)

27 
	~<us.h
>

29 
	g__BEGIN_DECLS


31 
	#__ed_size_t


	)

32 
	#__ed_NULL


	)

33 
	~<ddef.h
>

35 
	~<bs/tys.h
>

36 
	#__ed_FILE


	)

37 
	#__ed___FILE


	)

41 #i!
defed
 
__FILE_defed
 && defed 
__ed_FILE


44 
	g_IO_FILE
;

46 
__BEGIN_NAMESPACE_STD


48 
_IO_FILE
 
	tFILE
;

49 
	g__END_NAMESPACE_STD


50 #i
defed
 
__USE_LARGEFILE64
 || defed 
__USE_SVID
 || defed 
__USE_POSIX
 \

51 || 
defed
 
	g__USE_BSD
 || defed 
	g__USE_ISOC99
 || defed 
	g__USE_XOPEN
 \

52 || 
defed
 
__USE_POSIX2


53 
	$__USING_NAMESPACE_STD
(
FILE
)

56 
	#__FILE_defed
 1

	)

58 #unde
__ed_FILE


61 #i!
defed
 
____FILE_defed
 && defed 
__ed___FILE


64 
_IO_FILE
 
	t__FILE
;

66 
	#____FILE_defed
 1

	)

68 #unde
__ed___FILE


71 #ifdef 
_STDIO_H


72 
	#_STDIO_USES_IOSTREAM


	)

74 
	~<libio.h
>

76 #i
defed
 
__USE_XOPEN
 || defed 
__USE_XOPEN2K8


77 #ifde
__GNUC__


78 #ide
_VA_LIST_DEFINED


79 
_G_va_li
 
	tva_li
;

80 
	#_VA_LIST_DEFINED


	)

83 
	~<dg.h
>

87 #ifde
__USE_XOPEN2K8


88 #ide
__off_t_defed


89 #ide
__USE_FILE_OFFSET64


90 
__off_t
 
	toff_t
;

92 
__off64_t
 
	toff_t
;

94 
	#__off_t_defed


	)

96 #i
defed
 
__USE_LARGEFILE64
 && !defed 
__off64_t_defed


97 
__off64_t
 
	toff64_t
;

98 
	#__off64_t_defed


	)

101 #ide
__ssize_t_defed


102 
__ssize_t
 
	tssize_t
;

103 
	#__ssize_t_defed


	)

108 
__BEGIN_NAMESPACE_STD


109 #ide
__USE_FILE_OFFSET64


110 
_G_os_t
 
	tos_t
;

112 
_G_os64_t
 
	tos_t
;

114 
__END_NAMESPACE_STD


115 #ifde
__USE_LARGEFILE64


116 
_G_os64_t
 
	tos64_t
;

120 
	#_IOFBF
 0

	)

121 
	#_IOLBF
 1

	)

122 
	#_IONBF
 2

	)

126 #ide
BUFSIZ


127 
	#BUFSIZ
 
_IO_BUFSIZ


	)

133 #ide
EOF


134 
	#EOF
 (-1)

	)

140 
	#SEEK_SET
 0

	)

141 
	#SEEK_CUR
 1

	)

142 
	#SEEK_END
 2

	)

143 #ifde
__USE_GNU


144 
	#SEEK_DATA
 3

	)

145 
	#SEEK_HOLE
 4

	)

149 #i
defed
 
__USE_SVID
 || defed 
__USE_XOPEN


151 
	#P_tmpd
 "/tmp"

	)

164 
	~<bs/dio_lim.h
>

168 
_IO_FILE
 *
d
;

169 
_IO_FILE
 *
dout
;

170 
_IO_FILE
 *
dr
;

172 
	#d
 
d


	)

173 
	#dout
 
dout


	)

174 
	#dr
 
dr


	)

176 
__BEGIN_NAMESPACE_STD


178 
	$move
 (cڡ *
__fame

__THROW
;

180 
	$me
 (cڡ *
__d
, cڡ *
__w

__THROW
;

181 
__END_NAMESPACE_STD


183 #ifde
__USE_ATFILE


185 
	$mt
 (
__dfd
, cڡ *
__d
, 
__wfd
,

186 cڡ *
__w

__THROW
;

189 
__BEGIN_NAMESPACE_STD


194 #ide
__USE_FILE_OFFSET64


195 
FILE
 *
	$tmpfe
 (
__wur
;

197 #ifde
__REDIRECT


198 
FILE
 *
	`__REDIRECT
 (
tmpfe
, (), 
tmpfe64

__wur
;

200 
	#tmpfe
 
tmpfe64


	)

204 #ifde
__USE_LARGEFILE64


205 
FILE
 *
	$tmpfe64
 (
__wur
;

209 *
	$tmam
 (*
__s

__THROW
 
__wur
;

210 
__END_NAMESPACE_STD


212 #ifde
__USE_MISC


215 *
	$tmam_r
 (*
__s

__THROW
 
__wur
;

219 #i
defed
 
__USE_SVID
 || defed 
__USE_XOPEN


227 *
	$mam
 (cڡ *
__d
, cڡ *
__pfx
)

228 
__THROW
 
__ibu_mloc__
 
__wur
;

232 
__BEGIN_NAMESPACE_STD


237 
	`fo
 (
FILE
 *
__am
);

242 
	`fush
 (
FILE
 *
__am
);

243 
__END_NAMESPACE_STD


245 #ifde
__USE_MISC


252 
	`fush_uocked
 (
FILE
 *
__am
);

255 #ifde
__USE_GNU


262 
	`fol
 ();

266 
__BEGIN_NAMESPACE_STD


267 #ide
__USE_FILE_OFFSET64


272 
FILE
 *
	$fݒ
 (cڡ *
__ri
 
__fame
,

273 cڡ *
__ri
 
__modes

__wur
;

278 
FILE
 *
	$eݒ
 (cڡ *
__ri
 
__fame
,

279 cڡ *
__ri
 
__modes
,

280 
FILE
 *
__ri
 
__am

__wur
;

282 #ifde
__REDIRECT


283 
FILE
 *
	`__REDIRECT
 (
fݒ
, (cڡ *
__ri
 
__fame
,

284 cڡ *
__ri
 
__modes
), 
fݒ64
)

285 
__wur
;

286 
FILE
 *
	`__REDIRECT
 (
eݒ
, (cڡ *
__ri
 
__fame
,

287 cڡ *
__ri
 
__modes
,

288 
FILE
 *
__ri
 
__am
), 
eݒ64
)

289 
__wur
;

291 
	#fݒ
 
fݒ64


	)

292 
	#eݒ
 
eݒ64


	)

295 
__END_NAMESPACE_STD


296 #ifde
__USE_LARGEFILE64


297 
FILE
 *
	$fݒ64
 (cڡ *
__ri
 
__fame
,

298 cڡ *
__ri
 
__modes

__wur
;

299 
FILE
 *
	$eݒ64
 (cڡ *
__ri
 
__fame
,

300 cڡ *
__ri
 
__modes
,

301 
FILE
 *
__ri
 
__am

__wur
;

304 #ifdef 
__USE_POSIX


306 
FILE
 *
	$fdݒ
 (
__fd
, cڡ *
__modes

__THROW
 
__wur
;

309 #ifdef 
__USE_GNU


312 
FILE
 *
	$fݒcook
 (*
__ri
 
__magic_cook
,

313 cڡ *
__ri
 
__modes
,

314 
_IO_cook_io_funis_t
 
__io_funcs

__THROW
 
__wur
;

317 #ifde
__USE_XOPEN2K8


319 
FILE
 *
	$fmemݒ
 (*
__s
, 
size_t
 
__n
, cڡ *
__modes
)

320 
__THROW
 
__wur
;

325 
FILE
 *
	$ݒ_memam
 (**
__buoc
, 
size_t
 *
__sizoc

__THROW
 
__wur
;

329 
__BEGIN_NAMESPACE_STD


332 
	$tbuf
 (
FILE
 *
__ri
 
__am
, *__ri 
__buf

__THROW
;

336 
	$tvbuf
 (
FILE
 *
__ri
 
__am
, *__ri 
__buf
,

337 
__modes
, 
size_t
 
__n

__THROW
;

338 
__END_NAMESPACE_STD


340 #ifdef 
__USE_BSD


343 
	$tbufr
 (
FILE
 *
__ri
 
__am
, *__ri 
__buf
,

344 
size_t
 
__size

__THROW
;

347 
	$ebuf
 (
FILE
 *
__am

__THROW
;

351 
__BEGIN_NAMESPACE_STD


356 
	`rtf
 (
FILE
 *
__ri
 
__am
,

357 cڡ *
__ri
 
__fm
, ...);

362 
	`tf
 (cڡ *
__ri
 
__fm
, ...);

364 
	$rtf
 (*
__ri
 
__s
,

365 cڡ *
__ri
 
__fm
, ...
__THROWNL
;

371 
	`vrtf
 (
FILE
 *
__ri
 
__s
, cڡ *__ri 
__fm
,

372 
_G_va_li
 
__g
);

377 
	`vtf
 (cڡ *
__ri
 
__fm
, 
_G_va_li
 
__g
);

379 
	$vrtf
 (*
__ri
 
__s
, cڡ *__ri 
__fm
,

380 
_G_va_li
 
__g

__THROWNL
;

381 
__END_NAMESPACE_STD


383 #i
defed
 
__USE_BSD
 || defed 
__USE_ISOC99
 || defed 
__USE_UNIX98


384 
__BEGIN_NAMESPACE_C99


386 
	$tf
 (*
__ri
 
__s
, 
size_t
 
__maxn
,

387 cڡ *
__ri
 
__fm
, ...)

388 
__THROWNL
 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 3, 4)));

390 
	$vtf
 (*
__ri
 
__s
, 
size_t
 
__maxn
,

391 cڡ *
__ri
 
__fm
, 
_G_va_li
 
__g
)

392 
__THROWNL
 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 3, 0)));

393 
__END_NAMESPACE_C99


396 #ifde
__USE_GNU


399 
	$vartf
 (**
__ri
 
__r
, cڡ *__ri 
__f
,

400 
_G_va_li
 
__g
)

401 
__THROWNL
 
	`__ibu__
 ((
	$__fm__
 (
__tf__
, 2, 0))
__wur
;

402 
	$__artf
 (**
__ri
 
__r
,

403 cڡ *
__ri
 
__fmt
, ...)

404 
__THROWNL
 
	`__ibu__
 ((
	$__fm__
 (
__tf__
, 2, 3))
__wur
;

405 
	$artf
 (**
__ri
 
__r
,

406 cڡ *
__ri
 
__fmt
, ...)

407 
__THROWNL
 
	`__ibu__
 ((
	$__fm__
 (
__tf__
, 2, 3))
__wur
;

410 #ifde
__USE_XOPEN2K8


412 
	$vdtf
 (
__fd
, cڡ *
__ri
 
__fmt
,

413 
_G_va_li
 
__g
)

414 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 2, 0)));

415 
	$dtf
 (
__fd
, cڡ *
__ri
 
__fmt
, ...)

416 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 2, 3)));

420 
__BEGIN_NAMESPACE_STD


425 
	$fsnf
 (
FILE
 *
__ri
 
__am
,

426 cڡ *
__ri
 
__fm
, ...
__wur
;

431 
	$snf
 (cڡ *
__ri
 
__fm
, ...
__wur
;

433 
	$ssnf
 (cڡ *
__ri
 
__s
,

434 cڡ *
__ri
 
__fm
, ...
__THROW
;

436 #i
defed
 
__USE_ISOC99
 && !defed 
__USE_GNU
 \

437 && (!
defed
 
__LDBL_COMPAT
 || !defed 
__REDIRECT
) \

438 && (
defed
 
__STRICT_ANSI__
 || defed 
__USE_XOPEN2K
)

439 #ifde
__REDIRECT


443 
	`__REDIRECT
 (
fsnf
, (
FILE
 *
__ri
 
__am
,

444 cڡ *
__ri
 
__fm
, ...),

445 
__isoc99_fsnf

__wur
;

446 
	`__REDIRECT
 (
snf
, (cڡ *
__ri
 
__fm
, ...),

447 
__isoc99_snf

__wur
;

448 
	`__REDIRECT_NTH
 (
ssnf
, (cڡ *
__ri
 
__s
,

449 cڡ *
__ri
 
__fm
, ...),

450 
__isoc99_ssnf
);

452 
	$__isoc99_fsnf
 (
FILE
 *
__ri
 
__am
,

453 cڡ *
__ri
 
__fm
, ...
__wur
;

454 
	$__isoc99_snf
 (cڡ *
__ri
 
__fm
, ...
__wur
;

455 
	$__isoc99_ssnf
 (cڡ *
__ri
 
__s
,

456 cڡ *
__ri
 
__fm
, ...
__THROW
;

457 
	#fsnf
 
__isoc99_fsnf


	)

458 
	#snf
 
__isoc99_snf


	)

459 
	#ssnf
 
__isoc99_ssnf


	)

463 
__END_NAMESPACE_STD


465 #ifdef 
__USE_ISOC99


466 
__BEGIN_NAMESPACE_C99


471 
	$vfsnf
 (
FILE
 *
__ri
 
__s
, cڡ *__ri 
__fm
,

472 
_G_va_li
 
__g
)

473 
	`__ibu__
 ((
	$__fm__
 (
__snf__
, 2, 0))
__wur
;

479 
	$vsnf
 (cڡ *
__ri
 
__fm
, 
_G_va_li
 
__g
)

480 
	`__ibu__
 ((
	$__fm__
 (
__snf__
, 1, 0))
__wur
;

483 
	$vssnf
 (cڡ *
__ri
 
__s
,

484 cڡ *
__ri
 
__fm
, 
_G_va_li
 
__g
)

485 
__THROW
 
	`__ibu__
 ((
	`__fm__
 (
__snf__
, 2, 0)));

487 #i!
defed
 
__USE_GNU
 \

488 && (!
defed
 
__LDBL_COMPAT
 || !defed 
__REDIRECT
) \

489 && (
defed
 
__STRICT_ANSI__
 || defed 
__USE_XOPEN2K
)

490 #ifde
__REDIRECT


494 
	`__REDIRECT
 (
vfsnf
,

495 (
FILE
 *
__ri
 
__s
,

496 cڡ *
__ri
 
__fm
, 
_G_va_li
 
__g
),

497 
__isoc99_vfsnf
)

498 
	`__ibu__
 ((
	$__fm__
 (
__snf__
, 2, 0))
__wur
;

499 
	`__REDIRECT
 (
vsnf
, (cڡ *
__ri
 
__fm
,

500 
_G_va_li
 
__g
), 
__isoc99_vsnf
)

501 
	`__ibu__
 ((
	$__fm__
 (
__snf__
, 1, 0))
__wur
;

502 
	`__REDIRECT_NTH
 (
vssnf
,

503 (cڡ *
__ri
 
__s
,

504 cڡ *
__ri
 
__fm
,

505 
_G_va_li
 
__g
), 
__isoc99_vssnf
)

506 
	`__ibu__
 ((
	`__fm__
 (
__snf__
, 2, 0)));

508 
	$__isoc99_vfsnf
 (
FILE
 *
__ri
 
__s
,

509 cڡ *
__ri
 
__fm
,

510 
_G_va_li
 
__g

__wur
;

511 
	$__isoc99_vsnf
 (cڡ *
__ri
 
__fm
,

512 
_G_va_li
 
__g

__wur
;

513 
	$__isoc99_vssnf
 (cڡ *
__ri
 
__s
,

514 cڡ *
__ri
 
__fm
,

515 
_G_va_li
 
__g

__THROW
;

516 
	#vfsnf
 
__isoc99_vfsnf


	)

517 
	#vsnf
 
__isoc99_vsnf


	)

518 
	#vssnf
 
__isoc99_vssnf


	)

522 
__END_NAMESPACE_C99


526 
__BEGIN_NAMESPACE_STD


531 
	`fgc
 (
FILE
 *
__am
);

532 
	`gc
 (
FILE
 *
__am
);

538 
	`gch
 ();

539 
__END_NAMESPACE_STD


543 
	#gc
(
_

	`_IO_gc
 (_)

	)

545 #i
defed
 
__USE_POSIX
 || defed 
__USE_MISC


550 
	`gc_uocked
 (
FILE
 *
__am
);

551 
	`gch_uocked
 ();

554 #ifde
__USE_MISC


561 
	`fgc_uocked
 (
FILE
 *
__am
);

565 
__BEGIN_NAMESPACE_STD


573 
	`utc
 (
__c
, 
FILE
 *
__am
);

574 
	`putc
 (
__c
, 
FILE
 *
__am
);

580 
	`putch
 (
__c
);

581 
__END_NAMESPACE_STD


585 
	#putc
(
_ch
, 
_

	`_IO_putc
 (_ch, _)

	)

587 #ifde
__USE_MISC


594 
	`utc_uocked
 (
__c
, 
FILE
 *
__am
);

597 #i
defed
 
__USE_POSIX
 || defed 
__USE_MISC


602 
	`putc_uocked
 (
__c
, 
FILE
 *
__am
);

603 
	`putch_uocked
 (
__c
);

607 #i
defed
 
__USE_SVID
 || defed 
__USE_MISC
 \

608 || (
defed
 
__USE_XOPEN
 && !defed 
__USE_XOPEN2K
)

610 
	`gw
 (
FILE
 *
__am
);

613 
	`putw
 (
__w
, 
FILE
 *
__am
);

617 
__BEGIN_NAMESPACE_STD


622 *
	$fgs
 (*
__ri
 
__s
, 
__n
, 
FILE
 *__ri 
__am
)

623 
__wur
;

625 #i!
defed
 
__USE_ISOC11
 \

626 || (
defed
 
__lulus
 && __cplusplus <= 201103L)

638 *
	$gs
 (*
__s

__wur
 
__ibu_dd__
;

640 
__END_NAMESPACE_STD


642 #ifde
__USE_GNU


649 *
	$fgs_uocked
 (*
__ri
 
__s
, 
__n
,

650 
FILE
 *
__ri
 
__am

__wur
;

654 #ifdef 
__USE_XOPEN2K8


665 
_IO_ssize_t
 
	$__gdim
 (**
__ri
 
__l
,

666 
size_t
 *
__ri
 
__n
, 
__dim
,

667 
FILE
 *
__ri
 
__am

__wur
;

668 
_IO_ssize_t
 
	$gdim
 (**
__ri
 
__l
,

669 
size_t
 *
__ri
 
__n
, 
__dim
,

670 
FILE
 *
__ri
 
__am

__wur
;

678 
_IO_ssize_t
 
	$gle
 (**
__ri
 
__l
,

679 
size_t
 *
__ri
 
__n
,

680 
FILE
 *
__ri
 
__am

__wur
;

684 
__BEGIN_NAMESPACE_STD


689 
	`uts
 (cڡ *
__ri
 
__s
, 
FILE
 *__ri 
__am
);

695 
	`puts
 (cڡ *
__s
);

702 
	`ungc
 (
__c
, 
FILE
 *
__am
);

709 
size_t
 
	$d
 (*
__ri
 
__r
, 
size_t
 
__size
,

710 
size_t
 
__n
, 
FILE
 *
__ri
 
__am

__wur
;

715 
size_t
 
	`fwre
 (cڡ *
__ri
 
__r
, size_
__size
,

716 
size_t
 
__n
, 
FILE
 *
__ri
 
__s
);

717 
__END_NAMESPACE_STD


719 #ifde
__USE_GNU


726 
	`uts_uocked
 (cڡ *
__ri
 
__s
,

727 
FILE
 *
__ri
 
__am
);

730 #ifde
__USE_MISC


737 
size_t
 
	$d_uocked
 (*
__ri
 
__r
, 
size_t
 
__size
,

738 
size_t
 
__n
, 
FILE
 *
__ri
 
__am

__wur
;

739 
size_t
 
	`fwre_uocked
 (cڡ *
__ri
 
__r
, size_
__size
,

740 
size_t
 
__n
, 
FILE
 *
__ri
 
__am
);

744 
__BEGIN_NAMESPACE_STD


749 
	`fek
 (
FILE
 *
__am
, 
__off
, 
__wh
);

754 
	$l
 (
FILE
 *
__am

__wur
;

759 
	`wd
 (
FILE
 *
__am
);

760 
__END_NAMESPACE_STD


767 #i
defed
 
__USE_LARGEFILE
 || defed 
__USE_XOPEN2K


768 #ide
__USE_FILE_OFFSET64


773 
	`feko
 (
FILE
 *
__am
, 
__off_t
 
__off
, 
__wh
);

778 
__off_t
 
	$lo
 (
FILE
 *
__am

__wur
;

780 #ifde
__REDIRECT


781 
	`__REDIRECT
 (
feko
,

782 (
FILE
 *
__am
, 
__off64_t
 
__off
, 
__wh
),

783 
feko64
);

784 
__off64_t
 
	`__REDIRECT
 (
lo
, (
FILE
 *
__am
), 
lo64
);

786 
	#feko
 
feko64


	)

787 
	#lo
 
lo64


	)

792 
__BEGIN_NAMESPACE_STD


793 #ide
__USE_FILE_OFFSET64


798 
	`fgpos
 (
FILE
 *
__ri
 
__am
, 
os_t
 *__ri 
__pos
);

803 
	`fos
 (
FILE
 *
__am
, cڡ 
os_t
 *
__pos
);

805 #ifde
__REDIRECT


806 
	`__REDIRECT
 (
fgpos
, (
FILE
 *
__ri
 
__am
,

807 
os_t
 *
__ri
 
__pos
), 
fgpos64
);

808 
	`__REDIRECT
 (
fos
,

809 (
FILE
 *
__am
, cڡ 
os_t
 *
__pos
), 
fos64
);

811 
	#fgpos
 
fgpos64


	)

812 
	#fos
 
fos64


	)

815 
__END_NAMESPACE_STD


817 #ifde
__USE_LARGEFILE64


818 
	`feko64
 (
FILE
 *
__am
, 
__off64_t
 
__off
, 
__wh
);

819 
__off64_t
 
	$lo64
 (
FILE
 *
__am

__wur
;

820 
	`fgpos64
 (
FILE
 *
__ri
 
__am
, 
os64_t
 *__ri 
__pos
);

821 
	`fos64
 (
FILE
 *
__am
, cڡ 
os64_t
 *
__pos
);

824 
__BEGIN_NAMESPACE_STD


826 
	$
 (
FILE
 *
__am

__THROW
;

828 
	$of
 (
FILE
 *
__am

__THROW
 
__wur
;

830 
	$
 (
FILE
 *
__am

__THROW
 
__wur
;

831 
__END_NAMESPACE_STD


833 #ifde
__USE_MISC


835 
	$_uocked
 (
FILE
 *
__am

__THROW
;

836 
	$of_uocked
 (
FILE
 *
__am

__THROW
 
__wur
;

837 
	$_uocked
 (
FILE
 *
__am

__THROW
 
__wur
;

841 
__BEGIN_NAMESPACE_STD


846 
	`
 (cڡ *
__s
);

847 
__END_NAMESPACE_STD


853 
	~<bs/sys_i.h
>

856 #ifdef 
__USE_POSIX


858 
	$fo
 (
FILE
 *
__am

__THROW
 
__wur
;

861 #ifde
__USE_MISC


863 
	$fo_uocked
 (
FILE
 *
__am

__THROW
 
__wur
;

867 #i(
defed
 
__USE_POSIX2
 || defed 
__USE_SVID
 || defed 
__USE_BSD
 || \

868 
defed
 
__USE_MISC
)

873 
FILE
 *
	$pݒ
 (cڡ *
__commd
, cڡ *
__modes

__wur
;

879 
	`po
 (
FILE
 *
__am
);

883 #ifdef 
__USE_POSIX


885 *
	$mid
 (*
__s

__THROW
;

889 #ifde
__USE_XOPEN


891 *
	`curid
 (*
__s
);

895 #ifdef 
__USE_GNU


896 
oback
;

899 
	$oback_tf
 (
oback
 *
__ri
 
__oback
,

900 cڡ *
__ri
 
__fm
, ...)

901 
__THROWNL
 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 2, 3)));

902 
	$oback_vtf
 (
oback
 *
__ri
 
__oback
,

903 cڡ *
__ri
 
__fm
,

904 
_G_va_li
 
__gs
)

905 
__THROWNL
 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 2, 0)));

909 #i
defed
 
__USE_POSIX
 || defed 
__USE_MISC


913 
	$ockfe
 (
FILE
 *
__am

__THROW
;

917 
	$rylockfe
 (
FILE
 *
__am

__THROW
 
__wur
;

920 
	$fuockfe
 (
FILE
 *
__am

__THROW
;

923 #i
defed
 
__USE_XOPEN
 && !defed 
__USE_XOPEN2K
 && !defed 
__USE_GNU


927 
	#__ed_gt


	)

928 
	~<gt.h
>

933 #ifde
__USE_EXTERN_INLINES


934 
	~<bs/dio.h
>

936 #i
__USE_FORTIFY_LEVEL
 > 0 && 
defed
 
__ex_ways_le


937 
	~<bs/dio2.h
>

939 #ifde
__LDBL_COMPAT


940 
	~<bs/dio-ldbl.h
>

943 
__END_DECLS


	@/usr/include/stdlib.h

22 #idef 
_STDLIB_H


24 
	~<us.h
>

27 
	#__ed_size_t


	)

28 #ide
__ed_mloc_d_oc


29 
	#__ed_wch_t


	)

30 
	#__ed_NULL


	)

32 
	~<ddef.h
>

34 
	g__BEGIN_DECLS


36 #ide
__ed_mloc_d_oc


37 
	#_STDLIB_H
 1

	)

39 #i(
defed
 
__USE_XOPEN
 || defed 
__USE_XOPEN2K8
&& !defed 
_SYS_WAIT_H


41 
	~<bs/waags.h
>

42 
	~<bs/waus.h
>

44 #ifde
__USE_BSD


49 #i
defed
 
__GNUC__
 && !defed 
__lulus


50 
	#__WAIT_INT
(
us
) \

51 (
	`__exnsi__
 (((uni { 
	`__tyof
(
us

__
; 
__i
; }) \

52 { .
__
 = (
us
}).
__i
))

	)

54 
	#__WAIT_INT
(
us
(*(*&(us))

	)

62 #i!
defed
 
__GNUC__
 || __GNUC__ < 2 || defed 
__lulus


63 
	#__WAIT_STATUS
 *

	)

64 
	#__WAIT_STATUS_DEFN
 *

	)

69 
wa
 *
	m__ur
;

70 *
	m__
;

71 } 
	t__WAIT_STATUS
 
	t__ibu__
 ((
	t__t_uni__
));

72 
	#__WAIT_STATUS_DEFN
 *

	)

77 
	#__WAIT_INT
(
us
(us)

	)

78 
	#__WAIT_STATUS
 *

	)

79 
	#__WAIT_STATUS_DEFN
 *

	)

84 
	#WEXITSTATUS
(
us

	`__WEXITSTATUS
 (
	`__WAIT_INT
 (us))

	)

85 
	#WTERMSIG
(
us

	`__WTERMSIG
 (
	`__WAIT_INT
 (us))

	)

86 
	#WSTOPSIG
(
us

	`__WSTOPSIG
 (
	`__WAIT_INT
 (us))

	)

87 
	#WIFEXITED
(
us

	`__WIFEXITED
 (
	`__WAIT_INT
 (us))

	)

88 
	#WIFSIGNALED
(
us

	`__WIFSIGNALED
 (
	`__WAIT_INT
 (us))

	)

89 
	#WIFSTOPPED
(
us

	`__WIFSTOPPED
 (
	`__WAIT_INT
 (us))

	)

90 #ifde
__WIFCONTINUED


91 
	#WIFCONTINUED
(
us

	`__WIFCONTINUED
 (
	`__WAIT_INT
 (us))

	)

95 
__BEGIN_NAMESPACE_STD


99 
	mqu
;

100 
	mm
;

101 } 
	tdiv_t
;

104 #ide
__ldiv_t_defed


107 
	mqu
;

108 
	mm
;

109 } 
	tldiv_t
;

110 
	#__ldiv_t_defed
 1

	)

112 
	g__END_NAMESPACE_STD


114 #i
defed
 
__USE_ISOC99
 && !defed 
__div_t_defed


115 
__BEGIN_NAMESPACE_C99


117 
__exnsi__
 struct

119 
	mqu
;

120 
	mm
;

121 } 
	tdiv_t
;

122 
	#__div_t_defed
 1

	)

123 
	g__END_NAMESPACE_C99


128 
	#RAND_MAX
 2147483647

	)

133 
	#EXIT_FAILURE
 1

	)

134 
	#EXIT_SUCCESS
 0

	)

138 
	#MB_CUR_MAX
 (
	`__y_g_mb_cur_max
 ())

	)

139 
size_t
 
	$__y_g_mb_cur_max
 (
__THROW
 
__wur
;

142 
__BEGIN_NAMESPACE_STD


144 
	$of
 (cڡ *
__Ō
)

145 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1)
__wur
;

147 
	$oi
 (cڡ *
__Ō
)

148 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1)
__wur
;

150 
	$
 (cڡ *
__Ō
)

151 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1)
__wur
;

152 
__END_NAMESPACE_STD


154 #i
defed
 
__USE_ISOC99
 || defed 
__USE_MISC


155 
__BEGIN_NAMESPACE_C99


157 
__exnsi__
 
	$l
 (cڡ *
__Ō
)

158 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1)
__wur
;

159 
__END_NAMESPACE_C99


162 
__BEGIN_NAMESPACE_STD


164 
	$od
 (cڡ *
__ri
 
__Ō
,

165 **
__ri
 
__dr
)

166 
__THROW
 
	`__nnu
 ((1));

167 
__END_NAMESPACE_STD


169 #ifdef 
__USE_ISOC99


170 
__BEGIN_NAMESPACE_C99


172 
	$of
 (cڡ *
__ri
 
__Ō
,

173 **
__ri
 
__dr

__THROW
 
	`__nnu
 ((1));

175 
	$d
 (cڡ *
__ri
 
__Ō
,

176 **
__ri
 
__dr
)

177 
__THROW
 
	`__nnu
 ((1));

178 
__END_NAMESPACE_C99


181 
__BEGIN_NAMESPACE_STD


183 
	$
 (cڡ *
__ri
 
__Ō
,

184 **
__ri
 
__dr
, 
__ba
)

185 
__THROW
 
	`__nnu
 ((1));

187 
	$oul
 (cڡ *
__ri
 
__Ō
,

188 **
__ri
 
__dr
, 
__ba
)

189 
__THROW
 
	`__nnu
 ((1));

190 
__END_NAMESPACE_STD


192 #ifde
__USE_BSD


194 
__exnsi__


195 
	$oq
 (cڡ *
__ri
 
__Ō
,

196 **
__ri
 
__dr
, 
__ba
)

197 
__THROW
 
	`__nnu
 ((1));

199 
__exnsi__


200 
	$ouq
 (cڡ *
__ri
 
__Ō
,

201 **
__ri
 
__dr
, 
__ba
)

202 
__THROW
 
	`__nnu
 ((1));

205 #i
defed
 
__USE_ISOC99
 || defed 
__USE_MISC


206 
__BEGIN_NAMESPACE_C99


208 
__exnsi__


209 
	$l
 (cڡ *
__ri
 
__Ō
,

210 **
__ri
 
__dr
, 
__ba
)

211 
__THROW
 
	`__nnu
 ((1));

213 
__exnsi__


214 
	$ou
 (cڡ *
__ri
 
__Ō
,

215 **
__ri
 
__dr
, 
__ba
)

216 
__THROW
 
	`__nnu
 ((1));

217 
__END_NAMESPACE_C99


221 #ifde
__USE_GNU


235 
	~<xlo.h
>

239 
	$_l
 (cڡ *
__ri
 
__Ō
,

240 **
__ri
 
__dr
, 
__ba
,

241 
__lo_t
 
__loc

__THROW
 
	`__nnu
 ((1, 4));

243 
	$oul_l
 (cڡ *
__ri
 
__Ō
,

244 **
__ri
 
__dr
,

245 
__ba
, 
__lo_t
 
__loc
)

246 
__THROW
 
	`__nnu
 ((1, 4));

248 
__exnsi__


249 
	$l_l
 (cڡ *
__ri
 
__Ō
,

250 **
__ri
 
__dr
, 
__ba
,

251 
__lo_t
 
__loc
)

252 
__THROW
 
	`__nnu
 ((1, 4));

254 
__exnsi__


255 
	$ou_l
 (cڡ *
__ri
 
__Ō
,

256 **
__ri
 
__dr
,

257 
__ba
, 
__lo_t
 
__loc
)

258 
__THROW
 
	`__nnu
 ((1, 4));

260 
	$od_l
 (cڡ *
__ri
 
__Ō
,

261 **
__ri
 
__dr
, 
__lo_t
 
__loc
)

262 
__THROW
 
	`__nnu
 ((1, 3));

264 
	$of_l
 (cڡ *
__ri
 
__Ō
,

265 **
__ri
 
__dr
, 
__lo_t
 
__loc
)

266 
__THROW
 
	`__nnu
 ((1, 3));

268 
	$d_l
 (cڡ *
__ri
 
__Ō
,

269 **
__ri
 
__dr
,

270 
__lo_t
 
__loc
)

271 
__THROW
 
	`__nnu
 ((1, 3));

275 #ifde
__USE_EXTERN_INLINES


276 
__BEGIN_NAMESPACE_STD


277 
__ex_le
 

278 
	`__NTH
 (
	$oi
 (cڡ *
__Ō
))

280  (
	`
 (
__Ō
, (**
NULL
, 10);

281 
	}
}

282 
__ex_le
 

283 
__NTH
 (
	$
 (cڡ *
__Ō
))

285  
	`
 (
__Ō
, (**
NULL
, 10);

286 
	}
}

287 
	g__END_NAMESPACE_STD


289 #i
defed
 
__USE_MISC
 || defed 
__USE_ISOC99


290 
__BEGIN_NAMESPACE_C99


291 
__exnsi__
 
__ex_le
 

292 
__NTH
 (
	$l
 (cڡ *
__Ō
))

294  
	`l
 (
__Ō
, (**
NULL
, 10);

295 
	}
}

296 
	g__END_NAMESPACE_C99


301 #i
defed
 
__USE_SVID
 || defed 
__USE_XOPEN_EXTENDED


305 *
	$l64a
 (
__n

__THROW
 
__wur
;

308 
	$a64l
 (cڡ *
__s
)

309 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1)
__wur
;

313 #i
defed
 
__USE_SVID
 || defed 
__USE_XOPEN_EXTENDED
 || defed 
__USE_BSD


314 
	~<sys/tys.h
>

321 
	$ndom
 (
__THROW
;

324 
	$dom
 (
__ed

__THROW
;

330 *
	$e
 (
__ed
, *
__ebuf
,

331 
size_t
 
__

__THROW
 
	`__nnu
 ((2));

335 *
	$te
 (*
__ebuf

__THROW
 
	`__nnu
 ((1));

338 #ifde
__USE_MISC


343 
	sndom_da


345 
t32_t
 *

;

346 
t32_t
 *

;

347 
t32_t
 *
e
;

348 
nd_ty
;

349 
nd_deg
;

350 
nd_p
;

351 
t32_t
 *
d_r
;

354 
	$ndom_r
 (
ndom_da
 *
__ri
 
__buf
,

355 
t32_t
 *
__ri
 
__su

__THROW
 
	`__nnu
 ((1, 2));

357 
	$dom_r
 (
__ed
, 
ndom_da
 *
__buf
)

358 
__THROW
 
	`__nnu
 ((2));

360 
	$e_r
 (
__ed
, *
__ri
 
__ebuf
,

361 
size_t
 
__
,

362 
ndom_da
 *
__ri
 
__buf
)

363 
__THROW
 
	`__nnu
 ((2, 4));

365 
	$te_r
 (*
__ri
 
__ebuf
,

366 
ndom_da
 *
__ri
 
__buf
)

367 
__THROW
 
	`__nnu
 ((1, 2));

372 
__BEGIN_NAMESPACE_STD


374 
	$nd
 (
__THROW
;

376 
	$d
 (
__ed

__THROW
;

377 
__END_NAMESPACE_STD


379 #ifde
__USE_POSIX


381 
	$nd_r
 (*
__ed

__THROW
;

385 #i
defed
 
__USE_SVID
 || defed 
__USE_XOPEN


389 
	$dnd48
 (
__THROW
;

390 
	$d48
 (
__xsubi
[3]
__THROW
 
	`__nnu
 ((1));

393 
	$̪d48
 (
__THROW
;

394 
	$Īd48
 (
__xsubi
[3])

395 
__THROW
 
	`__nnu
 ((1));

398 
	$mnd48
 (
__THROW
;

399 
	$jnd48
 (
__xsubi
[3])

400 
__THROW
 
	`__nnu
 ((1));

403 
	$d48
 (
__edv

__THROW
;

404 *
	$ed48
 (
__ed16v
[3])

405 
__THROW
 
	`__nnu
 ((1));

406 
	$lcg48
 (
__m
[7]
__THROW
 
	`__nnu
 ((1));

408 #ifde
__USE_MISC


412 
	sdnd48_da


414 
__x
[3];

415 
__d_x
[3];

416 
__c
;

417 
__
;

418 
__exnsi__
 
__a
;

423 
	$dnd48_r
 (
dnd48_da
 *
__ri
 
__bufr
,

424 *
__ri
 
__su

__THROW
 
	`__nnu
 ((1, 2));

425 
	$d48_r
 (
__xsubi
[3],

426 
dnd48_da
 *
__ri
 
__bufr
,

427 *
__ri
 
__su

__THROW
 
	`__nnu
 ((1, 2));

430 
	$̪d48_r
 (
dnd48_da
 *
__ri
 
__bufr
,

431 *
__ri
 
__su
)

432 
__THROW
 
	`__nnu
 ((1, 2));

433 
	$Īd48_r
 (
__xsubi
[3],

434 
dnd48_da
 *
__ri
 
__bufr
,

435 *
__ri
 
__su
)

436 
__THROW
 
	`__nnu
 ((1, 2));

439 
	$mnd48_r
 (
dnd48_da
 *
__ri
 
__bufr
,

440 *
__ri
 
__su
)

441 
__THROW
 
	`__nnu
 ((1, 2));

442 
	$jnd48_r
 (
__xsubi
[3],

443 
dnd48_da
 *
__ri
 
__bufr
,

444 *
__ri
 
__su
)

445 
__THROW
 
	`__nnu
 ((1, 2));

448 
	$d48_r
 (
__edv
, 
dnd48_da
 *
__bufr
)

449 
__THROW
 
	`__nnu
 ((2));

451 
	$ed48_r
 (
__ed16v
[3],

452 
dnd48_da
 *
__bufr

__THROW
 
	`__nnu
 ((1, 2));

454 
	$lcg48_r
 (
__m
[7],

455 
dnd48_da
 *
__bufr
)

456 
__THROW
 
	`__nnu
 ((1, 2));

462 #ide
__mloc_d_oc_defed


463 
	#__mloc_d_oc_defed


	)

464 
__BEGIN_NAMESPACE_STD


466 *
	$mloc
 (
size_t
 
__size

__THROW
 
__ibu_mloc__
 
__wur
;

468 *
	$oc
 (
size_t
 
__nmemb
, size_
__size
)

469 
__THROW
 
__ibu_mloc__
 
__wur
;

470 
__END_NAMESPACE_STD


473 #ide
__ed_mloc_d_oc


474 
__BEGIN_NAMESPACE_STD


480 *
	$loc
 (*
__r
, 
size_t
 
__size
)

481 
__THROW
 
__ibu_wn_unud_su__
;

483 
	$
 (*
__r

__THROW
;

484 
__END_NAMESPACE_STD


486 #ifdef 
__USE_MISC


488 
	$c
 (*
__r

__THROW
;

491 #i
defed
 
__USE_GNU
 || defed 
__USE_BSD
 || defed 
__USE_MISC


492 
	~<lo.h
>

495 #i(
defed
 
__USE_XOPEN_EXTENDED
 && !defed 
__USE_XOPEN2K
) \

496 || 
defed
 
__USE_BSD


498 *
	$vloc
 (
size_t
 
__size

__THROW
 
__ibu_mloc__
 
__wur
;

501 #ifde
__USE_XOPEN2K


503 
	$posix_memign
 (**
__memr
, 
size_t
 
__ignmt
, size_
__size
)

504 
__THROW
 
	`__nnu
 ((1)
__wur
;

507 #ifde
__USE_ISOC11


509 *
	$igd_loc
 (
size_t
 
__ignmt
, size_
__size
)

510 
__THROW
 
__ibu_mloc__
 
	`__ibu_loc_size__
 ((2)
__wur
;

513 
__BEGIN_NAMESPACE_STD


515 
	$abt
 (
__THROW
 
	`__ibu__
 ((
__nܑu__
));

519 
	`ex
 ((*
__func
()
__THROW
 
	`__nnu
 ((1));

521 #i
defed
 
__USE_ISOC11
 || defed 
__USE_ISOCXX11


523 #ifde
__lulus


524 "C++" 
	`_quick_ex
 ((*
__func
) ())

525 
__THROW
 
	`__asm
 ("_quick_ex"
	`__nnu
 ((1));

527 
	`_quick_ex
 ((*
__func
()
__THROW
 
	`__nnu
 ((1));

530 
__END_NAMESPACE_STD


532 #ifdef 
__USE_MISC


535 
	`_ex
 ((*
__func
(
__us
, *
__g
), *__arg)

536 
__THROW
 
	`__nnu
 ((1));

539 
__BEGIN_NAMESPACE_STD


543 
	$ex
 (
__us

__THROW
 
	`__ibu__
 ((
__nܑu__
));

545 #i
defed
 
__USE_ISOC11
 || defed 
__USE_ISOCXX11


549 
	$quick_ex
 (
__us

__THROW
 
	`__ibu__
 ((
__nܑu__
));

551 
__END_NAMESPACE_STD


553 #ifde
__USE_ISOC99


554 
__BEGIN_NAMESPACE_C99


557 
	$_Ex
 (
__us

__THROW
 
	`__ibu__
 ((
__nܑu__
));

558 
__END_NAMESPACE_C99


562 
__BEGIN_NAMESPACE_STD


564 *
	$gv
 (cڡ *
__me

__THROW
 
	`__nnu
 ((1)
__wur
;

565 
__END_NAMESPACE_STD


567 #ifde
__USE_GNU


570 *
	$cu_gv
 (cڡ *
__me
)

571 
__THROW
 
	`__nnu
 ((1)
__wur
;

574 #i
defed
 
__USE_SVID
 || defed 
__USE_XOPEN


578 
	$punv
 (*
__rg

__THROW
 
	`__nnu
 ((1));

581 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN2K


584 
	$nv
 (cڡ *
__me
, cڡ *
__vue
, 
__a
)

585 
__THROW
 
	`__nnu
 ((2));

588 
	$unnv
 (cڡ *
__me

__THROW
 
	`__nnu
 ((1));

591 #ifdef 
__USE_MISC


595 
	$nv
 (
__THROW
;

599 #i
defed
 
__USE_MISC
 \

600 || (
defed
 
__USE_XOPEN_EXTENDED
 && !defed 
__USE_XOPEN2K8
)

606 *
	$mkmp
 (*
__me

__THROW
 
	`__nnu
 ((1));

609 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN_EXTENDED
 \

610 || 
defed
 
__USE_XOPEN2K8


619 #ide
__USE_FILE_OFFSET64


620 
	$mkemp
 (*
__me

	`__nnu
 ((1)
__wur
;

622 #ifde
__REDIRECT


623 
	`__REDIRECT
 (
mkemp
, (*
__me
), 
mkemp64
)

624 
	`__nnu
 ((1)
__wur
;

626 
	#mkemp
 
mkemp64


	)

629 #ifde
__USE_LARGEFILE64


630 
	$mkemp64
 (*
__me

	`__nnu
 ((1)
__wur
;

634 #ifde
__USE_MISC


641 #ide
__USE_FILE_OFFSET64


642 
	$mkemps
 (*
__me
, 
__suffixn

	`__nnu
 ((1)
__wur
;

644 #ifde
__REDIRECT


645 
	`__REDIRECT
 (
mkemps
, (*
__me
, 
__suffixn
),

646 
mkemps64

	`__nnu
 ((1)
__wur
;

648 
	#mkemps
 
mkemps64


	)

651 #ifde
__USE_LARGEFILE64


652 
	$mkemps64
 (*
__me
, 
__suffixn
)

653 
	`__nnu
 ((1)
__wur
;

657 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN2K8


663 *
	$mkdmp
 (*
__me

__THROW
 
	`__nnu
 ((1)
__wur
;

666 #ifde
__USE_GNU


673 #ide
__USE_FILE_OFFSET64


674 
	$mkoemp
 (*
__me
, 
__ags

	`__nnu
 ((1)
__wur
;

676 #ifde
__REDIRECT


677 
	`__REDIRECT
 (
mkoemp
, (*
__me
, 
__ags
), 
mkoemp64
)

678 
	`__nnu
 ((1)
__wur
;

680 
	#mkoemp
 
mkoemp64


	)

683 #ifde
__USE_LARGEFILE64


684 
	$mkoemp64
 (*
__me
, 
__ags

	`__nnu
 ((1)
__wur
;

693 #ide
__USE_FILE_OFFSET64


694 
	$mkoemps
 (*
__me
, 
__suffixn
, 
__ags
)

695 
	`__nnu
 ((1)
__wur
;

697 #ifde
__REDIRECT


698 
	`__REDIRECT
 (
mkoemps
, (*
__me
, 
__suffixn
,

699 
__ags
), 
mkoemps64
)

700 
	`__nnu
 ((1)
__wur
;

702 
	#mkoemps
 
mkoemps64


	)

705 #ifde
__USE_LARGEFILE64


706 
	$mkoemps64
 (*
__me
, 
__suffixn
, 
__ags
)

707 
	`__nnu
 ((1)
__wur
;

712 
__BEGIN_NAMESPACE_STD


717 
	$syem
 (cڡ *
__commd

__wur
;

718 
__END_NAMESPACE_STD


721 #ifdef 
__USE_GNU


724 *
	$nilize_fe_me
 (cڡ *
__me
)

725 
__THROW
 
	`__nnu
 ((1)
__wur
;

728 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN_EXTENDED


734 *
	$th
 (cڡ *
__ri
 
__me
,

735 *
__ri
 
__sved

__THROW
 
__wur
;

740 #ide
__COMPAR_FN_T


741 
	#__COMPAR_FN_T


	)

742 (*
	t__comr__t
) (const *, const *);

744 #ifdef 
__USE_GNU


745 
__comr__t
 
	tcomris__t
;

748 #ifde
__USE_GNU


749 (*
	t__comr_d__t
) (const *, const *, *);

752 
__BEGIN_NAMESPACE_STD


755 *
	$bch
 (cڡ *
__key
, cڡ *
__ba
,

756 
size_t
 
__nmemb
, size_
__size
, 
__comr__t
 
__comr
)

757 
	`__nnu
 ((1, 2, 5)
__wur
;

759 #ifde
__USE_EXTERN_INLINES


760 
	~<bs/dlib-bch.h
>

765 
	$qst
 (*
__ba
, 
size_t
 
__nmemb
, size_
__size
,

766 
__comr__t
 
__comr

	`__nnu
 ((1, 4));

767 #ifde
__USE_GNU


768 
	$qst_r
 (*
__ba
, 
size_t
 
__nmemb
, size_
__size
,

769 
__comr_d__t
 
__comr
, *
__g
)

770 
	`__nnu
 ((1, 4));

775 
	$abs
 (
__x

__THROW
 
	`__ibu__
 ((
__cڡ__
)
__wur
;

776 
	$bs
 (
__x

__THROW
 
	`__ibu__
 ((
__cڡ__
)
__wur
;

777 
__END_NAMESPACE_STD


779 #ifde
__USE_ISOC99


780 
__exnsi__
 
	$abs
 (
__x
)

781 
__THROW
 
	`__ibu__
 ((
__cڡ__
)
__wur
;

785 
__BEGIN_NAMESPACE_STD


789 
div_t
 
	$div
 (
__num
, 
__dom
)

790 
__THROW
 
	`__ibu__
 ((
__cڡ__
)
__wur
;

791 
ldiv_t
 
	$ldiv
 (
__num
, 
__dom
)

792 
__THROW
 
	`__ibu__
 ((
__cڡ__
)
__wur
;

793 
__END_NAMESPACE_STD


795 #ifde
__USE_ISOC99


796 
__BEGIN_NAMESPACE_C99


797 
__exnsi__
 
div_t
 
	$div
 (
__num
,

798 
__dom
)

799 
__THROW
 
	`__ibu__
 ((
__cڡ__
)
__wur
;

800 
__END_NAMESPACE_C99


804 #i(
defed
 
__USE_XOPEN_EXTENDED
 && !defed 
__USE_XOPEN2K8
) \

805 || 
defed
 
__USE_SVID


812 *
	$ecvt
 (
__vue
, 
__ndig
, *
__ri
 
__det
,

813 *
__ri
 
__sign

__THROW
 
	`__nnu
 ((3, 4)
__wur
;

818 *
	$fcvt
 (
__vue
, 
__ndig
, *
__ri
 
__det
,

819 *
__ri
 
__sign

__THROW
 
	`__nnu
 ((3, 4)
__wur
;

824 *
	$gcvt
 (
__vue
, 
__ndig
, *
__buf
)

825 
__THROW
 
	`__nnu
 ((3)
__wur
;

828 #ifde
__USE_MISC


830 *
	$qecvt
 (
__vue
, 
__ndig
,

831 *
__ri
 
__det
, *__ri 
__sign
)

832 
__THROW
 
	`__nnu
 ((3, 4)
__wur
;

833 *
	$qfcvt
 (
__vue
, 
__ndig
,

834 *
__ri
 
__det
, *__ri 
__sign
)

835 
__THROW
 
	`__nnu
 ((3, 4)
__wur
;

836 *
	$qgcvt
 (
__vue
, 
__ndig
, *
__buf
)

837 
__THROW
 
	`__nnu
 ((3)
__wur
;

842 
	$ecvt_r
 (
__vue
, 
__ndig
, *
__ri
 
__det
,

843 *
__ri
 
__sign
, *__ri 
__buf
,

844 
size_t
 
__n

__THROW
 
	`__nnu
 ((3, 4, 5));

845 
	$fcvt_r
 (
__vue
, 
__ndig
, *
__ri
 
__det
,

846 *
__ri
 
__sign
, *__ri 
__buf
,

847 
size_t
 
__n

__THROW
 
	`__nnu
 ((3, 4, 5));

849 
	$qecvt_r
 (
__vue
, 
__ndig
,

850 *
__ri
 
__det
, *__ri 
__sign
,

851 *
__ri
 
__buf
, 
size_t
 
__n
)

852 
__THROW
 
	`__nnu
 ((3, 4, 5));

853 
	$qfcvt_r
 (
__vue
, 
__ndig
,

854 *
__ri
 
__det
, *__ri 
__sign
,

855 *
__ri
 
__buf
, 
size_t
 
__n
)

856 
__THROW
 
	`__nnu
 ((3, 4, 5));

860 
__BEGIN_NAMESPACE_STD


863 
	$mbn
 (cڡ *
__s
, 
size_t
 
__n

__THROW
;

866 
	$mbtowc
 (
wch_t
 *
__ri
 
__pwc
,

867 cڡ *
__ri
 
__s
, 
size_t
 
__n

__THROW
;

870 
	$womb
 (*
__s
, 
wch_t
 
__wch

__THROW
;

874 
size_t
 
	$mbowcs
 (
wch_t
 *
__ri
 
__pwcs
,

875 cڡ *
__ri
 
__s
, 
size_t
 
__n

__THROW
;

877 
size_t
 
	$wcombs
 (*
__ri
 
__s
,

878 cڡ 
wch_t
 *
__ri
 
__pwcs
, 
size_t
 
__n
)

879 
__THROW
;

880 
__END_NAMESPACE_STD


883 #ifde
__USE_SVID


888 
	$mch
 (cڡ *
__ڣ

__THROW
 
	`__nnu
 ((1)
__wur
;

892 #i
defed
 
__USE_XOPEN_EXTENDED
 || defed 
__USE_XOPEN2K8


899 
	$gsubt
 (**
__ri
 
__tip
,

900 *cڡ *
__ri
 
__toks
,

901 **
__ri
 
__vu
)

902 
__THROW
 
	`__nnu
 ((1, 2, 3)
__wur
;

906 #ifde
__USE_XOPEN


908 
	$tkey
 (cڡ *
__key

__THROW
 
	`__nnu
 ((1));

914 #ifde
__USE_XOPEN2KXSI


916 
	$posix_ݒ
 (
__oag

__wur
;

919 #ifde
__USE_XOPEN


924 
	$g
 (
__fd

__THROW
;

928 
	$uock
 (
__fd

__THROW
;

933 *
	$ame
 (
__fd

__THROW
 
__wur
;

936 #ifde
__USE_GNU


940 
	$ame_r
 (
__fd
, *
__buf
, 
size_t
 
__bu
)

941 
__THROW
 
	`__nnu
 ((2));

944 
	`g
 ();

947 #ifde
__USE_BSD


951 
	$gldavg
 (
__ldavg
[], 
__m
)

952 
__THROW
 
	`__nnu
 ((1));

955 
	~<bs/dlib-t.h
>

958 #i
__USE_FORTIFY_LEVEL
 > 0 && 
defed
 
__ftify_funi


959 
	~<bs/dlib.h
>

961 #ifde
__LDBL_COMPAT


962 
	~<bs/dlib-ldbl.h
>

966 #unde
__ed_mloc_d_oc


968 
__END_DECLS


	@/usr/include/string.h

22 #idef 
_STRING_H


23 
	#_STRING_H
 1

	)

25 
	~<us.h
>

27 
	g__BEGIN_DECLS


30 
	#__ed_size_t


	)

31 
	#__ed_NULL


	)

32 
	~<ddef.h
>

39 #i
defed
 
__lulus
 && (__lulu>199711L || 
__GNUC_PREREQ
 (4, 4))

40 
	#__CORRECT_ISO_CPP_STRING_H_PROTO


	)

44 
__BEGIN_NAMESPACE_STD


46 *
	$memy
 (*
__ri
 
__de
, cڡ *__ri 
__c
,

47 
size_t
 
__n

__THROW
 
	`__nnu
 ((1, 2));

50 *
	$memmove
 (*
__de
, cڡ *
__c
, 
size_t
 
__n
)

51 
__THROW
 
	`__nnu
 ((1, 2));

52 
__END_NAMESPACE_STD


57 #i
defed
 
__USE_SVID
 || defed 
__USE_BSD
 || defed 
__USE_XOPEN


58 *
	$memcy
 (*
__ri
 
__de
, cڡ *__ri 
__c
,

59 
__c
, 
size_t
 
__n
)

60 
__THROW
 
	`__nnu
 ((1, 2));

64 
__BEGIN_NAMESPACE_STD


66 *
	$memt
 (*
__s
, 
__c
, 
size_t
 
__n

__THROW
 
	`__nnu
 ((1));

69 
	$memcmp
 (cڡ *
__s1
, cڡ *
__s2
, 
size_t
 
__n
)

70 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

73 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


76 *
	`memchr
 (*
__s
, 
__c
, 
size_t
 
__n
)

77 
__THROW
 
	`__asm
 ("memchr"
__ibu_pu__
 
	`__nnu
 ((1));

78 cڡ *
	`memchr
 (cڡ *
__s
, 
__c
, 
size_t
 
__n
)

79 
__THROW
 
	`__asm
 ("memchr"
__ibu_pu__
 
	`__nnu
 ((1));

81 #ifde
__OPTIMIZE__


82 
__ex_ways_le
 *

83 
	`memchr
 (*
__s
, 
__c
, 
size_t
 
__n

__THROW


85  
	`__but_memchr
 (
__s
, 
__c
, 
__n
);

88 
__ex_ways_le
 const *

89 
	`memchr
 (cڡ *
__s
, 
__c
, 
size_t
 
__n

__THROW


91  
	`__but_memchr
 (
__s
, 
__c
, 
__n
);

94 
	}
}

96 *
	$memchr
 (cڡ *
__s
, 
__c
, 
size_t
 
__n
)

97 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1));

99 
__END_NAMESPACE_STD


101 #ifde
__USE_GNU


104 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


105 "C++" *
	$wmemchr
 (*
__s
, 
__c
)

106 
__THROW
 
	`__asm
 ("wmemchr"
__ibu_pu__
 
	`__nnu
 ((1));

107 "C++" cڡ *
	$wmemchr
 (cڡ *
__s
, 
__c
)

108 
__THROW
 
	`__asm
 ("wmemchr"
__ibu_pu__
 
	`__nnu
 ((1));

110 *
	$wmemchr
 (cڡ *
__s
, 
__c
)

111 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1));

115 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


116 "C++" *
	$memrchr
 (*
__s
, 
__c
, 
size_t
 
__n
)

117 
__THROW
 
	`__asm
 ("memrchr"
__ibu_pu__
 
	`__nnu
 ((1));

118 "C++" cڡ *
	$memrchr
 (cڡ *
__s
, 
__c
, 
size_t
 
__n
)

119 
__THROW
 
	`__asm
 ("memrchr"
__ibu_pu__
 
	`__nnu
 ((1));

121 *
	$memrchr
 (cڡ *
__s
, 
__c
, 
size_t
 
__n
)

122 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1));

127 
__BEGIN_NAMESPACE_STD


129 *
	$ry
 (*
__ri
 
__de
, cڡ *__ri 
__c
)

130 
__THROW
 
	`__nnu
 ((1, 2));

132 *
	$y
 (*
__ri
 
__de
,

133 cڡ *
__ri
 
__c
, 
size_t
 
__n
)

134 
__THROW
 
	`__nnu
 ((1, 2));

137 *
	$rt
 (*
__ri
 
__de
, cڡ *__ri 
__c
)

138 
__THROW
 
	`__nnu
 ((1, 2));

140 *
	$t
 (*
__ri
 
__de
, cڡ *__ri 
__c
,

141 
size_t
 
__n

__THROW
 
	`__nnu
 ((1, 2));

144 
	$rcmp
 (cڡ *
__s1
, cڡ *
__s2
)

145 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

147 
	$cmp
 (cڡ *
__s1
, cڡ *
__s2
, 
size_t
 
__n
)

148 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

151 
	$rcl
 (cڡ *
__s1
, cڡ *
__s2
)

152 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

154 
size_t
 
	$rxm
 (*
__ri
 
__de
,

155 cڡ *
__ri
 
__c
, 
size_t
 
__n
)

156 
__THROW
 
	`__nnu
 ((2));

157 
__END_NAMESPACE_STD


159 #ifde
__USE_XOPEN2K8


163 
	~<xlo.h
>

166 
	$rcl_l
 (cڡ *
__s1
, cڡ *
__s2
, 
__lo_t
 
__l
)

167 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2, 3));

169 
size_t
 
	$rxm_l
 (*
__de
, cڡ *
__c
, 
size_t
 
__n
,

170 
__lo_t
 
__l

__THROW
 
	`__nnu
 ((2, 4));

173 #i
defed
 
__USE_SVID
 || defed 
__USE_BSD
 || defed 
__USE_XOPEN_EXTENDED
 \

174 || 
defed
 
__USE_XOPEN2K8


176 *
	$rdup
 (cڡ *
__s
)

177 
__THROW
 
__ibu_mloc__
 
	`__nnu
 ((1));

183 #i
defed
 
__USE_XOPEN2K8


184 *
	$dup
 (cڡ *
__rg
, 
size_t
 
__n
)

185 
__THROW
 
__ibu_mloc__
 
	`__nnu
 ((1));

188 #i
defed
 
__USE_GNU
 && defed 
__GNUC__


190 
	#rdu
(
s
) \

191 (
__exnsi__
 \

193 cڡ *
__d
 = (
s
); \

194 
size_t
 
__n
 = 
	`
 (
__d
) + 1; \

195 *
__w
 = (*
	`__but_lo
 (
__n
); \

196 (*
	`memy
 (
__w
, 
__d
, 
__n
); \

197 
	}
}))

	)

200 
	#du
(
s
, 
n
) \

201 (
__exnsi__
 \

203 cڡ *
__d
 = (
s
); \

204 
size_t
 
__n
 = 
	`n
 (
__d
, (
n
)); \

205 *
__w
 = (*
	`__but_lo
 (
__n
 + 1); \

206 
__w
[
__n
] = '\0'; \

207 (*
	`memy
 (
__w
, 
__d
, 
__n
); \

208 }))

	)

211 
	g__BEGIN_NAMESPACE_STD


213 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


216 *
rchr
 (*
__s
, 
__c
)

217 
__THROW
 
__asm
 ("rchr"
__ibu_pu__
 
__nnu
 ((1));

218 cڡ *
rchr
 (cڡ *
__s
, 
__c
)

219 
__THROW
 
__asm
 ("rchr"
__ibu_pu__
 
__nnu
 ((1));

221 #ifde
__OPTIMIZE__


222 
__ex_ways_le
 *

223 
rchr
 (*
__s
, 
__c

	g__THROW


225  
__but_rchr
 (
__s
, 
__c
);

228 
__ex_ways_le
 const *

229 
rchr
 (cڡ *
__s
, 
__c

	g__THROW


231  
__but_rchr
 (
__s
, 
__c
);

236 *
	$rchr
 (cڡ *
__s
, 
__c
)

237 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1));

240 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


243 *
	`chr
 (*
__s
, 
__c
)

244 
__THROW
 
	`__asm
 ("chr"
__ibu_pu__
 
	`__nnu
 ((1));

245 cڡ *
	`chr
 (cڡ *
__s
, 
__c
)

246 
__THROW
 
	`__asm
 ("chr"
__ibu_pu__
 
	`__nnu
 ((1));

248 #ifde
__OPTIMIZE__


249 
__ex_ways_le
 *

250 
	`chr
 (*
__s
, 
__c

__THROW


252  
	`__but_chr
 (
__s
, 
__c
);

255 
__ex_ways_le
 const *

256 
	`chr
 (cڡ *
__s
, 
__c

__THROW


258  
	`__but_chr
 (
__s
, 
__c
);

261 
	}
}

263 *
	$chr
 (cڡ *
__s
, 
__c
)

264 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1));

266 
__END_NAMESPACE_STD


268 #ifde
__USE_GNU


271 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


272 "C++" *
	$rchul
 (*
__s
, 
__c
)

273 
__THROW
 
	`__asm
 ("rchul"
__ibu_pu__
 
	`__nnu
 ((1));

274 "C++" cڡ *
	$rchul
 (cڡ *
__s
, 
__c
)

275 
__THROW
 
	`__asm
 ("rchul"
__ibu_pu__
 
	`__nnu
 ((1));

277 *
	$rchul
 (cڡ *
__s
, 
__c
)

278 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1));

282 
__BEGIN_NAMESPACE_STD


285 
size_t
 
	$rcn
 (cڡ *
__s
, cڡ *
__je
)

286 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

289 
size_t
 
	$rn
 (cڡ *
__s
, cڡ *
__ac
)

290 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

292 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


295 *
	`brk
 (*
__s
, cڡ *
__ac
)

296 
__THROW
 
	`__asm
 ("brk"
__ibu_pu__
 
	`__nnu
 ((1, 2));

297 cڡ *
	`brk
 (cڡ *
__s
, cڡ *
__ac
)

298 
__THROW
 
	`__asm
 ("brk"
__ibu_pu__
 
	`__nnu
 ((1, 2));

300 #ifde
__OPTIMIZE__


301 
__ex_ways_le
 *

302 
	`brk
 (*
__s
, cڡ *
__ac

__THROW


304  
	`__but_brk
 (
__s
, 
__ac
);

307 
__ex_ways_le
 const *

308 
	`brk
 (cڡ *
__s
, cڡ *
__ac

__THROW


310  
	`__but_brk
 (
__s
, 
__ac
);

313 
	}
}

315 *
	$brk
 (cڡ *
__s
, cڡ *
__ac
)

316 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

319 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


322 *
	`rr
 (*
__hayack
, cڡ *
__ed
)

323 
__THROW
 
	`__asm
 ("rr"
__ibu_pu__
 
	`__nnu
 ((1, 2));

324 cڡ *
	`rr
 (cڡ *
__hayack
, cڡ *
__ed
)

325 
__THROW
 
	`__asm
 ("rr"
__ibu_pu__
 
	`__nnu
 ((1, 2));

327 #ifde
__OPTIMIZE__


328 
__ex_ways_le
 *

329 
	`rr
 (*
__hayack
, cڡ *
__ed

__THROW


331  
	`__but_rr
 (
__hayack
, 
__ed
);

334 
__ex_ways_le
 const *

335 
	`rr
 (cڡ *
__hayack
, cڡ *
__ed

__THROW


337  
	`__but_rr
 (
__hayack
, 
__ed
);

340 
	}
}

342 *
	$rr
 (cڡ *
__hayack
, cڡ *
__ed
)

343 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

348 *
	$ok
 (*
__ri
 
__s
, cڡ *__ri 
__dim
)

349 
__THROW
 
	`__nnu
 ((2));

350 
__END_NAMESPACE_STD


354 *
	$__ok_r
 (*
__ri
 
__s
,

355 cڡ *
__ri
 
__dim
,

356 **
__ri
 
__ve_r
)

357 
__THROW
 
	`__nnu
 ((2, 3));

358 #i
defed
 
__USE_POSIX
 || defed 
__USE_MISC


359 *
	$ok_r
 (*
__ri
 
__s
, cڡ *__ri 
__dim
,

360 **
__ri
 
__ve_r
)

361 
__THROW
 
	`__nnu
 ((2, 3));

364 #ifde
__USE_GNU


366 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


367 "C++" *
	$rr
 (*
__hayack
, cڡ *
__ed
)

368 
__THROW
 
	`__asm
 ("rr"
__ibu_pu__
 
	`__nnu
 ((1, 2));

369 "C++" cڡ *
	$rr
 (cڡ *
__hayack
,

370 cڡ *
__ed
)

371 
__THROW
 
	`__asm
 ("rr"
__ibu_pu__
 
	`__nnu
 ((1, 2));

373 *
	$rr
 (cڡ *
__hayack
, cڡ *
__ed
)

374 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

378 #ifde
__USE_GNU


382 *
	$memmem
 (cڡ *
__hayack
, 
size_t
 
__hayackn
,

383 cڡ *
__ed
, 
size_t
 
__edn
)

384 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 3));

388 *
	$__mempy
 (*
__ri
 
__de
,

389 cڡ *
__ri
 
__c
, 
size_t
 
__n
)

390 
__THROW
 
	`__nnu
 ((1, 2));

391 *
	$mempy
 (*
__ri
 
__de
,

392 cڡ *
__ri
 
__c
, 
size_t
 
__n
)

393 
__THROW
 
	`__nnu
 ((1, 2));

397 
__BEGIN_NAMESPACE_STD


399 
size_t
 
	$
 (cڡ *
__s
)

400 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1));

401 
__END_NAMESPACE_STD


403 #ifdef 
__USE_XOPEN2K8


406 
size_t
 
	$n
 (cڡ *
__rg
, 
size_t
 
__maxn
)

407 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1));

411 
__BEGIN_NAMESPACE_STD


413 *
	$
 (
__um

__THROW
;

414 
__END_NAMESPACE_STD


415 #i
defed
 
__USE_XOPEN2K
 || defed 
__USE_MISC


423 #i
defed
 
__USE_XOPEN2K
 && !defed 
__USE_GNU


426 #ifde
__REDIRECT_NTH


427 
	`__REDIRECT_NTH
 (
_r
,

428 (
__um
, *
__buf
, 
size_t
 
__bu
),

429 
__xpg__r

	`__nnu
 ((2));

431 
	$__xpg__r
 (
__um
, *
__buf
, 
size_t
 
__bu
)

432 
__THROW
 
	`__nnu
 ((2));

433 
	#_r
 
__xpg__r


	)

438 *
	$_r
 (
__um
, *
__buf
, 
size_t
 
__bu
)

439 
__THROW
 
	`__nnu
 ((2)
__wur
;

443 #ifde
__USE_XOPEN2K8


445 *
	$_l
 (
__um
, 
__lo_t
 
__l

__THROW
;

451 
	$__bzo
 (*
__s
, 
size_t
 
__n

__THROW
 
	`__nnu
 ((1));

453 #ifde
__USE_BSD


455 
	$bcy
 (cڡ *
__c
, *
__de
, 
size_t
 
__n
)

456 
__THROW
 
	`__nnu
 ((1, 2));

459 
	$bzo
 (*
__s
, 
size_t
 
__n

__THROW
 
	`__nnu
 ((1));

462 
	$bcmp
 (cڡ *
__s1
, cڡ *
__s2
, 
size_t
 
__n
)

463 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

466 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


469 *
	`dex
 (*
__s
, 
__c
)

470 
__THROW
 
	`__asm
 ("dex"
__ibu_pu__
 
	`__nnu
 ((1));

471 cڡ *
	`dex
 (cڡ *
__s
, 
__c
)

472 
__THROW
 
	`__asm
 ("dex"
__ibu_pu__
 
	`__nnu
 ((1));

474 #i
defed
 
__OPTIMIZE__
 && !defed 
__CORRECT_ISO_CPP_STRINGS_H_PROTO


475 
__ex_ways_le
 *

476 
	`dex
 (*
__s
, 
__c

__THROW


478  
	`__but_dex
 (
__s
, 
__c
);

481 
__ex_ways_le
 const *

482 
	`dex
 (cڡ *
__s
, 
__c

__THROW


484  
	`__but_dex
 (
__s
, 
__c
);

487 
	}
}

489 *
	$dex
 (cڡ *
__s
, 
__c
)

490 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1));

494 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


497 *
	`rdex
 (*
__s
, 
__c
)

498 
__THROW
 
	`__asm
 ("rdex"
__ibu_pu__
 
	`__nnu
 ((1));

499 cڡ *
	`rdex
 (cڡ *
__s
, 
__c
)

500 
__THROW
 
	`__asm
 ("rdex"
__ibu_pu__
 
	`__nnu
 ((1));

502 #i
defed
 
__OPTIMIZE__
 && !defed 
__CORRECT_ISO_CPP_STRINGS_H_PROTO


503 
__ex_ways_le
 *

504 
	`rdex
 (*
__s
, 
__c

__THROW


506  
	`__but_rdex
 (
__s
, 
__c
);

509 
__ex_ways_le
 const *

510 
	`rdex
 (cڡ *
__s
, 
__c

__THROW


512  
	`__but_rdex
 (
__s
, 
__c
);

515 
	}
}

517 *
	$rdex
 (cڡ *
__s
, 
__c
)

518 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1));

523 
	$ffs
 (
__i

__THROW
 
	`__ibu__
 ((
__cڡ__
));

527 #ifdef 
__USE_GNU


528 
	$ff
 (
__l

__THROW
 
	`__ibu__
 ((
__cڡ__
));

529 
__exnsi__
 
	$ffl
 (
__
)

530 
__THROW
 
	`__ibu__
 ((
__cڡ__
));

534 
	$rcmp
 (cڡ *
__s1
, cڡ *
__s2
)

535 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

538 
	$cmp
 (cڡ *
__s1
, cڡ *
__s2
, 
size_t
 
__n
)

539 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

542 #ifdef 
__USE_GNU


545 
	$rcmp_l
 (cڡ *
__s1
, cڡ *
__s2
,

546 
__lo_t
 
__loc
)

547 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2, 3));

549 
	$cmp_l
 (cڡ *
__s1
, cڡ *
__s2
,

550 
size_t
 
__n
, 
__lo_t
 
__loc
)

551 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2, 4));

554 #ifdef 
__USE_BSD


557 *
	$rp
 (**
__ri
 
__rgp
,

558 cڡ *
__ri
 
__dim
)

559 
__THROW
 
	`__nnu
 ((1, 2));

562 #ifdef 
__USE_XOPEN2K8


564 *
	$rsigl
 (
__sig

__THROW
;

567 *
	$__py
 (*
__ri
 
__de
, cڡ *__ri 
__c
)

568 
__THROW
 
	`__nnu
 ((1, 2));

569 *
	$py
 (*
__ri
 
__de
, cڡ *__ri 
__c
)

570 
__THROW
 
	`__nnu
 ((1, 2));

574 *
	$__y
 (*
__ri
 
__de
,

575 cڡ *
__ri
 
__c
, 
size_t
 
__n
)

576 
__THROW
 
	`__nnu
 ((1, 2));

577 *
	$y
 (*
__ri
 
__de
,

578 cڡ *
__ri
 
__c
, 
size_t
 
__n
)

579 
__THROW
 
	`__nnu
 ((1, 2));

582 #ifdef 
__USE_GNU


584 
	$rvscmp
 (cڡ *
__s1
, cڡ *
__s2
)

585 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

588 *
	$ry
 (*
__rg

__THROW
 
	`__nnu
 ((1));

591 *
	$memob
 (*
__s
, 
size_t
 
__n

__THROW
 
	`__nnu
 ((1));

593 #ide
bame


598 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


599 "C++" *
	$bame
 (*
__fame
)

600 
__THROW
 
	`__asm
 ("bame"
	`__nnu
 ((1));

601 "C++" cڡ *
	$bame
 (cڡ *
__fame
)

602 
__THROW
 
	`__asm
 ("bame"
	`__nnu
 ((1));

604 *
	$bame
 (cڡ *
__fame

__THROW
 
	`__nnu
 ((1));

610 #i
defed
 
__GNUC__
 && __GNUC__ >= 2

611 #i
defed
 
__OPTIMIZE__
 && !defed 
__OPTIMIZE_SIZE__
 \

612 && !
defed
 
__NO_INLINE__
 && !defed 
__lulus


632 
	~<bs/rg.h
>

635 
	~<bs/rg2.h
>

638 #i
__USE_FORTIFY_LEVEL
 > 0 && 
defed
 
__ftify_funi


640 
	~<bs/rg3.h
>

644 
__END_DECLS


	@/usr/include/sys/socket.h

19 #idef 
_SYS_SOCKET_H


20 
	#_SYS_SOCKET_H
 1

	)

22 
	~<us.h
>

24 
	g__BEGIN_DECLS


26 
	~<sys/uio.h
>

27 
	#__ed_size_t


	)

28 
	~<ddef.h
>

29 #ifde
__USE_GNU


31 
	~<bs/sigt.h
>

38 
	~<bs/sock.h
>

40 #ifde
__USE_BSD


43 
	sosockaddr


45 
	m_my
;

46 
	m_da
[14];

54 
	mSHUT_RD
 = 0,

55 
	#SHUT_RD
 
SHUT_RD


	)

56 
	mSHUT_WR
,

57 
	#SHUT_WR
 
SHUT_WR


	)

58 
	mSHUT_RDWR


59 
	#SHUT_RDWR
 
SHUT_RDWR


	)

68 #i
defed
 
__lulus
 || !
__GNUC_PREREQ
 (2, 7|| !defed 
__USE_GNU


69 
	#__SOCKADDR_ARG
 
sockaddr
 *
__ri


	)

70 
	#__CONST_SOCKADDR_ARG
 cڡ 
sockaddr
 *

	)

74 
	#__SOCKADDR_ALLTYPES
 \

75 
	`__SOCKADDR_ONETYPE
 (
sockaddr
) \

76 
	`__SOCKADDR_ONETYPE
 (
sockaddr_
) \

77 
	`__SOCKADDR_ONETYPE
 (
sockaddr_ax25
) \

78 
	`__SOCKADDR_ONETYPE
 (
sockaddr_dl
) \

79 
	`__SOCKADDR_ONETYPE
 (
sockaddr_e
) \

80 
	`__SOCKADDR_ONETYPE
 (
sockaddr_
) \

81 
	`__SOCKADDR_ONETYPE
 (
sockaddr_6
) \

82 
	`__SOCKADDR_ONETYPE
 (
sockaddr_p
) \

83 
	`__SOCKADDR_ONETYPE
 (
sockaddr_x
) \

84 
	`__SOCKADDR_ONETYPE
 (
sockaddr_iso
) \

85 
	`__SOCKADDR_ONETYPE
 (
sockaddr_ns
) \

86 
	`__SOCKADDR_ONETYPE
 (
sockaddr_un
) \

87 
	`__SOCKADDR_ONETYPE
 (
sockaddr_x25
)

	)

89 
	#__SOCKADDR_ONETYPE
(
ty
ty *
__ri
 
__
##ty##__;

	)

90 uni { 
	m__SOCKADDR_ALLTYPES


91 } 
	t__SOCKADDR_ARG
 
	t__ibu__
 ((
	t__t_uni__
));

92 #unde
__SOCKADDR_ONETYPE


93 
	#__SOCKADDR_ONETYPE
(
ty
cڡ ty *
__ri
 
__
##ty##__;

	)

94 uni { 
	m__SOCKADDR_ALLTYPES


95 } 
	t__CONST_SOCKADDR_ARG
 
	t__ibu__
 ((
	t__t_uni__
));

96 #unde
__SOCKADDR_ONETYPE


99 #ifde
__USE_GNU


101 
	smmsghdr


103 
msghdr
 
	mmsg_hdr
;

104 
	mmsg_n
;

113 
	$sock
 (
__doma
, 
__ty
, 
__oc

__THROW
;

119 
	$sock
 (
__doma
, 
__ty
, 
__oc
,

120 
__fds
[2]
__THROW
;

123 
	$bd
 (
__fd
, 
__CONST_SOCKADDR_ARG
 
__addr
, 
sockn_t
 
__n
)

124 
__THROW
;

127 
	$gsockme
 (
__fd
, 
__SOCKADDR_ARG
 
__addr
,

128 
sockn_t
 *
__ri
 
__n

__THROW
;

137 
	`c
 (
__fd
, 
__CONST_SOCKADDR_ARG
 
__addr
, 
sockn_t
 
__n
);

141 
	$gme
 (
__fd
, 
__SOCKADDR_ARG
 
__addr
,

142 
sockn_t
 *
__ri
 
__n

__THROW
;

149 
ssize_t
 
	`nd
 (
__fd
, cڡ *
__buf
, 
size_t
 
__n
, 
__ags
);

156 
ssize_t
 
	`cv
 (
__fd
, *
__buf
, 
size_t
 
__n
, 
__ags
);

163 
ssize_t
 
	`ndto
 (
__fd
, cڡ *
__buf
, 
size_t
 
__n
,

164 
__ags
, 
__CONST_SOCKADDR_ARG
 
__addr
,

165 
sockn_t
 
__addr_n
);

174 
ssize_t
 
	`cvom
 (
__fd
, *
__ri
 
__buf
, 
size_t
 
__n
,

175 
__ags
, 
__SOCKADDR_ARG
 
__addr
,

176 
sockn_t
 *
__ri
 
__addr_n
);

184 
ssize_t
 
	`ndmsg
 (
__fd
, cڡ 
msghdr
 *
__mesge
,

185 
__ags
);

187 #ifde
__USE_GNU


193 
	`ndmmsg
 (
__fd
, 
mmsghdr
 *
__vmesges
,

194 
__vn
, 
__ags
);

202 
ssize_t
 
	`cvmsg
 (
__fd
, 
msghdr
 *
__mesge
, 
__ags
);

204 #ifde
__USE_GNU


210 
	`cvmmsg
 (
__fd
, 
mmsghdr
 *
__vmesges
,

211 
__vn
, 
__ags
,

212 cڡ 
timeec
 *
__tmo
);

219 
	$gsockt
 (
__fd
, 
__v
, 
__݊ame
,

220 *
__ri
 
__tv
,

221 
sockn_t
 *
__ri
 
__ݎ

__THROW
;

226 
	$tsockt
 (
__fd
, 
__v
, 
__݊ame
,

227 cڡ *
__tv
, 
sockn_t
 
__ݎ

__THROW
;

233 
	$li
 (
__fd
, 
__n

__THROW
;

243 
	`ac
 (
__fd
, 
__SOCKADDR_ARG
 
__addr
,

244 
sockn_t
 *
__ri
 
__addr_n
);

246 #ifde
__USE_GNU


251 
	`ac4
 (
__fd
, 
__SOCKADDR_ARG
 
__addr
,

252 
sockn_t
 *
__ri
 
__addr_n
, 
__ags
);

261 
	$shutdown
 (
__fd
, 
__how

__THROW
;

264 #ifde
__USE_XOPEN2K


266 
	$sockmk
 (
__fd

__THROW
;

270 #ifde
__USE_MISC


274 
	$isfdty
 (
__fd
, 
__fdty

__THROW
;

279 #i
__USE_FORTIFY_LEVEL
 > 0 && 
defed
 
__ftify_funi


280 
	~<bs/sock2.h
>

283 
__END_DECLS


	@/usr/include/sys/stat.h

22 #idef 
_SYS_STAT_H


23 
	#_SYS_STAT_H
 1

	)

25 
	~<us.h
>

27 
	~<bs/tys.h
>

29 #i
defed
 
__USE_XOPEN
 || defed 
__USE_XOPEN2K
 || defed 
__USE_MISC
 \

30 || 
defed
 
	g__USE_ATFILE


31 #i
defed
 
__USE_XOPEN
 || defed 
__USE_XOPEN2K


32 
	#__ed_time_t


	)

34 #i
defed
 
__USE_MISC
 || defed 
__USE_ATFILE


35 
	#__ed_timeec


	)

37 
	~<time.h
>

40 #i
defed
 
__USE_XOPEN
 || defed 
__USE_XOPEN2K


43 #ide
__dev_t_defed


44 
__dev_t
 
	tdev_t
;

45 
	#__dev_t_defed


	)

48 #ide
__gid_t_defed


49 
__gid_t
 
	tgid_t
;

50 
	#__gid_t_defed


	)

53 #ide
__o_t_defed


54 #ide
__USE_FILE_OFFSET64


55 
__o_t
 
	to_t
;

57 
__o64_t
 
	to_t
;

59 
	#__o_t_defed


	)

62 #ide
__mode_t_defed


63 
__mode_t
 
	tmode_t
;

64 
	#__mode_t_defed


	)

67 #ide
__ƚk_t_defed


68 
__ƚk_t
 
	tƚk_t
;

69 
	#__ƚk_t_defed


	)

72 #ide
__off_t_defed


73 #ide
__USE_FILE_OFFSET64


74 
__off_t
 
	toff_t
;

76 
__off64_t
 
	toff_t
;

78 
	#__off_t_defed


	)

81 #ide
__uid_t_defed


82 
__uid_t
 
	tuid_t
;

83 
	#__uid_t_defed


	)

87 #ifde
__USE_UNIX98


88 #ide
__blkt_t_defed


89 #ide
__USE_FILE_OFFSET64


90 
__blkt_t
 
	tblkt_t
;

92 
__blkt64_t
 
	tblkt_t
;

94 
	#__blkt_t_defed


	)

97 #ide
__blksize_t_defed


98 
__blksize_t
 
	tblksize_t
;

99 
	#__blksize_t_defed


	)

103 
	g__BEGIN_DECLS


105 
	~<bs/.h
>

107 #i
defed
 
__USE_BSD
 || defed 
__USE_MISC
 || defed 
__USE_XOPEN


108 
	#S_IFMT
 
__S_IFMT


	)

109 
	#S_IFDIR
 
__S_IFDIR


	)

110 
	#S_IFCHR
 
__S_IFCHR


	)

111 
	#S_IFBLK
 
__S_IFBLK


	)

112 
	#S_IFREG
 
__S_IFREG


	)

113 #ifde
__S_IFIFO


114 
	#S_IFIFO
 
__S_IFIFO


	)

116 #ifde
__S_IFLNK


117 
	#S_IFLNK
 
__S_IFLNK


	)

119 #i(
defed
 
__USE_BSD
 || defed 
__USE_MISC
 || defed 
__USE_UNIX98
) \

120 && 
defed
 
	g__S_IFSOCK


121 
	#S_IFSOCK
 
__S_IFSOCK


	)

127 
	#__S_ISTYPE
(
mode
, 
mask
(((mode& 
__S_IFMT
=(mask))

	)

129 
	#S_ISDIR
(
mode

	`__S_ISTYPE
((mode), 
__S_IFDIR
)

	)

130 
	#S_ISCHR
(
mode

	`__S_ISTYPE
((mode), 
__S_IFCHR
)

	)

131 
	#S_ISBLK
(
mode

	`__S_ISTYPE
((mode), 
__S_IFBLK
)

	)

132 
	#S_ISREG
(
mode

	`__S_ISTYPE
((mode), 
__S_IFREG
)

	)

133 #ifde
__S_IFIFO


134 
	#S_ISFIFO
(
mode

	`__S_ISTYPE
((mode), 
__S_IFIFO
)

	)

136 #ifde
__S_IFLNK


137 
	#S_ISLNK
(
mode

	`__S_ISTYPE
((mode), 
__S_IFLNK
)

	)

140 #i
defed
 
__USE_BSD
 && !defed 
__S_IFLNK


141 
	#S_ISLNK
(
mode
0

	)

144 #i(
defed
 
__USE_BSD
 || defed 
__USE_UNIX98
 || defed 
__USE_XOPEN2K
) \

145 && 
defed
 
	g__S_IFSOCK


146 
	#S_ISSOCK
(
mode

	`__S_ISTYPE
((mode), 
__S_IFSOCK
)

	)

147 #i
defed
 
__USE_XOPEN2K


148 
	#S_ISSOCK
(
mode
0

	)

155 #ifdef 
__USE_POSIX199309


156 
	#S_TYPEISMQ
(
buf

	`__S_TYPEISMQ
(buf)

	)

157 
	#S_TYPEISSEM
(
buf

	`__S_TYPEISSEM
(buf)

	)

158 
	#S_TYPEISSHM
(
buf

	`__S_TYPEISSHM
(buf)

	)

164 
	#S_ISUID
 
__S_ISUID


	)

165 
	#S_ISGID
 
__S_ISGID


	)

167 #i
defed
 
__USE_BSD
 || defed 
__USE_MISC
 || defed 
__USE_XOPEN


169 
	#S_ISVTX
 
__S_ISVTX


	)

172 
	#S_IRUSR
 
__S_IREAD


	)

173 
	#S_IWUSR
 
__S_IWRITE


	)

174 
	#S_IXUSR
 
__S_IEXEC


	)

176 
	#S_IRWXU
 (
__S_IREAD
|
__S_IWRITE
|
__S_IEXEC
)

	)

178 #i
defed
 
__USE_MISC
 && defed 
__USE_BSD


179 
	#S_IREAD
 
S_IRUSR


	)

180 
	#S_IWRITE
 
S_IWUSR


	)

181 
	#S_IEXEC
 
S_IXUSR


	)

184 
	#S_IRGRP
 (
S_IRUSR
 >> 3

	)

185 
	#S_IWGRP
 (
S_IWUSR
 >> 3

	)

186 
	#S_IXGRP
 (
S_IXUSR
 >> 3

	)

188 
	#S_IRWXG
 (
S_IRWXU
 >> 3)

	)

190 
	#S_IROTH
 (
S_IRGRP
 >> 3

	)

191 
	#S_IWOTH
 (
S_IWGRP
 >> 3

	)

192 
	#S_IXOTH
 (
S_IXGRP
 >> 3

	)

194 
	#S_IRWXO
 (
S_IRWXG
 >> 3)

	)

197 #ifdef 
__USE_BSD


199 
	#ACCESSPERMS
 (
S_IRWXU
|
S_IRWXG
|
S_IRWXO


	)

200 
	#ALLPERMS
 (
S_ISUID
|
S_ISGID
|
S_ISVTX
|
S_IRWXU
|
S_IRWXG
|
S_IRWXO
)

	)

201 
	#DEFFILEMODE
 (
S_IRUSR
|
S_IWUSR
|
S_IRGRP
|
S_IWGRP
|
S_IROTH
|
S_IWOTH
)

	)

203 
	#S_BLKSIZE
 512

	)

207 #ide
__USE_FILE_OFFSET64


209 
	$
 (cڡ *
__ri
 
__fe
,

210 

 *
__ri
 
__buf

__THROW
 
	`__nnu
 ((1, 2));

214 
	$f
 (
__fd
, 

 *
__buf

__THROW
 
	`__nnu
 ((2));

216 #ifde
__REDIRECT_NTH


217 
	`__REDIRECT_NTH
 (

, (cڡ *
__ri
 
__fe
,

218 

 *
__ri
 
__buf
), 
64
)

219 
	`__nnu
 ((1, 2));

220 
	`__REDIRECT_NTH
 (
f
, (
__fd
, 

 *
__buf
), 
f64
)

221 
	`__nnu
 ((2));

223 
	#
 
64


	)

224 
	#f
 
f64


	)

227 #ifde
__USE_LARGEFILE64


228 
	$64
 (cڡ *
__ri
 
__fe
,

229 
64
 *
__ri
 
__buf

__THROW
 
	`__nnu
 ((1, 2));

230 
	$f64
 (
__fd
, 
64
 *
__buf

__THROW
 
	`__nnu
 ((2));

233 #ifde
__USE_ATFILE


237 #ide
__USE_FILE_OFFSET64


238 
	$f
 (
__fd
, cڡ *
__ri
 
__fe
,

239 

 *
__ri
 
__buf
, 
__ag
)

240 
__THROW
 
	`__nnu
 ((2, 3));

242 #ifde
__REDIRECT_NTH


243 
	`__REDIRECT_NTH
 (
f
, (
__fd
, cڡ *
__ri
 
__fe
,

244 

 *
__ri
 
__buf
,

245 
__ag
),

246 
f64

	`__nnu
 ((2, 3));

248 
	#f
 
f64


	)

252 #ifde
__USE_LARGEFILE64


253 
	$f64
 (
__fd
, cڡ *
__ri
 
__fe
,

254 
64
 *
__ri
 
__buf
, 
__ag
)

255 
__THROW
 
	`__nnu
 ((2, 3));

259 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN_EXTENDED
 || defed 
__USE_XOPEN2K


260 #ide
__USE_FILE_OFFSET64


263 
	$l
 (cڡ *
__ri
 
__fe
,

264 

 *
__ri
 
__buf

__THROW
 
	`__nnu
 ((1, 2));

266 #ifde
__REDIRECT_NTH


267 
	`__REDIRECT_NTH
 (
l
,

268 (cڡ *
__ri
 
__fe
,

269 

 *
__ri
 
__buf
), 
l64
)

270 
	`__nnu
 ((1, 2));

272 
	#l
 
l64


	)

275 #ifde
__USE_LARGEFILE64


276 
	$l64
 (cڡ *
__ri
 
__fe
,

277 
64
 *
__ri
 
__buf
)

278 
__THROW
 
	`__nnu
 ((1, 2));

284 
	$chmod
 (cڡ *
__fe
, 
__mode_t
 
__mode
)

285 
__THROW
 
	`__nnu
 ((1));

287 #ifde
__USE_BSD


291 
	$lchmod
 (cڡ *
__fe
, 
__mode_t
 
__mode
)

292 
__THROW
 
	`__nnu
 ((1));

296 #i
defed
 
__USE_BSD
 || defed 
__USE_POSIX


297 
	$fchmod
 (
__fd
, 
__mode_t
 
__mode

__THROW
;

300 #ifde
__USE_ATFILE


303 
	$fchmod
 (
__fd
, cڡ *
__fe
, 
__mode_t
 
__mode
,

304 
__ag
)

305 
__THROW
 
	`__nnu
 ((2)
__wur
;

312 
__mode_t
 
	$umask
 (
__mode_t
 
__mask

__THROW
;

314 #ifdef 
__USE_GNU


317 
__mode_t
 
	$gumask
 (
__THROW
;

321 
	$mkd
 (cڡ *
__th
, 
__mode_t
 
__mode
)

322 
__THROW
 
	`__nnu
 ((1));

324 #ifde
__USE_ATFILE


328 
	$mkd
 (
__fd
, cڡ *
__th
, 
__mode_t
 
__mode
)

329 
__THROW
 
	`__nnu
 ((2));

335 #i
defed
 
__USE_MISC
 || defed 
__USE_BSD
 || defed 
__USE_XOPEN_EXTENDED


336 
	$mknod
 (cڡ *
__th
, 
__mode_t
 
__mode
, 
__dev_t
 
__dev
)

337 
__THROW
 
	`__nnu
 ((1));

339 #ifde
__USE_ATFILE


343 
	$mknod
 (
__fd
, cڡ *
__th
, 
__mode_t
 
__mode
,

344 
__dev_t
 
__dev

__THROW
 
	`__nnu
 ((2));

350 
	$mkfifo
 (cڡ *
__th
, 
__mode_t
 
__mode
)

351 
__THROW
 
	`__nnu
 ((1));

353 #ifde
__USE_ATFILE


357 
	$mkfift
 (
__fd
, cڡ *
__th
, 
__mode_t
 
__mode
)

358 
__THROW
 
	`__nnu
 ((2));

361 #ifde
__USE_ATFILE


364 
	$utimt
 (
__fd
, cڡ *
__th
,

365 cڡ 
timeec
 
__times
[2],

366 
__ags
)

367 
__THROW
 
	`__nnu
 ((2));

370 #ifde
__USE_XOPEN2K8


372 
	$futims
 (
__fd
, cڡ 
timeec
 
__times
[2]
__THROW
;

390 #ide
_STAT_VER


391 
	#_STAT_VER
 0

	)

393 #ide
_MKNOD_VER


394 
	#_MKNOD_VER
 0

	)

398 #ide
__USE_FILE_OFFSET64


399 
	$__fx
 (
__v
, 
__fdes
, 

 *
___buf
)

400 
__THROW
 
	`__nnu
 ((3));

401 
	$__x
 (
__v
, cڡ *
__fame
,

402 

 *
___buf

__THROW
 
	`__nnu
 ((2, 3));

403 
	$__lx
 (
__v
, cڡ *
__fame
,

404 

 *
___buf

__THROW
 
	`__nnu
 ((2, 3));

405 
	$__fx
 (
__v
, 
__fdes
, cڡ *
__fame
,

406 

 *
___buf
, 
__ag
)

407 
__THROW
 
	`__nnu
 ((3, 4));

409 #ifde
__REDIRECT_NTH


410 
	`__REDIRECT_NTH
 (
__fx
, (
__v
, 
__fdes
,

411 

 *
___buf
), 
__fx64
)

412 
	`__nnu
 ((3));

413 
	`__REDIRECT_NTH
 (
__x
, (
__v
, cڡ *
__fame
,

414 

 *
___buf
), 
__x64
)

415 
	`__nnu
 ((2, 3));

416 
	`__REDIRECT_NTH
 (
__lx
, (
__v
, cڡ *
__fame
,

417 

 *
___buf
), 
__lx64
)

418 
	`__nnu
 ((2, 3));

419 
	`__REDIRECT_NTH
 (
__fx
, (
__v
, 
__fdes
,

420 cڡ *
__fame
,

421 

 *
___buf
, 
__ag
),

422 
__fx64

	`__nnu
 ((3, 4));

425 
	#__fx
 
__fx64


	)

426 
	#__x
 
__x64


	)

427 
	#__lx
 
__lx64


	)

431 #ifde
__USE_LARGEFILE64


432 
	$__fx64
 (
__v
, 
__fdes
, 
64
 *
___buf
)

433 
__THROW
 
	`__nnu
 ((3));

434 
	$__x64
 (
__v
, cڡ *
__fame
,

435 
64
 *
___buf

__THROW
 
	`__nnu
 ((2, 3));

436 
	$__lx64
 (
__v
, cڡ *
__fame
,

437 
64
 *
___buf

__THROW
 
	`__nnu
 ((2, 3));

438 
	$__fx64
 (
__v
, 
__fdes
, cڡ *
__fame
,

439 
64
 *
___buf
, 
__ag
)

440 
__THROW
 
	`__nnu
 ((3, 4));

442 
	$__xmknod
 (
__v
, cڡ *
__th
, 
__mode_t
 
__mode
,

443 
__dev_t
 *
__dev

__THROW
 
	`__nnu
 ((2, 4));

445 
	$__xmknod
 (
__v
, 
__fd
, cڡ *
__th
,

446 
__mode_t
 
__mode
, 
__dev_t
 *
__dev
)

447 
__THROW
 
	`__nnu
 ((3, 5));

449 #ifde
__USE_EXTERN_INLINES


452 
__ex_le
 

453 
	`__NTH
 (
	$
 (cڡ *
__th
, 

 *
__buf
))

455  
	`__x
 (
_STAT_VER
, 
__th
, 
__buf
);

456 
	}
}

458 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN_EXTENDED


459 
__ex_le
 

460 
__NTH
 (
	$l
 (cڡ *
__th
, 

 *
__buf
))

462  
	`__lx
 (
_STAT_VER
, 
__th
, 
__buf
);

463 
	}
}

466 
__ex_le
 

467 
__NTH
 (
	$f
 (
__fd
, 

 *
__buf
))

469  
	`__fx
 (
_STAT_VER
, 
__fd
, 
__buf
);

470 
	}
}

472 #ifde
__USE_ATFILE


473 
__ex_le
 

474 
__NTH
 (
	$f
 (
__fd
, cڡ *
__fame
, 

 *
__buf
,

475 
__ag
))

477  
	`__fx
 (
_STAT_VER
, 
__fd
, 
__fame
, 
__buf
, 
__ag
);

478 
	}
}

481 #i
defed
 
__USE_MISC
 || defed 
__USE_BSD


482 
__ex_le
 

483 
__NTH
 (
	$mknod
 (cڡ *
__th
, 
__mode_t
 
__mode
, 
__dev_t
 
__dev
))

485  
	`__xmknod
 (
_MKNOD_VER
, 
__th
, 
__mode
, &
__dev
);

486 
	}
}

489 #ifde
__USE_ATFILE


490 
__ex_le
 

491 
__NTH
 (
	$mknod
 (
__fd
, cڡ *
__th
, 
__mode_t
 
__mode
,

492 
__dev_t
 
__dev
))

494  
	`__xmknod
 (
_MKNOD_VER
, 
__fd
, 
__th
, 
__mode
, &
__dev
);

495 
	}
}

498 #i
defed
 
__USE_LARGEFILE64
 \

499 && (! 
defed
 
	g__USE_FILE_OFFSET64
 \

500 || (
defed
 
	g__REDIRECT_NTH
 && defed 
	g__OPTIMIZE__
))

501 
__ex_le
 

502 
__NTH
 (
	$64
 (cڡ *
__th
, 
64
 *
__buf
))

504  
	`__x64
 (
_STAT_VER
, 
__th
, 
__buf
);

505 
	}
}

507 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN_EXTENDED


508 
__ex_le
 

509 
__NTH
 (
	$l64
 (cڡ *
__th
, 
64
 *
__buf
))

511  
	`__lx64
 (
_STAT_VER
, 
__th
, 
__buf
);

512 
	}
}

515 
__ex_le
 

516 
__NTH
 (
	$f64
 (
__fd
, 
64
 *
__buf
))

518  
	`__fx64
 (
_STAT_VER
, 
__fd
, 
__buf
);

519 
	}
}

521 #ifde
__USE_ATFILE


522 
__ex_le
 

523 
__NTH
 (
	$f64
 (
__fd
, cڡ *
__fame
, 
64
 *
__buf
,

524 
__ag
))

526  
	`__fx64
 (
_STAT_VER
, 
__fd
, 
__fame
, 
__buf
, 
__ag
);

527 
	}
}

534 
	g__END_DECLS


	@/usr/include/sys/types.h

22 #idef 
_SYS_TYPES_H


23 
	#_SYS_TYPES_H
 1

	)

25 
	~<us.h
>

27 
	g__BEGIN_DECLS


29 
	~<bs/tys.h
>

31 #ifdef 
__USE_BSD


32 #ide
__u_ch_defed


33 
__u_ch
 
	tu_ch
;

34 
__u_sht
 
	tu_sht
;

35 
__u_t
 
	tu_t
;

36 
__u_lg
 
	tu_lg
;

37 
__quad_t
 
	tquad_t
;

38 
__u_quad_t
 
	tu_quad_t
;

39 
__fsid_t
 
	tfsid_t
;

40 
	#__u_ch_defed


	)

44 
__loff_t
 
	tloff_t
;

46 #ide
__o_t_defed


47 #ide
__USE_FILE_OFFSET64


48 
__o_t
 
	to_t
;

50 
__o64_t
 
	to_t
;

52 
	#__o_t_defed


	)

54 #i
defed
 
__USE_LARGEFILE64
 && !defed 
__o64_t_defed


55 
__o64_t
 
	to64_t
;

56 
	#__o64_t_defed


	)

59 #ide
__dev_t_defed


60 
__dev_t
 
	tdev_t
;

61 
	#__dev_t_defed


	)

64 #ide
__gid_t_defed


65 
__gid_t
 
	tgid_t
;

66 
	#__gid_t_defed


	)

69 #ide
__mode_t_defed


70 
__mode_t
 
	tmode_t
;

71 
	#__mode_t_defed


	)

74 #ide
__ƚk_t_defed


75 
__ƚk_t
 
	tƚk_t
;

76 
	#__ƚk_t_defed


	)

79 #ide
__uid_t_defed


80 
__uid_t
 
	tuid_t
;

81 
	#__uid_t_defed


	)

84 #ide
__off_t_defed


85 #ide
__USE_FILE_OFFSET64


86 
__off_t
 
	toff_t
;

88 
__off64_t
 
	toff_t
;

90 
	#__off_t_defed


	)

92 #i
defed
 
__USE_LARGEFILE64
 && !defed 
__off64_t_defed


93 
__off64_t
 
	toff64_t
;

94 
	#__off64_t_defed


	)

97 #ide
__pid_t_defed


98 
__pid_t
 
	tpid_t
;

99 
	#__pid_t_defed


	)

102 #i(
defed
 
__USE_SVID
 || defed 
__USE_XOPEN
 || defed 
__USE_XOPEN2K8
) \

103 && !
defed
 
__id_t_defed


104 
__id_t
 
	tid_t
;

105 
	#__id_t_defed


	)

108 #ide
__ssize_t_defed


109 
__ssize_t
 
	tssize_t
;

110 
	#__ssize_t_defed


	)

113 #ifdef 
__USE_BSD


114 #ide
__daddr_t_defed


115 
__daddr_t
 
	tdaddr_t
;

116 
__ddr_t
 
	tddr_t
;

117 
	#__daddr_t_defed


	)

121 #i(
defed
 
__USE_SVID
 || defed 
__USE_XOPEN
&& !defed 
__key_t_defed


122 
__key_t
 
	tkey_t
;

123 
	#__key_t_defed


	)

126 #i
defed
 
__USE_XOPEN
 || defed 
__USE_XOPEN2K8


127 
	#__ed_ock_t


	)

129 
	#__ed_time_t


	)

130 
	#__ed_tim_t


	)

131 
	#__ed_ockid_t


	)

132 
	~<time.h
>

134 #ifde
__USE_XOPEN


135 #ide
__ucds_t_defed


136 
__ucds_t
 
	tucds_t
;

137 
	#__ucds_t_defed


	)

139 #ide
__sucds_t_defed


140 
__sucds_t
 
	tsucds_t
;

141 
	#__sucds_t_defed


	)

145 
	#__ed_size_t


	)

146 
	~<ddef.h
>

148 #ifde
__USE_MISC


150 
	tulg
;

151 
	tusht
;

152 
	tut
;

157 #i!
__GNUC_PREREQ
 (2, 7)

160 #ide
__t8_t_defed


161 
	#__t8_t_defed


	)

162 
	tt8_t
;

163 
	tt16_t
;

164 
	tt32_t
;

165 #i
__WORDSIZE
 == 64

166 
	tt64_t
;

168 
__exnsi__
 
	tt64_t
;

173 
	tu_t8_t
;

174 
	tu_t16_t
;

175 
	tu_t32_t
;

176 #i
__WORDSIZE
 == 64

177 
	tu_t64_t
;

179 
__exnsi__
 
	tu_t64_t
;

182 
	tgi_t
;

187 
	#__tN_t
(
N
, 
MODE
) \

188 ##
	tN
##
	t_t
 
	t__ibu__
 ((
	t__mode__
 (
	tMODE
)))

	)

189 
	t__u_tN_t
(
	tN
, 
	tMODE
) \

190 
	tu_t
##
	tN
##
	t_t
 
	t__ibu__
 ((
	t__mode__
 (
	tMODE
)))

	)

192 #ide
	t__t8_t_defed


193 
	t__t8_t_defed


	)

194 
	t__tN_t
 (8, 
	t__QI__
);

195 
__tN_t
 (16, 
__HI__
);

196 
__tN_t
 (32, 
__SI__
);

197 
__tN_t
 (64, 
__DI__
);

200 
__u_tN_t
 (8, 
__QI__
);

201 
__u_tN_t
 (16, 
__HI__
);

202 
__u_tN_t
 (32, 
__SI__
);

203 
__u_tN_t
 (64, 
__DI__
);

205 
	tgi_t
 
	t__ibu__
 ((
	t__mode__
 (
	t__wd__
)));

211 
	#__BIT_TYPES_DEFINED__
 1

	)

214 #ifdef 
__USE_BSD


216 
	~<dn.h
>

219 
	~<sys/.h
>

222 
	~<sys/sysmaos.h
>

226 #i(
defed
 
__USE_UNIX98
 || defed 
__USE_XOPEN2K8
) \

227 && !
defed
 
__blksize_t_defed


228 
__blksize_t
 
	tblksize_t
;

229 
	#__blksize_t_defed


	)

233 #ide
__USE_FILE_OFFSET64


234 #ide
__blkt_t_defed


235 
__blkt_t
 
	tblkt_t
;

236 
	#__blkt_t_defed


	)

238 #ide
__fsblkt_t_defed


239 
__fsblkt_t
 
	tfsblkt_t
;

240 
	#__fsblkt_t_defed


	)

242 #ide
__fsft_t_defed


243 
__fsft_t
 
	tfsft_t
;

244 
	#__fsft_t_defed


	)

247 #ide
__blkt_t_defed


248 
__blkt64_t
 
	tblkt_t
;

249 
	#__blkt_t_defed


	)

251 #ide
__fsblkt_t_defed


252 
__fsblkt64_t
 
	tfsblkt_t
;

253 
	#__fsblkt_t_defed


	)

255 #ide
__fsft_t_defed


256 
__fsft64_t
 
	tfsft_t
;

257 
	#__fsft_t_defed


	)

261 #ifde
__USE_LARGEFILE64


262 
__blkt64_t
 
	tblkt64_t
;

263 
__fsblkt64_t
 
	tfsblkt64_t
;

264 
__fsft64_t
 
	tfsft64_t
;

269 #i
defed
 
__USE_POSIX199506
 || defed 
__USE_UNIX98


270 
	~<bs/hadtys.h
>

273 
	g__END_DECLS


	@/usr/include/alloca.h

18 #idef 
_ALLOCA_H


19 
	#_ALLOCA_H
 1

	)

21 
	~<us.h
>

23 
	#__ed_size_t


	)

24 
	~<ddef.h
>

26 
	g__BEGIN_DECLS


29 #unde
lo


32 *
	$lo
 (
size_t
 
__size

__THROW
;

34 #ifdef 
__GNUC__


35 
	#lo
(
size

	`__but_lo
 (size)

	)

38 
__END_DECLS


	@/usr/include/bits/byteswap.h

19 #i!
defed
 
_BYTESWAP_H
 && !defed 
_NETINET_IN_H
 && !defed 
_ENDIAN_H


23 #ide
_BITS_BYTESWAP_H


24 
	#_BITS_BYTESWAP_H
 1

	)

26 
	~<us.h
>

27 
	~<bs/tys.h
>

28 
	~<bs/wdsize.h
>

31 
	#__bsw_cڡt_16
(
x
) \

32 ((((((
x
>> 8& 0xff| (((x& 0xff<< 8)))

	)

35 
	~<bs/bysw-16.h
>

38 
	#__bsw_cڡt_32
(
x
) \

39 ((((
x
) & 0xff000000) >> 24) | (((x) & 0x00ff0000) >> 8) | \

40 (((
x
& 0x0000ff00<< 8| (((x& 0x000000ff<< 24))

	)

42 #ifde
__GNUC__


43 #i
__GNUC_PREREQ
 (4, 3)

44 
__le
 

45 
	$__bsw_32
 (
__bsx
)

47  
	`__but_bsw32
 (
__bsx
);

48 
	}
}

49 #i
__GNUC__
 >= 2

50 #i
__WORDSIZE
 =64 || (
defed
 
__i486__
 || defed 
__ium__
 \

51 || 
defed
 
	g__iumo__
 || defed 
	g__ium4__
 \

52 || 
defed
 
	g__k8__
 || defed 
	g__hl__
 \

53 || 
defed
 
	g__k6__
 || defed 
	g__noca__
 \

54 || 
defed
 
	g__ce2__
 || defed 
	g__geode__
 \

55 || 
defed
 
	g__amdm10__
)

58 
	#__bsw_32
(
x
) \

59 (
__exnsi__
 \

60 ({ 
__v
, 
__x
 = (
x
); \

61 i(
	`__but_cڡt_p
 (
__x
)) \

62 
__v
 = 
	`__bsw_cڡt_32
 (
__x
); \

64 
	`__asm__
 ("bsw %0" : "" (
__v
: "0" (
__x
)); \

65 
__v
; }))

	)

67 
	#__bsw_32
(
x
) \

68 (
__exnsi__
 \

69 ({ 
__v
, 
__x
 = (
x
); \

70 i(
	`__but_cڡt_p
 (
__x
)) \

71 
__v
 = 
	`__bsw_cڡt_32
 (
__x
); \

73 
	`__asm__
 ("rorw $8, %w0;" \

76 : "" (
__v
) \

77 : "0" (
__x
) \

79 
__v
; }))

	)

82 
	#__bsw_32
(
x
) \

83 (
__exnsi__
 \

84 ({ 
__x
 = (
x
); 
	`__bsw_cڡt_32
 (__x); }))

	)

87 
__le
 

88 
	$__bsw_32
 (
__bsx
)

90  
	`__bsw_cڡt_32
 (
__bsx
);

91 
	}
}

95 #i
__GNUC_PREREQ
 (2, 0)

97 
	#__bsw_cڡt_64
(
x
) \

98 (
	`__exnsi__
 ((((
x
) & 0xff00000000000000ull) >> 56) \

99 | (((
x
) & 0x00ff000000000000ull) >> 40) \

100 | (((
x
) & 0x0000ff0000000000ull) >> 24) \

101 | (((
x
) & 0x000000ff00000000ull) >> 8) \

102 | (((
x
) & 0x00000000ff000000ull) << 8) \

103 | (((
x
) & 0x0000000000ff0000ull) << 24) \

104 | (((
x
) & 0x000000000000ff00ull) << 40) \

105 | (((
x
& 0x00000000000000ffu<< 56)))

	)

107 #i
__GNUC_PREREQ
 (4, 3)

108 
__le
 
__ut64_t


109 
	$__bsw_64
 (
__ut64_t
 
__bsx
)

111  
	`__but_bsw64
 (
__bsx
);

112 
	}
}

113 #i
__WORDSIZE
 == 64

114 
	#__bsw_64
(
x
) \

115 (
__exnsi__
 \

116 ({ 
__ut64_t
 
__v
, 
__x
 = (
x
); \

117 i(
	`__but_cڡt_p
 (
__x
)) \

118 
__v
 = 
	`__bsw_cڡt_64
 (
__x
); \

120 
	`__asm__
 ("bsw %q0" : "" (
__v
: "0" (
__x
)); \

121 
__v
; }))

	)

123 
	#__bsw_64
(
x
) \

124 (
__exnsi__
 \

125 ({ uni { 
__exnsi__
 
__ut64_t
 
__
; \

126 
__l
[2]; } 
__w
, 
__r
; \

127 i(
	`__but_cڡt_p
 (
x
)) \

128 
__r
.
__
 = 
	`__bsw_cڡt_64
 (
x
); \

131 
__w
.
__
 = (
x
); \

132 
__r
.
__l
[0] = 
	`__bsw_32
 (
__w
.__l[1]); \

133 
__r
.
__l
[1] = 
	`__bsw_32
 (
__w
.__l[0]); \

135 
__r
.
__
; }))

	)

138 
	#__bsw_cڡt_64
(
x
) \

139 ((((
x
) & 0xff00000000000000ull) >> 56) \

140 | (((
x
) & 0x00ff000000000000ull) >> 40) \

141 | (((
x
) & 0x0000ff0000000000ull) >> 24) \

142 | (((
x
) & 0x000000ff00000000ull) >> 8) \

143 | (((
x
) & 0x00000000ff000000ull) << 8) \

144 | (((
x
) & 0x0000000000ff0000ull) << 24) \

145 | (((
x
) & 0x000000000000ff00ull) << 40) \

146 | (((
x
& 0x00000000000000ffu<< 56))

	)

148 
__le
 
__ut64_t


149 
	$__bsw_64
 (
__ut64_t
 
__bsx
)

151  
	`__bsw_cڡt_64
 (
__bsx
);

152 
	}
}

	@/usr/include/bits/errno.h

19 #ifde
_ERRNO_H


21 #unde
EDOM


22 #unde
EILSEQ


23 #unde
ERANGE


24 
	~<lux/o.h
>

27 
	#ENOTSUP
 
EOPNOTSUPP


	)

30 #ide
ECANCELED


31 
	#ECANCELED
 125

	)

35 #ide
EOWNERDEAD


36 
	#EOWNERDEAD
 130

	)

37 
	#ENOTRECOVERABLE
 131

	)

40 #ide
ERFKILL


41 
	#ERFKILL
 132

	)

44 #ide
EHWPOISON


45 
	#EHWPOISON
 133

	)

48 #ide
__ASSEMBLER__


50 *
	$__o_loti
 (
__THROW
 
	`__ibu__
 ((
__cڡ__
));

52 #i!
defed
 
_LIBC
 || defed 
_LIBC_REENTRANT


54 
	#o
 (*
	`__o_loti
 ())

	)

59 #i!
defed
 
_ERRNO_H
 && defed 
__ed_Emh


63 
	#EDOM
 33

	)

64 
	#EILSEQ
 84

	)

65 
	#ERANGE
 34

	)

	@/usr/include/bits/fcntl.h

19 #ide
_FCNTL_H


23 #ifde
__x86_64__


24 
	#__O_LARGEFILE
 0

	)

27 #ifde
__x86_64__


29 
	#F_GETLK64
 5

	)

30 
	#F_SETLK64
 6

	)

31 
	#F_SETLKW64
 7

	)

35 
	sock


37 
	ml_ty
;

38 
	ml_wh
;

39 #ide
__USE_FILE_OFFSET64


40 
__off_t
 
	ml_t
;

41 
__off_t
 
	ml_n
;

43 
__off64_t
 
	ml_t
;

44 
__off64_t
 
	ml_n
;

46 
__pid_t
 
	ml_pid
;

49 #ifde
__USE_LARGEFILE64


50 
	sock64


52 
	ml_ty
;

53 
	ml_wh
;

54 
__off64_t
 
	ml_t
;

55 
__off64_t
 
	ml_n
;

56 
__pid_t
 
	ml_pid
;

61 
	~<bs/f-lux.h
>

	@/usr/include/bits/fcntl2.h

19 #idef 
_FCNTL_H


25 #ide
__USE_FILE_OFFSET64


26 
	$__ݒ_2
 (cڡ *
__th
, 
__oag

	`__nnu
 ((1));

27 
	`__REDIRECT
 (
__ݒ_s
, (cڡ *
__th
, 
__oag
, ...),

28 
ݒ

	`__nnu
 ((1));

30 
	`__REDIRECT
 (
__ݒ_2
, (cڡ *
__th
, 
__oag
),

31 
__ݒ64_2

	`__nnu
 ((1));

32 
	`__REDIRECT
 (
__ݒ_s
, (cڡ *
__th
, 
__oag
, ...),

33 
ݒ64

	`__nnu
 ((1));

35 
	`__rde
 (
__ݒ_too_my_gs
,

37 
	`__rde
 (
__ݒ_missg_mode
,

40 
__ftify_funi
 

41 
	$ݒ
 (cڡ *
__th
, 
__oag
, ...)

43 i(
	`__va_g_ck_n
 () > 1)

44 
	`__ݒ_too_my_gs
 ();

46 i(
	`__but_cڡt_p
 (
__oag
))

48 i((
__oag
 & 
O_CREAT
!0 && 
	`__va_g_ck_n
 () < 1)

50 
	`__ݒ_missg_mode
 ();

51  
	`__ݒ_2
 (
__th
, 
__oag
);

53  
	`__ݒ_s
 (
__th
, 
__oag
, 
	`__va_g_ck
 ());

56 i(
	`__va_g_ck_n
 () < 1)

57  
	`__ݒ_2
 (
__th
, 
__oag
);

59  
	`__ݒ_s
 (
__th
, 
__oag
, 
	`__va_g_ck
 ());

60 
	}
}

63 #ifde
__USE_LARGEFILE64


64 
	$__ݒ64_2
 (cڡ *
__th
, 
__oag

	`__nnu
 ((1));

65 
	`__REDIRECT
 (
__ݒ64_s
, (cڡ *
__th
, 
__oag
,

66 ...), 
ݒ64

	`__nnu
 ((1));

67 
	`__rde
 (
__ݒ64_too_my_gs
,

69 
	`__rde
 (
__ݒ64_missg_mode
,

72 
__ftify_funi
 

73 
	$ݒ64
 (cڡ *
__th
, 
__oag
, ...)

75 i(
	`__va_g_ck_n
 () > 1)

76 
	`__ݒ64_too_my_gs
 ();

78 i(
	`__but_cڡt_p
 (
__oag
))

80 i((
__oag
 & 
O_CREAT
!0 && 
	`__va_g_ck_n
 () < 1)

82 
	`__ݒ64_missg_mode
 ();

83  
	`__ݒ64_2
 (
__th
, 
__oag
);

85  
	`__ݒ64_s
 (
__th
, 
__oag
, 
	`__va_g_ck
 ());

88 i(
	`__va_g_ck_n
 () < 1)

89  
	`__ݒ64_2
 (
__th
, 
__oag
);

91  
	`__ݒ64_s
 (
__th
, 
__oag
, 
	`__va_g_ck
 ());

92 
	}
}

96 #ifde
__USE_ATFILE


97 #ide
__USE_FILE_OFFSET64


98 
	$__ݒ_2
 (
__fd
, cڡ *
__th
, 
__oag
)

99 
	`__nnu
 ((2));

100 
	`__REDIRECT
 (
__ݒ_s
, (
__fd
, cڡ *
__th
,

101 
__oag
, ...), 
ݒ
)

102 
	`__nnu
 ((2));

104 
	`__REDIRECT
 (
__ݒ_2
, (
__fd
, cڡ *
__th
,

105 
__oag
), 
__ݒ64_2
)

106 
	`__nnu
 ((2));

107 
	`__REDIRECT
 (
__ݒ_s
, (
__fd
, cڡ *
__th
,

108 
__oag
, ...), 
ݒ64
)

109 
	`__nnu
 ((2));

111 
	`__rde
 (
__ݒ_too_my_gs
,

113 
	`__rde
 (
__ݒ_missg_mode
,

116 
__ftify_funi
 

117 
	$ݒ
 (
__fd
, cڡ *
__th
, 
__oag
, ...)

119 i(
	`__va_g_ck_n
 () > 1)

120 
	`__ݒ_too_my_gs
 ();

122 i(
	`__but_cڡt_p
 (
__oag
))

124 i((
__oag
 & 
O_CREAT
!0 && 
	`__va_g_ck_n
 () < 1)

126 
	`__ݒ_missg_mode
 ();

127  
	`__ݒ_2
 (
__fd
, 
__th
, 
__oag
);

129  
	`__ݒ_s
 (
__fd
, 
__th
, 
__oag
, 
	`__va_g_ck
 ());

132 i(
	`__va_g_ck_n
 () < 1)

133  
	`__ݒ_2
 (
__fd
, 
__th
, 
__oag
);

135  
	`__ݒ_s
 (
__fd
, 
__th
, 
__oag
, 
	`__va_g_ck
 ());

136 
	}
}

139 #ifde
__USE_LARGEFILE64


140 
	$__ݒ64_2
 (
__fd
, cڡ *
__th
, 
__oag
)

141 
	`__nnu
 ((2));

142 
	`__REDIRECT
 (
__ݒ64_s
, (
__fd
, cڡ *
__th
,

143 
__oag
, ...), 
ݒ64
)

144 
	`__nnu
 ((2));

145 
	`__rde
 (
__ݒ64_too_my_gs
,

147 
	`__rde
 (
__ݒ64_missg_mode
,

150 
__ftify_funi
 

151 
	$ݒ64
 (
__fd
, cڡ *
__th
, 
__oag
, ...)

153 i(
	`__va_g_ck_n
 () > 1)

154 
	`__ݒ64_too_my_gs
 ();

156 i(
	`__but_cڡt_p
 (
__oag
))

158 i((
__oag
 & 
O_CREAT
!0 && 
	`__va_g_ck_n
 () < 1)

160 
	`__ݒ64_missg_mode
 ();

161  
	`__ݒ64_2
 (
__fd
, 
__th
, 
__oag
);

163  
	`__ݒ64_s
 (
__fd
, 
__th
, 
__oag
, 
	`__va_g_ck
 ());

166 i(
	`__va_g_ck_n
 () < 1)

167  
	`__ݒ64_2
 (
__fd
, 
__th
, 
__oag
);

169  
	`__ݒ64_s
 (
__fd
, 
__th
, 
__oag
, 
	`__va_g_ck
 ());

170 
	}
}

	@/usr/include/bits/in.h

20 #ide
_NETINET_IN_H


29 #ifde
_UAPI_LINUX_IN6_H


33 
	#__USE_KERNEL_IPV6_DEFS


	)

39 
	#IP_OPTIONS
 4

	)

40 
	#IP_HDRINCL
 3

	)

41 
	#IP_TOS
 1

	)

42 
	#IP_TTL
 2

	)

43 
	#IP_RECVOPTS
 6

	)

45 
	#IP_RECVRETOPTS
 
IP_RETOPTS


	)

46 
	#IP_RETOPTS
 7

	)

47 
	#IP_MULTICAST_IF
 32

	)

48 
	#IP_MULTICAST_TTL
 33

	)

49 
	#IP_MULTICAST_LOOP
 34

	)

50 
	#IP_ADD_MEMBERSHIP
 35

	)

51 
	#IP_DROP_MEMBERSHIP
 36

	)

52 
	#IP_UNBLOCK_SOURCE
 37

	)

53 
	#IP_BLOCK_SOURCE
 38

	)

54 
	#IP_ADD_SOURCE_MEMBERSHIP
 39

	)

55 
	#IP_DROP_SOURCE_MEMBERSHIP
 40

	)

56 
	#IP_MSFILTER
 41

	)

57 #i
defed
 
__USE_MISC
 || defed 
__USE_GNU


58 
	#MCAST_JOIN_GROUP
 42

	)

59 
	#MCAST_BLOCK_SOURCE
 43

	)

60 
	#MCAST_UNBLOCK_SOURCE
 44

	)

61 
	#MCAST_LEAVE_GROUP
 45

	)

62 
	#MCAST_JOIN_SOURCE_GROUP
 46

	)

63 
	#MCAST_LEAVE_SOURCE_GROUP
 47

	)

64 
	#MCAST_MSFILTER
 48

	)

65 
	#IP_MULTICAST_ALL
 49

	)

66 
	#IP_UNICAST_IF
 50

	)

68 
	#MCAST_EXCLUDE
 0

	)

69 
	#MCAST_INCLUDE
 1

	)

72 
	#IP_ROUTER_ALERT
 5

	)

73 
	#IP_PKTINFO
 8

	)

74 
	#IP_PKTOPTIONS
 9

	)

75 
	#IP_PMTUDISC
 10

	)

76 
	#IP_MTU_DISCOVER
 10

	)

77 
	#IP_RECVERR
 11

	)

78 
	#IP_RECVTTL
 12

	)

79 
	#IP_RECVTOS
 13

	)

80 
	#IP_MTU
 14

	)

81 
	#IP_FREEBIND
 15

	)

82 
	#IP_IPSEC_POLICY
 16

	)

83 
	#IP_XFRM_POLICY
 17

	)

84 
	#IP_PASSSEC
 18

	)

85 
	#IP_TRANSPARENT
 19

	)

86 
	#IP_MULTICAST_ALL
 49

	)

89 
	#IP_ORIGDSTADDR
 20

	)

90 
	#IP_RECVORIGDSTADDR
 
IP_ORIGDSTADDR


	)

92 
	#IP_MINTTL
 21

	)

96 
	#IP_PMTUDISC_DONT
 0

	)

97 
	#IP_PMTUDISC_WANT
 1

	)

98 
	#IP_PMTUDISC_DO
 2

	)

99 
	#IP_PMTUDISC_PROBE
 3

	)

102 
	#SOL_IP
 0

	)

104 
	#IP_DEFAULT_MULTICAST_TTL
 1

	)

105 
	#IP_DEFAULT_MULTICAST_LOOP
 1

	)

106 
	#IP_MAX_MEMBERSHIPS
 20

	)

108 #i
defed
 
__USE_MISC
 || defed 
__USE_GNU


112 
	s_ts


114 
_addr
 
	m_d
;

115 
	m_ts
[40];

119 
	s_mqn


121 
_addr
 
	mimr_muɟddr
;

122 
_addr
 
	mimr_addss
;

123 
	mimr_ifdex
;

127 
	s_pktfo


129 
	mi_ifdex
;

130 
_addr
 
	mi_ec_d
;

131 
_addr
 
	mi_addr
;

138 
	#IPV6_ADDRFORM
 1

	)

139 
	#IPV6_2292PKTINFO
 2

	)

140 
	#IPV6_2292HOPOPTS
 3

	)

141 
	#IPV6_2292DSTOPTS
 4

	)

142 
	#IPV6_2292RTHDR
 5

	)

143 
	#IPV6_2292PKTOPTIONS
 6

	)

144 
	#IPV6_CHECKSUM
 7

	)

145 
	#IPV6_2292HOPLIMIT
 8

	)

147 
	#SCM_SRCRT
 
IPV6_RXSRCRT


	)

149 
	#IPV6_NEXTHOP
 9

	)

150 
	#IPV6_AUTHHDR
 10

	)

151 
	#IPV6_UNICAST_HOPS
 16

	)

152 
	#IPV6_MULTICAST_IF
 17

	)

153 
	#IPV6_MULTICAST_HOPS
 18

	)

154 
	#IPV6_MULTICAST_LOOP
 19

	)

155 
	#IPV6_JOIN_GROUP
 20

	)

156 
	#IPV6_LEAVE_GROUP
 21

	)

157 
	#IPV6_ROUTER_ALERT
 22

	)

158 
	#IPV6_MTU_DISCOVER
 23

	)

159 
	#IPV6_MTU
 24

	)

160 
	#IPV6_RECVERR
 25

	)

161 
	#IPV6_V6ONLY
 26

	)

162 
	#IPV6_JOIN_ANYCAST
 27

	)

163 
	#IPV6_LEAVE_ANYCAST
 28

	)

164 
	#IPV6_IPSEC_POLICY
 34

	)

165 
	#IPV6_XFRM_POLICY
 35

	)

167 
	#IPV6_RECVPKTINFO
 49

	)

168 
	#IPV6_PKTINFO
 50

	)

169 
	#IPV6_RECVHOPLIMIT
 51

	)

170 
	#IPV6_HOPLIMIT
 52

	)

171 
	#IPV6_RECVHOPOPTS
 53

	)

172 
	#IPV6_HOPOPTS
 54

	)

173 
	#IPV6_RTHDRDSTOPTS
 55

	)

174 
	#IPV6_RECVRTHDR
 56

	)

175 
	#IPV6_RTHDR
 57

	)

176 
	#IPV6_RECVDSTOPTS
 58

	)

177 
	#IPV6_DSTOPTS
 59

	)

179 
	#IPV6_RECVTCLASS
 66

	)

180 
	#IPV6_TCLASS
 67

	)

183 
	#IPV6_ADD_MEMBERSHIP
 
IPV6_JOIN_GROUP


	)

184 
	#IPV6_DROP_MEMBERSHIP
 
IPV6_LEAVE_GROUP


	)

185 
	#IPV6_RXHOPOPTS
 
IPV6_HOPOPTS


	)

186 
	#IPV6_RXDSTOPTS
 
IPV6_DSTOPTS


	)

189 
	#IPV6_PMTUDISC_DONT
 0

	)

190 
	#IPV6_PMTUDISC_WANT
 1

	)

191 
	#IPV6_PMTUDISC_DO
 2

	)

192 
	#IPV6_PMTUDISC_PROBE
 3

	)

195 
	#SOL_IPV6
 41

	)

196 
	#SOL_ICMPV6
 58

	)

199 
	#IPV6_RTHDR_LOOSE
 0

	)

200 
	#IPV6_RTHDR_STRICT
 1

	)

202 
	#IPV6_RTHDR_TYPE_0
 0

	)

	@/usr/include/bits/pthreadtypes.h

18 #ide
_BITS_PTHREADTYPES_H


19 
	#_BITS_PTHREADTYPES_H
 1

	)

21 
	~<bs/wdsize.h
>

23 #ifde
__x86_64__


24 #i
__WORDSIZE
 == 64

25 
	#__SIZEOF_PTHREAD_ATTR_T
 56

	)

26 
	#__SIZEOF_PTHREAD_MUTEX_T
 40

	)

27 
	#__SIZEOF_PTHREAD_MUTEXATTR_T
 4

	)

28 
	#__SIZEOF_PTHREAD_COND_T
 48

	)

29 
	#__SIZEOF_PTHREAD_CONDATTR_T
 4

	)

30 
	#__SIZEOF_PTHREAD_RWLOCK_T
 56

	)

31 
	#__SIZEOF_PTHREAD_RWLOCKATTR_T
 8

	)

32 
	#__SIZEOF_PTHREAD_BARRIER_T
 32

	)

33 
	#__SIZEOF_PTHREAD_BARRIERATTR_T
 4

	)

35 
	#__SIZEOF_PTHREAD_ATTR_T
 32

	)

36 
	#__SIZEOF_PTHREAD_MUTEX_T
 32

	)

37 
	#__SIZEOF_PTHREAD_MUTEXATTR_T
 4

	)

38 
	#__SIZEOF_PTHREAD_COND_T
 48

	)

39 
	#__SIZEOF_PTHREAD_CONDATTR_T
 4

	)

40 
	#__SIZEOF_PTHREAD_RWLOCK_T
 44

	)

41 
	#__SIZEOF_PTHREAD_RWLOCKATTR_T
 8

	)

42 
	#__SIZEOF_PTHREAD_BARRIER_T
 20

	)

43 
	#__SIZEOF_PTHREAD_BARRIERATTR_T
 4

	)

46 
	#__SIZEOF_PTHREAD_ATTR_T
 36

	)

47 
	#__SIZEOF_PTHREAD_MUTEX_T
 24

	)

48 
	#__SIZEOF_PTHREAD_MUTEXATTR_T
 4

	)

49 
	#__SIZEOF_PTHREAD_COND_T
 48

	)

50 
	#__SIZEOF_PTHREAD_CONDATTR_T
 4

	)

51 
	#__SIZEOF_PTHREAD_RWLOCK_T
 32

	)

52 
	#__SIZEOF_PTHREAD_RWLOCKATTR_T
 8

	)

53 
	#__SIZEOF_PTHREAD_BARRIER_T
 20

	)

54 
	#__SIZEOF_PTHREAD_BARRIERATTR_T
 4

	)

60 
	thad_t
;

63 
	uhad__t


65 
	m__size
[
__SIZEOF_PTHREAD_ATTR_T
];

66 
	m__ign
;

68 #ide
__have_had__t


69 
had__t
 
	thad__t
;

70 
	#__have_had__t
 1

	)

74 #ifde
__x86_64__


75 
	s__had__li


77 
__had__li
 *
	m__ev
;

78 
__had__li
 *
	m__xt
;

79 } 
	t__had_li_t
;

81 
	s__had__i


83 
__had__i
 *
	m__xt
;

84 } 
	t__had_i_t
;

92 
	s__had_mux_s


94 
	m__lock
;

95 
	m__cou
;

96 
	m__owr
;

97 #ifde
__x86_64__


98 
	m__nurs
;

102 
	m__kd
;

103 #ifde
__x86_64__


104 
	m__s
;

105 
	m__isi
;

106 
__had_li_t
 
	m__li
;

107 
	#__PTHREAD_MUTEX_HAVE_PREV
 1

	)

108 
	#__PTHREAD_MUTEX_HAVE_ELISION
 1

	)

110 
	m__nurs
;

111 
__exnsi__
 union

115 
	m__es
;

116 
	m__isi
;

117 
	#__s
 
d
.
__es


	)

118 
	#__isi
 
d
.
__isi


	)

119 
	#__PTHREAD_MUTEX_HAVE_ELISION
 2

	)

120 } 
	md
;

121 
__had_i_t
 
	m__li
;

124 } 
	m__da
;

125 
	m__size
[
__SIZEOF_PTHREAD_MUTEX_T
];

126 
	m__ign
;

127 } 
	thad_mux_t
;

131 
	m__size
[
__SIZEOF_PTHREAD_MUTEXATTR_T
];

132 
	m__ign
;

133 } 
	thad_mux_t
;

142 
	m__lock
;

143 
	m__fux
;

144 
__exnsi__
 
	m__tٮ_q
;

145 
__exnsi__
 
	m__wakeup_q
;

146 
__exnsi__
 
	m__wok_q
;

147 *
	m__mux
;

148 
	m__nwas
;

149 
	m__brd_q
;

150 } 
	m__da
;

151 
	m__size
[
__SIZEOF_PTHREAD_COND_T
];

152 
__exnsi__
 
	m__ign
;

153 } 
	thad_cd_t
;

157 
	m__size
[
__SIZEOF_PTHREAD_CONDATTR_T
];

158 
	m__ign
;

159 } 
	thad_cd_t
;

163 
	thad_key_t
;

167 
	thad__t
;

170 #i
defed
 
__USE_UNIX98
 || defed 
__USE_XOPEN2K


175 #ifde
__x86_64__


178 
	m__lock
;

179 
	m___ads
;

180 
	m__ads_wakeup
;

181 
	m__wr_wakeup
;

182 
	m___ads_queued
;

183 
	m___wrs_queued
;

184 
	m__wr
;

185 
	m__shed
;

186 
	m__d1
;

187 
	m__d2
;

190 
	m__ags
;

191 
	#__PTHREAD_RWLOCK_INT_FLAGS_SHARED
 1

	)

192 } 
	m__da
;

196 
	m__lock
;

197 
	m___ads
;

198 
	m__ads_wakeup
;

199 
	m__wr_wakeup
;

200 
	m___ads_queued
;

201 
	m___wrs_queued
;

204 
	m__ags
;

205 
	m__shed
;

206 
	m__d1
;

207 
	m__d2
;

208 
	m__wr
;

209 } 
	m__da
;

211 
	m__size
[
__SIZEOF_PTHREAD_RWLOCK_T
];

212 
	m__ign
;

213 } 
	thad_rwlock_t
;

217 
	m__size
[
__SIZEOF_PTHREAD_RWLOCKATTR_T
];

218 
	m__ign
;

219 } 
	thad_rwlock_t
;

223 #ifde
__USE_XOPEN2K


225 vީ
	thad_lock_t
;

232 
	m__size
[
__SIZEOF_PTHREAD_BARRIER_T
];

233 
	m__ign
;

234 } 
	thad_brr_t
;

238 
	m__size
[
__SIZEOF_PTHREAD_BARRIERATTR_T
];

239 
	m__ign
;

240 } 
	thad_brr_t
;

244 #ide
__x86_64__


246 
	#__nup_f_ibu
 
	`__ibu__
 ((
	`__grm__
 (1)))

	)

	@/usr/include/bits/sigset.h

19 #idef 
_SIGSET_H_tys


20 
	#_SIGSET_H_tys
 1

	)

22 
	t__sig_omic_t
;

26 
	#_SIGSET_NWORDS
 (1024 / (8 *  ()))

	)

29 
	m__v
[
_SIGSET_NWORDS
];

30 } 
	t__sigt_t
;

41 #i!
defed
 
_SIGSET_H_s
 && defed 
_SIGNAL_H


42 
	#_SIGSET_H_s
 1

	)

44 #ide
_EXTERN_INLINE


45 
	#_EXTERN_INLINE
 
__ex_le


	)

49 
	#__sigmask
(
sig
) \

50 (((1<< (((
sig
- 1% (8 *  ())))

	)

53 
	#__sigwd
(
sig
(((sig- 1/ (8 *  ()))

	)

55 #i
defed
 
__GNUC__
 && __GNUC__ >= 2

56 
	#__sigemyt
(
t
) \

57 (
	`__exnsi__
 ({ 
__t
 = 
_SIGSET_NWORDS
; \

58 
sigt_t
 *
__t
 = (
t
); \

59 --
__t
 >0
__t
->
__v
[__cnt] = 0; \

60 0; }))

	)

61 
	#__sigflt
(
t
) \

62 (
	`__exnsi__
 ({ 
__t
 = 
_SIGSET_NWORDS
; \

63 
sigt_t
 *
__t
 = (
t
); \

64 --
__t
 >0
__t
->
__v
[__cnt] = ~0UL; \

65 0; }))

	)

67 #ifde
__USE_GNU


71 
	#__sigimyt
(
t
) \

72 (
	`__exnsi__
 ({ 
__t
 = 
_SIGSET_NWORDS
; \

73 cڡ 
sigt_t
 *
__t
 = (
t
); \

74 
__t
 = 
__t
->
__v
[--
__t
]; \

75 !
__t
 && --
__t
 >= 0) \

76 
__t
 = 
__t
->
__v
[
__t
]; \

77 
__t
 =0; }))

	)

78 
	#__sigdt
(
de
, 

, 
right
) \

79 (
	`__exnsi__
 ({ 
__t
 = 
_SIGSET_NWORDS
; \

80 
sigt_t
 *
__de
 = (
de
); \

81 cڡ 
sigt_t
 *
__
 = (

); \

82 cڡ 
sigt_t
 *
__right
 = (
right
); \

83 --
__t
 >= 0) \

84 
__de
->
__v
[
__t
] = (
__
->__val[__cnt] \

85 & 
__right
->
__v
[
__t
]); \

86 0; }))

	)

87 
	#__sigܣt
(
de
, 

, 
right
) \

88 (
	`__exnsi__
 ({ 
__t
 = 
_SIGSET_NWORDS
; \

89 
sigt_t
 *
__de
 = (
de
); \

90 cڡ 
sigt_t
 *
__
 = (

); \

91 cڡ 
sigt_t
 *
__right
 = (
right
); \

92 --
__t
 >= 0) \

93 
__de
->
__v
[
__t
] = (
__
->__val[__cnt] \

94 | 
__right
->
__v
[
__t
]); \

95 0; }))

	)

102 
__sigismemb
 (cڡ 
__sigt_t
 *, );

103 
__sigaddt
 (
__sigt_t
 *, );

104 
__sigdt
 (
__sigt_t
 *, );

106 #ifde
__USE_EXTERN_INLINES


107 
	#__SIGSETFN
(
NAME
, 
BODY
, 
CONST
) \

108 
_EXTERN_INLINE
 \

109 
	`NAME
 (
CONST
 
__sigt_t
 *
__t
, 
__sig
) \

111 
__mask
 = 
	`__sigmask
 (
__sig
); \

112 
__wd
 = 
	`__sigwd
 (
__sig
); \

113  
BODY
; \

114 }

	)

116 
__SIGSETFN
 (
__sigismemb
, (
__t
->
__v
[
__wd
] & 
__mask
) ? 1 : 0, const)

117 
__SIGSETFN
 (
__sigaddt
, ((
__t
->
__v
[
__wd
] |
__mask
), 0), )

118 
__SIGSETFN
 (
__sigdt
, ((
__t
->
__v
[
__wd
] &~
__mask
), 0), )

120 #unde
__SIGSETFN


	@/usr/include/bits/socket.h

19 #ide
__BITS_SOCKET_H


20 
	#__BITS_SOCKET_H


	)

22 #ide
_SYS_SOCKET_H


26 
	#__ed_size_t


	)

27 
	~<ddef.h
>

29 
	~<sys/tys.h
>

32 #ide
__sockn_t_defed


33 
__sockn_t
 
	tsockn_t
;

34 
	#__sockn_t_defed


	)

38 
	~<bs/sock_ty.h
>

41 
	#PF_UNSPEC
 0

	)

42 
	#PF_LOCAL
 1

	)

43 
	#PF_UNIX
 
PF_LOCAL


	)

44 
	#PF_FILE
 
PF_LOCAL


	)

45 
	#PF_INET
 2

	)

46 
	#PF_AX25
 3

	)

47 
	#PF_IPX
 4

	)

48 
	#PF_APPLETALK
 5

	)

49 
	#PF_NETROM
 6

	)

50 
	#PF_BRIDGE
 7

	)

51 
	#PF_ATMPVC
 8

	)

52 
	#PF_X25
 9

	)

53 
	#PF_INET6
 10

	)

54 
	#PF_ROSE
 11

	)

55 
	#PF_DECt
 12

	)

56 
	#PF_NETBEUI
 13

	)

57 
	#PF_SECURITY
 14

	)

58 
	#PF_KEY
 15

	)

59 
	#PF_NETLINK
 16

	)

60 
	#PF_ROUTE
 
PF_NETLINK


	)

61 
	#PF_PACKET
 17

	)

62 
	#PF_ASH
 18

	)

63 
	#PF_ECONET
 19

	)

64 
	#PF_ATMSVC
 20

	)

65 
	#PF_RDS
 21

	)

66 
	#PF_SNA
 22

	)

67 
	#PF_IRDA
 23

	)

68 
	#PF_PPPOX
 24

	)

69 
	#PF_WANPIPE
 25

	)

70 
	#PF_LLC
 26

	)

71 
	#PF_CAN
 29

	)

72 
	#PF_TIPC
 30

	)

73 
	#PF_BLUETOOTH
 31

	)

74 
	#PF_IUCV
 32

	)

75 
	#PF_RXRPC
 33

	)

76 
	#PF_ISDN
 34

	)

77 
	#PF_PHONET
 35

	)

78 
	#PF_IEEE802154
 36

	)

79 
	#PF_CAIF
 37

	)

80 
	#PF_ALG
 38

	)

81 
	#PF_NFC
 39

	)

82 
	#PF_VSOCK
 40

	)

83 
	#PF_MAX
 41

	)

86 
	#AF_UNSPEC
 
PF_UNSPEC


	)

87 
	#AF_LOCAL
 
PF_LOCAL


	)

88 
	#AF_UNIX
 
PF_UNIX


	)

89 
	#AF_FILE
 
PF_FILE


	)

90 
	#AF_INET
 
PF_INET


	)

91 
	#AF_AX25
 
PF_AX25


	)

92 
	#AF_IPX
 
PF_IPX


	)

93 
	#AF_APPLETALK
 
PF_APPLETALK


	)

94 
	#AF_NETROM
 
PF_NETROM


	)

95 
	#AF_BRIDGE
 
PF_BRIDGE


	)

96 
	#AF_ATMPVC
 
PF_ATMPVC


	)

97 
	#AF_X25
 
PF_X25


	)

98 
	#AF_INET6
 
PF_INET6


	)

99 
	#AF_ROSE
 
PF_ROSE


	)

100 
	#AF_DECt
 
PF_DECt


	)

101 
	#AF_NETBEUI
 
PF_NETBEUI


	)

102 
	#AF_SECURITY
 
PF_SECURITY


	)

103 
	#AF_KEY
 
PF_KEY


	)

104 
	#AF_NETLINK
 
PF_NETLINK


	)

105 
	#AF_ROUTE
 
PF_ROUTE


	)

106 
	#AF_PACKET
 
PF_PACKET


	)

107 
	#AF_ASH
 
PF_ASH


	)

108 
	#AF_ECONET
 
PF_ECONET


	)

109 
	#AF_ATMSVC
 
PF_ATMSVC


	)

110 
	#AF_RDS
 
PF_RDS


	)

111 
	#AF_SNA
 
PF_SNA


	)

112 
	#AF_IRDA
 
PF_IRDA


	)

113 
	#AF_PPPOX
 
PF_PPPOX


	)

114 
	#AF_WANPIPE
 
PF_WANPIPE


	)

115 
	#AF_LLC
 
PF_LLC


	)

116 
	#AF_CAN
 
PF_CAN


	)

117 
	#AF_TIPC
 
PF_TIPC


	)

118 
	#AF_BLUETOOTH
 
PF_BLUETOOTH


	)

119 
	#AF_IUCV
 
PF_IUCV


	)

120 
	#AF_RXRPC
 
PF_RXRPC


	)

121 
	#AF_ISDN
 
PF_ISDN


	)

122 
	#AF_PHONET
 
PF_PHONET


	)

123 
	#AF_IEEE802154
 
PF_IEEE802154


	)

124 
	#AF_CAIF
 
PF_CAIF


	)

125 
	#AF_ALG
 
PF_ALG


	)

126 
	#AF_NFC
 
PF_NFC


	)

127 
	#AF_VSOCK
 
PF_VSOCK


	)

128 
	#AF_MAX
 
PF_MAX


	)

134 
	#SOL_RAW
 255

	)

135 
	#SOL_DECNET
 261

	)

136 
	#SOL_X25
 262

	)

137 
	#SOL_PACKET
 263

	)

138 
	#SOL_ATM
 264

	)

139 
	#SOL_AAL
 265

	)

140 
	#SOL_IRDA
 266

	)

143 
	#SOMAXCONN
 128

	)

146 
	~<bs/sockaddr.h
>

149 
	ssockaddr


151 
__SOCKADDR_COMMON
 (
_
);

152 
	m_da
[14];

158 
	#__ss_igy
 

	)

159 
	#_SS_SIZE
 128

	)

160 
	#_SS_PADSIZE
 (
_SS_SIZE
 - (2 *  (
__ss_igy
)))

	)

162 
	ssockaddr_age


164 
__SOCKADDR_COMMON
 (
ss_
);

165 
__ss_igy
 
	m__ss_ign
;

166 
	m__ss_ddg
[
_SS_PADSIZE
];

173 
	mMSG_OOB
 = 0x01,

174 
	#MSG_OOB
 
MSG_OOB


	)

175 
	mMSG_PEEK
 = 0x02,

176 
	#MSG_PEEK
 
MSG_PEEK


	)

177 
	mMSG_DONTROUTE
 = 0x04,

178 
	#MSG_DONTROUTE
 
MSG_DONTROUTE


	)

179 #ifde
__USE_GNU


181 
	mMSG_TRYHARD
 = 
MSG_DONTROUTE
,

182 
	#MSG_TRYHARD
 
MSG_DONTROUTE


	)

184 
	mMSG_CTRUNC
 = 0x08,

185 
	#MSG_CTRUNC
 
MSG_CTRUNC


	)

186 
	mMSG_PROXY
 = 0x10,

187 
	#MSG_PROXY
 
MSG_PROXY


	)

188 
	mMSG_TRUNC
 = 0x20,

189 
	#MSG_TRUNC
 
MSG_TRUNC


	)

190 
	mMSG_DONTWAIT
 = 0x40,

191 
	#MSG_DONTWAIT
 
MSG_DONTWAIT


	)

192 
	mMSG_EOR
 = 0x80,

193 
	#MSG_EOR
 
MSG_EOR


	)

194 
	mMSG_WAITALL
 = 0x100,

195 
	#MSG_WAITALL
 
MSG_WAITALL


	)

196 
	mMSG_FIN
 = 0x200,

197 
	#MSG_FIN
 
MSG_FIN


	)

198 
	mMSG_SYN
 = 0x400,

199 
	#MSG_SYN
 
MSG_SYN


	)

200 
	mMSG_CONFIRM
 = 0x800,

201 
	#MSG_CONFIRM
 
MSG_CONFIRM


	)

202 
	mMSG_RST
 = 0x1000,

203 
	#MSG_RST
 
MSG_RST


	)

204 
	mMSG_ERRQUEUE
 = 0x2000,

205 
	#MSG_ERRQUEUE
 
MSG_ERRQUEUE


	)

206 
	mMSG_NOSIGNAL
 = 0x4000,

207 
	#MSG_NOSIGNAL
 
MSG_NOSIGNAL


	)

208 
	mMSG_MORE
 = 0x8000,

209 
	#MSG_MORE
 
MSG_MORE


	)

210 
	mMSG_WAITFORONE
 = 0x10000,

211 
	#MSG_WAITFORONE
 
MSG_WAITFORONE


	)

212 
	mMSG_FASTOPEN
 = 0x20000000,

213 
	#MSG_FASTOPEN
 
MSG_FASTOPEN


	)

215 
	mMSG_CMSG_CLOEXEC
 = 0x40000000

218 
	#MSG_CMSG_CLOEXEC
 
MSG_CMSG_CLOEXEC


	)

224 
	smsghdr


226 *
	mmsg_me
;

227 
sockn_t
 
	mmsg_m
;

229 
iovec
 *
	mmsg_iov
;

230 
size_t
 
	mmsg_iovn
;

232 *
	mmsg_cڌ
;

233 
size_t
 
	mmsg_cڌn
;

238 
	mmsg_ags
;

242 
	scmsghdr


244 
size_t
 
	mcmsg_n
;

249 
	mcmsg_v
;

250 
	mcmsg_ty
;

251 #i(!
defed
 
__STRICT_ANSI__
 && 
__GNUC__
 >2|| 
__STDC_VERSION__
 >= 199901L

252 
__exnsi__
 
__cmsg_da
 
	m__exr
;

257 #i(!
defed
 
__STRICT_ANSI__
 && 
__GNUC__
 >2|| 
__STDC_VERSION__
 >= 199901L

258 
	#CMSG_DATA
(
cmsg
((cmsg)->
__cmsg_da
)

	)

260 
	#CMSG_DATA
(
cmsg
((*((
cmsghdr
 *(cmsg+ 1))

	)

262 
	#CMSG_NXTHDR
(
mhdr
, 
cmsg

	`__cmsg_nxthdr
 (mhdr, cmsg)

	)

263 
	#CMSG_FIRSTHDR
(
mhdr
) \

264 ((
size_t
(
mhdr
)->
msg_cڌn
 > (
cmsghdr
) \

265 ? (
cmsghdr
 *(
mhdr
)->
msg_cڌ
 : (cmsghd*0)

	)

266 
	#CMSG_ALIGN
(
n
((֒+  (
size_t
) - 1) \

267 & (
size_t
~( (size_t- 1))

	)

268 
	#CMSG_SPACE
(
n
(
	`CMSG_ALIGN
 (len) \

269 + 
	`CMSG_ALIGN
 ( (
cmsghdr
)))

	)

270 
	#CMSG_LEN
(
n
(
	`CMSG_ALIGN
 ( (
cmsghdr
)+ (n))

	)

272 
cmsghdr
 *
	$__cmsg_nxthdr
 (
msghdr
 *
__mhdr
,

273 
cmsghdr
 *
__cmsg

__THROW
;

274 #ifde
__USE_EXTERN_INLINES


275 #ide
_EXTERN_INLINE


276 
	#_EXTERN_INLINE
 
__ex_le


	)

278 
_EXTERN_INLINE
 
cmsghdr
 *

279 
	`__NTH
 (
	$__cmsg_nxthdr
 (
msghdr
 *
__mhdr
, 
cmsghdr
 *
__cmsg
))

281 i((
size_t

__cmsg
->
cmsg_n
 <  (
cmsghdr
))

283  (
cmsghdr
 *) 0;

285 
__cmsg
 = (
cmsghdr
 *) ((*) __cmsg

286 + 
	`CMSG_ALIGN
 (
__cmsg
->
cmsg_n
));

287 i((*(
__cmsg
 + 1> ((*
__mhdr
->
msg_cڌ


288 + 
__mhdr
->
msg_cڌn
)

289 || ((*
__cmsg
 + 
	`CMSG_ALIGN
 (__cmsg->
cmsg_n
)

290 > ((*
__mhdr
->
msg_cڌ
 + __mhdr->
msg_cڌn
)))

292  (
cmsghdr
 *) 0;

293  
__cmsg
;

294 
	}
}

301 
	mSCM_RIGHTS
 = 0x01

302 
	#SCM_RIGHTS
 
SCM_RIGHTS


	)

303 #ifde
__USE_GNU


304 , 
	mSCM_CREDENTIALS
 = 0x02

305 
	#SCM_CREDENTIALS
 
SCM_CREDENTIALS


	)

309 #ifde
__USE_GNU


311 
	sued


313 
pid_t
 
	mpid
;

314 
uid_t
 
	muid
;

315 
gid_t
 
	mgid
;

320 #i!
defed
 
__USE_MISC
 && !defed 
__USE_GNU


321 #ide
FIOGETOWN


322 
	#__SYS_SOCKET_H_undef_FIOGETOWN


	)

324 #ide
FIOSETOWN


325 
	#__SYS_SOCKET_H_undef_FIOSETOWN


	)

327 #ide
SIOCATMARK


328 
	#__SYS_SOCKET_H_undef_SIOCATMARK


	)

330 #ide
SIOCGPGRP


331 
	#__SYS_SOCKET_H_undef_SIOCGPGRP


	)

333 #ide
SIOCGSTAMP


334 
	#__SYS_SOCKET_H_undef_SIOCGSTAMP


	)

336 #ide
SIOCGSTAMPNS


337 
	#__SYS_SOCKET_H_undef_SIOCGSTAMPNS


	)

339 #ide
SIOCSPGRP


340 
	#__SYS_SOCKET_H_undef_SIOCSPGRP


	)

345 
	~<asm/sock.h
>

347 #i!
defed
 
__USE_MISC
 && !defed 
__USE_GNU


348 #ifde
__SYS_SOCKET_H_undef_FIOGETOWN


349 #unde
__SYS_SOCKET_H_undef_FIOGETOWN


350 #unde
FIOGETOWN


352 #ifde
__SYS_SOCKET_H_undef_FIOSETOWN


353 #unde
__SYS_SOCKET_H_undef_FIOSETOWN


354 #unde
FIOSETOWN


356 #ifde
__SYS_SOCKET_H_undef_SIOCATMARK


357 #unde
__SYS_SOCKET_H_undef_SIOCATMARK


358 #unde
SIOCATMARK


360 #ifde
__SYS_SOCKET_H_undef_SIOCGPGRP


361 #unde
__SYS_SOCKET_H_undef_SIOCGPGRP


362 #unde
SIOCGPGRP


364 #ifde
__SYS_SOCKET_H_undef_SIOCGSTAMP


365 #unde
__SYS_SOCKET_H_undef_SIOCGSTAMP


366 #unde
SIOCGSTAMP


368 #ifde
__SYS_SOCKET_H_undef_SIOCGSTAMPNS


369 #unde
__SYS_SOCKET_H_undef_SIOCGSTAMPNS


370 #unde
SIOCGSTAMPNS


372 #ifde
__SYS_SOCKET_H_undef_SIOCSPGRP


373 #unde
__SYS_SOCKET_H_undef_SIOCSPGRP


374 #unde
SIOCSPGRP


379 
	slg


381 
	ml_off
;

382 
	ml_lg
;

	@/usr/include/bits/socket2.h

19 #ide
_SYS_SOCKET_H


23 
ssize_t
 
__cv_chk
 (
__fd
, *
__buf
, 
size_t
 
__n
, size_
__bu
,

24 
__ags
);

25 
ssize_t
 
__REDIRECT
 (
__cv_s
, (
__fd
, *
__buf
, 
size_t
 
__n
,

26 
__ags
), 
cv
);

27 
ssize_t
 
__REDIRECT
 (
__cv_chk_wn
,

28 (
__fd
, *
__buf
, 
size_t
 
__n
, size_
__bu
,

29 
__ags
), 
__cv_chk
)

30 
__wǉr
 ("recv called with biggerengthhan size of destination "

33 
__ftify_funi
 
ssize_t


34 
	$cv
 (
__fd
, *
__buf
, 
size_t
 
__n
, 
__ags
)

36 i(
	`__bos0
 (
__buf
!(
size_t
) -1)

38 i(!
	`__but_cڡt_p
 (
__n
))

39  
	`__cv_chk
 (
__fd
, 
__buf
, 
__n
, 
	`__bos0
 (__buf), 
__ags
);

41 i(
__n
 > 
	`__bos0
 (
__buf
))

42  
	`__cv_chk_wn
 (
__fd
, 
__buf
, 
__n
, 
	`__bos0
 (__buf), 
__ags
);

44  
	`__cv_s
 (
__fd
, 
__buf
, 
__n
, 
__ags
);

45 
	}
}

47 
ssize_t
 
__cvom_chk
 (
__fd
, *
__ri
 
__buf
, 
size_t
 
__n
,

48 
size_t
 
__bu
, 
__ags
,

49 
__SOCKADDR_ARG
 
__addr
,

50 
sockn_t
 *
__ri
 
__addr_n
);

51 
ssize_t
 
__REDIRECT
 (
__cvom_s
,

52 (
__fd
, *
__ri
 
__buf
, 
size_t
 
__n
,

53 
__ags
, 
__SOCKADDR_ARG
 
__addr
,

54 
sockn_t
 *
__ri
 
__addr_n
), 
cvom
);

55 
ssize_t
 
__REDIRECT
 (
__cvom_chk_wn
,

56 (
__fd
, *
__ri
 
__buf
, 
size_t
 
__n
,

57 
size_t
 
__bu
, 
__ags
,

58 
__SOCKADDR_ARG
 
__addr
,

59 
sockn_t
 *
__ri
 
__addr_n
), 
__cvom_chk
)

60 
__wǉr
 ("recvfrom called with biggerengthhan size of "

63 
__ftify_funi
 
ssize_t


64 
	$cvom
 (
__fd
, *
__ri
 
__buf
, 
size_t
 
__n
, 
__ags
,

65 
__SOCKADDR_ARG
 
__addr
, 
sockn_t
 *
__ri
 
__addr_n
)

67 i(
	`__bos0
 (
__buf
!(
size_t
) -1)

69 i(!
	`__but_cڡt_p
 (
__n
))

70  
	`__cvom_chk
 (
__fd
, 
__buf
, 
__n
, 
	`__bos0
 (__buf), 
__ags
,

71 
__addr
, 
__addr_n
);

72 i(
__n
 > 
	`__bos0
 (
__buf
))

73  
	`__cvom_chk_wn
 (
__fd
, 
__buf
, 
__n
, 
	`__bos0
 (__buf), 
__ags
,

74 
__addr
, 
__addr_n
);

76  
	`__cvom_s
 (
__fd
, 
__buf
, 
__n
, 
__ags
, 
__addr
, 
__addr_n
);

77 
	}
}

	@/usr/include/bits/stat.h

18 #i!
defed
 
_SYS_STAT_H
 && !defed 
_FCNTL_H


22 #ide
_BITS_STAT_H


23 
	#_BITS_STAT_H
 1

	)

26 #ide
__x86_64__


27 
	#_STAT_VER_LINUX_OLD
 1

	)

28 
	#_STAT_VER_KERNEL
 1

	)

29 
	#_STAT_VER_SVR4
 2

	)

30 
	#_STAT_VER_LINUX
 3

	)

33 
	#_MKNOD_VER_LINUX
 1

	)

34 
	#_MKNOD_VER_SVR4
 2

	)

35 
	#_MKNOD_VER
 
_MKNOD_VER_LINUX


	)

37 
	#_STAT_VER_KERNEL
 0

	)

38 
	#_STAT_VER_LINUX
 1

	)

41 
	#_MKNOD_VER_LINUX
 0

	)

44 
	#_STAT_VER
 
_STAT_VER_LINUX


	)

46 
	s


48 
__dev_t
 
	m_dev
;

49 #ide
__x86_64__


50 
	m__d1
;

52 #i
defed
 
__x86_64__
 || !defed 
__USE_FILE_OFFSET64


53 
__o_t
 
	m_o
;

55 
__o_t
 
	m___o
;

57 #ide
__x86_64__


58 
__mode_t
 
	m_mode
;

59 
__ƚk_t
 
	m_ƚk
;

61 
__ƚk_t
 
	m_ƚk
;

62 
__mode_t
 
	m_mode
;

64 
__uid_t
 
	m_uid
;

65 
__gid_t
 
	m_gid
;

66 #ifde
__x86_64__


67 
	m__d0
;

69 
__dev_t
 
	m_rdev
;

70 #ide
__x86_64__


71 
	m__d2
;

73 #i
defed
 
__x86_64__
 || !defed 
__USE_FILE_OFFSET64


74 
__off_t
 
	m_size
;

76 
__off64_t
 
	m_size
;

78 
__blksize_t
 
	m_blksize
;

79 #i
defed
 
__x86_64__
 || !defed 
__USE_FILE_OFFSET64


80 
__blkt_t
 
	m_blocks
;

82 
__blkt64_t
 
	m_blocks
;

84 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN2K8


91 
timeec
 
	m_im
;

92 
timeec
 
	m_mtim
;

93 
timeec
 
	m_im
;

94 
	#_ime
 
_im
.
tv_c


	)

95 
	#_mtime
 
_mtim
.
tv_c


	)

96 
	#_ime
 
_im
.
tv_c


	)

98 
__time_t
 
	m_ime
;

99 
__sys_ulg_t
 
	m_imc
;

100 
__time_t
 
	m_mtime
;

101 
__sys_ulg_t
 
	m_mtimc
;

102 
__time_t
 
	m_ime
;

103 
__sys_ulg_t
 
	m_imc
;

105 #ifde
__x86_64__


106 
__sys_g_t
 
	m__glibc_rved
[3];

108 #ide
__USE_FILE_OFFSET64


109 
	m__glibc_rved4
;

110 
	m__glibc_rved5
;

112 
__o64_t
 
	m_o
;

117 #ifde
__USE_LARGEFILE64


119 
	s64


121 
__dev_t
 
	m_dev
;

122 #ifde
__x86_64__


123 
__o64_t
 
	m_o
;

124 
__ƚk_t
 
	m_ƚk
;

125 
__mode_t
 
	m_mode
;

127 
	m__d1
;

128 
__o_t
 
	m___o
;

129 
__mode_t
 
	m_mode
;

130 
__ƚk_t
 
	m_ƚk
;

132 
__uid_t
 
	m_uid
;

133 
__gid_t
 
	m_gid
;

134 #ifde
__x86_64__


135 
	m__d0
;

136 
__dev_t
 
	m_rdev
;

137 
__off_t
 
	m_size
;

139 
__dev_t
 
	m_rdev
;

140 
	m__d2
;

141 
__off64_t
 
	m_size
;

143 
__blksize_t
 
	m_blksize
;

144 
__blkt64_t
 
	m_blocks
;

145 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN2K8


152 
timeec
 
	m_im
;

153 
timeec
 
	m_mtim
;

154 
timeec
 
	m_im
;

156 
__time_t
 
	m_ime
;

157 
__sys_ulg_t
 
	m_imc
;

158 
__time_t
 
	m_mtime
;

159 
__sys_ulg_t
 
	m_mtimc
;

160 
__time_t
 
	m_ime
;

161 
__sys_ulg_t
 
	m_imc
;

163 #ifde
__x86_64__


164 
__sys_g_t
 
	m__glibc_rved
[3];

166 
__o64_t
 
	m_o
;

172 
	#_STATBUF_ST_BLKSIZE


	)

173 
	#_STATBUF_ST_RDEV


	)

175 
	#_STATBUF_ST_NSEC


	)

179 
	#__S_IFMT
 0170000

	)

182 
	#__S_IFDIR
 0040000

	)

183 
	#__S_IFCHR
 0020000

	)

184 
	#__S_IFBLK
 0060000

	)

185 
	#__S_IFREG
 0100000

	)

186 
	#__S_IFIFO
 0010000

	)

187 
	#__S_IFLNK
 0120000

	)

188 
	#__S_IFSOCK
 0140000

	)

192 
	#__S_TYPEISMQ
(
buf
((buf)->
_mode
 - (buf)->_mode)

	)

193 
	#__S_TYPEISSEM
(
buf
((buf)->
_mode
 - (buf)->_mode)

	)

194 
	#__S_TYPEISSHM
(
buf
((buf)->
_mode
 - (buf)->_mode)

	)

198 
	#__S_ISUID
 04000

	)

199 
	#__S_ISGID
 02000

	)

200 
	#__S_ISVTX
 01000

	)

201 
	#__S_IREAD
 0400

	)

202 
	#__S_IWRITE
 0200

	)

203 
	#__S_IEXEC
 0100

	)

205 #ifde
__USE_ATFILE


206 
	#UTIME_NOW
 ((1<< 30- 1l)

	)

207 
	#UTIME_OMIT
 ((1<< 30- 2l)

	)

	@/usr/include/bits/stdio-ldbl.h

19 #ide
_STDIO_H


23 
__BEGIN_NAMESPACE_STD


24 
	$__LDBL_REDIR_DECL
 (
rtf
)

25 
	$__LDBL_REDIR_DECL
 (
tf
)

26 
	$__LDBL_REDIR_DECL
 (
rtf
)

27 
	$__LDBL_REDIR_DECL
 (
vrtf
)

28 
	$__LDBL_REDIR_DECL
 (
vtf
)

29 
	$__LDBL_REDIR_DECL
 (
vrtf
)

30 #i
defed
 
__USE_ISOC99
 && !defed 
__USE_GNU
 \

31 && !
defed
 
__REDIRECT
 \

32 && (
defed
 
__STRICT_ANSI__
 || defed 
__USE_XOPEN2K
)

33 
	$__LDBL_REDIR1_DECL
 (
fsnf
, 
__dbl___isoc99_fsnf
)

34 
	$__LDBL_REDIR1_DECL
 (
snf
, 
__dbl___isoc99_snf
)

35 
	$__LDBL_REDIR1_DECL
 (
ssnf
, 
__dbl___isoc99_ssnf
)

37 
	$__LDBL_REDIR_DECL
 (
fsnf
)

38 
	$__LDBL_REDIR_DECL
 (
snf
)

39 
	$__LDBL_REDIR_DECL
 (
ssnf
)

41 
__END_NAMESPACE_STD


43 #i
defed
 
__USE_BSD
 || defed 
__USE_ISOC99
 || defed 
__USE_UNIX98


44 
__BEGIN_NAMESPACE_C99


45 
	$__LDBL_REDIR_DECL
 (
tf
)

46 
	$__LDBL_REDIR_DECL
 (
vtf
)

47 
__END_NAMESPACE_C99


50 #ifdef 
__USE_ISOC99


51 
__BEGIN_NAMESPACE_C99


52 #i!
defed
 
__USE_GNU
 && !defed 
__REDIRECT
 \

53 && (
defed
 
__STRICT_ANSI__
 || defed 
__USE_XOPEN2K
)

54 
	$__LDBL_REDIR1_DECL
 (
vfsnf
, 
__dbl___isoc99_vfsnf
)

55 
	$__LDBL_REDIR1_DECL
 (
vsnf
, 
__dbl___isoc99_vsnf
)

56 
	$__LDBL_REDIR1_DECL
 (
vssnf
, 
__dbl___isoc99_vssnf
)

58 
	$__LDBL_REDIR_DECL
 (
vfsnf
)

59 
	$__LDBL_REDIR_DECL
 (
vssnf
)

60 
	$__LDBL_REDIR_DECL
 (
vsnf
)

62 
__END_NAMESPACE_C99


65 #ifde
__USE_XOPEN2K8


66 
	$__LDBL_REDIR_DECL
 (
vdtf
)

67 
	$__LDBL_REDIR_DECL
 (
dtf
)

70 #ifde
__USE_GNU


71 
	$__LDBL_REDIR_DECL
 (
vartf
)

72 
	$__LDBL_REDIR_DECL
 (
__artf
)

73 
	$__LDBL_REDIR_DECL
 (
artf
)

74 
	$__LDBL_REDIR_DECL
 (
oback_tf
)

75 
	$__LDBL_REDIR_DECL
 (
oback_vtf
)

78 #i
__USE_FORTIFY_LEVEL
 > 0 && 
defed
 
__ftify_funi


79 
	$__LDBL_REDIR_DECL
 (
__rtf_chk
)

80 
	$__LDBL_REDIR_DECL
 (
__vrtf_chk
)

81 #i
defed
 
__USE_BSD
 || defed 
__USE_ISOC99
 || defed 
__USE_UNIX98


82 
	$__LDBL_REDIR_DECL
 (
__tf_chk
)

83 
	$__LDBL_REDIR_DECL
 (
__vtf_chk
)

85 #i
__USE_FORTIFY_LEVEL
 > 1

86 
	$__LDBL_REDIR_DECL
 (
__rtf_chk
)

87 
	$__LDBL_REDIR_DECL
 (
__tf_chk
)

88 
	$__LDBL_REDIR_DECL
 (
__vrtf_chk
)

89 
	$__LDBL_REDIR_DECL
 (
__vtf_chk
)

90 #ifde
__USE_XOPEN2K8


91 
	$__LDBL_REDIR_DECL
 (
__dtf_chk
)

92 
	$__LDBL_REDIR_DECL
 (
__vdtf_chk
)

94 #ifde
__USE_GNU


95 
	$__LDBL_REDIR_DECL
 (
__artf_chk
)

96 
	$__LDBL_REDIR_DECL
 (
__vartf_chk
)

97 
	$__LDBL_REDIR_DECL
 (
__oback_tf_chk
)

98 
	$__LDBL_REDIR_DECL
 (
__oback_vtf_chk
)

	@/usr/include/bits/stdio.h

19 #ide
_STDIO_H


23 #ide
__ex_le


24 
	#__STDIO_INLINE
 
le


	)

26 
	#__STDIO_INLINE
 
__ex_le


	)

30 #ifde
__USE_EXTERN_INLINES


33 #i!(
__USE_FORTIFY_LEVEL
 > 0 && 
defed
 
__ftify_funi
)

35 
__STDIO_INLINE
 

36 
	$vtf
 (cڡ *
__ri
 
__fmt
, 
_G_va_li
 
__g
)

38  
	`vrtf
 (
dout
, 
__fmt
, 
__g
);

39 
	}
}

43 
__STDIO_INLINE
 

44 
	$gch
 ()

46  
	`_IO_gc
 (
d
);

47 
	}
}

50 #ifde
__USE_MISC


52 
__STDIO_INLINE
 

53 
	$fgc_uocked
 (
FILE
 *
__
)

55  
	`_IO_gc_uocked
 (
__
);

56 
	}
}

60 #i
defed
 
__USE_POSIX
 || defed 
__USE_MISC


62 
__STDIO_INLINE
 

63 
	$gc_uocked
 (
FILE
 *
__
)

65  
	`_IO_gc_uocked
 (
__
);

66 
	}
}

69 
__STDIO_INLINE
 

70 
	$gch_uocked
 ()

72  
	`_IO_gc_uocked
 (
d
);

73 
	}
}

78 
__STDIO_INLINE
 

79 
	$putch
 (
__c
)

81  
	`_IO_putc
 (
__c
, 
dout
);

82 
	}
}

85 #ifde
__USE_MISC


87 
__STDIO_INLINE
 

88 
	$utc_uocked
 (
__c
, 
FILE
 *
__am
)

90  
	`_IO_putc_uocked
 (
__c
, 
__am
);

91 
	}
}

95 #i
defed
 
__USE_POSIX
 || defed 
__USE_MISC


97 
__STDIO_INLINE
 

98 
	$putc_uocked
 (
__c
, 
FILE
 *
__am
)

100  
	`_IO_putc_uocked
 (
__c
, 
__am
);

101 
	}
}

104 
__STDIO_INLINE
 

105 
	$putch_uocked
 (
__c
)

107  
	`_IO_putc_uocked
 (
__c
, 
dout
);

108 
	}
}

112 #ifdef 
__USE_GNU


114 
__STDIO_INLINE
 
_IO_ssize_t


115 
	$gle
 (**
__l
, 
size_t
 *
__n
, 
FILE
 *
__am
)

117  
	`__gdim
 (
__l
, 
__n
, '\n', 
__am
);

118 
	}
}

122 #ifde
__USE_MISC


124 
__STDIO_INLINE
 

125 
__NTH
 (
	$of_uocked
 (
FILE
 *
__am
))

127  
	`_IO_of_uocked
 (
__am
);

128 
	}
}

131 
__STDIO_INLINE
 

132 
__NTH
 (
	$_uocked
 (
FILE
 *
__am
))

134  
	`_IO__uocked
 (
__am
);

135 
	}
}

141 #i
defed
 
__USE_MISC
 && defed 
__GNUC__
 && defed 
__OPTIMIZE__
 \

142 && !
defed
 
	g__lulus


144 
	#d_uocked
(
r
, 
size
, 
n
, 
am
) \

145 (
	`__exnsi__
 ((
	`__but_cڡt_p
 (
size
&& __but_cڡt_(
n
) \

146 && (
size_t
(
size
* (size_t(
n
) <= 8 \

147 && (
size_t
(
size
) != 0) \

148 ? ({ *
__r
 = (*(
r
); \

149 
FILE
 *
__am
 = (
am
); \

150 
size_t
 
__t
; \

151 
__t
 = (
size_t
(
size
* (size_t(
n
); \

152 
__t
 > 0; --__cnt) \

154 
__c
 = 
	`_IO_gc_uocked
 (
__am
); \

155 i(
__c
 =
EOF
) \

157 *
__r
++ = 
__c
; \

159 ((
size_t
(
size
* (size_t(
n
- 
__t
) \

160 / (
size_t
(
size
); }) \

161 : (((
	`__but_cڡt_p
 (
size
&& (
size_t
) (size) == 0) \

162 || (
	`__but_cڡt_p
 (
n
&& (
size_t
) (n) == 0)) \

164 ? (((
r
), ((
am
), ((
size
), \

165 ((
n
), (
size_t
) 0) \

166 : 
	`d_uocked
 (
r
, 
size
, 
n
, 
am
))))

	)

168 
	#fwre_uocked
(
r
, 
size
, 
n
, 
am
) \

169 (
	`__exnsi__
 ((
	`__but_cڡt_p
 (
size
&& __but_cڡt_(
n
) \

170 && (
size_t
(
size
* (size_t(
n
) <= 8 \

171 && (
size_t
(
size
) != 0) \

172 ? ({ cڡ *
__r
 = (cڡ *(
r
); \

173 
FILE
 *
__am
 = (
am
); \

174 
size_t
 
__t
; \

175 
__t
 = (
size_t
(
size
* (size_t(
n
); \

176 
__t
 > 0; --__cnt) \

177 i(
	`_IO_putc_uocked
 (*
__r
++, 
__am
=
EOF
) \

179 ((
size_t
(
size
* (size_t(
n
- 
__t
) \

180 / (
size_t
(
size
); }) \

181 : (((
	`__but_cڡt_p
 (
size
&& (
size_t
) (size) == 0) \

182 || (
	`__but_cڡt_p
 (
n
&& (
size_t
) (n) == 0)) \

184 ? (((
r
), ((
am
), ((
size
), \

185 ((
n
), (
size_t
) 0) \

186 : 
	`fwre_uocked
 (
r
, 
size
, 
n
, 
am
))))

	)

190 #unde
__STDIO_INLINE


	@/usr/include/bits/stdio2.h

19 #ide
_STDIO_H


23 
	$__rtf_chk
 (*
__ri
 
__s
, 
__ag
, 
size_t
 
__
,

24 cڡ *
__ri
 
__fm
, ...
__THROW
;

25 
	$__vrtf_chk
 (*
__ri
 
__s
, 
__ag
, 
size_t
 
__
,

26 cڡ *
__ri
 
__fm
,

27 
_G_va_li
 
__

__THROW
;

29 #ifde
__va_g_ck


30 
__ftify_funi
 

31 
	`__NTH
 (
	$rtf
 (*
__ri
 
__s
, cڡ *__ri 
__fmt
, ...))

33  
	`__but___rtf_chk
 (
__s
, 
__USE_FORTIFY_LEVEL
 - 1,

34 
	`__bos
 (
__s
), 
__fmt
, 
	`__va_g_ck
 ());

35 
	}
}

36 #i!
defed
 
__lulus


37 
	#rtf
(
r
, ...) \

38 
	`__but___rtf_chk
 (
r
, 
__USE_FORTIFY_LEVEL
 - 1, 
	`__bos
 (str), \

39 
__VA_ARGS__
)

	)

42 
__ftify_funi
 

43 
__NTH
 (
	$vrtf
 (*
__ri
 
__s
, cڡ *__ri 
__fmt
,

44 
_G_va_li
 
__
))

46  
	`__but___vrtf_chk
 (
__s
, 
__USE_FORTIFY_LEVEL
 - 1,

47 
	`__bos
 (
__s
), 
__fmt
, 
__
);

48 
	}
}

50 #i
defed
 
__USE_BSD
 || defed 
__USE_ISOC99
 || defed 
__USE_UNIX98


52 
	$__tf_chk
 (*
__ri
 
__s
, 
size_t
 
__n
, 
__ag
,

53 
size_t
 
__
, cڡ *
__ri
 
__fm
,

54 ...
__THROW
;

55 
	$__vtf_chk
 (*
__ri
 
__s
, 
size_t
 
__n
, 
__ag
,

56 
size_t
 
__
, cڡ *
__ri
 
__fm
,

57 
_G_va_li
 
__

__THROW
;

59 #ifde
__va_g_ck


60 
__ftify_funi
 

61 
	`__NTH
 (
	$tf
 (*
__ri
 
__s
, 
size_t
 
__n
,

62 cڡ *
__ri
 
__fmt
, ...))

64  
	`__but___tf_chk
 (
__s
, 
__n
, 
__USE_FORTIFY_LEVEL
 - 1,

65 
	`__bos
 (
__s
), 
__fmt
, 
	`__va_g_ck
 ());

66 
	}
}

67 #i!
defed
 
__lulus


68 
	#tf
(
r
, 
n
, ...) \

69 
	`__but___tf_chk
 (
r
, 
n
, 
__USE_FORTIFY_LEVEL
 - 1, 
	`__bos
 (str), \

70 
__VA_ARGS__
)

	)

73 
__ftify_funi
 

74 
__NTH
 (
	$vtf
 (*
__ri
 
__s
, 
size_t
 
__n
,

75 cڡ *
__ri
 
__fmt
, 
_G_va_li
 
__
))

77  
	`__but___vtf_chk
 (
__s
, 
__n
, 
__USE_FORTIFY_LEVEL
 - 1,

78 
	`__bos
 (
__s
), 
__fmt
, 
__
);

79 
	}
}

83 #i
__USE_FORTIFY_LEVEL
 > 1

85 
__rtf_chk
 (
FILE
 *
__ri
 
__am
, 
__ag
,

86 cڡ *
__ri
 
__fm
, ...);

87 
__tf_chk
 (
__ag
, cڡ *
__ri
 
__fm
, ...);

88 
__vrtf_chk
 (
FILE
 *
__ri
 
__am
, 
__ag
,

89 cڡ *
__ri
 
__fm
, 
_G_va_li
 
__
);

90 
__vtf_chk
 (
__ag
, cڡ *
__ri
 
__fm
,

91 
_G_va_li
 
__
);

93 #ifde
__va_g_ck


94 
__ftify_funi
 

95 
	$rtf
 (
FILE
 *
__ri
 
__am
, cڡ *__ri 
__fmt
, ...)

97  
	`__rtf_chk
 (
__am
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
,

98 
	`__va_g_ck
 ());

99 
	}
}

101 
__ftify_funi
 

102 
	$tf
 (cڡ *
__ri
 
__fmt
, ...)

104  
	`__tf_chk
 (
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
, 
	`__va_g_ck
 ());

105 
	}
}

106 #i!
defed
 
__lulus


107 
	#tf
(...) \

108 
	`__tf_chk
 (
__USE_FORTIFY_LEVEL
 - 1, 
__VA_ARGS__
)

	)

109 
	#rtf
(
am
, ...) \

110 
	`__rtf_chk
 (
am
, 
__USE_FORTIFY_LEVEL
 - 1, 
__VA_ARGS__
)

	)

113 
__ftify_funi
 

114 
	$vtf
 (cڡ *
__ri
 
__fmt
, 
_G_va_li
 
__
)

116 #ifde
__USE_EXTERN_INLINES


117  
	`__vrtf_chk
 (
dout
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
, 
__
);

119  
	`__vtf_chk
 (
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
, 
__
);

121 
	}
}

123 
__ftify_funi
 

124 
	$vrtf
 (
FILE
 *
__ri
 
__am
,

125 cڡ *
__ri
 
__fmt
, 
_G_va_li
 
__
)

127  
	`__vrtf_chk
 (
__am
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
, 
__
);

128 
	}
}

130 #ifde
__USE_XOPEN2K8


131 
	$__dtf_chk
 (
__fd
, 
__ag
, cڡ *
__ri
 
__fmt
,

132 ...
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 3, 4)));

133 
	$__vdtf_chk
 (
__fd
, 
__ag
,

134 cڡ *
__ri
 
__fmt
, 
_G_va_li
 
__g
)

135 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 3, 0)));

137 #ifde
__va_g_ck


138 
__ftify_funi
 

139 
	$dtf
 (
__fd
, cڡ *
__ri
 
__fmt
, ...)

141  
	`__dtf_chk
 (
__fd
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
,

142 
	`__va_g_ck
 ());

143 
	}
}

144 #i!
defed
 
__lulus


145 
	#dtf
(
fd
, ...) \

146 
	`__dtf_chk
 (
fd
, 
__USE_FORTIFY_LEVEL
 - 1, 
__VA_ARGS__
)

	)

149 
__ftify_funi
 

150 
	$vdtf
 (
__fd
, cڡ *
__ri
 
__fmt
, 
_G_va_li
 
__
)

152  
	`__vdtf_chk
 (
__fd
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
, 
__
);

153 
	}
}

156 #ifde
__USE_GNU


158 
	$__artf_chk
 (**
__ri
 
__r
, 
__ag
,

159 cڡ *
__ri
 
__fmt
, ...)

160 
__THROW
 
	`__ibu__
 ((
	$__fm__
 (
__tf__
, 3, 4))
__wur
;

161 
	$__vartf_chk
 (**
__ri
 
__r
, 
__ag
,

162 cڡ *
__ri
 
__fmt
, 
_G_va_li
 
__g
)

163 
__THROW
 
	`__ibu__
 ((
	$__fm__
 (
__tf__
, 3, 0))
__wur
;

164 
	$__oback_tf_chk
 (
oback
 *
__ri
 
__oback
,

165 
__ag
, cڡ *
__ri
 
__fm
,

167 
__THROW
 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 3, 4)));

168 
	$__oback_vtf_chk
 (
oback
 *
__ri
 
__oback
,

169 
__ag
,

170 cڡ *
__ri
 
__fm
,

171 
_G_va_li
 
__gs
)

172 
__THROW
 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 3, 0)));

174 #ifde
__va_g_ck


175 
__ftify_funi
 

176 
	`__NTH
 (
	$artf
 (**
__ri
 
__r
, cڡ *__ri 
__fmt
, ...))

178  
	`__artf_chk
 (
__r
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
,

179 
	`__va_g_ck
 ());

180 
	}
}

182 
__ftify_funi
 

183 
__NTH
 (
	$__artf
 (**
__ri
 
__r
, cڡ *__ri 
__fmt
,

186  
	`__artf_chk
 (
__r
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
,

187 
	`__va_g_ck
 ());

188 
	}
}

190 
__ftify_funi
 

191 
__NTH
 (
	$oback_tf
 (
oback
 *
__ri
 
__oback
,

192 cڡ *
__ri
 
__fmt
, ...))

194  
	`__oback_tf_chk
 (
__oback
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
,

195 
	`__va_g_ck
 ());

196 
	}
}

197 #i!
defed
 
__lulus


198 
	#artf
(
r
, ...) \

199 
	`__artf_chk
 (
r
, 
__USE_FORTIFY_LEVEL
 - 1, 
__VA_ARGS__
)

	)

200 
	#__artf
(
r
, ...) \

201 
	`__artf_chk
 (
r
, 
__USE_FORTIFY_LEVEL
 - 1, 
__VA_ARGS__
)

	)

202 
	#oback_tf
(
oback
, ...) \

203 
	`__oback_tf_chk
 (
oback
, 
__USE_FORTIFY_LEVEL
 - 1, 
__VA_ARGS__
)

	)

206 
__ftify_funi
 

207 
__NTH
 (
	$vartf
 (**
__ri
 
__r
, cڡ *__ri 
__fmt
,

208 
_G_va_li
 
__
))

210  
	`__vartf_chk
 (
__r
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
, 
__
);

211 
	}
}

213 
__ftify_funi
 

214 
__NTH
 (
	$oback_vtf
 (
oback
 *
__ri
 
__oback
,

215 cڡ *
__ri
 
__fmt
, 
_G_va_li
 
__
))

217  
	`__oback_vtf_chk
 (
__oback
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
,

218 
__
);

219 
	}
}

225 #i!
defed
 
__USE_ISOC11
 \

226 || (
defed
 
	g__lulus
 && __lulu<201103L && !defed 
__USE_GNU
)

227 *
	$__gs_chk
 (*
__r
, 
size_t

__wur
;

228 *
	`__REDIRECT
 (
__gs_wn
, (*
__r
), 
gs
)

229 
__wur
 
	`__wǉr
 ("please use fgets or getline instead, gets can't "

232 
__ftify_funi
 
__wur
 *

233 
	$gs
 (*
__r
)

235 i(
	`__bos
 (
__r
!(
size_t
) -1)

236  
	`__gs_chk
 (
__r
, 
	`__bos
 (__str));

237  
	`__gs_wn
 (
__r
);

238 
	}
}

241 *
	$__fgs_chk
 (*
__ri
 
__s
, 
size_t
 
__size
, 
__n
,

242 
FILE
 *
__ri
 
__am

__wur
;

243 *
	`__REDIRECT
 (
__fgs_s
,

244 (*
__ri
 
__s
, 
__n
,

245 
FILE
 *
__ri
 
__am
), 
fgs

__wur
;

246 *
	`__REDIRECT
 (
__fgs_chk_wn
,

247 (*
__ri
 
__s
, 
size_t
 
__size
, 
__n
,

248 
FILE
 *
__ri
 
__am
), 
__fgs_chk
)

249 
__wur
 
	`__wǉr
 ("fgets called with bigger sizehanength "

252 
__ftify_funi
 
__wur
 *

253 
	$fgs
 (*
__ri
 
__s
, 
__n
, 
FILE
 *__ri 
__am
)

255 i(
	`__bos
 (
__s
!(
size_t
) -1)

257 i(!
	`__but_cڡt_p
 (
__n
) || __n <= 0)

258  
	`__fgs_chk
 (
__s
, 
	`__bos
 (__s), 
__n
, 
__am
);

260 i((
size_t

__n
 > 
	`__bos
 (
__s
))

261  
	`__fgs_chk_wn
 (
__s
, 
	`__bos
 (__s), 
__n
, 
__am
);

263  
	`__fgs_s
 (
__s
, 
__n
, 
__am
);

264 
	}
}

266 
size_t
 
	$__d_chk
 (*
__ri
 
__r
, 
size_t
 
__
,

267 
size_t
 
__size
, size_
__n
,

268 
FILE
 *
__ri
 
__am

__wur
;

269 
size_t
 
	`__REDIRECT
 (
__d_s
,

270 (*
__ri
 
__r
, 
size_t
 
__size
,

271 
size_t
 
__n
, 
FILE
 *
__ri
 
__am
),

272 
d

__wur
;

273 
size_t
 
	`__REDIRECT
 (
__d_chk_wn
,

274 (*
__ri
 
__r
, 
size_t
 
__
,

275 
size_t
 
__size
, size_
__n
,

276 
FILE
 *
__ri
 
__am
),

277 
__d_chk
)

278 
__wur
 
	`__wǉr
 ("fread called with bigger size *membhanength "

281 
__ftify_funi
 
__wur
 
size_t


282 
	$d
 (*
__ri
 
__r
, 
size_t
 
__size
, size_
__n
,

283 
FILE
 *
__ri
 
__am
)

285 i(
	`__bos0
 (
__r
!(
size_t
) -1)

287 i(!
	`__but_cڡt_p
 (
__size
)

288 || !
	`__but_cڡt_p
 (
__n
)

289 || (
__size
 | 
__n
>(((
size_t
) 1) << (8 *  (size_t) / 2)))

290  
	`__d_chk
 (
__r
, 
	`__bos0
 (__r), 
__size
, 
__n
, 
__am
);

292 i(
__size
 * 
__n
 > 
	`__bos0
 (
__r
))

293  
	`__d_chk_wn
 (
__r
, 
	`__bos0
 (__r), 
__size
, 
__n
, 
__am
);

295  
	`__d_s
 (
__r
, 
__size
, 
__n
, 
__am
);

296 
	}
}

298 #ifde
__USE_GNU


299 *
	$__fgs_uocked_chk
 (*
__ri
 
__s
, 
size_t
 
__size
,

300 
__n
, 
FILE
 *
__ri
 
__am

__wur
;

301 *
	`__REDIRECT
 (
__fgs_uocked_s
,

302 (*
__ri
 
__s
, 
__n
,

303 
FILE
 *
__ri
 
__am
), 
fgs_uocked

__wur
;

304 *
	`__REDIRECT
 (
__fgs_uocked_chk_wn
,

305 (*
__ri
 
__s
, 
size_t
 
__size
, 
__n
,

306 
FILE
 *
__ri
 
__am
), 
__fgs_uocked_chk
)

307 
__wur
 
	`__wǉr
 ("fgets_unlocked called with bigger sizehanength "

310 
__ftify_funi
 
__wur
 *

311 
	$fgs_uocked
 (*
__ri
 
__s
, 
__n
, 
FILE
 *__ri 
__am
)

313 i(
	`__bos
 (
__s
!(
size_t
) -1)

315 i(!
	`__but_cڡt_p
 (
__n
) || __n <= 0)

316  
	`__fgs_uocked_chk
 (
__s
, 
	`__bos
 (__s), 
__n
, 
__am
);

318 i((
size_t

__n
 > 
	`__bos
 (
__s
))

319  
	`__fgs_uocked_chk_wn
 (
__s
, 
	`__bos
 (__s), 
__n
, 
__am
);

321  
	`__fgs_uocked_s
 (
__s
, 
__n
, 
__am
);

322 
	}
}

325 #ifde
__USE_MISC


326 #unde
d_uocked


327 
size_t
 
	$__d_uocked_chk
 (*
__ri
 
__r
, 
size_t
 
__
,

328 
size_t
 
__size
, size_
__n
,

329 
FILE
 *
__ri
 
__am

__wur
;

330 
size_t
 
	`__REDIRECT
 (
__d_uocked_s
,

331 (*
__ri
 
__r
, 
size_t
 
__size
,

332 
size_t
 
__n
, 
FILE
 *
__ri
 
__am
),

333 
d_uocked

__wur
;

334 
size_t
 
	`__REDIRECT
 (
__d_uocked_chk_wn
,

335 (*
__ri
 
__r
, 
size_t
 
__
,

336 
size_t
 
__size
, size_
__n
,

337 
FILE
 *
__ri
 
__am
),

338 
__d_uocked_chk
)

339 
__wur
 
	`__wǉr
 ("fread_unlocked called with bigger size *membhan "

342 
__ftify_funi
 
__wur
 
size_t


343 
	$d_uocked
 (*
__ri
 
__r
, 
size_t
 
__size
, size_
__n
,

344 
FILE
 *
__ri
 
__am
)

346 i(
	`__bos0
 (
__r
!(
size_t
) -1)

348 i(!
	`__but_cڡt_p
 (
__size
)

349 || !
	`__but_cڡt_p
 (
__n
)

350 || (
__size
 | 
__n
>(((
size_t
) 1) << (8 *  (size_t) / 2)))

351  
	`__d_uocked_chk
 (
__r
, 
	`__bos0
 (__r), 
__size
, 
__n
,

352 
__am
);

354 i(
__size
 * 
__n
 > 
	`__bos0
 (
__r
))

355  
	`__d_uocked_chk_wn
 (
__r
, 
	`__bos0
 (__r), 
__size
, 
__n
,

356 
__am
);

359 #ifde
__USE_EXTERN_INLINES


360 i(
	`__but_cڡt_p
 (
__size
)

361 && 
	`__but_cڡt_p
 (
__n
)

362 && (
__size
 | 
__n
< (((
size_t
) 1) << (8 *  (size_t) / 2))

363 && 
__size
 * 
__n
 <= 8)

365 
size_t
 
__t
 = 
__size
 * 
__n
;

366 *
__
 = (*
__r
;

367 i(
__t
 == 0)

370 ; 
__t
 > 0; --__cnt)

372 
__c
 = 
	`_IO_gc_uocked
 (
__am
);

373 i(
__c
 =
EOF
)

375 *
__
++ = 
__c
;

377  (
__
 - (*
__r
/ 
__size
;

380  
	`__d_uocked_s
 (
__r
, 
__size
, 
__n
, 
__am
);

381 
	}
}

	@/usr/include/bits/stdio_lim.h

18 #i!
defed
 
_STDIO_H
 && !defed 
__ed_FOPEN_MAX
 && !defed 
__ed_IOV_MAX


22 #ifde
_STDIO_H


23 
	#L_tmam
 20

	)

24 
	#TMP_MAX
 238328

	)

25 
	#FILENAME_MAX
 4096

	)

27 #ifde
__USE_POSIX


28 
	#L_mid
 9

	)

29 #i!
defed
 
__USE_XOPEN2K
 || defed 
__USE_GNU


30 
	#L_curid
 9

	)

35 #i
defed
 
__ed_FOPEN_MAX
 || defed 
_STDIO_H


36 #unde
FOPEN_MAX


37 
	#FOPEN_MAX
 16

	)

40 #i
defed
 
__ed_IOV_MAX
 && !defed 
IOV_MAX


41 
	#IOV_MAX
 1024

	)

	@/usr/include/bits/stdlib-bsearch.h

19 
__ex_le
 *

20 
	$bch
 (cڡ *
__key
, cڡ *
__ba
, 
size_t
 
__nmemb
, size_
__size
,

21 
__comr__t
 
__comr
)

23 
size_t
 
__l
, 
__u
, 
__idx
;

24 cڡ *
__p
;

25 
__comris
;

27 
__l
 = 0;

28 
__u
 = 
__nmemb
;

29 
__l
 < 
__u
)

31 
__idx
 = (
__l
 + 
__u
) / 2;

32 
__p
 = (*(((cڡ *
__ba
+ (
__idx
 * 
__size
));

33 
__comris
 = (*
__comr
(
__key
, 
__p
);

34 i(
__comris
 < 0)

35 
__u
 = 
__idx
;

36 i(
__comris
 > 0)

37 
__l
 = 
__idx
 + 1;

39  (*
__p
;

42  
NULL
;

43 
	}
}

	@/usr/include/bits/stdlib-float.h

19 #ide
_STDLIB_H


23 #ifde
__USE_EXTERN_INLINES


24 
__BEGIN_NAMESPACE_STD


25 
__ex_le
 

26 
__NTH
 (
	$of
 (cڡ *
__Ō
))

28  
	`od
 (
__Ō
, (**
NULL
);

29 
	}
}

30 
	g__END_NAMESPACE_STD


	@/usr/include/bits/stdlib-ldbl.h

19 #ide
_STDLIB_H


23 #ifdef 
__USE_ISOC99


24 
__BEGIN_NAMESPACE_C99


25 
	$__LDBL_REDIR1_DECL
 (
d
, 
od
)

26 
__END_NAMESPACE_C99


29 #ifde
__USE_GNU


30 
	$__LDBL_REDIR1_DECL
 (
d_l
, 
od_l
)

33 #ifde
__USE_MISC


34 
	$__LDBL_REDIR1_DECL
 (
qecvt
, 
ecvt
)

35 
	$__LDBL_REDIR1_DECL
 (
qfcvt
, 
fcvt
)

36 
	$__LDBL_REDIR1_DECL
 (
qgcvt
, 
gcvt
)

37 
	$__LDBL_REDIR1_DECL
 (
qecvt_r
, 
ecvt_r
)

38 
	$__LDBL_REDIR1_DECL
 (
qfcvt_r
, 
fcvt_r
)

	@/usr/include/bits/stdlib.h

19 #ide
_STDLIB_H


23 *
	$__th_chk
 (cڡ *
__ri
 
__me
,

24 *
__ri
 
__sved
,

25 
size_t
 
__svedn

__THROW
 
__wur
;

26 *
	`__REDIRECT_NTH
 (
__th_s
,

27 (cڡ *
__ri
 
__me
,

28 *
__ri
 
__sved
), 
th

__wur
;

29 *
	`__REDIRECT_NTH
 (
__th_chk_wn
,

30 (cڡ *
__ri
 
__me
,

31 *
__ri
 
__sved
,

32 
size_t
 
__svedn
), 
__th_chk

__wur


33 
	`__wǉr
 ("secondrgument ofealpath must beither NULL ort "

36 
__ftify_funi
 
__wur
 *

37 
	`__NTH
 (
	$th
 (cڡ *
__ri
 
__me
, *__ri 
__sved
))

39 i(
	`__bos
 (
__sved
!(
size_t
) -1)

41 #i
defed
 
_LIBC_LIMITS_H_
 && defed 
PATH_MAX


42 i(
	`__bos
 (
__sved
< 
PATH_MAX
)

43  
	`__th_chk_wn
 (
__me
, 
__sved
, 
	`__bos
 (__resolved));

45  
	`__th_chk
 (
__me
, 
__sved
, 
	`__bos
 (__resolved));

48  
	`__th_s
 (
__me
, 
__sved
);

49 
	}
}

52 
	$__ame_r_chk
 (
__fd
, *
__buf
, 
size_t
 
__bu
,

53 
size_t
 
__ėl

__THROW
 
	`__nnu
 ((2));

54 
	`__REDIRECT_NTH
 (
__ame_r_s
, (
__fd
, *
__buf
,

55 
size_t
 
__bu
), 
ame_r
)

56 
	`__nnu
 ((2));

57 
	`__REDIRECT_NTH
 (
__ame_r_chk_wn
,

58 (
__fd
, *
__buf
, 
size_t
 
__bu
,

59 
size_t
 
__ėl
), 
__ame_r_chk
)

60 
	`__nnu
 ((2)
	`__wǉr
 ("ptsname_r called with buflen biggerhan "

63 
__ftify_funi
 

64 
	`__NTH
 (
	$ame_r
 (
__fd
, *
__buf
, 
size_t
 
__bu
))

66 i(
	`__bos
 (
__buf
!(
size_t
) -1)

68 i(!
	`__but_cڡt_p
 (
__bu
))

69  
	`__ame_r_chk
 (
__fd
, 
__buf
, 
__bu
, 
	`__bos
 (__buf));

70 i(
__bu
 > 
	`__bos
 (
__buf
))

71  
	`__ame_r_chk_wn
 (
__fd
, 
__buf
, 
__bu
, 
	`__bos
 (__buf));

73  
	`__ame_r_s
 (
__fd
, 
__buf
, 
__bu
);

74 
	}
}

77 
	$__womb_chk
 (*
__s
, 
wch_t
 
__wch
, 
size_t
 
__bu
)

78 
__THROW
 
__wur
;

79 
	`__REDIRECT_NTH
 (
__womb_s
, (*
__s
, 
wch_t
 
__wch
),

80 
womb

__wur
;

82 
__ftify_funi
 
__wur
 

83 
	`__NTH
 (
	$womb
 (*
__s
, 
wch_t
 
__wch
))

88 
	#__STDLIB_MB_LEN_MAX
 16

	)

89 #i
defed
 
MB_LEN_MAX
 && MB_LEN_MAX !
__STDLIB_MB_LEN_MAX


92 i(
	`__bos
 (
__s
!(
size_t
-1 && 
__STDLIB_MB_LEN_MAX
 > __bos (__s))

93  
	`__womb_chk
 (
__s
, 
__wch
, 
	`__bos
 (__s));

94  
	`__womb_s
 (
__s
, 
__wch
);

95 
	}
}

98 
size_t
 
	$__mbowcs_chk
 (
wch_t
 *
__ri
 
__d
,

99 cڡ *
__ri
 
__c
,

100 
size_t
 
__n
, size_
__dn

__THROW
;

101 
size_t
 
	`__REDIRECT_NTH
 (
__mbowcs_s
,

102 (
wch_t
 *
__ri
 
__d
,

103 cڡ *
__ri
 
__c
,

104 
size_t
 
__n
), 
mbowcs
);

105 
size_t
 
	`__REDIRECT_NTH
 (
__mbowcs_chk_wn
,

106 (
wch_t
 *
__ri
 
__d
,

107 cڡ *
__ri
 
__c
,

108 
size_t
 
__n
, size_
__dn
), 
__mbowcs_chk
)

109 
	`__wǉr
 ("mbstowcs called with dst buffer smallerhanen "

112 
__ftify_funi
 
size_t


113 
	`__NTH
 (
	$mbowcs
 (
wch_t
 *
__ri
 
__d
, cڡ *__ri 
__c
,

114 
size_t
 
__n
))

116 i(
	`__bos
 (
__d
!(
size_t
) -1)

118 i(!
	`__but_cڡt_p
 (
__n
))

119  
	`__mbowcs_chk
 (
__d
, 
__c
, 
__n
,

120 
	`__bos
 (
__d
/  (
wch_t
));

122 i(
__n
 > 
	`__bos
 (
__d
/  (
wch_t
))

123  
	`__mbowcs_chk_wn
 (
__d
, 
__c
, 
__n
,

124 
	`__bos
 (
__d
/  (
wch_t
));

126  
	`__mbowcs_s
 (
__d
, 
__c
, 
__n
);

127 
	}
}

130 
size_t
 
	$__wcombs_chk
 (*
__ri
 
__d
,

131 cڡ 
wch_t
 *
__ri
 
__c
,

132 
size_t
 
__n
, size_
__dn

__THROW
;

133 
size_t
 
	`__REDIRECT_NTH
 (
__wcombs_s
,

134 (*
__ri
 
__d
,

135 cڡ 
wch_t
 *
__ri
 
__c
,

136 
size_t
 
__n
), 
wcombs
);

137 
size_t
 
	`__REDIRECT_NTH
 (
__wcombs_chk_wn
,

138 (*
__ri
 
__d
,

139 cڡ 
wch_t
 *
__ri
 
__c
,

140 
size_t
 
__n
, size_
__dn
), 
__wcombs_chk
)

141 
	`__wǉr
 ("wcstombs called with dst buffer smallerhanen");

143 
__ftify_funi
 
size_t


144 
	`__NTH
 (
	$wcombs
 (*
__ri
 
__d
, cڡ 
wch_t
 *__ri 
__c
,

145 
size_t
 
__n
))

147 i(
	`__bos
 (
__d
!(
size_t
) -1)

149 i(!
	`__but_cڡt_p
 (
__n
))

150  
	`__wcombs_chk
 (
__d
, 
__c
, 
__n
, 
	`__bos
 (__dst));

151 i(
__n
 > 
	`__bos
 (
__d
))

152  
	`__wcombs_chk_wn
 (
__d
, 
__c
, 
__n
, 
	`__bos
 (__dst));

154  
	`__wcombs_s
 (
__d
, 
__c
, 
__n
);

155 
	}
}

	@/usr/include/bits/string.h

19 #ide
_STRING_H


24 
	#_STRING_ARCH_uligd
 1

	)

28 #i!
defed
 
__x86_64__
 && (defed 
__i486__
 || defed 
__ium__
 \

29 || 
defed
 
	g__iumo__
 || defed 
	g__ium4__
 \

30 || 
defed
 
	g__noca__
 || defed 
	g__om__
 \

31 || 
defed
 
	g__ce2__
 || defed 
	g__cei7__
 \

32 || 
defed
 
	g__k6__
 || defed 
	g__geode__
 \

33 || 
defed
 
	g__k8__
 || defed 
	g__hl__
 \

34 || 
defed
 
	g__amdm10__
)

38 #i!
defed
 
__NO_STRING_INLINES
 && defed 
__USE_STRING_INLINES
 \

39 && 
defed
 
	g__GNUC__
 && __GNUC__ >= 2

41 #ide
__STRING_INLINE


42 #ide
__ex_le


43 
	#__STRING_INLINE
 
le


	)

45 
	#__STRING_INLINE
 
__ex_le


	)

50 
	#__STRING_SMALL_GET16
(
c
, 
idx
) \

51 ((((cڡ *(
c
))[
idx
 + 1] << 8) \

52 | ((cڡ *(
c
))[
idx
])

	)

53 
	#__STRING_SMALL_GET32
(
c
, 
idx
) \

54 (((((cڡ *(
c
))[
idx
 + 3] << 8 \

55 | ((cڡ *(
c
))[
idx
 + 2]) << 8 \

56 | ((cڡ *(
c
))[
idx
 + 1]) << 8 \

57 | ((cڡ *(
c
))[
idx
])

	)

61 
	#_HAVE_STRING_ARCH_memy
 1

	)

62 
	#memy
(
de
, 
c
, 
n
) \

63 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
n
) \

64 ? 
	`__memy_c
 ((
de
), (
c
), (
n
)) \

65 : 
	`__memy_g
 ((
de
), (
c
), (
n
))))

	)

66 
	#__memy_c
(
de
, 
c
, 
n
) \

67 ((
n
) == 0 \

68 ? (
de
) \

69 : (((
n
) % 4 == 0) \

70 ? 
	`__memy_by4
 (
de
, 
c
, 
n
) \

71 : (((
n
) % 2 == 0) \

72 ? 
	`__memy_by2
 (
de
, 
c
, 
n
) \

73 : 
	`__memy_g
 (
de
, 
c
, 
n
))))

	)

75 
__STRING_INLINE
 *
__memy_by4
 (*
__de
, cڡ *
__c
,

76 
size_t
 
__n
);

78 
__STRING_INLINE
 *

79 
	$__memy_by4
 (*
__de
, cڡ *
__c
, 
size_t
 
__n
)

81 
__d0
, 
__d1
;

82 *
__tmp
 = 
__de
;

83 
__asm__
 
__vީe__


91 : "=&r" (
__d0
), "=&r" (
__tmp
), "=&r" (
__c
), "=&r" (
__d1
)

92 : "1" (
__tmp
), "2" (
__c
), "3" (
__n
 / 4)

94  
__de
;

95 
	}
}

97 
__STRING_INLINE
 *
__memy_by2
 (*
__de
, cڡ *
__c
,

98 
size_t
 
__n
);

100 
__STRING_INLINE
 *

101 
	$__memy_by2
 (*
__de
, cڡ *
__c
, 
size_t
 
__n
)

103 
__d0
, 
__d1
;

104 *
__tmp
 = 
__de
;

105 
__asm__
 
__vީe__


118 : "=&q" (
__d0
), "=&r" (
__tmp
), "=&r" (
__c
), "=&r" (
__d1
)

119 : "1" (
__tmp
), "2" (
__c
), "3" (
__n
 / 2)

121  
__de
;

122 
	}
}

124 
__STRING_INLINE
 *
__memy_g
 (*
__de
, cڡ *
__c
, 
size_t
 
__n
);

126 
__STRING_INLINE
 *

127 
	$__memy_g
 (*
__de
, cڡ *
__c
, 
size_t
 
__n
)

129 
__d0
, 
__d1
, 
__d2
;

130 *
__tmp
 = 
__de
;

131 
__asm__
 
__vީe__


142 : "=&c" (
__d0
), "=&D" (
__d1
), "=&S" (
__d2
),

143 "=m" ( *(ru { 
__exnsi__
 
__x
[
__n
]; } *)
__de
)

144 : "0" (
__n
), "1" (
__tmp
), "2" (
__c
),

145 "m" ( *(ru { 
__exnsi__
 
__x
[
__n
]; } *)
__c
)

147  
__de
;

148 
	}
}

150 
	#_HAVE_STRING_ARCH_memmove
 1

	)

151 #ide
_FORCE_INLINES


154 
	#memmove
(
de
, 
c
, 
n

	`__memmove_g
 (de, src,)

	)

156 
__STRING_INLINE
 *
	$__memmove_g
 (*, cڡ *, 
size_t
)

157 
	`__asm__
 ("memmove");

159 
__STRING_INLINE
 *

160 
	$__memmove_g
 (*
__de
, cڡ *
__c
, 
size_t
 
__n
)

162 
__d0
, 
__d1
, 
__d2
;

163 *
__tmp
 = 
__de
;

164 i(
__de
 < 
__c
)

165 
__asm__
 
__vީe__


168 : "=&c" (
__d0
), "=&S" (
__d1
), "=&D" (
__d2
),

169 "=m" ( *(ru { 
__exnsi__
 
__x
[
__n
]; } *)
__de
)

170 : "0" (
__n
), "1" (
__c
), "2" (
__tmp
),

171 "m" ( *(ru { 
__exnsi__
 
__x
[
__n
]; } *)
__c
));

173 
__asm__
 
__vީe__


177 : "=&c" (
__d0
), "=&S" (
__d1
), "=&D" (
__d2
),

178 "=m" ( *(ru { 
__exnsi__
 
__x
[
__n
]; } *)
__de
)

179 : "0" (
__n
), "1" (__- 1 + (cڡ *
__c
),

180 "2" (
__n
 - 1 + (*
__tmp
),

181 "m" ( *(ru { 
__exnsi__
 
__x
[
__n
]; } *)
__c
));

182  
__de
;

183 
	}
}

187 
	#_HAVE_STRING_ARCH_memcmp
 1

	)

188 #ide
_FORCE_INLINES


189 #ide
__PIC__


191 
__STRING_INLINE
 

192 
	$memcmp
 (cڡ *
__s1
, cڡ *
__s2
, 
size_t
 
__n
)

194 
__d0
, 
__d1
, 
__d2
;

195 
__s
;

196 
__asm__
 
__vީe__


204 : "=&a" (
__s
), "=&S" (
__d0
), "=&D" (
__d1
), "=&c" (
__d2
)

205 : "0" (0), "1" (
__s1
), "2" (
__s2
), "3" (
__n
),

206 "m" ( *(ru { 
__exnsi__
 
__x
[
__n
]; } *)
__s1
),

207 "m" ( *(ru { 
__exnsi__
 
__x
[
__n
]; } *)
__s2
)

209  
__s
;

210 
	}
}

215 
	#_HAVE_STRING_ARCH_memt
 1

	)

216 
	#_USE_STRING_ARCH_memt
 1

	)

217 
	#memt
(
s
, 
c
, 
n
) \

218 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
n
) && (n) <= 16 \

219 ? ((
n
) == 1 \

220 ? 
	`__memt_c1
 ((
s
), (
c
)) \

221 : 
	`__memt_gc
 ((
s
), (
c
), (
n
))) \

222 : (
	`__but_cڡt_p
 (
c
) \

223 ? (
	`__but_cڡt_p
 (
n
) \

224 ? 
	`__memt_c
 ((
s
), (
c
), (
n
)) \

225 : 
	`memt
 ((
s
), (
c
), (
n
))) \

226 : (
	`__but_cڡt_p
 (
n
) \

227 ? 
	`__memt_g
 ((
s
), (
c
), (
n
)) \

228 : 
	`memt
 ((
s
), (
c
), (
n
))))))

	)

230 
	#__memt_c1
(
s
, 
c
({ *
__s
 = (s); \

231 *((*
__s
((
c
); \

232 
__s
; })

	)

234 
	#__memt_gc
(
s
, 
c
, 
n
) \

235 ({ *
__s
 = (
s
); \

237 
__ui
; \

238 
__usi
; \

239 
__uc
; \

240 } *
__u
 = 
__s
; \

241 
__c
 = (((((
c
))) * 0x01010101; \

247 i((
n
) == 3 || (n) >= 5) \

248 
__asm__
 
	`__vީe__
 ("" : "" (
__c
) : "0" (__c)); \

251 
n
) \

254 
__u
->
__ui
 = 
__c
; \

255 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

257 
__u
->
__ui
 = 
__c
; \

258 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

260 
__u
->
__ui
 = 
__c
; \

261 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

263 
__u
->
__usi
 = (
__c
; \

264 
__u
 = 
	`__exnsi__
 ((*) __u + 2); \

265 
__u
->
__uc
 = (
__c
; \

269 
__u
->
__ui
 = 
__c
; \

270 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

272 
__u
->
__ui
 = 
__c
; \

273 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

275 
__u
->
__ui
 = 
__c
; \

276 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

278 
__u
->
__usi
 = (
__c
; \

282 
__u
->
__ui
 = 
__c
; \

283 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

285 
__u
->
__ui
 = 
__c
; \

286 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

288 
__u
->
__ui
 = 
__c
; \

289 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

291 
__u
->
__uc
 = (
__c
; \

295 
__u
->
__ui
 = 
__c
; \

296 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

298 
__u
->
__ui
 = 
__c
; \

299 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

301 
__u
->
__ui
 = 
__c
; \

302 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

304 
__u
->
__ui
 = 
__c
; \

309 
__s
; })

	)

311 
	#__memt_c
(
s
, 
c
, 
n
) \

312 (((
n
) % 4 == 0) \

313 ? 
	`__memt_c_by4
 (
s
, (((((
c
))) * 0x01010101,\

314 
n
) \

315 : (((
n
) % 2 == 0) \

316 ? 
	`__memt_c_by2
 (
s
, \

317 (((((
c
))) * 0x01010101,\

318 
n
) \

319 : 
	`memt
 (
s
, 
c
, 
n
)))

	)

321 
__STRING_INLINE
 *
__memt_c_by4
 (*
__s
, 
__c
,

322 
size_t
 
__n
);

324 
__STRING_INLINE
 *

325 
	$__memt_c_by4
 (*
__s
, 
__c
, 
size_t
 
__n
)

327 *
__tmp
 = 
__s
;

328 
__d0
;

329 #ifde
__i686__


330 
__asm__
 
__vީe__


333 : "=&a" (
__c
), "=&D" (
__tmp
), "=&c" (
__d0
),

334 "=m" ( *(ru { 
__exnsi__
 
__x
[
__n
]; } *)
__s
)

335 : "0" ((
__c
), "1" (
__tmp
), "2" (
__n
 / 4)

338 
__asm__
 
__vީe__


344 : "=&r" (
__c
), "=&r" (
__tmp
), "=&r" (
__d0
),

345 "=m" ( *(ru { 
__exnsi__
 
__x
[
__n
]; } *)
__s
)

346 : "0" ((
__c
), "1" (
__tmp
), "2" (
__n
 / 4)

349  
__s
;

350 
	}
}

352 
__STRING_INLINE
 *
__memt_c_by2
 (*
__s
, 
__c
,

353 
size_t
 
__n
);

355 
__STRING_INLINE
 *

356 
	$__memt_c_by2
 (*
__s
, 
__c
, 
size_t
 
__n
)

358 
__d0
, 
__d1
;

359 *
__tmp
 = 
__s
;

360 #ifde
__i686__


361 
__asm__
 
__vީe__


365 : "=&a" (
__d0
), "=&D" (
__tmp
), "=&c" (
__d1
),

366 "=m" ( *(ru { 
__exnsi__
 
__x
[
__n
]; } *)
__s
)

367 : "0" ((
__c
), "1" (
__tmp
), "2" (
__n
 / 4)

370 
__asm__
 
__vީe__


376 : "=&q" (
__d0
), "=&r" (
__tmp
), "=&r" (
__d1
),

377 "=m" ( *(ru { 
__exnsi__
 
__x
[
__n
]; } *)
__s
)

378 : "0" ((
__c
), "1" (
__tmp
), "2" (
__n
 / 4)

381  
__s
;

382 
	}
}

384 
	#__memt_g
(
s
, 
c
, 
n
) \

385 (((
n
) % 4 == 0) \

386 ? 
	`__memt_g_by4
 (
s
, 
c
, 
n
) \

387 : (((
n
) % 2 == 0) \

388 ? 
	`__memt_g_by2
 (
s
, 
c
, 
n
) \

389 : 
	`memt
 (
s
, 
c
, 
n
)))

	)

391 
__STRING_INLINE
 *
__memt_g_by4
 (*
__s
, 
__c
, 
size_t
 
__n
);

393 
__STRING_INLINE
 *

394 
	$__memt_g_by4
 (*
__s
, 
__c
, 
size_t
 
__n
)

396 *
__tmp
 = 
__s
;

397 
__d0
;

398 
__asm__
 
__vީe__


408 : "=&q" (
__c
), "=&r" (
__tmp
), "=&r" (
__d0
),

409 "=m" ( *(ru { 
__exnsi__
 
__x
[
__n
]; } *)
__s
)

410 : "0" ((
__c
), "1" (
__tmp
), "2" (
__n
 / 4)

412  
__s
;

413 
	}
}

415 
__STRING_INLINE
 *
__memt_g_by2
 (*
__s
, 
__c
, 
size_t
 
__n
);

417 
__STRING_INLINE
 *

418 
	$__memt_g_by2
 (*
__s
, 
__c
, 
size_t
 
__n
)

420 
__d0
, 
__d1
;

421 *
__tmp
 = 
__s
;

422 
__asm__
 
__vީe__


433 : "=&q" (
__d0
), "=&r" (
__tmp
), "=&r" (
__d1
),

434 "=m" ( *(ru { 
__exnsi__
 
__x
[
__n
]; } *)
__s
)

435 : "0" ((
__c
), "1" (
__tmp
), "2" (
__n
 / 4)

437  
__s
;

438 
	}
}

442 
	#_HAVE_STRING_ARCH_memchr
 1

	)

443 #ide
_FORCE_INLINES


444 
__STRING_INLINE
 *

445 
	$memchr
 (cڡ *
__s
, 
__c
, 
size_t
 
__n
)

447 
__d0
;

448 #ifde
__i686__


449 
__d1
;

451 *
__s
;

452 i(
__n
 == 0)

453  
NULL
;

454 #ifde
__i686__


455 
__asm__
 
__vީe__


459 : "=D" (
__s
), "=&c" (
__d0
), "=&r" (
__d1
)

460 : "a" (
__c
), "0" (
__s
), "1" (
__n
), "2" (1),

461 "m" ( *(ru { 
__exnsi__
 
__x
[
__n
]; } *)
__s
)

464 
__asm__
 
__vީe__


470 : "=D" (
__s
), "=&c" (
__d0
)

471 : "a" (
__c
), "0" (
__s
), "1" (
__n
),

472 "m" ( *(ru { 
__exnsi__
 
__x
[
__n
]; } *)
__s
)

475  
__s
 - 1;

476 
	}
}

479 
	#_HAVE_STRING_ARCH_memrchr
 1

	)

480 #ide
_FORCE_INLINES


481 
__STRING_INLINE
 *
__memrchr
 (cڡ *
__s
, 
__c
, 
size_t
 
__n
);

483 
__STRING_INLINE
 *

484 
	$__memrchr
 (cڡ *
__s
, 
__c
, 
size_t
 
__n
)

486 
__d0
;

487 #ifde
__i686__


488 
__d1
;

490 *
__s
;

491 i(
__n
 == 0)

492  
NULL
;

493 #ifde
__i686__


494 
__asm__
 
__vީe__


500 : "=D" (
__s
), "=&c" (
__d0
), "=&r" (
__d1
)

501 : "a" (
__c
), "0" (
__s
 + 
__n
 - 1), "1" (__n), "2" (-1),

502 "m" ( *(ru { 
__exnsi__
 
__x
[
__n
]; } *)
__s
)

505 
__asm__
 
__vީe__


512 : "=D" (
__s
), "=&c" (
__d0
)

513 : "a" (
__c
), "0" (
__s
 + 
__n
 - 1), "1" (__n),

514 "m" ( *(ru { 
__exnsi__
 
__x
[
__n
]; } *)
__s
)

517  
__s
;

518 
	}
}

519 #ifde
__USE_GNU


520 
	#memrchr
(
s
, 
c
, 
n

	`__memrchr
 ((s), (c), (n))

	)

525 
	#_HAVE_STRING_ARCH_wmemchr
 1

	)

526 
__STRING_INLINE
 *
__wmemchr
 (cڡ *
__s
, 
__c
);

528 #ide
_FORCE_INLINES


529 
__STRING_INLINE
 *

530 
	$__wmemchr
 (cڡ *
__s
, 
__c
)

532 
__d0
;

533 *
__s
;

534 
__asm__
 
__vީe__


537 : "=D" (
__s
), "=&c" (
__d0
)

538 : "a" (
__c
), "0" (
__s
), "1" (0xffffffff),

539 "m" ( *(ru { 
__x
[0xfffffff]; } *)
__s
)

541  
__s
 - 1;

542 
	}
}

543 #ifde
__USE_GNU


544 
__STRING_INLINE
 *

545 
	$wmemchr
 (cڡ *
__s
, 
__c
)

547  
	`__wmemchr
 (
__s
, 
__c
);

548 
	}
}

554 
	#_HAVE_STRING_ARCH_
 1

	)

555 
	#
(
r
) \

556 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
r
) \

557 ? 
	`__but_
 (
r
) \

558 : 
	`___g
 (
r
)))

	)

559 
__STRING_INLINE
 
size_t
 
___g
 (cڡ *
__r
);

561 
__STRING_INLINE
 
size_t


562 
	$___g
 (cڡ *
__r
)

564 
__dummy
;

565 cڡ *
__tmp
 = 
__r
;

566 
__asm__
 
__vީe__


572 : "" (
__tmp
), "=&q" (
__dummy
)

573 : "0" (
__r
),

574 "m" ( *(ru { 
__x
[0xfffffff]; } *)
__r
)

576  
__tmp
 - 
__r
 - 1;

577 
	}
}

581 
	#_HAVE_STRING_ARCH_ry
 1

	)

582 
	#ry
(
de
, 
c
) \

583 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
c
) \

584 ? ( ((
c
)[0]=1 && 
	`
 (src) + 1 <= 8 \

585 ? 
	`__ry_a_sml
 ((
de
), (
c
), 
	`
 (src) + 1) \

586 : (*
	`memy
 ((*(
de
), \

587 (cڡ *(
c
), \

588 
	`
 (
c
) + 1)) \

589 : 
	`__ry_g
 ((
de
), (
c
))))

	)

591 
	#__ry_a_sml
(
de
, 
c
, 

) \

592 (
	`__exnsi__
 ({ *
__de
 = (
de
); \

594 
__ui
; \

595 
__usi
; \

596 
__uc
; \

597 
__c
; \

598 } *
__u
 = (*
__de
; \

599 

) \

602 
__u
->
__uc
 = '\0'; \

605 
__u
->
__usi
 = 
	`__STRING_SMALL_GET16
 (
c
, 0); \

608 
__u
->
__usi
 = 
	`__STRING_SMALL_GET16
 (
c
, 0); \

609 
__u
 = 
	`__exnsi__
 ((*) __u + 2); \

610 
__u
->
__uc
 = '\0'; \

613 
__u
->
__ui
 = 
	`__STRING_SMALL_GET32
 (
c
, 0); \

616 
__u
->
__ui
 = 
	`__STRING_SMALL_GET32
 (
c
, 0); \

617 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

618 
__u
->
__uc
 = '\0'; \

621 
__u
->
__ui
 = 
	`__STRING_SMALL_GET32
 (
c
, 0); \

622 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

623 
__u
->
__usi
 = 
	`__STRING_SMALL_GET16
 (
c
, 4); \

626 
__u
->
__ui
 = 
	`__STRING_SMALL_GET32
 (
c
, 0); \

627 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

628 
__u
->
__usi
 = 
	`__STRING_SMALL_GET16
 (
c
, 4); \

629 
__u
 = 
	`__exnsi__
 ((*) __u + 2); \

630 
__u
->
__uc
 = '\0'; \

633 
__u
->
__ui
 = 
	`__STRING_SMALL_GET32
 (
c
, 0); \

634 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

635 
__u
->
__ui
 = 
	`__STRING_SMALL_GET32
 (
c
, 4); \

638 (*
__de
; }))

	)

640 
__STRING_INLINE
 *
__ry_g
 (*
__de
, cڡ *
__c
);

642 
__STRING_INLINE
 *

643 
	$__ry_g
 (*
__de
, cڡ *
__c
)

645 *
__tmp
 = 
__de
;

646 
__dummy
;

647 
__asm__
 
__vީe__


656 : "=&r" (
__c
), "=&r" (
__tmp
), "=&q" (
__dummy
),

657 "=m" ( *(ru { 
__x
[0xfffffff]; } *)
__de
)

658 : "0" (
__c
), "1" (
__tmp
),

659 "m" ( *(ru { 
__x
[0xfffffff]; } *)
__c
)

661  
__de
;

662 
	}
}

665 #ifde
__USE_GNU


666 
	#_HAVE_STRING_ARCH_py
 1

	)

668 
	#__py
(
de
, 
c
) \

669 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
c
) \

670 ? (
	`
 (
c
) + 1 <= 8 \

671 ? 
	`__py_a_sml
 ((
de
), (
c
), 
	`
 (src) + 1) \

672 : 
	`__py_c
 ((
de
), (
c
), 
	`
 (src) + 1)) \

673 : 
	`__py_g
 ((
de
), (
c
))))

	)

674 
	#__py_c
(
de
, 
c
, 

) \

675 ((

) % 4 == 0 \

676 ? 
	`__mempy_by4
 (
de
, 
c
, 

) - 1 \

677 : ((

) % 2 == 0 \

678 ? 
	`__mempy_by2
 (
de
, 
c
, 

) - 1 \

679 : 
	`__mempy_byn
 (
de
, 
c
, 

- 1))

	)

682 
	#py
(
de
, 
c

	`__py
 ((de), (c))

	)

684 
	#__py_a_sml
(
de
, 
c
, 

) \

685 (
	`__exnsi__
 ({ union { \

686 
__ui
; \

687 
__usi
; \

688 
__uc
; \

689 
__c
; \

690 } *
__u
 = (*(
de
); \

691 

) \

694 
__u
->
__uc
 = '\0'; \

697 
__u
->
__usi
 = 
	`__STRING_SMALL_GET16
 (
c
, 0); \

698 
__u
 = 
	`__exnsi__
 ((*) __u + 1); \

701 
__u
->
__usi
 = 
	`__STRING_SMALL_GET16
 (
c
, 0); \

702 
__u
 = 
	`__exnsi__
 ((*) __u + 2); \

703 
__u
->
__uc
 = '\0'; \

706 
__u
->
__ui
 = 
	`__STRING_SMALL_GET32
 (
c
, 0); \

707 
__u
 = 
	`__exnsi__
 ((*) __u + 3); \

710 
__u
->
__ui
 = 
	`__STRING_SMALL_GET32
 (
c
, 0); \

711 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

712 
__u
->
__uc
 = '\0'; \

715 
__u
->
__ui
 = 
	`__STRING_SMALL_GET32
 (
c
, 0); \

716 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

717 
__u
->
__usi
 = 
	`__STRING_SMALL_GET16
 (
c
, 4); \

718 
__u
 = 
	`__exnsi__
 ((*) __u + 1); \

721 
__u
->
__ui
 = 
	`__STRING_SMALL_GET32
 (
c
, 0); \

722 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

723 
__u
->
__usi
 = 
	`__STRING_SMALL_GET16
 (
c
, 4); \

724 
__u
 = 
	`__exnsi__
 ((*) __u + 2); \

725 
__u
->
__uc
 = '\0'; \

728 
__u
->
__ui
 = 
	`__STRING_SMALL_GET32
 (
c
, 0); \

729 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

730 
__u
->
__ui
 = 
	`__STRING_SMALL_GET32
 (
c
, 4); \

731 
__u
 = 
	`__exnsi__
 ((*) __u + 3); \

734 (*
__u
; }))

	)

736 
__STRING_INLINE
 *
__mempy_by4
 (*
__de
, cڡ *
__c
,

737 
size_t
 
__
);

739 
__STRING_INLINE
 *

740 
	$__mempy_by4
 (*
__de
, cڡ *
__c
, 
size_t
 
__
)

742 *
__tmp
 = 
__de
;

743 
__d0
, 
__d1
;

744 
__asm__
 
__vީe__


752 : "=&r" (
__d0
), "" (
__tmp
), "=&r" (
__c
), "=&r" (
__d1
)

753 : "1" (
__tmp
), "2" (
__c
), "3" (
__
 / 4)

755  
__tmp
;

756 
	}
}

758 
__STRING_INLINE
 *
__mempy_by2
 (*
__de
, cڡ *
__c
,

759 
size_t
 
__
);

761 
__STRING_INLINE
 *

762 
	$__mempy_by2
 (*
__de
, cڡ *
__c
, 
size_t
 
__
)

764 *
__tmp
 = 
__de
;

765 
__d0
, 
__d1
;

766 
__asm__
 
__vީe__


779 : "=&q" (
__d0
), "" (
__tmp
), "=&r" (
__c
), "=&r" (
__d1
),

780 "=m" ( *(ru { 
__exnsi__
 
__x
[
__
]; } *)
__de
)

781 : "1" (
__tmp
), "2" (
__c
), "3" (
__
 / 2),

782 "m" ( *(ru { 
__exnsi__
 
__x
[
__
]; } *)
__c
)

784  
__tmp
 + 2;

785 
	}
}

787 
__STRING_INLINE
 *
__mempy_byn
 (*
__de
, cڡ *
__c
,

788 
size_t
 
__
);

790 
__STRING_INLINE
 *

791 
	$__mempy_byn
 (*
__de
, cڡ *
__c
, 
size_t
 
__
)

793 
__d0
, 
__d1
;

794 *
__tmp
 = 
__de
;

795 
__asm__
 
__vީe__


806 : "=D" (
__tmp
), "=&c" (
__d0
), "=&S" (
__d1
),

807 "=m" ( *(ru { 
__exnsi__
 
__x
[
__
]; } *)
__de
)

808 : "0" (
__tmp
), "1" (
__
), "2" (
__c
),

809 "m" ( *(ru { 
__exnsi__
 
__x
[
__
]; } *)
__c
)

811  
__tmp
;

812 
	}
}

814 
__STRING_INLINE
 *
__py_g
 (*
__de
, cڡ *
__c
);

816 
__STRING_INLINE
 *

817 
	$__py_g
 (*
__de
, cڡ *
__c
)

819 *
__tmp
 = 
__de
;

820 
__dummy
;

821 
__asm__
 
__vީe__


830 : "=&r" (
__c
), "" (
__tmp
), "=&q" (
__dummy
),

831 "=m" ( *(ru { 
__x
[0xfffffff]; } *)
__de
)

832 : "0" (
__c
), "1" (
__tmp
),

833 "m" ( *(ru { 
__x
[0xfffffff]; } *)
__c
)

835  
__tmp
 - 1;

836 
	}
}

841 
	#_HAVE_STRING_ARCH_y
 1

	)

842 
	#y
(
de
, 
c
, 
n
) \

843 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
c
) \

844 ? ((
	`
 (
c
+ 1 >((
size_t
(
n
)) \

845 ? (*
	`memy
 ((*(
de
), \

846 (cڡ *(
c
), 
n
) \

847 : 
	`__y_cg
 ((
de
), (
c
), 
	`
 (c+ 1, 
n
))) \

848 : 
	`__y_gg
 ((
de
), (
c
), 
n
)))

	)

849 
	#__y_cg
(
de
, 
c
, 

, 
n
) \

850 (((

) % 4 == 0) \

851 ? 
	`__y_by4
 (
de
, 
c
, 

, 
n
) \

852 : (((

) % 2 == 0) \

853 ? 
	`__y_by2
 (
de
, 
c
, 

, 
n
) \

854 : 
	`__y_byn
 (
de
, 
c
, 

, 
n
)))

	)

856 
__STRING_INLINE
 *
__y_by4
 (*
__de
, cڡ 
__c
[],

857 
size_t
 
__
, size_
__n
);

859 
__STRING_INLINE
 *

860 
	$__y_by4
 (*
__de
, cڡ 
__c
[], 
size_t
 
__
, size_
__n
)

862 *
__tmp
 = 
__de
;

863 
__dummy1
, 
__dummy2
;

864 
__asm__
 
__vީe__


872 : "=&r" (
__dummy1
), "" (
__tmp
), "=&r" (
__c
), "=&r" (
__dummy2
),

873 "=m" ( *(ru { 
__exnsi__
 
__x
[
__
]; } *)
__de
)

874 : "1" (
__tmp
), "2" (
__c
), "3" (
__
 / 4),

875 "m" ( *(ru { 
__exnsi__
 
__x
[
__
]; } *)
__c
)

877 (
	`memt
 (
__tmp
, '\0', 
__n
 - 
__
);

878  
__de
;

879 
	}
}

881 
__STRING_INLINE
 *
__y_by2
 (*
__de
, cڡ 
__c
[],

882 
size_t
 
__
, size_
__n
);

884 
__STRING_INLINE
 *

885 
	$__y_by2
 (*
__de
, cڡ 
__c
[], 
size_t
 
__
, size_
__n
)

887 *
__tmp
 = 
__de
;

888 
__dummy1
, 
__dummy2
;

889 
__asm__
 
__vީe__


902 : "=&q" (
__dummy1
), "" (
__tmp
), "=&r" (
__c
), "=&r" (
__dummy2
),

903 "=m" ( *(ru { 
__exnsi__
 
__x
[
__
]; } *)
__de
)

904 : "1" (
__tmp
), "2" (
__c
), "3" (
__
 / 2),

905 "m" ( *(ru { 
__exnsi__
 
__x
[
__
]; } *)
__c
)

907 (
	`memt
 (
__tmp
 + 2, '\0', 
__n
 - 
__
);

908  
__de
;

909 
	}
}

911 
__STRING_INLINE
 *
__y_byn
 (*
__de
, cڡ 
__c
[],

912 
size_t
 
__
, size_
__n
);

914 
__STRING_INLINE
 *

915 
	$__y_byn
 (*
__de
, cڡ 
__c
[], 
size_t
 
__
, size_
__n
)

917 
__d0
, 
__d1
;

918 *
__tmp
 = 
__de
;

919 
__asm__
 
__vީe__


930 : "=D" (
__tmp
), "=&c" (
__d0
), "=&S" (
__d1
),

931 "=m" ( *(ru { 
__exnsi__
 
__x
[
__
]; } *)
__de
)

932 : "1" (
__
), "0" (
__tmp
),"2" (
__c
),

933 "m" ( *(ru { 
__exnsi__
 
__x
[
__
]; } *)
__c
)

935 (
	`memt
 (
__tmp
, '\0', 
__n
 - 
__
);

936  
__de
;

937 
	}
}

939 
__STRING_INLINE
 *
__y_gg
 (*
__de
, cڡ *
__c
,

940 
size_t
 
__n
);

942 
__STRING_INLINE
 *

943 
	$__y_gg
 (*
__de
, cڡ *
__c
, 
size_t
 
__n
)

945 *
__tmp
 = 
__de
;

946 
__dummy
;

947 i(
__n
 > 0)

948 
__asm__
 
__vީe__


964 : "=&r" (
__c
), "=&r" (
__tmp
), "=&q" (
__dummy
), "=&r" (
__n
)

965 : "0" (
__c
), "1" (
__tmp
), "3" (
__n
)

968  
__de
;

969 
	}
}

973 
	#_HAVE_STRING_ARCH_rt
 1

	)

974 
	#rt
(
de
, 
c
) \

975 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
c
) \

976 ? 
	`__rt_c
 ((
de
), (
c
), 
	`
 (src) + 1) \

977 : 
	`__rt_g
 ((
de
), (
c
))))

	)

979 
__STRING_INLINE
 *
__rt_c
 (*
__de
, cڡ 
__c
[],

980 
size_t
 
__
);

982 
__STRING_INLINE
 *

983 
	$__rt_c
 (*
__de
, cڡ 
__c
[], 
size_t
 
__
)

985 #ifde
__i686__


986 
__d0
;

987 *
__tmp
;

988 
__asm__
 
__vީe__


990 : "=D" (
__tmp
), "=&c" (
__d0
),

991 "=m" ( *(ru { 
__x
[0xfffffff]; } *)
__de
)

992 : "0" (
__de
), "1" (0xffffffff), "a" (0),

993 "m" ( *(ru { 
__exnsi__
 
__x
[
__
]; } *)
__c
)

995 --
__tmp
;

997 *
__tmp
 = 
__de
 - 1;

998 
__asm__
 
__vީe__


1003 : "" (
__tmp
),

1004 "=m" ( *(ru { 
__x
[0xfffffff]; } *)
__de
)

1005 : "0" (
__tmp
),

1006 "m" ( *(ru { 
__exnsi__
 
__x
[
__
]; } *)
__c
)

1009 (
	`memy
 (
__tmp
, 
__c
, 
__
);

1010  
__de
;

1011 
	}
}

1013 
__STRING_INLINE
 *
__rt_g
 (*
__de
, cڡ *
__c
);

1015 
__STRING_INLINE
 *

1016 
	$__rt_g
 (*
__de
, cڡ *
__c
)

1018 *
__tmp
 = 
__de
 - 1;

1019 
__dummy
;

1020 
__asm__
 
__vީe__


1032 : "=&q" (
__dummy
), "=&r" (
__tmp
), "=&r" (
__c
),

1033 "=m" ( *(ru { 
__x
[0xfffffff]; } *)
__de
)

1034 : "1" (
__tmp
), "2" (
__c
),

1035 "m" ( *(ru { 
__x
[0xfffffff]; } *)
__c
)

1037  
__de
;

1038 
	}
}

1042 
	#_HAVE_STRING_ARCH_t
 1

	)

1043 
	#t
(
de
, 
c
, 
n
) \

1044 (
	`__exnsi__
 ({ *
__de
 = (
de
); \

1045 
	`__but_cڡt_p
 (
c
&& __but_cڡt_(
n
) \

1046 ? (
	`
 (
c
< ((
size_t
(
n
)) \

1047 ? 
	`rt
 (
__de
, (
c
)) \

1048 : (*(*)
	`__mempy
 (
	`rchr
 (
__de
, '\0'), \

1049 (cڡ *(
c
), \

1050 (
n
)0, 
__de
)) \

1051 : 
	`__t_g
 (
__de
, (
c
), (
n
)); }))

	)

1053 
__STRING_INLINE
 *
__t_g
 (*
__de
, cڡ 
__c
[],

1054 
size_t
 
__n
);

1056 
__STRING_INLINE
 *

1057 
	$__t_g
 (*
__de
, cڡ 
__c
[], 
size_t
 
__n
)

1059 *
__tmp
 = 
__de
;

1060 
__dummy
;

1061 #ifde
__i686__


1062 
__asm__
 
__vީe__


1076 : "=&a" (
__dummy
), "=&D" (
__tmp
), "=&S" (
__c
), "=&c" (
__n
)

1077 : "g" (
__n
), "0" (0), "1" (
__tmp
), "2" (
__c
), "3" (0xffffffff)

1080 --
__tmp
;

1081 
__asm__
 
__vީe__


1098 : "=&q" (
__dummy
), "=&r" (
__tmp
), "=&r" (
__c
), "=&r" (
__n
)

1099 : "1" (
__tmp
), "2" (
__c
), "3" (
__n
)

1102  
__de
;

1103 
	}
}

1107 
	#_HAVE_STRING_ARCH_rcmp
 1

	)

1108 
	#rcmp
(
s1
, 
s2
) \

1109 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
s1
&& __but_cڡt_(
s2
) \

1110 && ( ((
s1
)[0]!1 || 
	`
 (s1) >= 4) \

1111 && ( ((
s2
)[0]!1 || 
	`
 (s2) >= 4) \

1112 ? 
	`memcmp
 ((cڡ *(
s1
), (cڡ *(
s2
), \

1113 (
	`
 (
s1
< s(
s2
) \

1114 ? 
	`
 (
s1
: s(
s2
)) + 1) \

1115 : (
	`__but_cڡt_p
 (
s1
) &&  ((s1)[0]) == 1 \

1116 &&  ((
s2
)[0]=1 && 
	`
 (
s1
) < 4 \

1117 ? (
	`__but_cڡt_p
 (
s2
) &&  ((s2)[0]) == 1 \

1118 ? 
	`__rcmp_cc
 ((cڡ *(
s1
), \

1119 (cڡ *(
s2
), \

1120 
	`
 (
s1
)) \

1121 : 
	`__rcmp_cg
 ((cڡ *(
s1
), \

1122 (cڡ *(
s2
), \

1123 
	`
 (
s1
))) \

1124 : (
	`__but_cڡt_p
 (
s2
&&  ((
s1
)[0]) == 1 \

1125 &&  ((
s2
)[0]=1 && 
	`
 (s2) < 4 \

1126 ? (
	`__but_cڡt_p
 (
s1
) \

1127 ? 
	`__rcmp_cc
 ((cڡ *(
s1
), \

1128 (cڡ *(
s2
), \

1129 
	`
 (
s2
)) \

1130 : 
	`__rcmp_gc
 ((cڡ *(
s1
), \

1131 (cڡ *(
s2
), \

1132 
	`
 (
s2
))) \

1133 : 
	`__rcmp_gg
 ((
s1
), (
s2
))))))

	)

1135 
	#__rcmp_cc
(
s1
, 
s2
, 
l
) \

1136 (
	`__exnsi__
 ({ 
__su
 = (
s1
)[0] - (
s2
)[0]; \

1137 i(
l
 > 0 && 
__su
 == 0) \

1139 
__su
 = (
s1
)[1] - (
s2
)[1]; \

1140 i(
l
 > 1 && 
__su
 == 0) \

1142 
__su
 = (
s1
)[2] - (
s2
)[2]; \

1143 i(
l
 > 2 && 
__su
 == 0) \

1144 
__su
 = (
s1
)[3] - (
s2
)[3]; \

1147 
__su
; }))

	)

1149 
	#__rcmp_cg
(
s1
, 
s2
, 
l1
) \

1150 (
	`__exnsi__
 ({ cڡ *
__s2
 = (
s2
); \

1151 
__su
 = (
s1
)[0] - 
__s2
[0]; \

1152 i(
l1
 > 0 && 
__su
 == 0) \

1154 
__su
 = (
s1
)[1] - 
__s2
[1]; \

1155 i(
l1
 > 1 && 
__su
 == 0) \

1157 
__su
 = (
s1
)[2] - 
__s2
[2]; \

1158 i(
l1
 > 2 && 
__su
 == 0) \

1159 
__su
 = (
s1
)[3] - 
__s2
[3]; \

1162 
__su
; }))

	)

1164 
	#__rcmp_gc
(
s1
, 
s2
, 
l2
) \

1165 (
	`__exnsi__
 ({ cڡ *
__s1
 = (
s1
); \

1166 
__su
 = 
__s1
[0] - (
s2
)[0]; \

1167 i(
l2
 > 0 && 
__su
 == 0) \

1169 
__su
 = 
__s1
[1] - (
s2
)[1]; \

1170 i(
l2
 > 1 && 
__su
 == 0) \

1172 
__su
 = 
__s1
[2] - (
s2
)[2]; \

1173 i(
l2
 > 2 && 
__su
 == 0) \

1174 
__su
 = 
__s1
[3] - (
s2
)[3]; \

1177 
__su
; }))

	)

1179 
__STRING_INLINE
 
__rcmp_gg
 (cڡ *
__s1
, cڡ *
__s2
);

1181 
__STRING_INLINE
 

1182 
	$__rcmp_gg
 (cڡ *
__s1
, cڡ *
__s2
)

1184 
__s
;

1185 
__asm__
 
__vީe__


1201 : "=q" (
__s
), "=&r" (
__s1
), "=&r" (
__s2
)

1202 : "1" (
__s1
), "2" (
__s2
),

1203 "m" ( *(ru { 
__x
[0xfffffff]; } *)
__s1
),

1204 "m" ( *(ru { 
__x
[0xfffffff]; } *)
__s2
)

1206  
__s
;

1207 
	}
}

1211 
	#_HAVE_STRING_ARCH_cmp
 1

	)

1212 
	#cmp
(
s1
, 
s2
, 
n
) \

1213 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
s1
&& 
	`
 (s1< ((
size_t
(
n
)) \

1214 ? 
	`rcmp
 ((
s1
), (
s2
)) \

1215 : (
	`__but_cڡt_p
 (
s2
&& 
	`
 (s2< ((
size_t
(
n
))\

1216 ? 
	`rcmp
 ((
s1
), (
s2
)) \

1217 : 
	`__cmp_g
 ((
s1
), (
s2
), (
n
)))))

	)

1219 
__STRING_INLINE
 
__cmp_g
 (cڡ *
__s1
, cڡ *
__s2
,

1220 
size_t
 
__n
);

1222 
__STRING_INLINE
 

1223 
	$__cmp_g
 (cڡ *
__s1
, cڡ *
__s2
, 
size_t
 
__n
)

1225 
__s
;

1226 
__asm__
 
__vީe__


1245 : "=q" (
__s
), "=&r" (
__s1
), "=&r" (
__s2
), "=&r" (
__n
)

1246 : "1" (
__s1
), "2" (
__s2
), "3" (
__n
),

1247 "m" ( *(ru { 
__exnsi__
 
__x
[
__n
]; } *)
__s1
),

1248 "m" ( *(ru { 
__exnsi__
 
__x
[
__n
]; } *)
__s2
)

1250  
__s
;

1251 
	}
}

1255 
	#_HAVE_STRING_ARCH_rchr
 1

	)

1256 
	#_USE_STRING_ARCH_rchr
 1

	)

1257 
	#rchr
(
s
, 
c
) \

1258 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
c
) \

1259 ? ((
c
) == '\0' \

1260 ? (*
	`__wmemchr
 ((
s
), (
c
)) \

1261 : 
	`__rchr_c
 ((
s
), ((
c
) & 0xff) << 8)) \

1262 : 
	`__rchr_g
 ((
s
), (
c
))))

	)

1264 
__STRING_INLINE
 *
__rchr_c
 (cڡ *
__s
, 
__c
);

1266 
__STRING_INLINE
 *

1267 
	$__rchr_c
 (cڡ *
__s
, 
__c
)

1269 
__d0
;

1270 *
__s
;

1271 
__asm__
 
__vީe__


1281 : "" (
__s
), "=&a" (
__d0
)

1282 : "0" (
__s
), "1" (
__c
),

1283 "m" ( *(ru { 
__x
[0xfffffff]; } *)
__s
)

1285  
__s
;

1286 
	}
}

1288 
__STRING_INLINE
 *
__rchr_g
 (cڡ *
__s
, 
__c
);

1290 
__STRING_INLINE
 *

1291 
	$__rchr_g
 (cڡ *
__s
, 
__c
)

1293 
__d0
;

1294 *
__s
;

1295 
__asm__
 
__vީe__


1306 : "" (
__s
), "=&a" (
__d0
)

1307 : "0" (
__s
), "1" (
__c
),

1308 "m" ( *(ru { 
__x
[0xfffffff]; } *)
__s
)

1310  
__s
;

1311 
	}
}

1315 
	#_HAVE_STRING_ARCH_rchul
 1

	)

1316 
	#__rchul
(
s
, 
c
) \

1317 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
c
) \

1318 ? ((
c
) == '\0' \

1319 ? (*
	`__wmemchr
 ((
s
), 
c
) \

1320 : 
	`__rchul_c
 ((
s
), ((
c
) & 0xff) << 8)) \

1321 : 
	`__rchul_g
 ((
s
), 
c
)))

	)

1323 
__STRING_INLINE
 *
__rchul_c
 (cڡ *
__s
, 
__c
);

1325 
__STRING_INLINE
 *

1326 
	$__rchul_c
 (cڡ *
__s
, 
__c
)

1328 
__d0
;

1329 *
__s
;

1330 
__asm__
 
__vީe__


1340 : "" (
__s
), "=&a" (
__d0
)

1341 : "0" (
__s
), "1" (
__c
),

1342 "m" ( *(ru { 
__x
[0xfffffff]; } *)
__s
)

1344  
__s
;

1345 
	}
}

1347 
__STRING_INLINE
 *
__rchul_g
 (cڡ *
__s
, 
__c
);

1349 
__STRING_INLINE
 *

1350 
	$__rchul_g
 (cڡ *
__s
, 
__c
)

1352 
__d0
;

1353 *
__s
;

1354 
__asm__
 
__vީe__


1365 : "" (
__s
), "=&a" (
__d0
)

1366 : "0" (
__s
), "1" (
__c
),

1367 "m" ( *(ru { 
__x
[0xfffffff]; } *)
__s
)

1369  
__s
;

1370 
	}
}

1371 #ifde
__USE_GNU


1372 
	#rchul
(
s
, 
c

	`__rchul
 ((s), (c))

	)

1376 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN_EXTENDED


1378 
	#_HAVE_STRING_ARCH_dex
 1

	)

1379 
	#dex
(
s
, 
c
) \

1380 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
c
) \

1381 ? 
	`__rchr_c
 ((
s
), ((
c
) & 0xff) << 8) \

1382 : 
	`__rchr_g
 ((
s
), (
c
))))

	)

1387 
	#_HAVE_STRING_ARCH_chr
 1

	)

1388 
	#chr
(
s
, 
c
) \

1389 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
c
) \

1390 ? 
	`__chr_c
 ((
s
), ((
c
) & 0xff) << 8) \

1391 : 
	`__chr_g
 ((
s
), (
c
))))

	)

1393 #ifde
__i686__


1394 
__STRING_INLINE
 *
__chr_c
 (cڡ *
__s
, 
__c
);

1396 
__STRING_INLINE
 *

1397 
	$__chr_c
 (cڡ *
__s
, 
__c
)

1399 
__d0
, 
__d1
;

1400 *
__s
;

1401 
__asm__
 
__vީe__


1409 : "=d" (
__s
), "=&S" (
__d0
), "=&a" (
__d1
)

1410 : "0" (1), "1" (
__s
), "2" (
__c
),

1411 "m" ( *(ru { 
__x
[0xfffffff]; } *)
__s
)

1413  
__s
 - 1;

1414 
	}
}

1416 
__STRING_INLINE
 *
__chr_g
 (cڡ *
__s
, 
__c
);

1418 
__STRING_INLINE
 *

1419 
	$__chr_g
 (cڡ *
__s
, 
__c
)

1421 
__d0
, 
__d1
;

1422 *
__s
;

1423 
__asm__
 
__vީe__


1432 : "=d" (
__s
), "=&S" (
__d0
), "=&a" (
__d1
)

1433 : "0" (1), "1" (
__s
), "2" (
__c
),

1434 "m" ( *(ru { 
__x
[0xfffffff]; } *)
__s
)

1436  
__s
 - 1;

1437 
	}
}

1439 
__STRING_INLINE
 *
__chr_c
 (cڡ *
__s
, 
__c
);

1441 
__STRING_INLINE
 *

1442 
	$__chr_c
 (cڡ *
__s
, 
__c
)

1444 
__d0
, 
__d1
;

1445 *
__s
;

1446 
__asm__
 
__vީe__


1456 : "=d" (
__s
), "=&S" (
__d0
), "=&a" (
__d1
)

1457 : "0" (0), "1" (
__s
), "2" (
__c
),

1458 "m" ( *(ru { 
__x
[0xfffffff]; } *)
__s
)

1460  
__s
;

1461 
	}
}

1463 
__STRING_INLINE
 *
__chr_g
 (cڡ *
__s
, 
__c
);

1465 
__STRING_INLINE
 *

1466 
	$__chr_g
 (cڡ *
__s
, 
__c
)

1468 
__d0
, 
__d1
;

1469 *
__s
;

1470 
__asm__
 
__vީe__


1481 : "" (
__s
), "=&S" (
__d0
), "=&a" (
__d1
)

1482 : "0" (0), "1" (
__s
), "2" (
__c
),

1483 "m" ( *(ru { 
__x
[0xfffffff]; } *)
__s
)

1485  
__s
;

1486 
	}
}

1490 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN_EXTENDED


1492 
	#_HAVE_STRING_ARCH_rdex
 1

	)

1493 
	#rdex
(
s
, 
c
) \

1494 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
c
) \

1495 ? 
	`__chr_c
 ((
s
), ((
c
) & 0xff) << 8) \

1496 : 
	`__chr_g
 ((
s
), (
c
))))

	)

1502 
	#_HAVE_STRING_ARCH_rcn
 1

	)

1503 
	#rcn
(
s
, 
je
) \

1504 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
je
) &&  ((reject)[0]) == 1 \

1505 ? ((
je
)[0] == '\0' \

1506 ? 
	`
 (
s
) \

1507 : ((
je
)[1] == '\0' \

1508 ? 
	`__rcn_c1
 ((
s
), (((
je
)[0] << 8) & 0xff00)) \

1509 : 
	`__rcn_cg
 ((
s
), (
je
), 
	`
 (reject)))) \

1510 : 
	`__rcn_g
 ((
s
), (
je
))))

	)

1512 
__STRING_INLINE
 
size_t
 
__rcn_c1
 (cڡ *
__s
, 
__je
);

1514 #ide
_FORCE_INLINES


1515 
__STRING_INLINE
 
size_t


1516 
	$__rcn_c1
 (cڡ *
__s
, 
__je
)

1518 
__d0
;

1519 *
__s
;

1520 
__asm__
 
__vީe__


1529 : "" (
__s
), "=&a" (
__d0
)

1530 : "0" (
__s
), "1" (
__je
),

1531 "m" ( *(ru { 
__x
[0xfffffff]; } *)
__s
)

1533  (
__s
 - 1- 
__s
;

1534 
	}
}

1537 
__STRING_INLINE
 
size_t
 
__rcn_cg
 (cڡ *
__s
, cڡ 
__je
[],

1538 
size_t
 
__je_n
);

1540 
__STRING_INLINE
 
size_t


1541 
	$__rcn_cg
 (cڡ *
__s
, cڡ 
__je
[], 
size_t
 
__je_n
)

1543 
__d0
, 
__d1
, 
__d2
;

1544 cڡ *
__s
;

1545 
__asm__
 
__vީe__


1556 : "=S" (
__s
), "=&a" (
__d0
), "=&c" (
__d1
), "=&D" (
__d2
)

1557 : "0" (
__s
), "d" (
__je
), "g" (
__je_n
)

1559  (
__s
 - 1- 
__s
;

1560 
	}
}

1562 
__STRING_INLINE
 
size_t
 
__rcn_g
 (cڡ *
__s
, cڡ *
__je
);

1563 #ifde
__PIC__


1565 
__STRING_INLINE
 
size_t


1566 
	$__rcn_g
 (cڡ *
__s
, cڡ *
__je
)

1568 
__d0
, 
__d1
, 
__d2
;

1569 cڡ *
__s
;

1570 
__asm__
 
__vީe__


1587 : "=S" (
__s
), "=&a" (
__d0
), "=&c" (
__d1
), "=&D" (
__d2
)

1588 : "r" (
__je
), "0" (
__s
), "1" (0), "2" (0xffffffff)

1590  (
__s
 - 1- 
__s
;

1591 
	}
}

1593 
__STRING_INLINE
 
size_t


1594 
	$__rcn_g
 (cڡ *
__s
, cڡ *
__je
)

1596 
__d0
, 
__d1
, 
__d2
, 
__d3
;

1597 cڡ *
__s
;

1598 
__asm__
 
__vީe__


1612 : "=S" (
__s
), "=&a" (
__d0
), "=&c" (
__d1
), "=&D" (
__d2
), "=&d" (
__d3
)

1613 : "0" (
__s
), "1" (0), "2" (0xffffffff), "3" (
__je
), "b" (__reject)

1616  (
__s
 - 1- 
__s
;

1617 
	}
}

1623 
	#_HAVE_STRING_ARCH_rn
 1

	)

1624 
	#rn
(
s
, 
ac
) \

1625 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
ac
) &&  ((accept)[0]) == 1 \

1626 ? ((
ac
)[0] == '\0' \

1627 ? (((
s
), 0) \

1628 : ((
ac
)[1] == '\0' \

1629 ? 
	`__rn_c1
 ((
s
), (((
ac
)[0] << 8 ) & 0xff00)) \

1630 : 
	`__rn_cg
 ((
s
), (
ac
), 
	`
 (accept)))) \

1631 : 
	`__rn_g
 ((
s
), (
ac
))))

	)

1633 #ide
_FORCE_INLINES


1634 
__STRING_INLINE
 
size_t
 
__rn_c1
 (cڡ *
__s
, 
__ac
);

1636 
__STRING_INLINE
 
size_t


1637 
	$__rn_c1
 (cڡ *
__s
, 
__ac
)

1639 
__d0
;

1640 *
__s
;

1642 
__asm__
 
__vީe__


1648 : "" (
__s
), "=&q" (
__d0
)

1649 : "0" (
__s
), "1" (
__ac
),

1650 "m" ( *(ru { 
__x
[0xfffffff]; } *)
__s
)

1652  (
__s
 - 1- 
__s
;

1653 
	}
}

1656 
__STRING_INLINE
 
size_t
 
__rn_cg
 (cڡ *
__s
, cڡ 
__ac
[],

1657 
size_t
 
__ac_n
);

1659 
__STRING_INLINE
 
size_t


1660 
	$__rn_cg
 (cڡ *
__s
, cڡ 
__ac
[], 
size_t
 
__ac_n
)

1662 
__d0
, 
__d1
, 
__d2
;

1663 cڡ *
__s
;

1664 
__asm__
 
__vީe__


1675 : "=S" (
__s
), "=&a" (
__d0
), "=&c" (
__d1
), "=&D" (
__d2
)

1676 : "0" (
__s
), "g" (
__ac
), "g" (
__ac_n
),

1679 "m" ( *(ru { 
__x
[0xfffffff]; } *)
__s
),

1680 "m" ( *(ru { 
__exnsi__
 
__x
[
__ac_n
]; } *)
__ac
)

1682  (
__s
 - 1- 
__s
;

1683 
	}
}

1685 
__STRING_INLINE
 
size_t
 
__rn_g
 (cڡ *
__s
, cڡ *
__ac
);

1686 #ifde
__PIC__


1688 
__STRING_INLINE
 
size_t


1689 
	$__rn_g
 (cڡ *
__s
, cڡ *
__ac
)

1691 
__d0
, 
__d1
, 
__d2
;

1692 cڡ *
__s
;

1693 
__asm__
 
__vީe__


1709 : "=S" (
__s
), "=&a" (
__d0
), "=&c" (
__d1
), "=&D" (
__d2
)

1710 : "d" (
__ac
), "0" (
__s
), "1" (0), "2" (0xffffffff), "3" (__accept)

1712  (
__s
 - 1- 
__s
;

1713 
	}
}

1715 
__STRING_INLINE
 
size_t


1716 
	$__rn_g
 (cڡ *
__s
, cڡ *
__ac
)

1718 
__d0
, 
__d1
, 
__d2
, 
__d3
;

1719 cڡ *
__s
;

1720 
__asm__
 
__vީe__


1734 : "=S" (
__s
), "=&a" (
__d0
), "=&c" (
__d1
), "=&D" (
__d2
), "=&d" (
__d3
)

1735 : "0" (
__s
), "1" (0), "2" (0xffffffff), "3" (
__ac
), "b" (__accept)

1737  (
__s
 - 1- 
__s
;

1738 
	}
}

1743 
	#_HAVE_STRING_ARCH_brk
 1

	)

1744 
	#brk
(
s
, 
ac
) \

1745 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
ac
) &&  ((accept)[0]) == 1 \

1746 ? ((
ac
)[0] == '\0' \

1747 ? (((
s
), (*) 0) \

1748 : ((
ac
)[1] == '\0' \

1749 ? 
	`rchr
 ((
s
), (
ac
)[0]) \

1750 : 
	`__brk_cg
 ((
s
), (
ac
), 
	`
 (accept)))) \

1751 : 
	`__brk_g
 ((
s
), (
ac
))))

	)

1753 
__STRING_INLINE
 *
__brk_cg
 (cڡ *
__s
, cڡ 
__ac
[],

1754 
size_t
 
__ac_n
);

1756 
__STRING_INLINE
 *

1757 
	$__brk_cg
 (cڡ *
__s
, cڡ 
__ac
[], 
size_t
 
__ac_n
)

1759 
__d0
, 
__d1
, 
__d2
;

1760 *
__s
;

1761 
__asm__
 
__vީe__


1776 : "=S" (
__s
), "=&a" (
__d0
), "=&c" (
__d1
), "=&D" (
__d2
)

1777 : "0" (
__s
), "d" (
__ac
), "g" (
__ac_n
)

1779  
__s
;

1780 
	}
}

1782 
__STRING_INLINE
 *
__brk_g
 (cڡ *
__s
, cڡ *
__ac
);

1783 #ifde
__PIC__


1785 
__STRING_INLINE
 *

1786 
	$__brk_g
 (cڡ *
__s
, cڡ *
__ac
)

1788 
__d0
, 
__d1
, 
__d2
;

1789 *
__s
;

1790 
__asm__
 
__vީe__


1811 : "=S" (
__s
), "=&a" (
__d0
), "=&c" (
__d1
), "=&D" (
__d2
)

1812 : "d" (
__ac
), "0" (
__s
), "1" (0), "2" (0xffffffff)

1814  
__s
;

1815 
	}
}

1817 
__STRING_INLINE
 *

1818 
	$__brk_g
 (cڡ *
__s
, cڡ *
__ac
)

1820 
__d0
, 
__d1
, 
__d2
, 
__d3
;

1821 *
__s
;

1822 
__asm__
 
__vީe__


1841 : "=S" (
__s
), "=&a" (
__d0
), "=&c" (
__d1
), "=&d" (
__d2
), "=&D" (
__d3
)

1842 : "0" (
__s
), "1" (0), "2" (0xffffffff), "b" (
__ac
)

1844  
__s
;

1845 
	}
}

1850 
	#_HAVE_STRING_ARCH_rr
 1

	)

1851 
	#rr
(
hayack
, 
ed
) \

1852 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
ed
) &&  ((needle)[0]) == 1 \

1853 ? ((
ed
)[0] == '\0' \

1854 ? (
hayack
) \

1855 : ((
ed
)[1] == '\0' \

1856 ? 
	`rchr
 ((
hayack
), (
ed
)[0]) \

1857 : 
	`__rr_cg
 ((
hayack
), (
ed
), \

1858 
	`
 (
ed
)))) \

1859 : 
	`__rr_g
 ((
hayack
), (
ed
))))

	)

1863 
__STRING_INLINE
 *
__rr_cg
 (cڡ *
__hayack
,

1864 cڡ 
__ed
[],

1865 
size_t
 
__ed_n
);

1867 
__STRING_INLINE
 *

1868 
	$__rr_cg
 (cڡ *
__hayack
, cڡ 
__ed
[],

1869 
size_t
 
__ed_n
)

1871 
__d0
, 
__d1
, 
__d2
;

1872 *
__s
;

1873 
__asm__
 
__vީe__


1886 : "=&a" (
__s
), "=&S" (
__d0
), "=&D" (
__d1
), "=&c" (
__d2
)

1887 : "g" (
__ed_n
), "1" (
__hayack
), "d" (
__ed
)

1889  
__s
;

1890 
	}
}

1892 
__STRING_INLINE
 *
__rr_g
 (cڡ *
__hayack
,

1893 cڡ *
__ed
);

1894 #ifde
__PIC__


1896 
__STRING_INLINE
 *

1897 
	$__rr_g
 (cڡ *
__hayack
, cڡ *
__ed
)

1899 
__d0
, 
__d1
, 
__d2
;

1900 *
__s
;

1901 
__asm__
 
__vީe__


1920 : "=&a" (
__s
), "=&c" (
__d0
), "=&S" (
__d1
), "=&D" (
__d2
)

1921 : "0" (0), "1" (0xffffffff), "2" (
__hayack
), "3" (
__ed
),

1922 "d" (
__ed
)

1924  
__s
;

1925 
	}
}

1927 
__STRING_INLINE
 *

1928 
	$__rr_g
 (cڡ *
__hayack
, cڡ *
__ed
)

1930 
__d0
, 
__d1
, 
__d2
, 
__d3
;

1931 *
__s
;

1932 
__asm__
 
__vީe__


1949 : "=&a" (
__s
), "=&c" (
__d0
), "=&S" (
__d1
), "=&D" (
__d2
), "=&d" (
__d3
)

1950 : "0" (0), "1" (0xffffffff), "2" (
__hayack
), "3" (
__ed
),

1951 "b" (
__ed
)

1953  
__s
;

1954 
	}
}

1960 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN_EXTENDED


1961 #ifde
__i686__


1962 
	#_HAVE_STRING_ARCH_ffs
 1

	)

1963 
	#ffs
(
wd
(
	`__but_cڡt_p
 (word) \

1964 ? 
	`__but_ffs
 (
wd
) \

1965 : ({ 
__t
, 
__tmp
; \

1966 
__asm__
 
__vީe__
 \

1969 : "=&r" (
__t
), "" (
__tmp
) \

1970 : "rm" (
wd
), "1" (-1)); \

1971 
__t
 + 1; }))

	)

1973 #ide
ff


1974 
	#ff
(
wd

	`ffs
(wd)

	)

1979 #ide
_FORCE_INLINES


1980 #unde
__STRING_INLINE


	@/usr/include/bits/string2.h

20 #ide
_STRING_H


24 #ide
__NO_STRING_INLINES


41 #ide
__STRING_INLINE


42 #ifde
__lulus


43 
	#__STRING_INLINE
 
le


	)

45 
	#__STRING_INLINE
 
__ex_le


	)

49 #i
_STRING_ARCH_uligd


51 
	~<dn.h
>

52 
	~<bs/tys.h
>

54 #i
__BYTE_ORDER
 =
__LITTLE_ENDIAN


55 
	#__STRING2_SMALL_GET16
(
c
, 
idx
) \

56 (((cڡ *(cڡ *(
c
))[
idx
 + 1] << 8 \

57 | ((cڡ *(cڡ *(
c
))[
idx
])

	)

58 
	#__STRING2_SMALL_GET32
(
c
, 
idx
) \

59 (((((cڡ *(cڡ *(
c
))[
idx
 + 3] << 8 \

60 | ((cڡ *(cڡ *(
c
))[
idx
 + 2]) << 8 \

61 | ((cڡ *(cڡ *(
c
))[
idx
 + 1]) << 8 \

62 | ((cڡ *(cڡ *(
c
))[
idx
])

	)

64 
	#__STRING2_SMALL_GET16
(
c
, 
idx
) \

65 (((cڡ *(cڡ *(
c
))[
idx
] << 8 \

66 | ((cڡ *(cڡ *(
c
))[
idx
 + 1])

	)

67 
	#__STRING2_SMALL_GET32
(
c
, 
idx
) \

68 (((((cڡ *(cڡ *(
c
))[
idx
] << 8 \

69 | ((cڡ *(cڡ *(
c
))[
idx
 + 1]) << 8 \

70 | ((cڡ *(cڡ *(
c
))[
idx
 + 2]) << 8 \

71 | ((cڡ *(cڡ *(
c
))[
idx
 + 3])

	)

76 
	#__STRING2_COPY_TYPE
(
N
) \

77 ru { 
__r
[
N
]; } \

78 
	t__ibu__
 ((
	t__cked__
)
	t__STRING2_COPY_ARR
##
	tN


	)

79 
	t__STRING2_COPY_TYPE
 (2);

80 
__STRING2_COPY_TYPE
 (3);

81 
__STRING2_COPY_TYPE
 (4);

82 
__STRING2_COPY_TYPE
 (5);

83 
__STRING2_COPY_TYPE
 (6);

84 
__STRING2_COPY_TYPE
 (7);

85 
__STRING2_COPY_TYPE
 (8);

86 #unde
__STRING2_COPY_TYPE


92 
	#__rg2_1br_p
(
__x
) \

93 ((
size_t
)(cڡ *)((
__x
+ 1- (size_t)(cڡ *)(__x=1)

	)

96 #i!
defed
 
_HAVE_STRING_ARCH_memt


97 #i!
__GNUC_PREREQ
 (3, 0)

98 #i
_STRING_ARCH_uligd


99 
	#memt
(
s
, 
c
, 
n
) \

100 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
n
) && (n) <= 16 \

101 ? ((
n
) == 1 \

102 ? 
	`__memt_1
 (
s
, 
c
) \

103 : 
	`__memt_gc
 (
s
, 
c
, 
n
)) \

104 : (
	`__but_cڡt_p
 (
c
) && (c) == '\0' \

105 ? ({ *
__s
 = (
s
); 
	`__bzo
 (__s, 
n
); __s; }) \

106 : 
	`memt
 (
s
, 
c
, 
n
))))

	)

108 
	#__memt_1
(
s
, 
c
({ *
__s
 = (s); \

109 *((
__ut8_t
 *
__s
(__ut8_t
c
; __s; })

	)

111 
	#__memt_gc
(
s
, 
c
, 
n
) \

112 ({ *
__s
 = (
s
); \

114 
__ui
; \

115 
__usi
; \

116 
__uc
; \

117 } *
__u
 = 
__s
; \

118 
__ut8_t
 
__c
 = (__ut8_t(
c
); \

121 ((
n
)) \

124 
__u
->
__ui
 = 
__c
 * 0x01010101; \

125 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

127 
__u
->
__ui
 = 
__c
 * 0x01010101; \

128 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

130 
__u
->
__ui
 = 
__c
 * 0x01010101; \

131 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

133 
__u
->
__usi
 = (
__c
 * 0x0101; \

134 
__u
 = 
	`__exnsi__
 ((*) __u + 2); \

135 
__u
->
__uc
 = (
__c
; \

139 
__u
->
__ui
 = 
__c
 * 0x01010101; \

140 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

142 
__u
->
__ui
 = 
__c
 * 0x01010101; \

143 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

145 
__u
->
__ui
 = 
__c
 * 0x01010101; \

146 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

148 
__u
->
__usi
 = (
__c
 * 0x0101; \

152 
__u
->
__ui
 = 
__c
 * 0x01010101; \

153 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

155 
__u
->
__ui
 = 
__c
 * 0x01010101; \

156 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

158 
__u
->
__ui
 = 
__c
 * 0x01010101; \

159 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

161 
__u
->
__uc
 = (
__c
; \

165 
__u
->
__ui
 = 
__c
 * 0x01010101; \

166 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

168 
__u
->
__ui
 = 
__c
 * 0x01010101; \

169 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

171 
__u
->
__ui
 = 
__c
 * 0x01010101; \

172 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

174 
__u
->
__ui
 = 
__c
 * 0x01010101; \

179 
__s
; })

	)

181 
	#memt
(
s
, 
c
, 
n
) \

182 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
c
) && (c) == '\0' \

183 ? ({ *
__s
 = (
s
); 
	`__bzo
 (__s, 
n
); __s; }) \

184 : 
	`memt
 (
s
, 
c
, 
n
)))

	)

193 #i
__GNUC_PREREQ
 (2, 91)

194 
	#__bzo
(
s
, 
n

	`__but_memt
 (s, '\0',)

	)

202 #ifde
__USE_GNU


203 #i!
defed
 
_HAVE_STRING_ARCH_mempy
 || defed 
_FORCE_INLINES


204 #ide
_HAVE_STRING_ARCH_mempy


205 #i
__GNUC_PREREQ
 (3, 4)

206 
	#__mempy
(
de
, 
c
, 
n

	`__but_mempy
 (de, src,)

	)

207 #i
__GNUC_PREREQ
 (3, 0)

208 
	#__mempy
(
de
, 
c
, 
n
) \

209 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
c
&& __but_cڡt_(
n
) \

210 && 
	`__rg2_1br_p
 (
c
&& 
n
 <= 8 \

211 ? 
	`__but_memy
 (
de
, 
c
, 
n
) + (n) \

212 : 
	`__mempy
 (
de
, 
c
, 
n
)))

	)

214 
	#__mempy
(
de
, 
c
, 
n
) \

215 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
c
&& __but_cڡt_(
n
) \

216 && 
	`__rg2_1br_p
 (
c
&& 
n
 <= 8 \

217 ? 
	`__mempy_sml
 (
de
, 
	`__mempy_gs
 (
c
), 
n
) \

218 : 
	`__mempy
 (
de
, 
c
, 
n
)))

	)

222 
	#mempy
(
de
, 
c
, 
n

	`__mempy
 (de, src,)

	)

225 #i!
__GNUC_PREREQ
 (3, 0|| 
defed
 
_FORCE_INLINES


226 #i
_STRING_ARCH_uligd


227 #ide
_FORCE_INLINES


228 
	#__mempy_gs
(
c
) \

229 ((cڡ *(
c
))[0], ((const *) (src))[2], \

230 ((cڡ *(
c
))[4], ((const *) (src))[6], \

231 
__exnsi__
 
	`__STRING2_SMALL_GET16
 (
c
, 0), \

232 
__exnsi__
 
	`__STRING2_SMALL_GET16
 (
c
, 4), \

233 
__exnsi__
 
	`__STRING2_SMALL_GET32
 (
c
, 0), \

234 
__exnsi__
 
	`__STRING2_SMALL_GET32
 (
c
, 4)

	)

236 
__STRING_INLINE
 *
__mempy_sml
 (*, , , , ,

237 
__ut16_t
, __ut16_t, 
__ut32_t
,

238 
__ut32_t
, 
size_t
);

239 
__STRING_INLINE
 *

240 
	$__mempy_sml
 (*
__de1
,

241 
__c0_1
, 
__c2_1
, 
__c4_1
, 
__c6_1
,

242 
__ut16_t
 
__c0_2
, __ut16_
__c4_2
,

243 
__ut32_t
 
__c0_4
, __ut32_
__c4_4
,

244 
size_t
 
__
)

247 
__ut32_t
 
__ui
;

248 
__ut16_t
 
__usi
;

249 
__uc
;

250 
__c
;

251 } *
__u
 = 
__de1
;

252 (
__
)

255 
__u
->
__c
 = 
__c0_1
;

256 
__u
 = 
	`__exnsi__
 ((*) __u + 1);

259 
__u
->
__usi
 = 
__c0_2
;

260 
__u
 = 
	`__exnsi__
 ((*) __u + 2);

263 
__u
->
__usi
 = 
__c0_2
;

264 
__u
 = 
	`__exnsi__
 ((*) __u + 2);

265 
__u
->
__c
 = 
__c2_1
;

266 
__u
 = 
	`__exnsi__
 ((*) __u + 1);

269 
__u
->
__ui
 = 
__c0_4
;

270 
__u
 = 
	`__exnsi__
 ((*) __u + 4);

273 
__u
->
__ui
 = 
__c0_4
;

274 
__u
 = 
	`__exnsi__
 ((*) __u + 4);

275 
__u
->
__c
 = 
__c4_1
;

276 
__u
 = 
	`__exnsi__
 ((*) __u + 1);

279 
__u
->
__ui
 = 
__c0_4
;

280 
__u
 = 
	`__exnsi__
 ((*) __u + 4);

281 
__u
->
__usi
 = 
__c4_2
;

282 
__u
 = 
	`__exnsi__
 ((*) __u + 2);

285 
__u
->
__ui
 = 
__c0_4
;

286 
__u
 = 
	`__exnsi__
 ((*) __u + 4);

287 
__u
->
__usi
 = 
__c4_2
;

288 
__u
 = 
	`__exnsi__
 ((*) __u + 2);

289 
__u
->
__c
 = 
__c6_1
;

290 
__u
 = 
	`__exnsi__
 ((*) __u + 1);

293 
__u
->
__ui
 = 
__c0_4
;

294 
__u
 = 
	`__exnsi__
 ((*) __u + 4);

295 
__u
->
__ui
 = 
__c4_4
;

296 
__u
 = 
	`__exnsi__
 ((*) __u + 4);

299  (*
__u
;

300 
	}
}

302 #ide
_FORCE_INLINES


303 
	#__mempy_gs
(
c
) \

304 ((cڡ *(
c
))[0], \

305 
	`__exnsi__
 ((
__STRING2_COPY_ARR2
) \

306 { { ((cڡ *(
c
))[0], ((const *) (src))[1] } }), \

307 
	`__exnsi__
 ((
__STRING2_COPY_ARR3
) \

308 { { ((cڡ *(
c
))[0], ((const *) (src))[1], \

309 ((cڡ *(
c
))[2] } }), \

310 
	`__exnsi__
 ((
__STRING2_COPY_ARR4
) \

311 { { ((cڡ *(
c
))[0], ((const *) (src))[1], \

312 ((cڡ *(
c
))[2], ((const *) (src))[3] } }), \

313 
	`__exnsi__
 ((
__STRING2_COPY_ARR5
) \

314 { { ((cڡ *(
c
))[0], ((const *) (src))[1], \

315 ((cڡ *(
c
))[2], ((const *) (src))[3], \

316 ((cڡ *(
c
))[4] } }), \

317 
	`__exnsi__
 ((
__STRING2_COPY_ARR6
) \

318 { { ((cڡ *(
c
))[0], ((const *) (src))[1], \

319 ((cڡ *(
c
))[2], ((const *) (src))[3], \

320 ((cڡ *(
c
))[4], ((const *) (src))[5] } }), \

321 
	`__exnsi__
 ((
__STRING2_COPY_ARR7
) \

322 { { ((cڡ *(
c
))[0], ((const *) (src))[1], \

323 ((cڡ *(
c
))[2], ((const *) (src))[3], \

324 ((cڡ *(
c
))[4], ((const *) (src))[5], \

325 ((cڡ *(
c
))[6] } }), \

326 
	`__exnsi__
 ((
__STRING2_COPY_ARR8
) \

327 { { ((cڡ *(
c
))[0], ((const *) (src))[1], \

328 ((cڡ *(
c
))[2], ((const *) (src))[3], \

329 ((cڡ *(
c
))[4], ((const *) (src))[5], \

330 ((cڡ *(
c
))[6], ((cڡ *(c))[7] } })

	)

332 
__STRING_INLINE
 *
__mempy_sml
 (*, , 
__STRING2_COPY_ARR2
,

333 
__STRING2_COPY_ARR3
,

334 
__STRING2_COPY_ARR4
,

335 
__STRING2_COPY_ARR5
,

336 
__STRING2_COPY_ARR6
,

337 
__STRING2_COPY_ARR7
,

338 
__STRING2_COPY_ARR8
, 
size_t
);

339 
__STRING_INLINE
 *

340 
	$__mempy_sml
 (*
__de
, 
__c1
,

341 
__STRING2_COPY_ARR2
 
__c2
, 
__STRING2_COPY_ARR3
 
__c3
,

342 
__STRING2_COPY_ARR4
 
__c4
, 
__STRING2_COPY_ARR5
 
__c5
,

343 
__STRING2_COPY_ARR6
 
__c6
, 
__STRING2_COPY_ARR7
 
__c7
,

344 
__STRING2_COPY_ARR8
 
__c8
, 
size_t
 
__
)

347 
__c
;

348 
__STRING2_COPY_ARR2
 
__s2
;

349 
__STRING2_COPY_ARR3
 
__s3
;

350 
__STRING2_COPY_ARR4
 
__s4
;

351 
__STRING2_COPY_ARR5
 
__s5
;

352 
__STRING2_COPY_ARR6
 
__s6
;

353 
__STRING2_COPY_ARR7
 
__s7
;

354 
__STRING2_COPY_ARR8
 
__s8
;

355 } *
__u
 = 
__de
;

356 (
__
)

359 
__u
->
__c
 = 
__c1
;

362 
__exnsi__
 
__u
->
__s2
 = 
__c2
;

365 
__exnsi__
 
__u
->
__s3
 = 
__c3
;

368 
__exnsi__
 
__u
->
__s4
 = 
__c4
;

371 
__exnsi__
 
__u
->
__s5
 = 
__c5
;

374 
__exnsi__
 
__u
->
__s6
 = 
__c6
;

377 
__exnsi__
 
__u
->
__s7
 = 
__c7
;

380 
__exnsi__
 
__u
->
__s8
 = 
__c8
;

383  
	`__exnsi__
 ((*
__u
 + 
__
);

384 
	}
}

392 #ide
_HAVE_STRING_ARCH_rchr


393 *
__wmemchr
 (cڡ *
__s
, 
__c
);

394 #i
__GNUC_PREREQ
 (3, 2)

395 
	#rchr
(
s
, 
c
) \

396 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
c
&& !__but_cڡt_(
s
) \

397 && (
c
) == '\0' \

398 ? (*
	`__wmemchr
 (
s
, 
c
) \

399 : 
	`__but_rchr
 (
s
, 
c
)))

	)

401 
	#rchr
(
s
, 
c
) \

402 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
c
) && (c) == '\0' \

403 ? (*
	`__wmemchr
 (
s
, 
c
) \

404 : 
	`rchr
 (
s
, 
c
)))

	)

410 #i(!
defed
 
_HAVE_STRING_ARCH_ry
 && !
__GNUC_PREREQ
 (3, 0)) \

411 || 
defed
 
	g_FORCE_INLINES


412 #i!
defed
 
_HAVE_STRING_ARCH_ry
 && !
__GNUC_PREREQ
 (3, 0)

413 
	#ry
(
de
, 
c
) \

414 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
c
) \

415 ? (
	`__rg2_1br_p
 (
c
&& 
	`
 (src) + 1 <= 8 \

416 ? 
	`__ry_sml
 (
de
, 
	`__ry_gs
 (
c
), \

417 
	`
 (
c
) + 1) \

418 : (*
	`memy
 (
de
, 
c
, 
	`
 (src) + 1)) \

419 : 
	`ry
 (
de
, 
c
)))

	)

422 #i
_STRING_ARCH_uligd


423 #ide
_FORCE_INLINES


424 
	#__ry_gs
(
c
) \

425 
__exnsi__
 
	`__STRING2_SMALL_GET16
 (
c
, 0), \

426 
__exnsi__
 
	`__STRING2_SMALL_GET16
 (
c
, 4), \

427 
__exnsi__
 
	`__STRING2_SMALL_GET32
 (
c
, 0), \

428 
__exnsi__
 
	`__STRING2_SMALL_GET32
 (
c
, 4)

	)

430 
__STRING_INLINE
 *
__ry_sml
 (*, 
__ut16_t
, __uint16_t,

431 
__ut32_t
, __ut32_t, 
size_t
);

432 
__STRING_INLINE
 *

433 
	$__ry_sml
 (*
__de
,

434 
__ut16_t
 
__c0_2
, __ut16_
__c4_2
,

435 
__ut32_t
 
__c0_4
, __ut32_
__c4_4
,

436 
size_t
 
__
)

439 
__ut32_t
 
__ui
;

440 
__ut16_t
 
__usi
;

441 
__uc
;

442 } *
__u
 = (*
__de
;

443 (
__
)

446 
__u
->
__uc
 = '\0';

449 
__u
->
__usi
 = 
__c0_2
;

452 
__u
->
__usi
 = 
__c0_2
;

453 
__u
 = 
	`__exnsi__
 ((*) __u + 2);

454 
__u
->
__uc
 = '\0';

457 
__u
->
__ui
 = 
__c0_4
;

460 
__u
->
__ui
 = 
__c0_4
;

461 
__u
 = 
	`__exnsi__
 ((*) __u + 4);

462 
__u
->
__uc
 = '\0';

465 
__u
->
__ui
 = 
__c0_4
;

466 
__u
 = 
	`__exnsi__
 ((*) __u + 4);

467 
__u
->
__usi
 = 
__c4_2
;

470 
__u
->
__ui
 = 
__c0_4
;

471 
__u
 = 
	`__exnsi__
 ((*) __u + 4);

472 
__u
->
__usi
 = 
__c4_2
;

473 
__u
 = 
	`__exnsi__
 ((*) __u + 2);

474 
__u
->
__uc
 = '\0';

477 
__u
->
__ui
 = 
__c0_4
;

478 
__u
 = 
	`__exnsi__
 ((*) __u + 4);

479 
__u
->
__ui
 = 
__c4_4
;

482  
__de
;

483 
	}
}

485 #ide
_FORCE_INLINES


486 
	#__ry_gs
(
c
) \

487 
	`__exnsi__
 ((
__STRING2_COPY_ARR2
) \

488 { { ((cڡ *(
c
))[0], '\0' } }), \

489 
	`__exnsi__
 ((
__STRING2_COPY_ARR3
) \

490 { { ((cڡ *(
c
))[0], ((const *) (src))[1], \

492 
	`__exnsi__
 ((
__STRING2_COPY_ARR4
) \

493 { { ((cڡ *(
c
))[0], ((const *) (src))[1], \

494 ((cڡ *(
c
))[2], '\0' } }), \

495 
	`__exnsi__
 ((
__STRING2_COPY_ARR5
) \

496 { { ((cڡ *(
c
))[0], ((const *) (src))[1], \

497 ((cڡ *(
c
))[2], ((const *) (src))[3], \

499 
	`__exnsi__
 ((
__STRING2_COPY_ARR6
) \

500 { { ((cڡ *(
c
))[0], ((const *) (src))[1], \

501 ((cڡ *(
c
))[2], ((const *) (src))[3], \

502 ((cڡ *(
c
))[4], '\0' } }), \

503 
	`__exnsi__
 ((
__STRING2_COPY_ARR7
) \

504 { { ((cڡ *(
c
))[0], ((const *) (src))[1], \

505 ((cڡ *(
c
))[2], ((const *) (src))[3], \

506 ((cڡ *(
c
))[4], ((const *) (src))[5], \

508 
	`__exnsi__
 ((
__STRING2_COPY_ARR8
) \

509 { { ((cڡ *(
c
))[0], ((const *) (src))[1], \

510 ((cڡ *(
c
))[2], ((const *) (src))[3], \

511 ((cڡ *(
c
))[4], ((const *) (src))[5], \

512 ((cڡ *(
c
))[6], '\0' } })

	)

514 
__STRING_INLINE
 *
__ry_sml
 (*, 
__STRING2_COPY_ARR2
,

515 
__STRING2_COPY_ARR3
,

516 
__STRING2_COPY_ARR4
,

517 
__STRING2_COPY_ARR5
,

518 
__STRING2_COPY_ARR6
,

519 
__STRING2_COPY_ARR7
,

520 
__STRING2_COPY_ARR8
, 
size_t
);

521 
__STRING_INLINE
 *

522 
	$__ry_sml
 (*
__de
,

523 
__STRING2_COPY_ARR2
 
__c2
, 
__STRING2_COPY_ARR3
 
__c3
,

524 
__STRING2_COPY_ARR4
 
__c4
, 
__STRING2_COPY_ARR5
 
__c5
,

525 
__STRING2_COPY_ARR6
 
__c6
, 
__STRING2_COPY_ARR7
 
__c7
,

526 
__STRING2_COPY_ARR8
 
__c8
, 
size_t
 
__
)

529 
__c
;

530 
__STRING2_COPY_ARR2
 
__s2
;

531 
__STRING2_COPY_ARR3
 
__s3
;

532 
__STRING2_COPY_ARR4
 
__s4
;

533 
__STRING2_COPY_ARR5
 
__s5
;

534 
__STRING2_COPY_ARR6
 
__s6
;

535 
__STRING2_COPY_ARR7
 
__s7
;

536 
__STRING2_COPY_ARR8
 
__s8
;

537 } *
__u
 = (*
__de
;

538 (
__
)

541 
__u
->
__c
 = '\0';

544 
__exnsi__
 
__u
->
__s2
 = 
__c2
;

547 
__exnsi__
 
__u
->
__s3
 = 
__c3
;

550 
__exnsi__
 
__u
->
__s4
 = 
__c4
;

553 
__exnsi__
 
__u
->
__s5
 = 
__c5
;

556 
__exnsi__
 
__u
->
__s6
 = 
__c6
;

559 
__exnsi__
 
__u
->
__s7
 = 
__c7
;

562 
__exnsi__
 
__u
->
__s8
 = 
__c8
;

565  
__de
;

566 
	}
}

572 #ifde
__USE_GNU


573 #i!
defed
 
_HAVE_STRING_ARCH_py
 || defed 
_FORCE_INLINES


574 #ide
_HAVE_STRING_ARCH_py


575 #i
__GNUC_PREREQ
 (3, 4)

576 
	#__py
(
de
, 
c

	`__but_py
 (de, src)

	)

577 #i
__GNUC_PREREQ
 (3, 0)

578 
	#__py
(
de
, 
c
) \

579 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
c
) \

580 ? (
	`__rg2_1br_p
 (
c
&& 
	`
 (src) + 1 <= 8 \

581 ? 
	`__but_ry
 (
de
, 
c
+ 
	`
 (src) \

582 : ((*(
__mempy
(
de
, 
c
, 
	`
 (src) + 1) \

584 : 
	`__py
 (
de
, 
c
)))

	)

586 
	#__py
(
de
, 
c
) \

587 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
c
) \

588 ? (
	`__rg2_1br_p
 (
c
&& 
	`
 (src) + 1 <= 8 \

589 ? 
	`__py_sml
 (
de
, 
	`__py_gs
 (
c
), \

590 
	`
 (
c
) + 1) \

591 : ((*(
__mempy
(
de
, 
c
, 
	`
 (src) + 1) \

593 : 
	`__py
 (
de
, 
c
)))

	)

597 
	#py
(
de
, 
c

	`__py
 (de, src)

	)

600 #i!
__GNUC_PREREQ
 (3, 0|| 
defed
 
_FORCE_INLINES


601 #i
_STRING_ARCH_uligd


602 #ide
_FORCE_INLINES


603 
	#__py_gs
(
c
) \

604 
__exnsi__
 
	`__STRING2_SMALL_GET16
 (
c
, 0), \

605 
__exnsi__
 
	`__STRING2_SMALL_GET16
 (
c
, 4), \

606 
__exnsi__
 
	`__STRING2_SMALL_GET32
 (
c
, 0), \

607 
__exnsi__
 
	`__STRING2_SMALL_GET32
 (
c
, 4)

	)

609 
__STRING_INLINE
 *
__py_sml
 (*, 
__ut16_t
, __uint16_t,

610 
__ut32_t
, __ut32_t, 
size_t
);

611 
__STRING_INLINE
 *

612 
	$__py_sml
 (*
__de
,

613 
__ut16_t
 
__c0_2
, __ut16_
__c4_2
,

614 
__ut32_t
 
__c0_4
, __ut32_
__c4_4
,

615 
size_t
 
__
)

618 
__ui
;

619 
__usi
;

620 
__uc
;

621 
__c
;

622 } *
__u
 = (*
__de
;

623 (
__
)

626 
__u
->
__uc
 = '\0';

629 
__u
->
__usi
 = 
__c0_2
;

630 
__u
 = 
	`__exnsi__
 ((*) __u + 1);

633 
__u
->
__usi
 = 
__c0_2
;

634 
__u
 = 
	`__exnsi__
 ((*) __u + 2);

635 
__u
->
__uc
 = '\0';

638 
__u
->
__ui
 = 
__c0_4
;

639 
__u
 = 
	`__exnsi__
 ((*) __u + 3);

642 
__u
->
__ui
 = 
__c0_4
;

643 
__u
 = 
	`__exnsi__
 ((*) __u + 4);

644 
__u
->
__uc
 = '\0';

647 
__u
->
__ui
 = 
__c0_4
;

648 
__u
 = 
	`__exnsi__
 ((*) __u + 4);

649 
__u
->
__usi
 = 
__c4_2
;

650 
__u
 = 
	`__exnsi__
 ((*) __u + 1);

653 
__u
->
__ui
 = 
__c0_4
;

654 
__u
 = 
	`__exnsi__
 ((*) __u + 4);

655 
__u
->
__usi
 = 
__c4_2
;

656 
__u
 = 
	`__exnsi__
 ((*) __u + 2);

657 
__u
->
__uc
 = '\0';

660 
__u
->
__ui
 = 
__c0_4
;

661 
__u
 = 
	`__exnsi__
 ((*) __u + 4);

662 
__u
->
__ui
 = 
__c4_4
;

663 
__u
 = 
	`__exnsi__
 ((*) __u + 3);

666  &
__u
->
__c
;

667 
	}
}

669 #ide
_FORCE_INLINES


670 
	#__py_gs
(
c
) \

671 
	`__exnsi__
 ((
__STRING2_COPY_ARR2
) \

672 { { ((cڡ *(
c
))[0], '\0' } }), \

673 
	`__exnsi__
 ((
__STRING2_COPY_ARR3
) \

674 { { ((cڡ *(
c
))[0], ((const *) (src))[1], \

676 
	`__exnsi__
 ((
__STRING2_COPY_ARR4
) \

677 { { ((cڡ *(
c
))[0], ((const *) (src))[1], \

678 ((cڡ *(
c
))[2], '\0' } }), \

679 
	`__exnsi__
 ((
__STRING2_COPY_ARR5
) \

680 { { ((cڡ *(
c
))[0], ((const *) (src))[1], \

681 ((cڡ *(
c
))[2], ((const *) (src))[3], \

683 
	`__exnsi__
 ((
__STRING2_COPY_ARR6
) \

684 { { ((cڡ *(
c
))[0], ((const *) (src))[1], \

685 ((cڡ *(
c
))[2], ((const *) (src))[3], \

686 ((cڡ *(
c
))[4], '\0' } }), \

687 
	`__exnsi__
 ((
__STRING2_COPY_ARR7
) \

688 { { ((cڡ *(
c
))[0], ((const *) (src))[1], \

689 ((cڡ *(
c
))[2], ((const *) (src))[3], \

690 ((cڡ *(
c
))[4], ((const *) (src))[5], \

692 
	`__exnsi__
 ((
__STRING2_COPY_ARR8
) \

693 { { ((cڡ *(
c
))[0], ((const *) (src))[1], \

694 ((cڡ *(
c
))[2], ((const *) (src))[3], \

695 ((cڡ *(
c
))[4], ((const *) (src))[5], \

696 ((cڡ *(
c
))[6], '\0' } })

	)

698 
__STRING_INLINE
 *
__py_sml
 (*, 
__STRING2_COPY_ARR2
,

699 
__STRING2_COPY_ARR3
,

700 
__STRING2_COPY_ARR4
,

701 
__STRING2_COPY_ARR5
,

702 
__STRING2_COPY_ARR6
,

703 
__STRING2_COPY_ARR7
,

704 
__STRING2_COPY_ARR8
, 
size_t
);

705 
__STRING_INLINE
 *

706 
	$__py_sml
 (*
__de
,

707 
__STRING2_COPY_ARR2
 
__c2
, 
__STRING2_COPY_ARR3
 
__c3
,

708 
__STRING2_COPY_ARR4
 
__c4
, 
__STRING2_COPY_ARR5
 
__c5
,

709 
__STRING2_COPY_ARR6
 
__c6
, 
__STRING2_COPY_ARR7
 
__c7
,

710 
__STRING2_COPY_ARR8
 
__c8
, 
size_t
 
__
)

713 
__c
;

714 
__STRING2_COPY_ARR2
 
__s2
;

715 
__STRING2_COPY_ARR3
 
__s3
;

716 
__STRING2_COPY_ARR4
 
__s4
;

717 
__STRING2_COPY_ARR5
 
__s5
;

718 
__STRING2_COPY_ARR6
 
__s6
;

719 
__STRING2_COPY_ARR7
 
__s7
;

720 
__STRING2_COPY_ARR8
 
__s8
;

721 } *
__u
 = (*
__de
;

722 (
__
)

725 
__u
->
__c
 = '\0';

728 
__exnsi__
 
__u
->
__s2
 = 
__c2
;

731 
__exnsi__
 
__u
->
__s3
 = 
__c3
;

734 
__exnsi__
 
__u
->
__s4
 = 
__c4
;

737 
__exnsi__
 
__u
->
__s5
 = 
__c5
;

740 
__exnsi__
 
__u
->
__s6
 = 
__c6
;

743 
__exnsi__
 
__u
->
__s7
 = 
__c7
;

746 
__exnsi__
 
__u
->
__s8
 = 
__c8
;

749  
__de
 + 
__
 - 1;

750 
	}
}

758 #ide
_HAVE_STRING_ARCH_y


759 #i
__GNUC_PREREQ
 (3, 2)

760 
	#y
(
de
, 
c
, 
n

	`__but_y
 (de, src,)

	)

762 
	#y
(
de
, 
c
, 
n
) \

763 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
c
&& __but_cڡt_(
n
) \

764 ? (
	`
 (
c
+ 1 >((
size_t
(
n
)) \

765 ? (*
	`memy
 (
de
, 
c
, 
n
) \

766 : 
	`y
 (
de
, 
c
, 
n
)) \

767 : 
	`y
 (
de
, 
c
, 
n
)))

	)

773 #ide
_HAVE_STRING_ARCH_t


774 #ifde
_USE_STRING_ARCH_rchr


775 
	#t
(
de
, 
c
, 
n
) \

776 (
	`__exnsi__
 ({ *
__de
 = (
de
); \

777 
	`__but_cڡt_p
 (
c
&& __but_cڡt_(
n
) \

778 ? (
	`
 (
c
< ((
size_t
(
n
)) \

779 ? 
	`rt
 (
__de
, 
c
) \

780 : (*((*
	`__mempy
 (
	`rchr
 (
__de
, '\0'), \

781 
c
, 
n
)'\0', 
__de
)) \

782 : 
	`t
 (
de
, 
c
, 
n
); }))

	)

783 #i
__GNUC_PREREQ
 (3, 2)

784 
	#t
(
de
, 
c
, 
n

	`__but_t
 (de, src,)

	)

786 
	#t
(
de
, 
c
, 
n
) \

787 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
c
&& __but_cڡt_(
n
) \

788 ? (
	`
 (
c
< ((
size_t
(
n
)) \

789 ? 
	`rt
 (
de
, 
c
) \

790 : 
	`t
 (
de
, 
c
, 
n
)) \

791 : 
	`t
 (
de
, 
c
, 
n
)))

	)

797 #ide
_HAVE_STRING_ARCH_rcmp


798 #i
__GNUC_PREREQ
 (3, 2)

799 
	#rcmp
(
s1
, 
s2
) \

800 
__exnsi__
 \

801 ({ 
size_t
 
__s1_n
, 
__s2_n
; \

802 (
	`__but_cڡt_p
 (
s1
&& __but_cڡt_(
s2
) \

803 && (
__s1_n
 = 
	`__but_
 (
s1
), 
__s2_n
 = __but_ (
s2
), \

804 (!
	`__rg2_1br_p
 (
s1
|| 
__s1_n
 >= 4) \

805 && (!
	`__rg2_1br_p
 (
s2
|| 
__s2_n
 >= 4)) \

806 ? 
	`__but_rcmp
 (
s1
, 
s2
) \

807 : (
	`__but_cڡt_p
 (
s1
&& 
	`__rg2_1br_p
 (s1) \

808 && (
__s1_n
 = 
	`__but_
 (
s1
), __s1_len < 4) \

809 ? (
	`__but_cڡt_p
 (
s2
&& 
	`__rg2_1br_p
 (s2) \

810 ? 
	`__but_rcmp
 (
s1
, 
s2
) \

811 : 
	`__rcmp_cg
 (
s1
, 
s2
, 
__s1_n
)) \

812 : (
	`__but_cڡt_p
 (
s2
&& 
	`__rg2_1br_p
 (s2) \

813 && (
__s2_n
 = 
	`__but_
 (
s2
), __s2_len < 4) \

814 ? (
	`__but_cڡt_p
 (
s1
&& 
	`__rg2_1br_p
 (s1) \

815 ? 
	`__but_rcmp
 (
s1
, 
s2
) \

816 : 
	`__rcmp_gc
 (
s1
, 
s2
, 
__s2_n
)) \

817 : 
	`__but_rcmp
 (
s1
, 
s2
)))); })

	)

819 
	#rcmp
(
s1
, 
s2
) \

820 
__exnsi__
 \

821 ({ 
size_t
 
__s1_n
, 
__s2_n
; \

822 (
	`__but_cڡt_p
 (
s1
&& __but_cڡt_(
s2
) \

823 && (
__s1_n
 = 
	`
 (
s1
), 
__s2_n
 = s(
s2
), \

824 (!
	`__rg2_1br_p
 (
s1
|| 
__s1_n
 >= 4) \

825 && (!
	`__rg2_1br_p
 (
s2
|| 
__s2_n
 >= 4)) \

826 ? 
	`memcmp
 ((cڡ *(
s1
), (cڡ *(
s2
), \

827 (
__s1_n
 < 
__s2_n
 ? __s1_len : __s2_len) + 1) \

828 : (
	`__but_cڡt_p
 (
s1
&& 
	`__rg2_1br_p
 (s1) \

829 && (
__s1_n
 = 
	`
 (
s1
), __s1_len < 4) \

830 ? (
	`__but_cڡt_p
 (
s2
&& 
	`__rg2_1br_p
 (s2) \

831 ? 
	`__rcmp_cc
 (
s1
, 
s2
, 
__s1_n
) \

832 : 
	`__rcmp_cg
 (
s1
, 
s2
, 
__s1_n
)) \

833 : (
	`__but_cڡt_p
 (
s2
&& 
	`__rg2_1br_p
 (s2) \

834 && (
__s2_n
 = 
	`
 (
s2
), __s2_len < 4) \

835 ? (
	`__but_cڡt_p
 (
s1
&& 
	`__rg2_1br_p
 (s1) \

836 ? 
	`__rcmp_cc
 (
s1
, 
s2
, 
__s2_n
) \

837 : 
	`__rcmp_gc
 (
s1
, 
s2
, 
__s2_n
)) \

838 : 
	`rcmp
 (
s1
, 
s2
)))); })

	)

841 
	#__rcmp_cc
(
s1
, 
s2
, 
l
) \

842 (
	`__exnsi__
 ({ 
__su
 = \

843 (((cڡ *(cڡ *(
s1
))[0] \

844 - ((cڡ *(cڡ *)(
s2
))[0]); \

845 i(
l
 > 0 && 
__su
 == 0) \

847 
__su
 = (((const *) \

848 (cڡ *(
s1
))[1] \

850 (cڡ *(
s2
))[1]); \

851 i(
l
 > 1 && 
__su
 == 0) \

853 
__su
 = \

855 (cڡ *(
s1
))[2] \

857 (cڡ *(
s2
))[2]); \

858 i(
l
 > 2 && 
__su
 == 0) \

859 
__su
 = \

861 (cڡ *(
s1
))[3] \

863 (cڡ *(
s2
))[3]); \

866 
__su
; }))

	)

868 
	#__rcmp_cg
(
s1
, 
s2
, 
l1
) \

869 (
	`__exnsi__
 ({ cڡ *
__s2
 = \

870 (cڡ *(cڡ *(
s2
); \

871 
__su
 = \

872 (((cڡ *(cڡ *(
s1
))[0] \

873 - 
__s2
[0]); \

874 i(
l1
 > 0 && 
__su
 == 0) \

876 
__su
 = (((const *) \

877 (cڡ *(
s1
))[1] - 
__s2
[1]); \

878 i(
l1
 > 1 && 
__su
 == 0) \

880 
__su
 = (((const *) \

881 (cڡ *(
s1
))[2] - 
__s2
[2]); \

882 i(
l1
 > 2 && 
__su
 == 0) \

883 
__su
 = (((const *) \

884 (cڡ *(
s1
))[3] \

885 - 
__s2
[3]); \

888 
__su
; }))

	)

890 
	#__rcmp_gc
(
s1
, 
s2
, 
l2
(- 
	`__rcmp_cg
 (s2, s1,2))

	)

895 #ide
_HAVE_STRING_ARCH_cmp


896 
	#cmp
(
s1
, 
s2
, 
n
) \

897 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
n
) \

898 && ((
	`__but_cڡt_p
 (
s1
) \

899 && 
	`
 (
s1
< ((
size_t
(
n
))) \

900 || (
	`__but_cڡt_p
 (
s2
) \

901 && 
	`
 (
s2
< ((
size_t
(
n
)))) \

902 ? 
	`rcmp
 (
s1
, 
s2
: 
	`cmp
 (s1, s2, 
n
)))

	)

908 #i!
defed
 
_HAVE_STRING_ARCH_rcn
 || defed 
_FORCE_INLINES


909 #ide
_HAVE_STRING_ARCH_rcn


910 #i
__GNUC_PREREQ
 (3, 2)

911 
	#rcn
(
s
, 
je
) \

912 
__exnsi__
 \

913 ({ 
__r0
, 
__r1
, 
__r2
; \

914 (
	`__but_cڡt_p
 (
je
&& 
	`__rg2_1br_p
 (reject) \

915 ? ((
	`__but_cڡt_p
 (
s
&& 
	`__rg2_1br_p
 (s)) \

916 ? 
	`__but_rcn
 (
s
, 
je
) \

917 : ((
__r0
 = ((cڡ *(
je
))[0], __r0 == '\0') \

918 ? 
	`
 (
s
) \

919 : ((
__r1
 = ((cڡ *(
je
))[1], __r1 == '\0') \

920 ? 
	`__rcn_c1
 (
s
, 
__r0
) \

921 : ((
__r2
 = ((cڡ *(
je
))[2], __r2 == '\0') \

922 ? 
	`__rcn_c2
 (
s
, 
__r0
, 
__r1
) \

923 : (((cڡ *(
je
))[3] == '\0' \

924 ? 
	`__rcn_c3
 (
s
, 
__r0
, 
__r1
, 
__r2
) \

925 : 
	`__but_rcn
 (
s
, 
je
)))))) \

926 : 
	`__but_rcn
 (
s
, 
je
)); })

	)

928 
	#rcn
(
s
, 
je
) \

929 
__exnsi__
 \

930 ({ 
__r0
, 
__r1
, 
__r2
; \

931 (
	`__but_cڡt_p
 (
je
&& 
	`__rg2_1br_p
 (reject) \

932 ? ((
__r0
 = ((cڡ *(
je
))[0], __r0 == '\0') \

933 ? 
	`
 (
s
) \

934 : ((
__r1
 = ((cڡ *(
je
))[1], __r1 == '\0') \

935 ? 
	`__rcn_c1
 (
s
, 
__r0
) \

936 : ((
__r2
 = ((cڡ *(
je
))[2], __r2 == '\0') \

937 ? 
	`__rcn_c2
 (
s
, 
__r0
, 
__r1
) \

938 : (((cڡ *(
je
))[3] == '\0' \

939 ? 
	`__rcn_c3
 (
s
, 
__r0
, 
__r1
, 
__r2
) \

940 : 
	`rcn
 (
s
, 
je
))))) \

941 : 
	`rcn
 (
s
, 
je
)); })

	)

945 
__STRING_INLINE
 
size_t
 
__rcn_c1
 (cڡ *
__s
, 
__je
);

946 
__STRING_INLINE
 
size_t


947 
	$__rcn_c1
 (cڡ *
__s
, 
__je
)

949 
size_t
 
__su
 = 0;

950 
__s
[
__su
] !'\0' && __s[__su] !
__je
)

951 ++
__su
;

952  
__su
;

953 
	}
}

955 
__STRING_INLINE
 
size_t
 
__rcn_c2
 (cڡ *
__s
, 
__je1
,

956 
__je2
);

957 
__STRING_INLINE
 
size_t


958 
	$__rcn_c2
 (cڡ *
__s
, 
__je1
, 
__je2
)

960 
size_t
 
__su
 = 0;

961 
__s
[
__su
] !'\0' && __s[__su] !
__je1


962 && 
__s
[
__su
] !
__je2
)

963 ++
__su
;

964  
__su
;

965 
	}
}

967 
__STRING_INLINE
 
size_t
 
__rcn_c3
 (cڡ *
__s
, 
__je1
,

968 
__je2
, 
__je3
);

969 
__STRING_INLINE
 
size_t


970 
	$__rcn_c3
 (cڡ *
__s
, 
__je1
, 
__je2
,

971 
__je3
)

973 
size_t
 
__su
 = 0;

974 
__s
[
__su
] !'\0' && __s[__su] !
__je1


975 && 
__s
[
__su
] !
__je2
 && __s[__su] !
__je3
)

976 ++
__su
;

977  
__su
;

978 
	}
}

984 #i!
defed
 
_HAVE_STRING_ARCH_rn
 || defed 
_FORCE_INLINES


985 #ide
_HAVE_STRING_ARCH_rn


986 #i
__GNUC_PREREQ
 (3, 2)

987 
	#rn
(
s
, 
ac
) \

988 
__exnsi__
 \

989 ({ 
__a0
, 
__a1
, 
__a2
; \

990 (
	`__but_cڡt_p
 (
ac
&& 
	`__rg2_1br_p
 (accept) \

991 ? ((
	`__but_cڡt_p
 (
s
&& 
	`__rg2_1br_p
 (s)) \

992 ? 
	`__but_rn
 (
s
, 
ac
) \

993 : ((
__a0
 = ((cڡ *(
ac
))[0], __a0 == '\0') \

994 ? (((
s
), (
size_t
) 0) \

995 : ((
__a1
 = ((cڡ *(
ac
))[1], __a1 == '\0') \

996 ? 
	`__rn_c1
 (
s
, 
__a0
) \

997 : ((
__a2
 = ((cڡ *(
ac
))[2], __a2 == '\0') \

998 ? 
	`__rn_c2
 (
s
, 
__a0
, 
__a1
) \

999 : (((cڡ *(
ac
))[3] == '\0' \

1000 ? 
	`__rn_c3
 (
s
, 
__a0
, 
__a1
, 
__a2
) \

1001 : 
	`__but_rn
 (
s
, 
ac
)))))) \

1002 : 
	`__but_rn
 (
s
, 
ac
)); })

	)

1004 
	#rn
(
s
, 
ac
) \

1005 
__exnsi__
 \

1006 ({ 
__a0
, 
__a1
, 
__a2
; \

1007 (
	`__but_cڡt_p
 (
ac
&& 
	`__rg2_1br_p
 (accept) \

1008 ? ((
__a0
 = ((cڡ *(
ac
))[0], __a0 == '\0') \

1009 ? (((
s
), (
size_t
) 0) \

1010 : ((
__a1
 = ((cڡ *(
ac
))[1], __a1 == '\0') \

1011 ? 
	`__rn_c1
 (
s
, 
__a0
) \

1012 : ((
__a2
 = ((cڡ *(
ac
))[2], __a2 == '\0') \

1013 ? 
	`__rn_c2
 (
s
, 
__a0
, 
__a1
) \

1014 : (((cڡ *(
ac
))[3] == '\0' \

1015 ? 
	`__rn_c3
 (
s
, 
__a0
, 
__a1
, 
__a2
) \

1016 : 
	`rn
 (
s
, 
ac
))))) \

1017 : 
	`rn
 (
s
, 
ac
)); })

	)

1021 
__STRING_INLINE
 
size_t
 
__rn_c1
 (cڡ *
__s
, 
__ac
);

1022 
__STRING_INLINE
 
size_t


1023 
	$__rn_c1
 (cڡ *
__s
, 
__ac
)

1025 
size_t
 
__su
 = 0;

1027 
__s
[
__su
] =
__ac
)

1028 ++
__su
;

1029  
__su
;

1030 
	}
}

1032 
__STRING_INLINE
 
size_t
 
__rn_c2
 (cڡ *
__s
, 
__ac1
,

1033 
__ac2
);

1034 
__STRING_INLINE
 
size_t


1035 
	$__rn_c2
 (cڡ *
__s
, 
__ac1
, 
__ac2
)

1037 
size_t
 
__su
 = 0;

1039 
__s
[
__su
] =
__ac1
 || __s[__su] =
__ac2
)

1040 ++
__su
;

1041  
__su
;

1042 
	}
}

1044 
__STRING_INLINE
 
size_t
 
__rn_c3
 (cڡ *
__s
, 
__ac1
,

1045 
__ac2
, 
__ac3
);

1046 
__STRING_INLINE
 
size_t


1047 
	$__rn_c3
 (cڡ *
__s
, 
__ac1
, 
__ac2
, 
__ac3
)

1049 
size_t
 
__su
 = 0;

1051 
__s
[
__su
] =
__ac1
 || __s[__su] =
__ac2


1052 || 
__s
[
__su
] =
__ac3
)

1053 ++
__su
;

1054  
__su
;

1055 
	}
}

1060 #i!
defed
 
_HAVE_STRING_ARCH_brk
 || defed 
_FORCE_INLINES


1061 #ide
_HAVE_STRING_ARCH_brk


1062 #i
__GNUC_PREREQ
 (3, 2)

1063 
	#brk
(
s
, 
ac
) \

1064 
__exnsi__
 \

1065 ({ 
__a0
, 
__a1
, 
__a2
; \

1066 (
	`__but_cڡt_p
 (
ac
&& 
	`__rg2_1br_p
 (accept) \

1067 ? ((
	`__but_cڡt_p
 (
s
&& 
	`__rg2_1br_p
 (s)) \

1068 ? 
	`__but_brk
 (
s
, 
ac
) \

1069 : ((
__a0
 = ((cڡ *(
ac
))[0], __a0 == '\0') \

1070 ? (((
s
), (*
NULL
) \

1071 : ((
__a1
 = ((cڡ *(
ac
))[1], __a1 == '\0') \

1072 ? 
	`__but_rchr
 (
s
, 
__a0
) \

1073 : ((
__a2
 = ((cڡ *(
ac
))[2], __a2 == '\0') \

1074 ? 
	`__brk_c2
 (
s
, 
__a0
, 
__a1
) \

1075 : (((cڡ *(
ac
))[3] == '\0' \

1076 ? 
	`__brk_c3
 (
s
, 
__a0
, 
__a1
, 
__a2
) \

1077 : 
	`__but_brk
 (
s
, 
ac
)))))) \

1078 : 
	`__but_brk
 (
s
, 
ac
)); })

	)

1080 
	#brk
(
s
, 
ac
) \

1081 
__exnsi__
 \

1082 ({ 
__a0
, 
__a1
, 
__a2
; \

1083 (
	`__but_cڡt_p
 (
ac
&& 
	`__rg2_1br_p
 (accept) \

1084 ? ((
__a0
 = ((cڡ *(
ac
))[0], __a0 == '\0') \

1085 ? (((
s
), (*
NULL
) \

1086 : ((
__a1
 = ((cڡ *(
ac
))[1], __a1 == '\0') \

1087 ? 
	`rchr
 (
s
, 
__a0
) \

1088 : ((
__a2
 = ((cڡ *(
ac
))[2], __a2 == '\0') \

1089 ? 
	`__brk_c2
 (
s
, 
__a0
, 
__a1
) \

1090 : (((cڡ *(
ac
))[3] == '\0' \

1091 ? 
	`__brk_c3
 (
s
, 
__a0
, 
__a1
, 
__a2
) \

1092 : 
	`brk
 (
s
, 
ac
))))) \

1093 : 
	`brk
 (
s
, 
ac
)); })

	)

1097 
__STRING_INLINE
 *
__brk_c2
 (cڡ *
__s
, 
__ac1
,

1098 
__ac2
);

1099 
__STRING_INLINE
 *

1100 
	$__brk_c2
 (cڡ *
__s
, 
__ac1
, 
__ac2
)

1103 *
__s
 !'\0' && *__!
__ac1
 && *__!
__ac2
)

1104 ++
__s
;

1105  *
__s
 ='\0' ? 
NULL
 : (*(
size_t
) __s;

1106 
	}
}

1108 
__STRING_INLINE
 *
__brk_c3
 (cڡ *
__s
, 
__ac1
,

1109 
__ac2
, 
__ac3
);

1110 
__STRING_INLINE
 *

1111 
	$__brk_c3
 (cڡ *
__s
, 
__ac1
, 
__ac2
, 
__ac3
)

1114 *
__s
 !'\0' && *__!
__ac1
 && *__!
__ac2


1115 && *
__s
 !
__ac3
)

1116 ++
__s
;

1117  *
__s
 ='\0' ? 
NULL
 : (*(
size_t
) __s;

1118 
	}
}

1124 #i!
defed
 
_HAVE_STRING_ARCH_rr
 && !
__GNUC_PREREQ
 (2, 97)

1125 
	#rr
(
hayack
, 
ed
) \

1126 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
ed
&& 
	`__rg2_1br_p
 (needle) \

1127 ? (((cڡ *(
ed
))[0] == '\0' \

1128 ? (*(
size_t
(
hayack
) \

1129 : (((cڡ *(
ed
))[1] == '\0' \

1130 ? 
	`rchr
 (
hayack
, \

1131 ((cڡ *(
ed
))[0]) \

1132 : 
	`rr
 (
hayack
, 
ed
))) \

1133 : 
	`rr
 (
hayack
, 
ed
)))

	)

1137 #i!
defed
 
_HAVE_STRING_ARCH_ok_r
 || defed 
_FORCE_INLINES


1138 #ide
_HAVE_STRING_ARCH_ok_r


1139 
	#__ok_r
(
s
, 
p
, 
x
) \

1140 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
p
&& 
	`__rg2_1br_p
 (sep) \

1141 && ((cڡ *(
p
))[0] != '\0' \

1142 && ((cڡ *(
p
))[1] == '\0' \

1143 ? 
	`__ok_r_1c
 (
s
, ((cڡ *(
p
))[0], 
x
) \

1144 : 
	`__ok_r
 (
s
, 
p
, 
x
)))

	)

1147 
__STRING_INLINE
 *
__ok_r_1c
 (*
__s
, 
__p
, **
__x
);

1148 
__STRING_INLINE
 *

1149 
	$__ok_r_1c
 (*
__s
, 
__p
, **
__x
)

1151 *
__su
;

1152 i(
__s
 =
NULL
)

1153 
__s
 = *
__x
;

1154 *
__s
 =
__p
)

1155 ++
__s
;

1156 
__su
 = 
NULL
;

1157 i(*
__s
 != '\0')

1159 
__su
 = 
__s
++;

1160 *
__s
 != '\0')

1161 i(*
__s
++ =
__p
)

1163 
__s
[-1] = '\0';

1167 *
__x
 = 
__s
;

1168  
__su
;

1169 
	}
}

1170 #i
defed
 
__USE_POSIX
 || defed 
__USE_MISC


1171 
	#ok_r
(
s
, 
p
, 
x

	`__ok_r
 (s, s,ex)

	)

1176 #i!
defed
 
_HAVE_STRING_ARCH_rp
 || defed 
_FORCE_INLINES


1177 #ide
_HAVE_STRING_ARCH_rp


1179 *
__rp_g
 (**
__rgp
, cڡ *
__dim
);

1180 
	#__rp
(
s
, 
je
) \

1181 
__exnsi__
 \

1182 ({ 
__r0
, 
__r1
, 
__r2
; \

1183 (
	`__but_cڡt_p
 (
je
&& 
	`__rg2_1br_p
 (reject) \

1184 && (
__r0
 = ((cڡ *(
je
))[0], \

1185 ((cڡ *(
je
))[0] != '\0') \

1186 ? ((
__r1
 = ((cڡ *(
je
))[1], \

1187 ((cڡ *(
je
))[1] == '\0') \

1188 ? 
	`__rp_1c
 (
s
, 
__r0
) \

1189 : ((
__r2
 = ((cڡ *(
je
))[2], __r2 == '\0') \

1190 ? 
	`__rp_2c
 (
s
, 
__r0
, 
__r1
) \

1191 : (((cڡ *(
je
))[3] == '\0' \

1192 ? 
	`__rp_3c
 (
s
, 
__r0
, 
__r1
, 
__r2
) \

1193 : 
	`__rp_g
 (
s
, 
je
)))) \

1194 : 
	`__rp_g
 (
s
, 
je
)); })

	)

1197 
__STRING_INLINE
 *
__rp_1c
 (**
__s
, 
__je
);

1198 
__STRING_INLINE
 *

1199 
	$__rp_1c
 (**
__s
, 
__je
)

1201 *
__tv
 = *
__s
;

1202 i(
__tv
 !
NULL
 && (*
__s
 = 
	`rchr
 (__tv, 
__je
)) != NULL)

1203 *(*
__s
)++ = '\0';

1204  
__tv
;

1205 
	}
}

1207 
__STRING_INLINE
 *
__rp_2c
 (**
__s
, 
__je1
, 
__je2
);

1208 
__STRING_INLINE
 *

1209 
	$__rp_2c
 (**
__s
, 
__je1
, 
__je2
)

1211 *
__tv
 = *
__s
;

1212 i(
__tv
 !
NULL
)

1214 *
__
 = 
__tv
;

1217 i(*
__
 == '\0')

1219 
__
 = 
NULL
;

1222 i(*
__
 =
__je1
 || *__ =
__je2
)

1224 *
__
++ = '\0';

1227 ++
__
;

1229 *
__s
 = 
__
;

1231  
__tv
;

1232 
	}
}

1234 
__STRING_INLINE
 *
__rp_3c
 (**
__s
, 
__je1
, 
__je2
,

1235 
__je3
);

1236 
__STRING_INLINE
 *

1237 
	$__rp_3c
 (**
__s
, 
__je1
, 
__je2
, 
__je3
)

1239 *
__tv
 = *
__s
;

1240 i(
__tv
 !
NULL
)

1242 *
__
 = 
__tv
;

1245 i(*
__
 == '\0')

1247 
__
 = 
NULL
;

1250 i(*
__
 =
__je1
 || *__ =
__je2
 || *__ =
__je3
)

1252 *
__
++ = '\0';

1255 ++
__
;

1257 *
__s
 = 
__
;

1259  
__tv
;

1260 
	}
}

1261 #ifde
__USE_BSD


1262 
	#rp
(
s
, 
je

	`__rp
 (s,eje)

	)

1269 #ifde
__USE_MISC


1271 #i!
defed
 
_HAVE_STRING_ARCH_rdup
 || !defed 
_HAVE_STRING_ARCH_dup


1272 
	#__ed_mloc_d_oc


	)

1273 
	~<dlib.h
>

1276 #ide
_HAVE_STRING_ARCH_rdup


1278 *
	$__rdup
 (cڡ *
__rg

__THROW
 
__ibu_mloc__
;

1279 
	#__rdup
(
s
) \

1280 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
s
&& 
	`__rg2_1br_p
 (s) \

1281 ? (((cڡ *(
s
))[0] == '\0' \

1282 ? (*
	`oc
 ((
size_t
) 1, (size_t) 1) \

1283 : ({ 
size_t
 
__n
 = 
	`
 (
s
) + 1; \

1284 *
__tv
 = (*
	`mloc
 (
__n
); \

1285 i(
__tv
 !
NULL
) \

1286 
__tv
 = (*
	`memy
 (__tv, 
s
, 
__n
); \

1287 
__tv
; 
	}
})) \

1288 : 
	`__rdup
 (
s
)))

	)

1290 #i
defed
 
__USE_SVID
 || defed 
__USE_BSD
 || defed 
__USE_XOPEN_EXTENDED


1291 
	#rdup
(
s

	`__rdup
 (s)

	)

1295 #ide
_HAVE_STRING_ARCH_dup


1297 *
	$__dup
 (cڡ *
__rg
, 
size_t
 
__n
)

1298 
__THROW
 
__ibu_mloc__
;

1299 
	#__dup
(
s
, 
n
) \

1300 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
s
&& 
	`__rg2_1br_p
 (s) \

1301 ? (((cڡ *(
s
))[0] == '\0' \

1302 ? (*
	`oc
 ((
size_t
) 1, (size_t) 1) \

1303 : ({ 
size_t
 
__n
 = 
	`
 (
s
) + 1; \

1304 
size_t
 
__n
 = (
n
); \

1305 *
__tv
; \

1306 i(
__n
 < 
__n
) \

1307 
__n
 = 
__n
 + 1; \

1308 
__tv
 = (*
	`mloc
 (
__n
); \

1309 i(
__tv
 !
NULL
) \

1311 
__tv
[
__n
 - 1] = '\0'; \

1312 
__tv
 = (*
	`memy
 (__tv, 
s
, \

1313 
__n
 - 1); \

1315 
__tv
; 
	}
})) \

1316 : 
	`__dup
 (
s
, 
n
)))

	)

1318 #ifde
__USE_GNU


1319 
	#dup
(
s
, 
n

	`__dup
 (s,)

	)

1325 #ide
_FORCE_INLINES


1326 #unde
__STRING_INLINE


	@/usr/include/bits/string3.h

18 #ide
_STRING_H


22 
__wnde
 (
__wn_memt_zo_n
,

25 #ide
__lulus


29 #unde
memy


30 #unde
memmove


31 #unde
memt


32 #unde
rt


33 #unde
ry


34 #unde
t


35 #unde
y


36 #ifde
__USE_GNU


37 #unde
mempy


38 #unde
py


40 #ifde
__USE_BSD


41 #unde
bcy


42 #unde
bzo


47 
__ftify_funi
 *

48 
__NTH
 (
	$memy
 (*
__ri
 
__de
, cڡ *__ri 
__c
,

49 
size_t
 
__n
))

51  
	`__but___memy_chk
 (
__de
, 
__c
, 
__n
, 
	`__bos0
 (__dest));

52 
	}
}

54 
__ftify_funi
 *

55 
__NTH
 (
	$memmove
 (*
__de
, cڡ *
__c
, 
size_t
 
__n
))

57  
	`__but___memmove_chk
 (
__de
, 
__c
, 
__n
, 
	`__bos0
 (__dest));

58 
	}
}

60 #ifde
__USE_GNU


61 
__ftify_funi
 *

62 
__NTH
 (
	$mempy
 (*
__ri
 
__de
, cڡ *__ri 
__c
,

63 
size_t
 
__n
))

65  
	`__but___mempy_chk
 (
__de
, 
__c
, 
__n
, 
	`__bos0
 (__dest));

66 
	}
}

75 
__ftify_funi
 *

76 
__NTH
 (
	$memt
 (*
__de
, 
__ch
, 
size_t
 
__n
))

78 i(
	`__but_cڡt_p
 (
__n
) && __len == 0

79 && (!
	`__but_cڡt_p
 (
__ch
) || __ch != 0))

81 
	`__wn_memt_zo_n
 ();

82  
__de
;

84  
	`__but___memt_chk
 (
__de
, 
__ch
, 
__n
, 
	`__bos0
 (__dest));

85 
	}
}

87 #ifde
__USE_BSD


88 
__ftify_funi
 

89 
__NTH
 (
	$bcy
 (cڡ *
__c
, *
__de
, 
size_t
 
__n
))

91 (
	`__but___memmove_chk
 (
__de
, 
__c
, 
__n
, 
	`__bos0
 (__dest));

92 
	}
}

94 
__ftify_funi
 

95 
__NTH
 (
	$bzo
 (*
__de
, 
size_t
 
__n
))

97 (
	`__but___memt_chk
 (
__de
, '\0', 
__n
, 
	`__bos0
 (__dest));

98 
	}
}

101 
__ftify_funi
 *

102 
__NTH
 (
	$ry
 (*
__ri
 
__de
, cڡ *__ri 
__c
))

104  
	`__but___ry_chk
 (
__de
, 
__c
, 
	`__bos
 (__dest));

105 
	}
}

107 #ifde
__USE_GNU


108 
__ftify_funi
 *

109 
__NTH
 (
	$py
 (*
__ri
 
__de
, cڡ *__ri 
__c
))

111  
	`__but___py_chk
 (
__de
, 
__c
, 
	`__bos
 (__dest));

112 
	}
}

116 
__ftify_funi
 *

117 
__NTH
 (
	$y
 (*
__ri
 
__de
, cڡ *__ri 
__c
,

118 
size_t
 
__n
))

120  
	`__but___y_chk
 (
__de
, 
__c
, 
__n
, 
	`__bos
 (__dest));

121 
	}
}

124 *
	$__y_chk
 (*
__de
, cڡ *
__c
, 
size_t
 
__n
,

125 
size_t
 
__den

__THROW
;

126 *
	`__REDIRECT_NTH
 (
__y_s
, (*
__de
, cڡ *
__c
,

127 
size_t
 
__n
), 
y
);

129 
__ftify_funi
 *

130 
	`__NTH
 (
	$y
 (*
__de
, cڡ *
__c
, 
size_t
 
__n
))

132 i(
	`__bos
 (
__de
!(
size_t
) -1

133 && (!
	`__but_cڡt_p
 (
__n
|| __<
	`__bos
 (
__de
)))

134  
	`__y_chk
 (
__de
, 
__c
, 
__n
, 
	`__bos
 (__dest));

135  
	`__y_s
 (
__de
, 
__c
, 
__n
);

136 
	}
}

139 
__ftify_funi
 *

140 
__NTH
 (
	$rt
 (*
__ri
 
__de
, cڡ *__ri 
__c
))

142  
	`__but___rt_chk
 (
__de
, 
__c
, 
	`__bos
 (__dest));

143 
	}
}

146 
__ftify_funi
 *

147 
__NTH
 (
	$t
 (*
__ri
 
__de
, cڡ *__ri 
__c
,

148 
size_t
 
__n
))

150  
	`__but___t_chk
 (
__de
, 
__c
, 
__n
, 
	`__bos
 (__dest));

151 
	}
}

	@/usr/include/bits/sys_errlist.h

19 #ide
_STDIO_H


25 #ifde 
__USE_BSD


26 
sys_ü
;

27 cڡ *cڡ 
sys_i
[];

29 #ifde 
__USE_GNU


30 
_sys_ü
;

31 cڡ *cڡ 
_sys_i
[];

	@/usr/include/bits/types.h

23 #idef 
_BITS_TYPES_H


24 
	#_BITS_TYPES_H
 1

	)

26 
	~<us.h
>

27 
	~<bs/wdsize.h
>

30 
	t__u_ch
;

31 
	t__u_sht
;

32 
	t__u_t
;

33 
	t__u_lg
;

36 sigd 
	t__t8_t
;

37 
	t__ut8_t
;

38 sigd 
	t__t16_t
;

39 
	t__ut16_t
;

40 sigd 
	t__t32_t
;

41 
	t__ut32_t
;

42 #i
__WORDSIZE
 == 64

43 sigd 
	t__t64_t
;

44 
	t__ut64_t
;

46 
__exnsi__
 sigd 
	t__t64_t
;

47 
__exnsi__
 
	t__ut64_t
;

51 #i
__WORDSIZE
 == 64

52 
	t__quad_t
;

53 
	t__u_quad_t
;

55 
__exnsi__
 
	t__quad_t
;

56 
__exnsi__
 
	t__u_quad_t
;

89 
	#__S16_TYPE
 

	)

90 
	#__U16_TYPE
 

	)

91 
	#__S32_TYPE
 

	)

92 
	#__U32_TYPE
 

	)

93 
	#__SLONGWORD_TYPE
 

	)

94 
	#__ULONGWORD_TYPE
 

	)

95 #i
__WORDSIZE
 == 32

96 
	#__SQUAD_TYPE
 
__quad_t


	)

97 
	#__UQUAD_TYPE
 
__u_quad_t


	)

98 
	#__SWORD_TYPE
 

	)

99 
	#__UWORD_TYPE
 

	)

100 
	#__SLONG32_TYPE
 

	)

101 
	#__ULONG32_TYPE
 

	)

102 
	#__S64_TYPE
 
__quad_t


	)

103 
	#__U64_TYPE
 
__u_quad_t


	)

106 
	#__STD_TYPE
 
__exnsi__
 

	)

107 #i
__WORDSIZE
 == 64

108 
	t__SQUAD_TYPE
 

	)

109 
	t__UQUAD_TYPE
 

	)

110 
	t__SWORD_TYPE
 

	)

111 
	t__UWORD_TYPE
 

	)

112 
	t__SLONG32_TYPE
 

	)

113 
	t__ULONG32_TYPE
 

	)

114 
	t__S64_TYPE
 

	)

115 
	t__U64_TYPE
 

	)

117 
	t__STD_TYPE
 

	)

121 
	~<bs/tysizes.h
>

124 
__STD_TYPE
 
	t__DEV_T_TYPE
 
	t__dev_t
;

125 
__STD_TYPE
 
__UID_T_TYPE
 
	g__uid_t
;

126 
__STD_TYPE
 
__GID_T_TYPE
 
	g__gid_t
;

127 
__STD_TYPE
 
__INO_T_TYPE
 
	g__o_t
;

128 
__STD_TYPE
 
__INO64_T_TYPE
 
	g__o64_t
;

129 
__STD_TYPE
 
__MODE_T_TYPE
 
	g__mode_t
;

130 
__STD_TYPE
 
__NLINK_T_TYPE
 
	g__ƚk_t
;

131 
__STD_TYPE
 
__OFF_T_TYPE
 
	g__off_t
;

132 
__STD_TYPE
 
__OFF64_T_TYPE
 
	g__off64_t
;

133 
__STD_TYPE
 
__PID_T_TYPE
 
	g__pid_t
;

134 
__STD_TYPE
 
__FSID_T_TYPE
 
	g__fsid_t
;

135 
__STD_TYPE
 
__CLOCK_T_TYPE
 
	g__ock_t
;

136 
__STD_TYPE
 
__RLIM_T_TYPE
 
	g__im_t
;

137 
__STD_TYPE
 
__RLIM64_T_TYPE
 
	g__im64_t
;

138 
__STD_TYPE
 
__ID_T_TYPE
 
	g__id_t
;

139 
__STD_TYPE
 
__TIME_T_TYPE
 
	g__time_t
;

140 
__STD_TYPE
 
__USECONDS_T_TYPE
 
	g__ucds_t
;

141 
__STD_TYPE
 
__SUSECONDS_T_TYPE
 
	g__sucds_t
;

143 
__STD_TYPE
 
__DADDR_T_TYPE
 
	g__daddr_t
;

144 
__STD_TYPE
 
__KEY_T_TYPE
 
	g__key_t
;

147 
__STD_TYPE
 
__CLOCKID_T_TYPE
 
	g__ockid_t
;

150 
__STD_TYPE
 
__TIMER_T_TYPE
 
	g__tim_t
;

153 
__STD_TYPE
 
__BLKSIZE_T_TYPE
 
	g__blksize_t
;

158 
__STD_TYPE
 
__BLKCNT_T_TYPE
 
	g__blkt_t
;

159 
__STD_TYPE
 
__BLKCNT64_T_TYPE
 
	g__blkt64_t
;

162 
__STD_TYPE
 
__FSBLKCNT_T_TYPE
 
	g__fsblkt_t
;

163 
__STD_TYPE
 
__FSBLKCNT64_T_TYPE
 
	g__fsblkt64_t
;

166 
__STD_TYPE
 
__FSFILCNT_T_TYPE
 
	g__fsft_t
;

167 
__STD_TYPE
 
__FSFILCNT64_T_TYPE
 
	g__fsft64_t
;

170 
__STD_TYPE
 
__FSWORD_T_TYPE
 
	g__fswd_t
;

172 
__STD_TYPE
 
__SSIZE_T_TYPE
 
	g__ssize_t
;

175 
__STD_TYPE
 
__SYSCALL_SLONG_TYPE
 
	g__sys_g_t
;

177 
__STD_TYPE
 
__SYSCALL_ULONG_TYPE
 
	g__sys_ulg_t
;

181 
__off64_t
 
	t__loff_t
;

182 
__quad_t
 *
	t__qaddr_t
;

183 *
	t__ddr_t
;

186 
__STD_TYPE
 
__SWORD_TYPE
 
	g___t
;

189 
__STD_TYPE
 
__U32_TYPE
 
	g__sockn_t
;

192 #unde
__STD_TYPE


	@/usr/include/bits/waitflags.h

19 #i!
defed
 
_SYS_WAIT_H
 && !defed 
_STDLIB_H


25 
	#WNOHANG
 1

	)

26 
	#WUNTRACED
 2

	)

29 
	#WSTOPPED
 2

	)

30 
	#WEXITED
 4

	)

31 
	#WCONTINUED
 8

	)

32 
	#WNOWAIT
 0x01000000

	)

34 
	#__WNOTHREAD
 0x20000000

	)

36 
	#__WALL
 0x40000000

	)

37 
	#__WCLONE
 0x80000000

	)

40 #i
defed
 
__USE_SVID
 || defed 
__USE_XOPEN
 || defed 
__USE_XOPEN2K8


41 #ide
__ENUM_IDTYPE_T


42 
	#__ENUM_IDTYPE_T
 1

	)

46 #unde
P_ALL


47 #unde
P_PID


48 #unde
P_PGID


52 
	mP_ALL
,

53 
	mP_PID
,

54 
	mP_PGID


55 } 
	tidty_t
;

	@/usr/include/bits/waitstatus.h

19 #i!
defed
 
_SYS_WAIT_H
 && !defed 
_STDLIB_H


28 
	#__WEXITSTATUS
(
us
(((us& 0xff00>> 8)

	)

31 
	#__WTERMSIG
(
us
((us& 0x7f)

	)

34 
	#__WSTOPSIG
(
us

	`__WEXITSTATUS
(us)

	)

37 
	#__WIFEXITED
(
us
(
	`__WTERMSIG
(us=0)

	)

40 
	#__WIFSIGNALED
(
us
) \

41 (((sigd (((
us
& 0x7f+ 1>> 1> 0)

	)

44 
	#__WIFSTOPPED
(
us
(((us& 0xff=0x7f)

	)

48 #ifde
WCONTINUED


49 
	#__WIFCONTINUED
(
us
((us=
__W_CONTINUED
)

	)

53 
	#__WCOREDUMP
(
us
((us& 
__WCOREFLAG
)

	)

56 
	#__W_EXITCODE
(
t
, 
sig
(ԑ<< 8 | (sig))

	)

57 
	#__W_STOPCODE
(
sig
((sig<< 8 | 0x7f)

	)

58 
	#__W_CONTINUED
 0xffff

	)

59 
	#__WCOREFLAG
 0x80

	)

62 #ifdef 
__USE_BSD


64 
	~<dn.h
>

66 
	uwa


68 
	mw_us
;

71 #if 
__BYTE_ORDER
 =
__LITTLE_ENDIAN


72 
	m__w_rmsig
:7;

73 
	m__w_cedump
:1;

74 
	m__w_tcode
:8;

77 #if 
__BYTE_ORDER
 =
__BIG_ENDIAN


79 
	m__w_tcode
:8;

80 
	m__w_cedump
:1;

81 
	m__w_rmsig
:7;

83 } 
	m__wa_rmed
;

86 #if 
__BYTE_ORDER
 =
__LITTLE_ENDIAN


87 
	m__w_v
:8;

88 
	m__w_sig
:8;

91 #if 
__BYTE_ORDER
 =
__BIG_ENDIAN


93 
	m__w_sig
:8;

94 
	m__w_v
:8;

96 } 
	m__wa_ݳd
;

99 
	#w_rmsig
 
__wa_rmed
.
__w_rmsig


	)

100 
	#w_cedump
 
__wa_rmed
.
__w_cedump


	)

101 
	#w_tcode
 
__wa_rmed
.
__w_tcode


	)

102 
	#w_sig
 
__wa_ݳd
.
__w_sig


	)

103 
	#w_v
 
__wa_ݳd
.
__w_v


	)

	@/usr/include/endian.h

18 #idef 
_ENDIAN_H


19 
	#_ENDIAN_H
 1

	)

21 
	~<us.h
>

31 
	#__LITTLE_ENDIAN
 1234

	)

32 
	#__BIG_ENDIAN
 4321

	)

33 
	#__PDP_ENDIAN
 3412

	)

36 
	~<bs/dn.h
>

40 #ide
__FLOAT_WORD_ORDER


41 
	#__FLOAT_WORD_ORDER
 
__BYTE_ORDER


	)

44 #ifdef 
__USE_BSD


45 
	#LITTLE_ENDIAN
 
__LITTLE_ENDIAN


	)

46 
	#BIG_ENDIAN
 
__BIG_ENDIAN


	)

47 
	#PDP_ENDIAN
 
__PDP_ENDIAN


	)

48 
	#BYTE_ORDER
 
__BYTE_ORDER


	)

51 #i
__BYTE_ORDER
 =
__LITTLE_ENDIAN


52 
	#__LONG_LONG_PAIR
(
HI
, 
LO
LO, 
	)
HI

53 #i
__BYTE_ORDER
 =
__BIG_ENDIAN


54 
	#__LONG_LONG_PAIR
(
HI
, 
LO
HI, 
	)
LO

58 #i
defed
 
__USE_BSD
 && !defed 
__ASSEMBLER__


60 
	~<bs/bysw.h
>

62 #i
__BYTE_ORDER
 =
__LITTLE_ENDIAN


63 
	#htobe16
(
x

	`__bsw_16
 (x)

	)

64 
	#hte16
(
x
(x)

	)

65 
	#be16toh
(
x

	`__bsw_16
 (x)

	)

66 
	#16toh
(
x
(x)

	)

68 
	#htobe32
(
x

	`__bsw_32
 (x)

	)

69 
	#hte32
(
x
(x)

	)

70 
	#be32toh
(
x

	`__bsw_32
 (x)

	)

71 
	#32toh
(
x
(x)

	)

73 
	#htobe64
(
x

	`__bsw_64
 (x)

	)

74 
	#hte64
(
x
(x)

	)

75 
	#be64toh
(
x

	`__bsw_64
 (x)

	)

76 
	#64toh
(
x
(x)

	)

79 
	#htobe16
(
x
(x)

	)

80 
	#hte16
(
x

	`__bsw_16
 (x)

	)

81 
	#be16toh
(
x
(x)

	)

82 
	#16toh
(
x

	`__bsw_16
 (x)

	)

84 
	#htobe32
(
x
(x)

	)

85 
	#hte32
(
x

	`__bsw_32
 (x)

	)

86 
	#be32toh
(
x
(x)

	)

87 
	#32toh
(
x

	`__bsw_32
 (x)

	)

89 
	#htobe64
(
x
(x)

	)

90 
	#hte64
(
x

	`__bsw_64
 (x)

	)

91 
	#be64toh
(
x
(x)

	)

92 
	#64toh
(
x

	`__bsw_64
 (x)

	)

	@/usr/include/features.h

18 #idef 
_FEATURES_H


19 
	#_FEATURES_H
 1

	)

101 #unde
__USE_ISOC11


102 #unde
__USE_ISOC99


103 #unde
__USE_ISOC95


104 #unde
__USE_ISOCXX11


105 #unde
__USE_POSIX


106 #unde
__USE_POSIX2


107 #unde
__USE_POSIX199309


108 #unde
__USE_POSIX199506


109 #unde
__USE_XOPEN


110 #unde
__USE_XOPEN_EXTENDED


111 #unde
__USE_UNIX98


112 #unde
__USE_XOPEN2K


113 #unde
__USE_XOPEN2KXSI


114 #unde
__USE_XOPEN2K8


115 #unde
__USE_XOPEN2K8XSI


116 #unde
__USE_LARGEFILE


117 #unde
__USE_LARGEFILE64


118 #unde
__USE_FILE_OFFSET64


119 #unde
__USE_BSD


120 #unde
__USE_SVID


121 #unde
__USE_MISC


122 #unde
__USE_ATFILE


123 #unde
__USE_GNU


124 #unde
__USE_REENTRANT


125 #unde
__USE_FORTIFY_LEVEL


126 #unde
__KERNEL_STRICT_NAMES


130 #ide
_LOOSE_KERNEL_NAMES


131 
	#__KERNEL_STRICT_NAMES


	)

141 #i
defed
 
__GNUC__
 && defed 
__GNUC_MINOR__


142 
	#__GNUC_PREREQ
(
maj
, 
m
) \

143 ((
__GNUC__
 << 16+ 
__GNUC_MINOR__
 >((
maj
<< 16+ (
m
))

	)

145 
	#__GNUC_PREREQ
(
maj
, 
m
0

	)

150 #ifde
_GNU_SOURCE


151 #unde
_ISOC95_SOURCE


152 
	#_ISOC95_SOURCE
 1

	)

153 #unde
_ISOC99_SOURCE


154 
	#_ISOC99_SOURCE
 1

	)

155 #unde
_ISOC11_SOURCE


156 
	#_ISOC11_SOURCE
 1

	)

157 #unde
_POSIX_SOURCE


158 
	#_POSIX_SOURCE
 1

	)

159 #unde
_POSIX_C_SOURCE


160 
	#_POSIX_C_SOURCE
 200809L

	)

161 #unde
_XOPEN_SOURCE


162 
	#_XOPEN_SOURCE
 700

	)

163 #unde
_XOPEN_SOURCE_EXTENDED


164 
	#_XOPEN_SOURCE_EXTENDED
 1

	)

165 #unde
_LARGEFILE64_SOURCE


166 
	#_LARGEFILE64_SOURCE
 1

	)

167 #unde
_DEFAULT_SOURCE


168 
	#_DEFAULT_SOURCE
 1

	)

169 #unde
_BSD_SOURCE


170 
	#_BSD_SOURCE
 1

	)

171 #unde
_SVID_SOURCE


172 
	#_SVID_SOURCE
 1

	)

173 #unde
_ATFILE_SOURCE


174 
	#_ATFILE_SOURCE
 1

	)

179 #i(
defed
 
_DEFAULT_SOURCE
 \

180 || (!
defed
 
	g__STRICT_ANSI__
 \

181 && !
defed
 
	g_ISOC99_SOURCE
 \

182 && !
defed
 
	g_POSIX_SOURCE
 && !defed 
	g_POSIX_C_SOURCE
 \

183 && !
defed
 
	g_XOPEN_SOURCE
 \

184 && !
defed
 
	g_BSD_SOURCE
 && !defed 
	g_SVID_SOURCE
))

185 #unde
_DEFAULT_SOURCE


186 
	#_DEFAULT_SOURCE
 1

	)

187 #unde
_BSD_SOURCE


188 
	#_BSD_SOURCE
 1

	)

189 #unde
_SVID_SOURCE


190 
	#_SVID_SOURCE
 1

	)

194 #i(
defed
 
_ISOC11_SOURCE
 \

195 || (
defed
 
	g__STDC_VERSION__
 && __STDC_VERSION__ >= 201112L))

196 
	#__USE_ISOC11
 1

	)

200 #i(
defed
 
_ISOC99_SOURCE
 || defed 
_ISOC11_SOURCE
 \

201 || (
defed
 
__STDC_VERSION__
 && __STDC_VERSION__ >= 199901L))

202 
	#__USE_ISOC99
 1

	)

206 #i(
defed
 
_ISOC99_SOURCE
 || defed 
_ISOC11_SOURCE
 \

207 || (
defed
 
__STDC_VERSION__
 && __STDC_VERSION__ >= 199409L))

208 
	#__USE_ISOC95
 1

	)

215 #i((
defed
 
__lulus
 && __cplusplus >= 201103L) \

216 || 
defed
 
__GXX_EXPERIMENTAL_CXX0X__
)

217 
	#__USE_ISOCXX11
 1

	)

223 #ifde
_DEFAULT_SOURCE


224 #i!
defed
 
_POSIX_SOURCE
 && !defed 
_POSIX_C_SOURCE


225 
	#__USE_POSIX_IMPLICITLY
 1

	)

227 #unde
_POSIX_SOURCE


228 
	#_POSIX_SOURCE
 1

	)

229 #unde
_POSIX_C_SOURCE


230 
	#_POSIX_C_SOURCE
 200809L

	)

232 #i((!
defed
 
__STRICT_ANSI__
 || (
_XOPEN_SOURCE
 - 0) >= 500) && \

233 !
defed
 
_POSIX_SOURCE
 && !defed 
_POSIX_C_SOURCE
)

234 
	#_POSIX_SOURCE
 1

	)

235 #i
defed
 
_XOPEN_SOURCE
 && (_XOPEN_SOURCE - 0) < 500

236 
	#_POSIX_C_SOURCE
 2

	)

237 #i
defed
 
_XOPEN_SOURCE
 && (_XOPEN_SOURCE - 0) < 600

238 
	#_POSIX_C_SOURCE
 199506L

	)

239 #i
defed
 
_XOPEN_SOURCE
 && (_XOPEN_SOURCE - 0) < 700

240 
	#_POSIX_C_SOURCE
 200112L

	)

242 
	#_POSIX_C_SOURCE
 200809L

	)

244 
	#__USE_POSIX_IMPLICITLY
 1

	)

247 #i
defed
 
_POSIX_SOURCE
 || 
_POSIX_C_SOURCE
 >1 || defed 
_XOPEN_SOURCE


248 
	#__USE_POSIX
 1

	)

251 #i
defed
 
_POSIX_C_SOURCE
 && _POSIX_C_SOURCE >2 || defed 
_XOPEN_SOURCE


252 
	#__USE_POSIX2
 1

	)

255 #i(
_POSIX_C_SOURCE
 - 0) >= 199309L

256 
	#__USE_POSIX199309
 1

	)

259 #i(
_POSIX_C_SOURCE
 - 0) >= 199506L

260 
	#__USE_POSIX199506
 1

	)

263 #i(
_POSIX_C_SOURCE
 - 0) >= 200112L

264 
	#__USE_XOPEN2K
 1

	)

265 #unde
__USE_ISOC95


266 
	#__USE_ISOC95
 1

	)

267 #unde
__USE_ISOC99


268 
	#__USE_ISOC99
 1

	)

271 #i(
_POSIX_C_SOURCE
 - 0) >= 200809L

272 
	#__USE_XOPEN2K8
 1

	)

273 #unde
_ATFILE_SOURCE


274 
	#_ATFILE_SOURCE
 1

	)

277 #ifdef 
_XOPEN_SOURCE


278 
	#__USE_XOPEN
 1

	)

279 #i(
_XOPEN_SOURCE
 - 0) >= 500

280 
	#__USE_XOPEN_EXTENDED
 1

	)

281 
	#__USE_UNIX98
 1

	)

282 #unde
_LARGEFILE_SOURCE


283 
	#_LARGEFILE_SOURCE
 1

	)

284 #i(
_XOPEN_SOURCE
 - 0) >= 600

285 #i(
_XOPEN_SOURCE
 - 0) >= 700

286 
	#__USE_XOPEN2K8
 1

	)

287 
	#__USE_XOPEN2K8XSI
 1

	)

289 
	#__USE_XOPEN2K
 1

	)

290 
	#__USE_XOPEN2KXSI
 1

	)

291 #unde
__USE_ISOC95


292 
	#__USE_ISOC95
 1

	)

293 #unde
__USE_ISOC99


294 
	#__USE_ISOC99
 1

	)

297 #ifde
_XOPEN_SOURCE_EXTENDED


298 
	#__USE_XOPEN_EXTENDED
 1

	)

303 #ifde
_LARGEFILE_SOURCE


304 
	#__USE_LARGEFILE
 1

	)

307 #ifde
_LARGEFILE64_SOURCE


308 
	#__USE_LARGEFILE64
 1

	)

311 #i
defed
 
_FILE_OFFSET_BITS
 && _FILE_OFFSET_BITS == 64

312 
	#__USE_FILE_OFFSET64
 1

	)

315 #i
defed
 
_BSD_SOURCE
 || defed 
_SVID_SOURCE


316 
	#__USE_MISC
 1

	)

319 #ifdef 
_BSD_SOURCE


320 
	#__USE_BSD
 1

	)

323 #ifdef 
_SVID_SOURCE


324 
	#__USE_SVID
 1

	)

327 #ifdef 
_ATFILE_SOURCE


328 
	#__USE_ATFILE
 1

	)

331 #ifdef 
_GNU_SOURCE


332 
	#__USE_GNU
 1

	)

335 #i
defed
 
_REENTRANT
 || defed 
_THREAD_SAFE


336 
	#__USE_REENTRANT
 1

	)

339 #i
defed
 
_FORTIFY_SOURCE
 && _FORTIFY_SOURCE > 0 \

340 && 
__GNUC_PREREQ
 (4, 1&& 
defed
 
	g__OPTIMIZE__
 && __OPTIMIZE__ > 0

341 #i
_FORTIFY_SOURCE
 > 1

342 
	#__USE_FORTIFY_LEVEL
 2

	)

344 
	#__USE_FORTIFY_LEVEL
 1

	)

347 
	#__USE_FORTIFY_LEVEL
 0

	)

352 
	~<dc-edef.h
>

360 #unde
__GNU_LIBRARY__


361 
	#__GNU_LIBRARY__
 6

	)

365 
	#__GLIBC__
 2

	)

366 
	#__GLIBC_MINOR__
 19

	)

368 
	#__GLIBC_PREREQ
(
maj
, 
m
) \

369 ((
__GLIBC__
 << 16+ 
__GLIBC_MINOR__
 >((
maj
<< 16+ (
m
))

	)

372 #ide
__ASSEMBLER__


373 #ide
_SYS_CDEFS_H


374 
	~<sys/cdefs.h
>

379 #i
defed
 
__USE_FILE_OFFSET64
 && !defed 
__REDIRECT


380 
	#__USE_LARGEFILE
 1

	)

381 
	#__USE_LARGEFILE64
 1

	)

387 #i
__GNUC_PREREQ
 (2, 7&& 
defed
 
__OPTIMIZE__
 \

388 && !
defed
 
	g__OPTIMIZE_SIZE__
 && !defed 
	g__NO_INLINE__
 \

389 && 
defed
 
	g__ex_le


390 
	#__USE_EXTERN_INLINES
 1

	)

398 
	~<gnu/ubs.h
>

	@/usr/include/getopt.h

19 #ide
_GETOPT_H


21 #ide
__ed_gt


22 
	#_GETOPT_H
 1

	)

32 #i!
defed
 
__GNU_LIBRARY__


33 
	~<y.h
>

36 #ide
__THROW


37 #ide
__GNUC_PREREQ


38 
	#__GNUC_PREREQ
(
maj
, 
m
(0)

	)

40 #i
defed
 
__lulus
 && 
__GNUC_PREREQ
 (2,8)

41 
	#__THROW
 
	`throw
 ()

	)

43 
	#__THROW


	)

47 #ifdef 
__lulus


57 *
ݏrg
;

71 
td
;

76 
݋
;

80 
tt
;

82 #ide
__ed_gt


104 
	sti


106 cڡ *
	gme
;

109 
	ghas_g
;

110 *
	gag
;

111 
	gv
;

116 
	#no_gumt
 0

	)

117 
	#qued_gumt
 1

	)

118 
	#tiڮ_gumt
 2

	)

146 #ifde
__GNU_LIBRARY__


150 
gt
 (
___gc
, *cڡ *
___gv
, cڡ *
__shtts
)

151 
__THROW
;

153 #i
defed
 
__ed_gt
 && defed 
__USE_POSIX2
 \

154 && !
defed
 
	g__USE_POSIX_IMPLICITLY
 && !defed 
	g__USE_GNU


158 #ifde
__REDIRECT


159 
__REDIRECT_NTH
 (
gt
, (
___gc
, *cڡ *
___gv
,

160 cڡ *
__shtts
),

161 
__posix_gt
);

163 
__posix_gt
 (
___gc
, *cڡ *
___gv
,

164 cڡ *
__shtts

__THROW
;

165 
	#gt
 
__posix_gt


	)

169 
gt
 ();

172 #ide
__ed_gt


173 
gt_lg
 (
___gc
, *cڡ *
___gv
,

174 cڡ *
__shtts
,

175 cڡ 
ti
 *
__lgts
, *
__lgd
)

176 
__THROW
;

177 
gt_lg_ly
 (
___gc
, *cڡ *
___gv
,

178 cڡ *
__shtts
,

179 cڡ 
ti
 *
__lgts
, *
__lgd
)

180 
__THROW
;

184 #ifdef 
__lulus


189 #unde
__ed_gt


	@/usr/include/libio.h

28 #ide
_IO_STDIO_H


29 
	#_IO_STDIO_H


	)

31 
	~<_G_cfig.h
>

33 
	#_IO_os_t
 
_G_os_t


	)

34 
	#_IO_os64_t
 
_G_os64_t


	)

35 
	#_IO_size_t
 
size_t


	)

36 
	#_IO_ssize_t
 
__ssize_t


	)

37 
	#_IO_off_t
 
__off_t


	)

38 
	#_IO_off64_t
 
__off64_t


	)

39 
	#_IO_pid_t
 
__pid_t


	)

40 
	#_IO_uid_t
 
__uid_t


	)

41 
	#_IO_icv_t
 
_G_icv_t


	)

42 
	#_IO_HAVE_ST_BLKSIZE
 
_G_HAVE_ST_BLKSIZE


	)

43 
	#_IO_BUFSIZ
 
_G_BUFSIZ


	)

44 
	#_IO_va_li
 
_G_va_li


	)

45 
	#_IO_wt_t
 
wt_t


	)

48 
	#__ed___va_li


	)

49 
	~<dg.h
>

50 #ifde
__GNUC_VA_LIST


51 #unde
_IO_va_li


52 
	#_IO_va_li
 
__gnuc_va_li


	)

55 #ide
__P


56 
	~<sys/cdefs.h
>

59 
	#_IO_UNIFIED_JUMPTABLES
 1

	)

61 #ide
EOF


62 
	#EOF
 (-1)

	)

64 #ide
NULL


65 #i
defed
 
__GNUG__
 && \

66 (
	g__GNUC__
 > 2 || (__GNUC__ =2 && 
__GNUC_MINOR__
 >= 8))

67 
	#NULL
 (
__nu
)

	)

69 #i!
defed
(
__lulus
)

70 
	#NULL
 ((*)0)

	)

72 
	#NULL
 (0)

	)

77 
	#_IOS_INPUT
 1

	)

78 
	#_IOS_OUTPUT
 2

	)

79 
	#_IOS_ATEND
 4

	)

80 
	#_IOS_APPEND
 8

	)

81 
	#_IOS_TRUNC
 16

	)

82 
	#_IOS_NOCREATE
 32

	)

83 
	#_IOS_NOREPLACE
 64

	)

84 
	#_IOS_BIN
 128

	)

92 
	#_IO_MAGIC
 0xFBAD0000

	)

93 
	#_OLD_STDIO_MAGIC
 0xFABC0000

	)

94 
	#_IO_MAGIC_MASK
 0xFFFF0000

	)

95 
	#_IO_USER_BUF
 1

	)

96 
	#_IO_UNBUFFERED
 2

	)

97 
	#_IO_NO_READS
 4

	)

98 
	#_IO_NO_WRITES
 8

	)

99 
	#_IO_EOF_SEEN
 0x10

	)

100 
	#_IO_ERR_SEEN
 0x20

	)

101 
	#_IO_DELETE_DONT_CLOSE
 0x40

	)

102 
	#_IO_LINKED
 0x80

	)

103 
	#_IO_IN_BACKUP
 0x100

	)

104 
	#_IO_LINE_BUF
 0x200

	)

105 
	#_IO_TIED_PUT_GET
 0x400

	)

106 
	#_IO_CURRENTLY_PUTTING
 0x800

	)

107 
	#_IO_IS_APPENDING
 0x1000

	)

108 
	#_IO_IS_FILEBUF
 0x2000

	)

109 
	#_IO_BAD_SEEN
 0x4000

	)

110 
	#_IO_USER_LOCK
 0x8000

	)

112 
	#_IO_FLAGS2_MMAP
 1

	)

113 
	#_IO_FLAGS2_NOTCANCEL
 2

	)

114 #ifde
_LIBC


115 
	#_IO_FLAGS2_FORTIFY
 4

	)

117 
	#_IO_FLAGS2_USER_WBUF
 8

	)

118 #ifde
_LIBC


119 
	#_IO_FLAGS2_SCANF_STD
 16

	)

120 
	#_IO_FLAGS2_NOCLOSE
 32

	)

121 
	#_IO_FLAGS2_CLOEXEC
 64

	)

125 
	#_IO_SKIPWS
 01

	)

126 
	#_IO_LEFT
 02

	)

127 
	#_IO_RIGHT
 04

	)

128 
	#_IO_INTERNAL
 010

	)

129 
	#_IO_DEC
 020

	)

130 
	#_IO_OCT
 040

	)

131 
	#_IO_HEX
 0100

	)

132 
	#_IO_SHOWBASE
 0200

	)

133 
	#_IO_SHOWPOINT
 0400

	)

134 
	#_IO_UPPERCASE
 01000

	)

135 
	#_IO_SHOWPOS
 02000

	)

136 
	#_IO_SCIENTIFIC
 04000

	)

137 
	#_IO_FIXED
 010000

	)

138 
	#_IO_UNITBUF
 020000

	)

139 
	#_IO_STDIO
 040000

	)

140 
	#_IO_DONT_CLOSE
 0100000

	)

141 
	#_IO_BOOLALPHA
 0200000

	)

144 
_IO_jump_t
; 
	g_IO_FILE
;

147 #ifde
_IO_MTSAFE_IO


148 #i
defed
 
__GLIBC__
 && __GLIBC__ >= 2

149 
	~<bs/dio-lock.h
>

154 
	t_IO_lock_t
;

160 
	s_IO_mk
 {

161 
_IO_mk
 *
	m_xt
;

162 
_IO_FILE
 *
	m_sbuf
;

166 
	m_pos
;

168 
t_ampos
(
ampos
 

{ 
	m_os
 = sp; }

169 
t_offt
(
offt
{ 
	m_pos
 = offt; 
	m_os
 = (
ampos
)(-2); }

170 
	mpublic
:

171 
ammk
(
ambuf
 *
sb
);

172 ~
ammk
();

173 
vg
({  
	m_os
 == -2; }

174 
d
(
ammk
&);

175 
d
();

180 
	e__codecvt_su


182 
	m__codecvt_ok
,

183 
	m__codecvt_l
,

184 
	m__codecvt_r
,

185 
	m__codecvt_nocv


188 #i
defed
 
_LIBC
 || defed 
_GLIBCPP_USE_WCHAR_T


191 
	s_IO_codecvt


193 (*
	m__codecvt_der
(
	m_IO_codecvt
 *);

194 
__codecvt_su
 (*
__codecvt_do_out
(
	m_IO_codecvt
 *,

195 
	m__mbe_t
 *,

196 cڡ 
	mwch_t
 *,

197 cڡ 
	mwch_t
 *,

198 cڡ 
	mwch_t
 **, *,

200 
__codecvt_su
 (*
__codecvt_do_unshi
(
	m_IO_codecvt
 *,

201 
	m__mbe_t
 *, *,

203 
__codecvt_su
 (*
__codecvt_do_
(
	m_IO_codecvt
 *,

204 
	m__mbe_t
 *,

206 cڡ **, 
	mwch_t
 *,

207 
	mwch_t
 *, wchar_t **);

208 (*
	m__codecvt_do_codg
(
	m_IO_codecvt
 *);

209 (*
	m__codecvt_do_ways_nocv
(
	m_IO_codecvt
 *);

210 (*
	m__codecvt_do_ngth
(
	m_IO_codecvt
 *, 
	m__mbe_t
 *,

211 cڡ *, cڡ *, 
	m_IO_size_t
);

212 (*
	m__codecvt_do_max_ngth
(
	m_IO_codecvt
 *);

214 
_IO_icv_t
 
	m__cd_
;

215 
_IO_icv_t
 
	m__cd_out
;

219 
	s_IO_wide_da


221 
wch_t
 *
	m_IO_ad_r
;

222 
wch_t
 *
	m_IO_ad_d
;

223 
wch_t
 *
	m_IO_ad_ba
;

224 
wch_t
 *
	m_IO_wre_ba
;

225 
wch_t
 *
	m_IO_wre_r
;

226 
wch_t
 *
	m_IO_wre_d
;

227 
wch_t
 *
	m_IO_buf_ba
;

228 
wch_t
 *
	m_IO_buf_d
;

230 
wch_t
 *
	m_IO_ve_ba
;

231 
wch_t
 *
	m_IO_backup_ba
;

233 
wch_t
 *
	m_IO_ve_d
;

235 
__mbe_t
 
	m_IO_e
;

236 
__mbe_t
 
	m_IO_ϡ_e
;

237 
_IO_codecvt
 
	m_codecvt
;

239 
wch_t
 
	m_shtbuf
[1];

241 cڡ 
_IO_jump_t
 *
	m_wide_vb
;

245 
	s_IO_FILE
 {

246 
	m_ags
;

247 
	#_IO_fe_ags
 
_ags


	)

251 * 
	m_IO_ad_r
;

252 * 
	m_IO_ad_d
;

253 * 
	m_IO_ad_ba
;

254 * 
	m_IO_wre_ba
;

255 * 
	m_IO_wre_r
;

256 * 
	m_IO_wre_d
;

257 * 
	m_IO_buf_ba
;

258 * 
	m_IO_buf_d
;

260 *
	m_IO_ve_ba
;

261 *
	m_IO_backup_ba
;

262 *
	m_IO_ve_d
;

264 
_IO_mk
 *
	m_mks
;

266 
_IO_FILE
 *
	m_cha
;

268 
	m_fo
;

270 
	m_blksize
;

272 
	m_ags2
;

274 
_IO_off_t
 
	m_d_offt
;

276 
	#__HAVE_COLUMN


	)

278 
	m_cur_cumn
;

279 sigd 
	m_vb_offt
;

280 
	m_shtbuf
[1];

284 
_IO_lock_t
 *
	m_lock
;

285 #ifde
_IO_USE_OLD_IO_FILE


288 
	s_IO_FILE_come


290 
_IO_FILE
 
	m_fe
;

292 #i
defed
 
_G_IO_IO_FILE_VERSION
 && _G_IO_IO_FILE_VERSION == 0x20001

293 
_IO_off64_t
 
	m_offt
;

294 #i
defed
 
_LIBC
 || defed 
_GLIBCPP_USE_WCHAR_T


296 
_IO_codecvt
 *
	m_codecvt
;

297 
_IO_wide_da
 *
	m_wide_da
;

298 
_IO_FILE
 *
	m_䓻s_li
;

299 *
	m_䓻s_buf
;

300 
size_t
 
	m_䓻s_size
;

302 *
	m__d1
;

303 *
	m__d2
;

304 *
	m__d3
;

305 *
	m__d4
;

306 
size_t
 
	m__d5
;

308 
	m_mode
;

310 
	m_unud2
[15 *  (- 4 *  (*-  (
size_t
)];

314 #ide
__lulus


315 
_IO_FILE
 
	t_IO_FILE
;

318 
	g_IO_FILE_us
;

320 
_IO_FILE_us
 
_IO_2_1_d_
;

321 
_IO_FILE_us
 
_IO_2_1_dout_
;

322 
_IO_FILE_us
 
_IO_2_1_dr_
;

323 #ide
_LIBC


324 
	#_IO_d
 ((
_IO_FILE
*)(&
_IO_2_1_d_
))

	)

325 
	#_IO_dout
 ((
_IO_FILE
*)(&
_IO_2_1_dout_
))

	)

326 
	#_IO_dr
 ((
_IO_FILE
*)(&
_IO_2_1_dr_
))

	)

328 
_IO_FILE
 *
_IO_d
 
ibu_hidd
;

329 
_IO_FILE
 *
_IO_dout
 
ibu_hidd
;

330 
_IO_FILE
 *
_IO_dr
 
ibu_hidd
;

338 
__ssize_t
 
	t__io_ad_
 (*
	t__cook
, *
	t__buf
, 
	tsize_t
 
	t__nbys
);

346 
__ssize_t
 
	t__io_wre_
 (*
	t__cook
, cڡ *
	t__buf
,

347 
	tsize_t
 
	t__n
);

355 
	t__io_ek_
 (*
	t__cook
, 
	t_IO_off64_t
 *
	t__pos
, 
	t__w
);

358 
	t__io_o_
 (*
	t__cook
);

361 #ifde
_GNU_SOURCE


363 
__io_ad_
 
	tcook_ad_funi_t
;

364 
__io_wre_
 
	tcook_wre_funi_t
;

365 
__io_ek_
 
	tcook_ek_funi_t
;

366 
__io_o_
 
	tcook_o_funi_t
;

371 
__io_ad_
 *
	mad
;

372 
__io_wre_
 *
	mwre
;

373 
__io_ek_
 *
	mek
;

374 
__io_o_
 *
	mo
;

375 } 
	t_IO_cook_io_funis_t
;

376 
_IO_cook_io_funis_t
 
	tcook_io_funis_t
;

378 
	g_IO_cook_fe
;

381 
_IO_cook_
 (
_IO_cook_fe
 *
__cfe
, 
__ad_wre
,

382 *
__cook
, 
_IO_cook_io_funis_t
 
__s
);

386 #ifde
__lulus


390 
__undow
 (
_IO_FILE
 *);

391 
__uow
 (
_IO_FILE
 *);

392 
__ovow
 (
_IO_FILE
 *, );

393 #i
defed
 
_LIBC
 || defed 
_GLIBCPP_USE_WCHAR_T


394 
_IO_wt_t
 
__wundow
 (
_IO_FILE
 *);

395 
_IO_wt_t
 
__wuow
 (
_IO_FILE
 *);

396 
_IO_wt_t
 
__wovow
 (
_IO_FILE
 *, _IO_wint_t);

399 #i 
__GNUC__
 >= 3

400 
	#_IO_BE
(
ex
, 
s

	`__but_ex
 (x),es)

	)

402 
	#_IO_BE
(
ex
, 
s
x)

	)

405 
	#_IO_gc_uocked
(
_
) \

406 (
	`_IO_BE
 ((
_
)->
_IO_ad_r
 >(_)->
_IO_ad_d
, 0) \

407 ? 
	`__uow
 (
_
: *(*(_)->
_IO_ad_r
++)

	)

408 
	#_IO_ekc_uocked
(
_
) \

409 (
	`_IO_BE
 ((
_
)->
_IO_ad_r
 >(_)->
_IO_ad_d
, 0) \

410 && 
	`__undow
 (
_
=
EOF
 ? EOF \

411 : *(*(
_
)->
_IO_ad_r
)

	)

412 
	#_IO_putc_uocked
(
_ch
, 
_
) \

413 (
	`_IO_BE
 ((
_
)->
_IO_wre_r
 >(_)->
_IO_wre_d
, 0) \

414 ? 
	`__ovow
 (
_
, ((
_ch
)) \

415 : ((*(
_
)->
_IO_wre_r
++ = (
_ch
)))

	)

417 #i
defed
 
_LIBC
 || defed 
_GLIBCPP_USE_WCHAR_T


418 
	#_IO_gwc_uocked
(
_
) \

419 (
	`_IO_BE
 ((
_
)->
_wide_da
 =
NULL
 \

420 || ((
_
)->
_wide_da
->
_IO_ad_r
 \

421 >(
_
)->
_wide_da
->
_IO_ad_d
), 0) \

422 ? 
	`__wuow
 (
_
: (
_IO_wt_t
*(_)->
_wide_da
->
_IO_ad_r
++)

	)

423 
	#_IO_putwc_uocked
(
_wch
, 
_
) \

424 (
	`_IO_BE
 ((
_
)->
_wide_da
 =
NULL
 \

425 || ((
_
)->
_wide_da
->
_IO_wre_r
 \

426 >(
_
)->
_wide_da
->
_IO_wre_d
), 0) \

427 ? 
	`__wovow
 (
_
, 
_wch
) \

428 : (
_IO_wt_t
(*(
_
)->
_wide_da
->
_IO_wre_r
++ = (
_wch
)))

	)

431 
	#_IO_of_uocked
(
__
(((__)->
_ags
 & 
_IO_EOF_SEEN
!0)

	)

432 
	#_IO__uocked
(
__
(((__)->
_ags
 & 
_IO_ERR_SEEN
!0)

	)

434 
_IO_gc
 (
_IO_FILE
 *
__
);

435 
_IO_putc
 (
__c
, 
_IO_FILE
 *
__
);

436 
_IO_of
 (
_IO_FILE
 *
__

__THROW
;

437 
_IO_
 (
_IO_FILE
 *
__

__THROW
;

439 
_IO_ekc_locked
 (
_IO_FILE
 *
__
);

442 
	#_IO_PENDING_OUTPUT_COUNT
(
_
) \

443 ((
_
)->
_IO_wre_r
 - (_)->
_IO_wre_ba
)

	)

445 
_IO_ockfe
 (
_IO_FILE
 *
__THROW
;

446 
_IO_fuockfe
 (
_IO_FILE
 *
__THROW
;

447 
_IO_rylockfe
 (
_IO_FILE
 *
__THROW
;

449 #ifde
_IO_MTSAFE_IO


450 
	#_IO_ekc
(
_

	`_IO_ekc_locked
 (_)

	)

451 
	#_IO_ockfe
(
_
) \

452 i(((
_
)->
_ags
 & 
_IO_USER_LOCK
=0
	`_IO_ockfe
 (_)

	)

453 
	#_IO_fuockfe
(
_
) \

454 i(((
_
)->
_ags
 & 
_IO_USER_LOCK
=0
	`_IO_fuockfe
 (_)

	)

456 
	#_IO_ekc
(
_

	`_IO_ekc_uocked
 (_)

	)

457 
	#_IO_ockfe
(
_


	)

458 
	#_IO_fuockfe
(
_


	)

459 
	#_IO_rylockfe
(
_


	)

460 
	#_IO_nup_gi_t
(
_f
, 
_


	)

461 
	#_IO_nup_gi_d
(
_Do


	)

464 
_IO_vfsnf
 (
_IO_FILE
 * 
__ri
, const * __restrict,

465 
_IO_va_li
, *
__ri
);

466 
_IO_vrtf
 (
_IO_FILE
 *
__ri
, const *__restrict,

467 
_IO_va_li
);

468 
_IO_ssize_t
 
_IO_dn
 (
_IO_FILE
 *, , _IO_ssize_t);

469 
_IO_size_t
 
_IO_sgn
 (
_IO_FILE
 *, *, _IO_size_t);

471 
_IO_off64_t
 
_IO_ekoff
 (
_IO_FILE
 *, _IO_off64_t, , );

472 
_IO_off64_t
 
_IO_ekpos
 (
_IO_FILE
 *, _IO_off64_t, );

474 
_IO__backup_
 (
_IO_FILE
 *
__THROW
;

476 #i
defed
 
_LIBC
 || defed 
_GLIBCPP_USE_WCHAR_T


477 
_IO_wt_t
 
_IO_gwc
 (
_IO_FILE
 *
__
);

478 
_IO_wt_t
 
_IO_putwc
 (
wch_t
 
__wc
, 
_IO_FILE
 *
__
);

479 
_IO_fwide
 (
_IO_FILE
 *
__
, 
__mode

__THROW
;

480 #i
__GNUC__
 >= 2

483 #i
defed
 
_LIBC
 && defed 
SHARED


484 
	~<shlib-comt.h
>

485 #i
SHLIB_COMPAT
 (
libc
, 
GLIBC_2_0
, 
GLIBC_2_1
)

486 
	#_IO_fwide_maybe_comtib
 \

487 (
	`__but_ex
 (&
_IO_d_ud
 =
NULL
, 0))

	)

488 cڡ 
_IO_d_ud
;

489 
wk_ex
 (
_IO_d_ud
);

492 #ide
_IO_fwide_maybe_comtib


493 
	#_IO_fwide_maybe_comtib
 (0)

	)

497 
	#_IO_fwide
(
__
, 
__mode
) \

498 ({ 
__su
 = (
__mode
); \

499 i(
__su
 < 0 && ! 
_IO_fwide_maybe_comtib
) \

501 i((
__
)->
_mode
 == 0) \

503 (
__
)->
_mode
 = -1; \

504 
__su
 = (
__
)->
_mode
; \

506 i(
	`__but_cڡt_p
 (
__mode
) && (__mode) == 0) \

507 
__su
 = 
_IO_fwide_maybe_comtib
 ? -1 : (
__
)->
_mode
; \

509 
__su
 = 
	`_IO_fwide
 (
__
, __result); \

510 
__su
; })

	)

513 
_IO_vfwsnf
 (
_IO_FILE
 * 
__ri
, cڡ 
wch_t
 * __restrict,

514 
_IO_va_li
, *
__ri
);

515 
_IO_vfwtf
 (
_IO_FILE
 *
__ri
, cڡ 
wch_t
 *__restrict,

516 
_IO_va_li
);

517 
_IO_ssize_t
 
_IO_wdn
 (
_IO_FILE
 *, 
wt_t
, _IO_ssize_t);

518 
_IO__wbackup_
 (
_IO_FILE
 *
__THROW
;

521 #ifde
__LDBL_COMPAT


522 
	~<bs/libio-ldbl.h
>

525 #ifde
__lulus


	@/usr/include/stdint.h

22 #ide
_STDINT_H


23 
	#_STDINT_H
 1

	)

25 
	~<us.h
>

26 
	~<bs/wch.h
>

27 
	~<bs/wdsize.h
>

34 #ide
__t8_t_defed


35 
	#__t8_t_defed


	)

36 sigd 
	tt8_t
;

37 
	tt16_t
;

38 
	tt32_t
;

39 #i
__WORDSIZE
 == 64

40 
	tt64_t
;

42 
__exnsi__


43 
	tt64_t
;

48 
	tut8_t
;

49 
	tut16_t
;

50 #ide
__ut32_t_defed


51 
	tut32_t
;

52 
	#__ut32_t_defed


	)

54 #i
__WORDSIZE
 == 64

55 
	tut64_t
;

57 
__exnsi__


58 
	tut64_t
;

65 sigd 
	tt_a8_t
;

66 
	tt_a16_t
;

67 
	tt_a32_t
;

68 #i
__WORDSIZE
 == 64

69 
	tt_a64_t
;

71 
__exnsi__


72 
	tt_a64_t
;

76 
	tut_a8_t
;

77 
	tut_a16_t
;

78 
	tut_a32_t
;

79 #i
__WORDSIZE
 == 64

80 
	tut_a64_t
;

82 
__exnsi__


83 
	tut_a64_t
;

90 sigd 
	tt_8_t
;

91 #i
__WORDSIZE
 == 64

92 
	tt_16_t
;

93 
	tt_32_t
;

94 
	tt_64_t
;

96 
	tt_16_t
;

97 
	tt_32_t
;

98 
__exnsi__


99 
	tt_64_t
;

103 
	tut_8_t
;

104 #i
__WORDSIZE
 == 64

105 
	tut_16_t
;

106 
	tut_32_t
;

107 
	tut_64_t
;

109 
	tut_16_t
;

110 
	tut_32_t
;

111 
__exnsi__


112 
	tut_64_t
;

117 #i
__WORDSIZE
 == 64

118 #ide
___t_defed


119 
	t_t
;

120 
	#___t_defed


	)

122 
	tu_t
;

124 #ide
___t_defed


125 
	t_t
;

126 
	#___t_defed


	)

128 
	tu_t
;

133 #i
__WORDSIZE
 == 64

134 
	ttmax_t
;

135 
	tutmax_t
;

137 
__exnsi__


138 
	ttmax_t
;

139 
__exnsi__


140 
	tutmax_t
;

144 #i
__WORDSIZE
 == 64

145 
	#__INT64_C
(
c
## 
L


	)

146 
	#__UINT64_C
(
c
## 
UL


	)

148 
	#__INT64_C
(
c
## 
LL


	)

149 
	#__UINT64_C
(
c
## 
ULL


	)

155 
	#INT8_MIN
 (-128)

	)

156 
	#INT16_MIN
 (-32767-1)

	)

157 
	#INT32_MIN
 (-2147483647-1)

	)

158 
	#INT64_MIN
 (-
	`__INT64_C
(9223372036854775807)-1)

	)

160 
	#INT8_MAX
 (127)

	)

161 
	#INT16_MAX
 (32767)

	)

162 
	#INT32_MAX
 (2147483647)

	)

163 
	#INT64_MAX
 (
	`__INT64_C
(9223372036854775807))

	)

166 
	#UINT8_MAX
 (255)

	)

167 
	#UINT16_MAX
 (65535)

	)

168 
	#UINT32_MAX
 (4294967295U)

	)

169 
	#UINT64_MAX
 (
	`__UINT64_C
(18446744073709551615))

	)

173 
	#INT_LEAST8_MIN
 (-128)

	)

174 
	#INT_LEAST16_MIN
 (-32767-1)

	)

175 
	#INT_LEAST32_MIN
 (-2147483647-1)

	)

176 
	#INT_LEAST64_MIN
 (-
	`__INT64_C
(9223372036854775807)-1)

	)

178 
	#INT_LEAST8_MAX
 (127)

	)

179 
	#INT_LEAST16_MAX
 (32767)

	)

180 
	#INT_LEAST32_MAX
 (2147483647)

	)

181 
	#INT_LEAST64_MAX
 (
	`__INT64_C
(9223372036854775807))

	)

184 
	#UINT_LEAST8_MAX
 (255)

	)

185 
	#UINT_LEAST16_MAX
 (65535)

	)

186 
	#UINT_LEAST32_MAX
 (4294967295U)

	)

187 
	#UINT_LEAST64_MAX
 (
	`__UINT64_C
(18446744073709551615))

	)

191 
	#INT_FAST8_MIN
 (-128)

	)

192 #i
__WORDSIZE
 == 64

193 
	#INT_FAST16_MIN
 (-9223372036854775807L-1)

	)

194 
	#INT_FAST32_MIN
 (-9223372036854775807L-1)

	)

196 
	#INT_FAST16_MIN
 (-2147483647-1)

	)

197 
	#INT_FAST32_MIN
 (-2147483647-1)

	)

199 
	#INT_FAST64_MIN
 (-
	`__INT64_C
(9223372036854775807)-1)

	)

201 
	#INT_FAST8_MAX
 (127)

	)

202 #i
__WORDSIZE
 == 64

203 
	#INT_FAST16_MAX
 (9223372036854775807L)

	)

204 
	#INT_FAST32_MAX
 (9223372036854775807L)

	)

206 
	#INT_FAST16_MAX
 (2147483647)

	)

207 
	#INT_FAST32_MAX
 (2147483647)

	)

209 
	#INT_FAST64_MAX
 (
	`__INT64_C
(9223372036854775807))

	)

212 
	#UINT_FAST8_MAX
 (255)

	)

213 #i
__WORDSIZE
 == 64

214 
	#UINT_FAST16_MAX
 (18446744073709551615UL)

	)

215 
	#UINT_FAST32_MAX
 (18446744073709551615UL)

	)

217 
	#UINT_FAST16_MAX
 (4294967295U)

	)

218 
	#UINT_FAST32_MAX
 (4294967295U)

	)

220 
	#UINT_FAST64_MAX
 (
	`__UINT64_C
(18446744073709551615))

	)

224 #i
__WORDSIZE
 == 64

225 
	#INTPTR_MIN
 (-9223372036854775807L-1)

	)

226 
	#INTPTR_MAX
 (9223372036854775807L)

	)

227 
	#UINTPTR_MAX
 (18446744073709551615UL)

	)

229 
	#INTPTR_MIN
 (-2147483647-1)

	)

230 
	#INTPTR_MAX
 (2147483647)

	)

231 
	#UINTPTR_MAX
 (4294967295U)

	)

236 
	#INTMAX_MIN
 (-
	`__INT64_C
(9223372036854775807)-1)

	)

238 
	#INTMAX_MAX
 (
	`__INT64_C
(9223372036854775807))

	)

241 
	#UINTMAX_MAX
 (
	`__UINT64_C
(18446744073709551615))

	)

247 #i
__WORDSIZE
 == 64

248 
	#PTRDIFF_MIN
 (-9223372036854775807L-1)

	)

249 
	#PTRDIFF_MAX
 (9223372036854775807L)

	)

251 
	#PTRDIFF_MIN
 (-2147483647-1)

	)

252 
	#PTRDIFF_MAX
 (2147483647)

	)

256 
	#SIG_ATOMIC_MIN
 (-2147483647-1)

	)

257 
	#SIG_ATOMIC_MAX
 (2147483647)

	)

260 #i
__WORDSIZE
 == 64

261 
	#SIZE_MAX
 (18446744073709551615UL)

	)

263 
	#SIZE_MAX
 (4294967295U)

	)

267 #ide
WCHAR_MIN


269 
	#WCHAR_MIN
 
__WCHAR_MIN


	)

270 
	#WCHAR_MAX
 
__WCHAR_MAX


	)

274 
	#WINT_MIN
 (0u)

	)

275 
	#WINT_MAX
 (4294967295u)

	)

278 
	#INT8_C
(
c

	)
c

279 
	#INT16_C
(
c

	)
c

280 
	#INT32_C
(
c

	)
c

281 #i
__WORDSIZE
 == 64

282 
	#INT64_C
(
c
## 
L


	)

284 
	#INT64_C
(
c
## 
LL


	)

288 
	#UINT8_C
(
c

	)
c

289 
	#UINT16_C
(
c

	)
c

290 
	#UINT32_C
(
c
## 
U


	)

291 #i
__WORDSIZE
 == 64

292 
	#UINT64_C
(
c
## 
UL


	)

294 
	#UINT64_C
(
c
## 
ULL


	)

298 #i
__WORDSIZE
 == 64

299 
	#INTMAX_C
(
c
## 
L


	)

300 
	#UINTMAX_C
(
c
## 
UL


	)

302 
	#INTMAX_C
(
c
## 
LL


	)

303 
	#UINTMAX_C
(
c
## 
ULL


	)

	@/usr/include/sys/select.h

21 #ide
_SYS_SELECT_H


22 
	#_SYS_SELECT_H
 1

	)

24 
	~<us.h
>

27 
	~<bs/tys.h
>

30 
	~<bs/.h
>

33 
	~<bs/sigt.h
>

35 #ide
__sigt_t_defed


36 
	#__sigt_t_defed


	)

37 
__sigt_t
 
	tsigt_t
;

41 
	#__ed_time_t


	)

42 
	#__ed_timeec


	)

43 
	~<time.h
>

44 
	#__ed_timev


	)

45 
	~<bs/time.h
>

47 #ide
__sucds_t_defed


48 
__sucds_t
 
	tsucds_t
;

49 
	#__sucds_t_defed


	)

54 
	t__fd_mask
;

57 #unde
__NFDBITS


59 
	#__NFDBITS
 (8 * ( (
__fd_mask
))

	)

60 
	#__FD_ELT
(
d
((d/ 
__NFDBITS
)

	)

61 
	#__FD_MASK
(
d
((
__fd_mask
1 << ((d% 
__NFDBITS
))

	)

68 #ifde
__USE_XOPEN


69 
__fd_mask
 
	mfds_bs
[
__FD_SETSIZE
 / 
__NFDBITS
];

70 
	#__FDS_BITS
(
t
((t)->
fds_bs
)

	)

72 
__fd_mask
 
	m__fds_bs
[
__FD_SETSIZE
 / 
__NFDBITS
];

73 
	#__FDS_BITS
(
t
((t)->
__fds_bs
)

	)

75 } 
	tfd_t
;

78 
	#FD_SETSIZE
 
__FD_SETSIZE


	)

80 #ifde
__USE_MISC


82 
__fd_mask
 
	tfd_mask
;

85 
	#NFDBITS
 
__NFDBITS


	)

90 
	#FD_SET
(
fd
, 
fd

	`__FD_SET
 (fd, fd)

	)

91 
	#FD_CLR
(
fd
, 
fd

	`__FD_CLR
 (fd, fd)

	)

92 
	#FD_ISSET
(
fd
, 
fd

	`__FD_ISSET
 (fd, fd)

	)

93 
	#FD_ZERO
(
fd

	`__FD_ZERO
 (fd)

	)

96 
__BEGIN_DECLS


106 

 (
__nfds
, 
fd_t
 *
__ri
 
__adfds
,

107 
fd_t
 *
__ri
 
__wrefds
,

108 
fd_t
 *
__ri
 
__exfds
,

109 
timev
 *
__ri
 
__timeout
);

111 #ifde
__USE_XOPEN2K


118 
p
 (
__nfds
, 
fd_t
 *
__ri
 
__adfds
,

119 
fd_t
 *
__ri
 
__wrefds
,

120 
fd_t
 *
__ri
 
__exfds
,

121 cڡ 
timeec
 *
__ri
 
__timeout
,

122 cڡ 
__sigt_t
 *
__ri
 
__sigmask
);

127 #i
__USE_FORTIFY_LEVEL
 > 0 && 
defed
 
__GNUC__


128 
	~<bs/2.h
>

131 
	g__END_DECLS


	@/usr/include/sys/sysmacros.h

19 #ide
_SYS_SYSMACROS_H


20 
	#_SYS_SYSMACROS_H
 1

	)

22 
	~<us.h
>

24 
__BEGIN_DECLS


26 
__exnsi__


27 
	$gnu_dev_maj
 (
__dev
)

28 
__THROW
 
__ibu_cڡ__
;

29 
__exnsi__


30 
	$gnu_dev_m
 (
__dev
)

31 
__THROW
 
__ibu_cڡ__
;

32 
__exnsi__


33 
	$gnu_dev_makedev
 (
__maj
,

34 
__m
)

35 
__THROW
 
__ibu_cڡ__
;

37 #ifde
__USE_EXTERN_INLINES


38 
__exnsi__
 
__ex_le
 
__ibu_cڡ__
 

39 
	`__NTH
 (
	$gnu_dev_maj
 (
__dev
))

41  ((
__dev
 >> 8) & 0xfff) | (() (__dev >> 32) & ~0xfff);

42 
	}
}

44 
__exnsi__
 
__ex_le
 
__ibu_cڡ__
 

45 
__NTH
 (
	$gnu_dev_m
 (
__dev
))

47  (
__dev
 & 0xff) | (() (__dev >> 12) & ~0xff);

48 
	}
}

50 
__exnsi__
 
__ex_le
 
__ibu_cڡ__
 

51 
__NTH
 (
	$gnu_dev_makedev
 (
__maj
, 
__m
))

53  ((
__m
 & 0xff| ((
__maj
 & 0xfff) << 8)

54 | ((((
__m
 & ~0xff)) << 12)

55 | ((((
__maj
 & ~0xfff)) << 32));

56 
	}
}

58 
	g__END_DECLS


61 
	#maj
(
dev

	`gnu_dev_maj
 (dev)

	)

62 
	#m
(
dev

	`gnu_dev_m
 (dev)

	)

63 
	#makedev
(
maj
, 
m

	`gnu_dev_makedev
 (maj, m)

	)

	@/usr/include/sys/uio.h

18 #ide
_SYS_UIO_H


19 
	#_SYS_UIO_H
 1

	)

21 
	~<us.h
>

23 
	~<sys/tys.h
>

25 
	g__BEGIN_DECLS


28 
	~<bs/uio.h
>

39 
ssize_t
 
	$adv
 (
__fd
, cڡ 
iovec
 *
__iovec
, 
__cou
)

40 
__wur
;

50 
ssize_t
 
	$wrev
 (
__fd
, cڡ 
iovec
 *
__iovec
, 
__cou
)

51 
__wur
;

54 #ifde
__USE_BSD


55 #ide
__USE_FILE_OFFSET64


65 
ssize_t
 
	$dv
 (
__fd
, cڡ 
iovec
 *
__iovec
, 
__cou
,

66 
__off_t
 
__offt

__wur
;

77 
ssize_t
 
	$pwrev
 (
__fd
, cڡ 
iovec
 *
__iovec
, 
__cou
,

78 
__off_t
 
__offt

__wur
;

80 #ifde
__REDIRECT


81 
ssize_t
 
	`__REDIRECT
 (
dv
, (
__fd
, cڡ 
iovec
 *
__iovec
,

82 
__cou
, 
__off64_t
 
__offt
),

83 
dv64

__wur
;

84 
ssize_t
 
	`__REDIRECT
 (
pwrev
, (
__fd
, cڡ 
iovec
 *
__iovec
,

85 
__cou
, 
__off64_t
 
__offt
),

86 
pwrev64

__wur
;

88 
	#dv
 
dv64


	)

89 
	#pwrev
 
pwrev64


	)

93 #ifde
__USE_LARGEFILE64


103 
ssize_t
 
	$dv64
 (
__fd
, cڡ 
iovec
 *
__iovec
, 
__cou
,

104 
__off64_t
 
__offt

__wur
;

115 
ssize_t
 
	$pwrev64
 (
__fd
, cڡ 
iovec
 *
__iovec
, 
__cou
,

116 
__off64_t
 
__offt

__wur
;

120 
__END_DECLS


	@/usr/include/time.h

22 #idef 
_TIME_H


24 #i(! 
defed
 
__ed_time_t
 && !defed 
__ed_ock_t
 && \

25 ! 
defed
 
	g__ed_timeec
)

26 
	#_TIME_H
 1

	)

27 
	~<us.h
>

29 
	g__BEGIN_DECLS


33 #ifdef 
_TIME_H


35 
	#__ed_size_t


	)

36 
	#__ed_NULL


	)

37 
	~<ddef.h
>

41 
	~<bs/time.h
>

44 #i!
defed
 
__STRICT_ANSI__
 && !defed 
__USE_XOPEN2K


45 #ide
CLK_TCK


46 
	#CLK_TCK
 
CLOCKS_PER_SEC


	)

52 #i!
defed
 
__ock_t_defed
 && (defed 
_TIME_H
 || defed 
__ed_ock_t
)

53 
	#__ock_t_defed
 1

	)

55 
	~<bs/tys.h
>

57 
__BEGIN_NAMESPACE_STD


59 
__ock_t
 
	tock_t
;

60 
	g__END_NAMESPACE_STD


61 #i
defed
 
__USE_XOPEN
 || defed 
__USE_POSIX
 || defed 
__USE_MISC


62 
	$__USING_NAMESPACE_STD
(
ock_t
)

66 #unde
__ed_ock_t


68 #i!
defed
 
__time_t_defed
 && (defed 
_TIME_H
 || defed 
__ed_time_t
)

69 
	#__time_t_defed
 1

	)

71 
	~<bs/tys.h
>

73 
__BEGIN_NAMESPACE_STD


75 
__time_t
 
	ttime_t
;

76 
__END_NAMESPACE_STD


77 #i
defed
 
__USE_POSIX
 || defed 
__USE_MISC
 || defed 
__USE_SVID


78 
	$__USING_NAMESPACE_STD
(
time_t
)

82 #unde
__ed_time_t


84 #i!
defed
 
__ockid_t_defed
 && \

85 ((
defed
 
_TIME_H
 && defed 
__USE_POSIX199309
|| defed 
__ed_ockid_t
)

86 
	#__ockid_t_defed
 1

	)

88 
	~<bs/tys.h
>

91 
__ockid_t
 
	tockid_t
;

94 #unde
__ockid_time_t


96 #i!
defed
 
__tim_t_defed
 && \

97 ((
defed
 
_TIME_H
 && defed 
__USE_POSIX199309
|| defed 
__ed_tim_t
)

98 
	#__tim_t_defed
 1

	)

100 
	~<bs/tys.h
>

103 
__tim_t
 
	ttim_t
;

106 #unde
__ed_tim_t


109 #i(!
defed
 
__timeec_defed
 \

110 && ((
defed
 
_TIME_H
 \

111 && (
defed
 
__USE_POSIX199309
 || defed 
__USE_MISC
 \

112 || 
defed
 
__USE_ISOC11
)) \

113 || 
defed
 
__ed_timeec
))

114 
	#__timeec_defed
 1

	)

116 
	~<bs/tys.h
>

120 
	stimeec


122 
__time_t
 
tv_c
;

123 
__sys_g_t
 
tv_nc
;

127 #unde
__ed_timeec


130 #ifdef 
_TIME_H


131 
__BEGIN_NAMESPACE_STD


133 
	stm


135 
tm_c
;

136 
tm_m
;

137 
tm_hour
;

138 
tm_mday
;

139 
tm_m
;

140 
tm_yr
;

141 
tm_wday
;

142 
tm_yday
;

143 
tm_isd
;

145 #ifdef 
__USE_BSD


146 
tm_gmtoff
;

147 cڡ *
tm_ze
;

149 
__tm_gmtoff
;

150 cڡ *
__tm_ze
;

153 
__END_NAMESPACE_STD


154 #i
defed
 
__USE_XOPEN
 || defed 
__USE_POSIX
 || defed 
__USE_MISC


155 
	$__USING_NAMESPACE_STD
(
tm
)

159 #ifde
__USE_POSIX199309


161 
	simec


163 
timeec
 
_rv
;

164 
timeec
 
_vue
;

168 
sigevt
;

172 #ifde
__USE_XOPEN2K


173 #ide
__pid_t_defed


174 
__pid_t
 
	tpid_t
;

175 
	#__pid_t_defed


	)

180 #ifde
__USE_ISOC11


182 
	#TIME_UTC
 1

	)

186 
__BEGIN_NAMESPACE_STD


189 
ock_t
 
	$ock
 (
__THROW
;

192 
time_t
 
	$time
 (
time_t
 *
__tim

__THROW
;

195 
	$difime
 (
time_t
 
__time1
,ime_
__time0
)

196 
__THROW
 
	`__ibu__
 ((
__cڡ__
));

199 
time_t
 
	$mktime
 (
tm
 *
__

__THROW
;

205 
size_t
 
	$rime
 (*
__ri
 
__s
, 
size_t
 
__maxsize
,

206 cڡ *
__ri
 
__fm
,

207 cڡ 
tm
 *
__ri
 
__

__THROW
;

208 
__END_NAMESPACE_STD


210 #ifde
__USE_XOPEN


213 *
	$time
 (cڡ *
__ri
 
__s
,

214 cڡ *
__ri
 
__fmt
, 
tm
 *
__
)

215 
__THROW
;

218 #ifde
__USE_XOPEN2K8


221 
	~<xlo.h
>

223 
size_t
 
	$rime_l
 (*
__ri
 
__s
, 
size_t
 
__maxsize
,

224 cڡ *
__ri
 
__fm
,

225 cڡ 
tm
 *
__ri
 
__
,

226 
__lo_t
 
__loc

__THROW
;

229 #ifde
__USE_GNU


230 *
	$time_l
 (cڡ *
__ri
 
__s
,

231 cڡ *
__ri
 
__fmt
, 
tm
 *
__
,

232 
__lo_t
 
__loc

__THROW
;

236 
__BEGIN_NAMESPACE_STD


239 
tm
 *
	$gmtime
 (cڡ 
time_t
 *
__tim

__THROW
;

243 
tm
 *
	$loime
 (cڡ 
time_t
 *
__tim

__THROW
;

244 
__END_NAMESPACE_STD


246 #i
defed
 
__USE_POSIX
 || defed 
__USE_MISC


249 
tm
 *
	$gmtime_r
 (cڡ 
time_t
 *
__ri
 
__tim
,

250 
tm
 *
__ri
 
__

__THROW
;

254 
tm
 *
	$loime_r
 (cڡ 
time_t
 *
__ri
 
__tim
,

255 
tm
 *
__ri
 
__

__THROW
;

258 
__BEGIN_NAMESPACE_STD


261 *
	$asime
 (cڡ 
tm
 *
__

__THROW
;

264 *
	$ime
 (cڡ 
time_t
 *
__tim

__THROW
;

265 
__END_NAMESPACE_STD


267 #i
defed
 
__USE_POSIX
 || defed 
__USE_MISC


272 *
	$asime_r
 (cڡ 
tm
 *
__ri
 
__
,

273 *
__ri
 
__buf

__THROW
;

276 *
	$ime_r
 (cڡ 
time_t
 *
__ri
 
__tim
,

277 *
__ri
 
__buf

__THROW
;

282 *
__tzme
[2];

283 
__daylight
;

284 
__timeze
;

287 #ifdef 
__USE_POSIX


289 *
tzme
[2];

293 
	$tzt
 (
__THROW
;

296 #i
defed
 
__USE_SVID
 || defed 
__USE_XOPEN


297 
daylight
;

298 
timeze
;

301 #ifde
__USE_SVID


304 
	$ime
 (cڡ 
time_t
 *
__wh

__THROW
;

310 
	#__ip
(
yr
) \

311 ((
yr
% 4 =0 && ((yr% 100 !0 || (yr% 400 =0))

	)

314 #ifde
__USE_MISC


319 
time_t
 
	$timegm
 (
tm
 *
__

__THROW
;

322 
time_t
 
	$timol
 (
tm
 *
__

__THROW
;

325 
	$dysize
 (
__yr

__THROW
 
	`__ibu__
 ((
__cڡ__
));

329 #ifde
__USE_POSIX199309


334 
	`nop
 (cڡ 
timeec
 *
__queed_time
,

335 
timeec
 *
__mag
);

339 
	$ock_gs
 (
ockid_t
 
__ock_id
, 
timeec
 *
__s

__THROW
;

342 
	$ock_gtime
 (
ockid_t
 
__ock_id
, 
timeec
 *
__

__THROW
;

345 
	$ock_ime
 (
ockid_t
 
__ock_id
, cڡ 
timeec
 *
__
)

346 
__THROW
;

348 #ifde
__USE_XOPEN2K


353 
	`ock_nop
 (
ockid_t
 
__ock_id
, 
__ags
,

354 cڡ 
timeec
 *
__q
,

355 
timeec
 *
__m
);

358 
	$ock_guockid
 (
pid_t
 
__pid
, 
ockid_t
 *
__ock_id

__THROW
;

363 
	$tim_
 (
ockid_t
 
__ock_id
,

364 
sigevt
 *
__ri
 
__evp
,

365 
tim_t
 *
__ri
 
__timid

__THROW
;

368 
	$tim_de
 (
tim_t
 
__timid

__THROW
;

371 
	$tim_ime
 (
tim_t
 
__timid
, 
__ags
,

372 cڡ 
imec
 *
__ri
 
__vue
,

373 
imec
 *
__ri
 
__ovue

__THROW
;

376 
	$tim_gtime
 (
tim_t
 
__timid
, 
imec
 *
__vue
)

377 
__THROW
;

380 
	$tim_govrun
 (
tim_t
 
__timid

__THROW
;

384 #ifde
__USE_ISOC11


386 
	$timeec_g
 (
timeec
 *
__ts
, 
__ba
)

387 
__THROW
 
	`__nnu
 ((1));

391 #ifde
__USE_XOPEN_EXTENDED


403 
gde_r
;

412 
tm
 *
	`gde
 (cڡ *
__rg
);

415 #ifde
__USE_GNU


426 
	`gde_r
 (cڡ *
__ri
 
__rg
,

427 
tm
 *
__ri
 
__sbu
);

430 
__END_DECLS


	@/usr/include/xlocale.h

20 #ide
_XLOCALE_H


21 
	#_XLOCALE_H
 1

	)

27 
	s__lo_ru


30 
__lo_da
 *
	m__los
[13];

33 cڡ *
	m__y_b
;

34 cڡ *
	m__y_tow
;

35 cڡ *
	m__y_tou
;

38 cڡ *
	m__mes
[13];

39 } *
	t__lo_t
;

42 
__lo_t
 
	tlo_t
;

	@/usr/include/_G_config.h

4 #ide
_G_cfig_h


5 
	#_G_cfig_h
 1

	)

9 
	~<bs/tys.h
>

10 
	#__ed_size_t


	)

11 #i
defed
 
_LIBC
 || defed 
_GLIBCPP_USE_WCHAR_T


12 
	#__ed_wch_t


	)

14 
	#__ed_NULL


	)

15 
	~<ddef.h
>

16 
	#__ed_mbe_t


	)

17 #i
defed
 
_LIBC
 || defed 
_GLIBCPP_USE_WCHAR_T


18 
	#__ed_wt_t


	)

20 
	~<wch.h
>

23 
__off_t
 
	m__pos
;

24 
__mbe_t
 
	m__e
;

25 } 
	t_G_os_t
;

28 
__off64_t
 
	m__pos
;

29 
__mbe_t
 
	m__e
;

30 } 
	t_G_os64_t
;

31 #i
defed
 
_LIBC
 || defed 
_GLIBCPP_USE_WCHAR_T


32 
	~<gcv.h
>

35 
__gcv_fo
 
	m__cd
;

38 
__gcv_fo
 
	m__cd
;

39 
__gcv__da
 
	m__da
;

40 } 
	m__combed
;

41 } 
	t_G_icv_t
;

46 
	#_G_va_li
 
__gnuc_va_li


	)

48 
	#_G_HAVE_MMAP
 1

	)

49 
	#_G_HAVE_MREMAP
 1

	)

51 
	#_G_IO_IO_FILE_VERSION
 0x20001

	)

54 
	#_G_HAVE_ST_BLKSIZE
 
	`defed
 (
_STATBUF_ST_BLKSIZE
)

	)

56 
	#_G_BUFSIZ
 8192

	)

	@/usr/include/asm/socket.h

1 
	~<asm-gic/sock.h
>

	@/usr/include/bits/byteswap-16.h

19 #ide
_BITS_BYTESWAP_H


23 #ifde
__GNUC__


24 #i
__GNUC__
 >= 2

25 
	#__bsw_16
(
x
) \

26 (
__exnsi__
 \

27 ({ 
__v
, 
__x
 = ((
x
); \

28 i(
	`__but_cڡt_p
 (
__x
)) \

29 
__v
 = 
	`__bsw_cڡt_16
 (
__x
); \

31 
	`__asm__
 ("rorw $8, %w0" \

32 : "" (
__v
) \

33 : "0" (
__x
) \

35 
__v
; }))

	)

38 
	#__bsw_16
(
x
) \

39 (
__exnsi__
 \

40 ({ 
__x
 = ((
x
); \

41 
	`__bsw_cڡt_16
 (
__x
); }))

	)

44 
__le
 

45 
	$__bsw_16
 (
__bsx
)

47  
	`__bsw_cڡt_16
 (
__bsx
);

48 
	}
}

	@/usr/include/bits/endian.h

3 #ide
_ENDIAN_H


7 
	#__BYTE_ORDER
 
__LITTLE_ENDIAN


	)

	@/usr/include/bits/fcntl-linux.h

19 #idef 
_FCNTL_H


37 #ifde
__USE_GNU


38 
	~<bs/uio.h
>

42 
	#O_ACCMODE
 0003

	)

43 
	#O_RDONLY
 00

	)

44 
	#O_WRONLY
 01

	)

45 
	#O_RDWR
 02

	)

46 #ide
O_CREAT


47 
	#O_CREAT
 0100

	)

49 #ide
O_EXCL


50 
	#O_EXCL
 0200

	)

52 #ide
O_NOCTTY


53 
	#O_NOCTTY
 0400

	)

55 #ide
O_TRUNC


56 
	#O_TRUNC
 01000

	)

58 #ide
O_APPEND


59 
	#O_APPEND
 02000

	)

61 #ide
O_NONBLOCK


62 
	#O_NONBLOCK
 04000

	)

64 #ide
O_NDELAY


65 
	#O_NDELAY
 
O_NONBLOCK


	)

67 #ide
O_SYNC


68 
	#O_SYNC
 04010000

	)

70 
	#O_FSYNC
 
O_SYNC


	)

71 #ide
O_ASYNC


72 
	#O_ASYNC
 020000

	)

74 #ide
__O_LARGEFILE


75 
	#__O_LARGEFILE
 0100000

	)

78 #ide
__O_DIRECTORY


79 
	#__O_DIRECTORY
 0200000

	)

81 #ide
__O_NOFOLLOW


82 
	#__O_NOFOLLOW
 0400000

	)

84 #ide
__O_CLOEXEC


85 
	#__O_CLOEXEC
 02000000

	)

87 #ide
__O_DIRECT


88 
	#__O_DIRECT
 040000

	)

90 #ide
__O_NOATIME


91 
	#__O_NOATIME
 01000000

	)

93 #ide
__O_PATH


94 
	#__O_PATH
 010000000

	)

96 #ide
__O_DSYNC


97 
	#__O_DSYNC
 010000

	)

99 #ide
__O_TMPFILE


100 
	#__O_TMPFILE
 020200000

	)

103 #ide
F_GETLK


104 #ide
__USE_FILE_OFFSET64


105 
	#F_GETLK
 5

	)

106 
	#F_SETLK
 6

	)

107 
	#F_SETLKW
 7

	)

109 
	#F_GETLK
 
F_GETLK64


	)

110 
	#F_SETLK
 
F_SETLK64


	)

111 
	#F_SETLKW
 
F_SETLKW64


	)

114 #ide
F_GETLK64


115 
	#F_GETLK64
 12

	)

116 
	#F_SETLK64
 13

	)

117 
	#F_SETLKW64
 14

	)

120 #ifde
__USE_LARGEFILE64


121 
	#O_LARGEFILE
 
__O_LARGEFILE


	)

124 #ifde
__USE_XOPEN2K8


125 
	#O_DIRECTORY
 
__O_DIRECTORY


	)

126 
	#O_NOFOLLOW
 
__O_NOFOLLOW


	)

127 
	#O_CLOEXEC
 
__O_CLOEXEC


	)

130 #ifde
__USE_GNU


131 
	#O_DIRECT
 
__O_DIRECT


	)

132 
	#O_NOATIME
 
__O_NOATIME


	)

133 
	#O_PATH
 
__O_PATH


	)

134 
	#O_TMPFILE
 
__O_TMPFILE


	)

140 #i
defed
 
__USE_POSIX199309
 || defed 
__USE_UNIX98


141 
	#O_DSYNC
 
__O_DSYNC


	)

142 #i
defed
 
__O_RSYNC


143 
	#O_RSYNC
 
__O_RSYNC


	)

145 
	#O_RSYNC
 
O_SYNC


	)

150 
	#F_DUPFD
 0

	)

151 
	#F_GETFD
 1

	)

152 
	#F_SETFD
 2

	)

153 
	#F_GETFL
 3

	)

154 
	#F_SETFL
 4

	)

156 #ide
__F_SETOWN


157 
	#__F_SETOWN
 8

	)

158 
	#__F_GETOWN
 9

	)

161 #i
defed
 
__USE_BSD
 || defed 
__USE_UNIX98
 || defed 
__USE_XOPEN2K8


162 
	#F_SETOWN
 
__F_SETOWN


	)

163 
	#F_GETOWN
 
__F_GETOWN


	)

166 #ide
__F_SETSIG


167 
	#__F_SETSIG
 10

	)

168 
	#__F_GETSIG
 11

	)

170 #ide
__F_SETOWN_EX


171 
	#__F_SETOWN_EX
 15

	)

172 
	#__F_GETOWN_EX
 16

	)

175 #ifde
__USE_GNU


176 
	#F_SETSIG
 
__F_SETSIG


	)

177 
	#F_GETSIG
 
__F_GETSIG


	)

178 
	#F_SETOWN_EX
 
__F_SETOWN_EX


	)

179 
	#F_GETOWN_EX
 
__F_GETOWN_EX


	)

182 #ifde
__USE_GNU


183 
	#F_SETLEASE
 1024

	)

184 
	#F_GETLEASE
 1025

	)

185 
	#F_NOTIFY
 1026

	)

186 
	#F_SETPIPE_SZ
 1031

	)

187 
	#F_GETPIPE_SZ
 1032

	)

189 #ifde
__USE_XOPEN2K8


190 
	#F_DUPFD_CLOEXEC
 1030

	)

195 
	#FD_CLOEXEC
 1

	)

197 #ide
F_RDLCK


199 
	#F_RDLCK
 0

	)

200 
	#F_WRLCK
 1

	)

201 
	#F_UNLCK
 2

	)

206 #ide
F_EXLCK


207 
	#F_EXLCK
 4

	)

208 
	#F_SHLCK
 8

	)

211 #ifde
__USE_BSD


213 
	#LOCK_SH
 1

	)

214 
	#LOCK_EX
 2

	)

215 
	#LOCK_NB
 4

	)

217 
	#LOCK_UN
 8

	)

220 #ifde
__USE_GNU


221 
	#LOCK_MAND
 32

	)

222 
	#LOCK_READ
 64

	)

223 
	#LOCK_WRITE
 128

	)

224 
	#LOCK_RW
 192

	)

227 #ifde
__USE_GNU


229 
	#DN_ACCESS
 0x00000001

	)

230 
	#DN_MODIFY
 0x00000002

	)

231 
	#DN_CREATE
 0x00000004

	)

232 
	#DN_DELETE
 0x00000008

	)

233 
	#DN_RENAME
 0x00000010

	)

234 
	#DN_ATTRIB
 0x00000020

	)

235 
	#DN_MULTISHOT
 0x80000000

	)

239 #ifde
__USE_GNU


241 
	e__pid_ty


243 
	mF_OWNER_TID
 = 0,

244 
	mF_OWNER_PID
,

245 
	mF_OWNER_PGRP
,

246 
	mF_OWNER_GID
 = 
F_OWNER_PGRP


250 
	sf_owr_ex


252 
__pid_ty
 
	mty
;

253 
__pid_t
 
	mpid
;

259 #ifdef 
__USE_BSD


260 
	#FAPPEND
 
O_APPEND


	)

261 
	#FFSYNC
 
O_FSYNC


	)

262 
	#FASYNC
 
O_ASYNC


	)

263 
	#FNONBLOCK
 
O_NONBLOCK


	)

264 
	#FNDELAY
 
O_NDELAY


	)

267 #ide
__POSIX_FADV_DONTNEED


268 
	#__POSIX_FADV_DONTNEED
 4

	)

269 
	#__POSIX_FADV_NOREUSE
 5

	)

272 #ifde
__USE_XOPEN2K


273 
	#POSIX_FADV_NORMAL
 0

	)

274 
	#POSIX_FADV_RANDOM
 1

	)

275 
	#POSIX_FADV_SEQUENTIAL
 2

	)

276 
	#POSIX_FADV_WILLNEED
 3

	)

277 
	#POSIX_FADV_DONTNEED
 
__POSIX_FADV_DONTNEED


	)

278 
	#POSIX_FADV_NOREUSE
 
__POSIX_FADV_NOREUSE


	)

282 #ifde
__USE_GNU


284 
	#SYNC_FILE_RANGE_WAIT_BEFORE
 1

	)

287 
	#SYNC_FILE_RANGE_WRITE
 2

	)

290 
	#SYNC_FILE_RANGE_WAIT_AFTER
 4

	)

295 
	#SPLICE_F_MOVE
 1

	)

296 
	#SPLICE_F_NONBLOCK
 2

	)

299 
	#SPLICE_F_MORE
 4

	)

300 
	#SPLICE_F_GIFT
 8

	)

304 
	#FALLOC_FL_KEEP_SIZE
 1

	)

307 
	#FALLOC_FL_PUNCH_HOLE
 2

	)

311 
	sfe_hd


313 
	mhd_bys
;

314 
	mhd_ty
;

316 
	mf_hd
[0];

320 
	#MAX_HANDLE_SZ
 128

	)

324 #ifde
__USE_ATFILE


325 
	#AT_FDCWD
 -100

	)

328 
	#AT_SYMLINK_NOFOLLOW
 0x100

	)

329 
	#AT_REMOVEDIR
 0x200

	)

331 
	#AT_SYMLINK_FOLLOW
 0x400

	)

332 #ifde
__USE_GNU


333 
	#AT_NO_AUTOMOUNT
 0x800

	)

335 
	#AT_EMPTY_PATH
 0x1000

	)

337 
	#AT_EACCESS
 0x200

	)

341 
	g__BEGIN_DECLS


343 #ifde
__USE_GNU


346 
ssize_t
 
	$adahd
 (
__fd
, 
__off64_t
 
__offt
, 
size_t
 
__cou
)

347 
__THROW
;

354 
	`sync_fe_nge
 (
__fd
, 
__off64_t
 
__offt
, __off64_
__cou
,

355 
__ags
);

362 
ssize_t
 
	`vmli
 (
__fdout
, cڡ 
iovec
 *
__iov
,

363 
size_t
 
__cou
, 
__ags
);

369 
ssize_t
 
	`li
 (
__fd
, 
__off64_t
 *
__off
, 
__fdout
,

370 
__off64_t
 *
__offout
, 
size_t
 
__n
,

371 
__ags
);

377 
ssize_t
 
	`e
 (
__fd
, 
__fdout
, 
size_t
 
__n
,

378 
__ags
);

384 #ide
__USE_FILE_OFFSET64


385 
	`o
 (
__fd
, 
__mode
, 
__off_t
 
__offt
, __off_
__n
);

387 #ifde
__REDIRECT


388 
	`__REDIRECT
 (
o
, (
__fd
, 
__mode
, 
__off64_t
 
__offt
,

389 
__off64_t
 
__n
),

390 
o64
);

392 
	#o
 
o64


	)

395 #ifde
__USE_LARGEFILE64


396 
	`o64
 (
__fd
, 
__mode
, 
__off64_t
 
__offt
,

397 
__off64_t
 
__n
);

402 
	$me_to_hd_
 (
__dfd
, cڡ *
__me
,

403 
fe_hd
 *
__hd
, *
__m_id
,

404 
__ags

__THROW
;

410 
	`ݒ_by_hd_
 (
__moudfd
, 
fe_hd
 *
__hd
,

411 
__ags
);

415 
__END_DECLS


	@/usr/include/bits/libio-ldbl.h

19 #ide
_IO_STDIO_H


23 
	$__LDBL_REDIR_DECL
 (
_IO_vfsnf
)

24 
	`__LDBL_REDIR_DECL
 (
_IO_vrtf
)

	@/usr/include/bits/select.h

18 #ide
_SYS_SELECT_H


22 
	~<bs/wdsize.h
>

25 #i
defed
 
__GNUC__
 && __GNUC__ >= 2

27 #i
__WORDSIZE
 == 64

28 
	#__FD_ZERO_STOS
 "osq"

	)

30 
	#__FD_ZERO_STOS
 "o"

	)

33 
	#__FD_ZERO
(
fd
) \

35 
__d0
, 
__d1
; \

36 
__asm__
 
	`__vީe__
 ("d;; " 
__FD_ZERO_STOS
 \

37 : "=c" (
__d0
), "=D" (
__d1
) \

38 : "a" (0), "0" ( (
fd_t
) \

39 /  (
__fd_mask
)), \

40 "1" (&
	`__FDS_BITS
 (
fd
)[0]) \

42 } 0)

	)

48 
	#__FD_ZERO
(
t
) \

50 
__i
; \

51 
fd_t
 *
__r
 = (
t
); \

52 
__i
 = 0; __<  (
fd_t
/  (
__fd_mask
); ++__i) \

53 
	`__FDS_BITS
 (
__r
)[
__i
] = 0; \

54 } 0)

	)

58 
	#__FD_SET
(
d
, 
t
) \

59 (((
	`__FDS_BITS
 (
t
)[
	`__FD_ELT
 (
d
)] |
	`__FD_MASK
 (d)))

	)

60 
	#__FD_CLR
(
d
, 
t
) \

61 (((
	`__FDS_BITS
 (
t
)[
	`__FD_ELT
 (
d
)] &~
	`__FD_MASK
 (d)))

	)

62 
	#__FD_ISSET
(
d
, 
t
) \

63 ((
	`__FDS_BITS
 (
t
)[
	`__FD_ELT
 (
d
)] & 
	`__FD_MASK
 (d)!0)

	)

	@/usr/include/bits/select2.h

19 #ide
_SYS_SELECT_H


24 
__fdt_chk
 (
__d
);

25 
	$__fdt_wn
 (
__d
)

26 
	`__wǉr
 ("bit outside of fd_set selected");

27 #unde
__FD_ELT


28 
	#__FD_ELT
(
d
) \

29 
__exnsi__
 \

30 ({ 
__d
 = (
d
); \

31 (
	`__but_cڡt_p
 (
__d
) \

32 ? (0 <
__d
 && __d < 
__FD_SETSIZE
 \

33 ? (
__d
 / 
__NFDBITS
) \

34 : 
	`__fdt_wn
 (
__d
)) \

35 : 
	`__fdt_chk
 (
__d
)); 
	}
})

	)

	@/usr/include/bits/sockaddr.h

23 #ide
_BITS_SOCKADDR_H


24 
	#_BITS_SOCKADDR_H
 1

	)

28 
	t_my_t
;

34 
	#__SOCKADDR_COMMON
(
_efix
) \

35 
_my_t
 
_efix
##
my


	)

37 
	#__SOCKADDR_COMMON_SIZE
 ( ())

	)

	@/usr/include/bits/socket_type.h

19 #ide
_SYS_SOCKET_H


24 
	e__sock_ty


26 
	mSOCK_STREAM
 = 1,

28 
	#SOCK_STREAM
 
SOCK_STREAM


	)

29 
	mSOCK_DGRAM
 = 2,

31 
	#SOCK_DGRAM
 
SOCK_DGRAM


	)

32 
	mSOCK_RAW
 = 3,

33 
	#SOCK_RAW
 
SOCK_RAW


	)

34 
	mSOCK_RDM
 = 4,

35 
	#SOCK_RDM
 
SOCK_RDM


	)

36 
	mSOCK_SEQPACKET
 = 5,

38 
	#SOCK_SEQPACKET
 
SOCK_SEQPACKET


	)

39 
	mSOCK_DCCP
 = 6,

40 
	#SOCK_DCCP
 
SOCK_DCCP


	)

41 
	mSOCK_PACKET
 = 10,

44 
	#SOCK_PACKET
 
SOCK_PACKET


	)

49 
	mSOCK_CLOEXEC
 = 02000000,

51 
	#SOCK_CLOEXEC
 
SOCK_CLOEXEC


	)

52 
	mSOCK_NONBLOCK
 = 00004000

54 
	#SOCK_NONBLOCK
 
SOCK_NONBLOCK


	)

	@/usr/include/bits/stdio-lock.h

19 #ide
_BITS_STDIO_LOCK_H


20 
	#_BITS_STDIO_LOCK_H
 1

	)

22 
	~<bs/libc-lock.h
>

23 
	~<lowvlock.h
>

27 
	#_IO_lock_exnsive
 1

	)

29 ru { 
	mlock
; 
	mt
; *
	mowr
; } 
	t_IO_lock_t
;

31 
	#_IO_lock_liz
 { 
LLL_LOCK_INITIALIZER
, 0, 
NULL
 }

	)

33 
	#_IO_lock_
(
_me
) \

34 ((
_me
(
_IO_lock_t

_IO_lock_liz
 , 0)

	)

36 
	#_IO_lock_fi
(
_me
) \

37 ((0)

	)

39 
	#_IO_lock_lock
(
_me
) \

41 *
__lf
 = 
THREAD_SELF
; \

42 i((
_me
).
owr
 !
__lf
) \

44 
	`l_lock
 ((
_me
).
lock
, 
LLL_PRIVATE
); \

45 (
_me
).
owr
 = 
__lf
; \

47 ++(
_me
).
t
; \

48 } 0)

	)

50 
	#_IO_lock_ylock
(
_me
) \

52 
__su
 = 0; \

53 *
__lf
 = 
THREAD_SELF
; \

54 i((
_me
).
owr
 !
__lf
) \

56 i(
	`l_ylock
 ((
_me
).
lock
) == 0) \

58 (
_me
).
owr
 = 
__lf
; \

59 (
_me
).
t
 = 1; \

62 
__su
 = 
EBUSY
; \

65 ++(
_me
).
t
; \

66 
__su
; \

67 })

	)

69 
	#_IO_lock_uock
(
_me
) \

71 i(--(
_me
).
t
 == 0) \

73 (
_me
).
owr
 = 
NULL
; \

74 
	`l_uock
 ((
_me
).
lock
, 
LLL_PRIVATE
); \

76 } 0)

	)

80 
	#_IO_nup_gi_t
(
_f
, 
_
) \

81 
	`__libc_nup_gi_t
 (((
_
)->
_ags
 & 
_IO_USER_LOCK
=0, 
_f
, _)

	)

82 
	#_IO_nup_gi_t_nrg
(
_f
) \

83 
	`__libc_nup_gi_t
 (1, 
_f
, 
NULL
)

	)

84 
	#_IO_nup_gi_d
(
_do
) \

85 
	`__libc_nup_gi_d
 (
_do
)

	)

87 #i
defed
 
_LIBC
 && !defed 
NOT_IN_libc


89 #ifde
__EXCEPTIONS


90 
	#_IO_acque_lock
(
_
) \

92 
_IO_FILE
 *
_IO_acque_lock_fe
 \

93 
	`__ibu__
((
	`nup
 (
_IO_acque_lock_f
))) \

94 (
_
); \

95 
	`_IO_ockfe
 (
_IO_acque_lock_fe
);

	)

96 
	#_IO_acque_lock_r_ags2
(
_
) \

98 
_IO_FILE
 *
_IO_acque_lock_fe
 \

99 
	`__ibu__
((
	`nup
 (
_IO_acque_lock_r_ags2_f
))) \

100 (
_
); \

101 
	`_IO_ockfe
 (
_IO_acque_lock_fe
);

	)

103 
	#_IO_acque_lock
(
_

_IO_acque_lock_eds_exis_abd


	)

104 
	#_IO_acque_lock_r_ags2
(
_

	`_IO_acque_lock
 (_)

	)

106 
	#_IO_a_lock
(
_
; } 0)

	)

	@/usr/include/bits/time.h

23 #i
defed
 
__ed_timev
 || defed 
__USE_GNU


24 #ide
_STRUCT_TIMEVAL


25 
	#_STRUCT_TIMEVAL
 1

	)

26 
	~<bs/tys.h
>

30 
	stimev


32 
__time_t
 
	mtv_c
;

33 
__sucds_t
 
	mtv_uc
;

38 #ide
__ed_timev


39 #ide
_BITS_TIME_H


40 
	#_BITS_TIME_H
 1

	)

48 
	#CLOCKS_PER_SEC
 1000000l

	)

50 #i(!
defed
 
__STRICT_ANSI__
 || defed 
__USE_POSIX
) \

51 && !
defed
 
	g__USE_XOPEN2K


54 
	~<bs/tys.h
>

55 
__syscf
 ();

56 
	#CLK_TCK
 ((
__ock_t

	`__syscf
 (2)

	)

59 #ifde
__USE_POSIX199309


61 
	#CLOCK_REALTIME
 0

	)

63 
	#CLOCK_MONOTONIC
 1

	)

65 
	#CLOCK_PROCESS_CPUTIME_ID
 2

	)

67 
	#CLOCK_THREAD_CPUTIME_ID
 3

	)

69 
	#CLOCK_MONOTONIC_RAW
 4

	)

71 
	#CLOCK_REALTIME_COARSE
 5

	)

73 
	#CLOCK_MONOTONIC_COARSE
 6

	)

75 
	#CLOCK_BOOTTIME
 7

	)

77 
	#CLOCK_REALTIME_ALARM
 8

	)

79 
	#CLOCK_BOOTTIME_ALARM
 9

	)

82 
	#TIMER_ABSTIME
 1

	)

85 #ifde
__USE_GNU


86 
	~<bs/timex.h
>

88 
__BEGIN_DECLS


91 
	$ock_adjtime
 (
__ockid_t
 
__ock_id
, 
timex
 *
__utx

__THROW
;

93 
__END_DECLS


99 #unde
__ed_timev


	@/usr/include/bits/typesizes.h

19 #ide
_BITS_TYPES_H


23 #idef 
_BITS_TYPESIZES_H


24 
	#_BITS_TYPESIZES_H
 1

	)

30 #i
defed
 
__x86_64__
 && defed 
__ILP32__


31 
	#__SYSCALL_SLONG_TYPE
 
__SQUAD_TYPE


	)

32 
	#__SYSCALL_ULONG_TYPE
 
__UQUAD_TYPE


	)

34 
	#__SYSCALL_SLONG_TYPE
 
__SLONGWORD_TYPE


	)

35 
	#__SYSCALL_ULONG_TYPE
 
__ULONGWORD_TYPE


	)

38 
	#__DEV_T_TYPE
 
__UQUAD_TYPE


	)

39 
	#__UID_T_TYPE
 
__U32_TYPE


	)

40 
	#__GID_T_TYPE
 
__U32_TYPE


	)

41 
	#__INO_T_TYPE
 
__SYSCALL_ULONG_TYPE


	)

42 
	#__INO64_T_TYPE
 
__UQUAD_TYPE


	)

43 
	#__MODE_T_TYPE
 
__U32_TYPE


	)

44 #ifde
__x86_64__


45 
	#__NLINK_T_TYPE
 
__SYSCALL_ULONG_TYPE


	)

46 
	#__FSWORD_T_TYPE
 
__SYSCALL_SLONG_TYPE


	)

48 
	#__NLINK_T_TYPE
 
__UWORD_TYPE


	)

49 
	#__FSWORD_T_TYPE
 
__SWORD_TYPE


	)

51 
	#__OFF_T_TYPE
 
__SYSCALL_SLONG_TYPE


	)

52 
	#__OFF64_T_TYPE
 
__SQUAD_TYPE


	)

53 
	#__PID_T_TYPE
 
__S32_TYPE


	)

54 
	#__RLIM_T_TYPE
 
__SYSCALL_ULONG_TYPE


	)

55 
	#__RLIM64_T_TYPE
 
__UQUAD_TYPE


	)

56 
	#__BLKCNT_T_TYPE
 
__SYSCALL_SLONG_TYPE


	)

57 
	#__BLKCNT64_T_TYPE
 
__SQUAD_TYPE


	)

58 
	#__FSBLKCNT_T_TYPE
 
__SYSCALL_ULONG_TYPE


	)

59 
	#__FSBLKCNT64_T_TYPE
 
__UQUAD_TYPE


	)

60 
	#__FSFILCNT_T_TYPE
 
__SYSCALL_ULONG_TYPE


	)

61 
	#__FSFILCNT64_T_TYPE
 
__UQUAD_TYPE


	)

62 
	#__ID_T_TYPE
 
__U32_TYPE


	)

63 
	#__CLOCK_T_TYPE
 
__SYSCALL_SLONG_TYPE


	)

64 
	#__TIME_T_TYPE
 
__SYSCALL_SLONG_TYPE


	)

65 
	#__USECONDS_T_TYPE
 
__U32_TYPE


	)

66 
	#__SUSECONDS_T_TYPE
 
__SYSCALL_SLONG_TYPE


	)

67 
	#__DADDR_T_TYPE
 
__S32_TYPE


	)

68 
	#__KEY_T_TYPE
 
__S32_TYPE


	)

69 
	#__CLOCKID_T_TYPE
 
__S32_TYPE


	)

70 
	#__TIMER_T_TYPE
 *

	)

71 
	#__BLKSIZE_T_TYPE
 
__SYSCALL_SLONG_TYPE


	)

72 
	#__FSID_T_TYPE
 su { 
__v
[2]; }

	)

73 
	#__SSIZE_T_TYPE
 
__SWORD_TYPE


	)

75 #ifde
__x86_64__


79 
	#__OFF_T_MATCHES_OFF64_T
 1

	)

82 
	#__INO_T_MATCHES_INO64_T
 1

	)

86 
	#__FD_SETSIZE
 1024

	)

	@/usr/include/bits/uio.h

18 #i!
defed
 
_SYS_UIO_H
 && !defed 
_FCNTL_H


22 #ide
_BITS_UIO_H


23 
	#_BITS_UIO_H
 1

	)

25 
	~<sys/tys.h
>

39 
	#UIO_MAXIOV
 1024

	)

43 
	siovec


45 *
	miov_ba
;

46 
size_t
 
	miov_n
;

52 #ifde
__USE_GNU


53 #i
defed
 
_SYS_UIO_H
 && !defed 
_BITS_UIO_H_FOR_SYS_UIO_H


54 
	#_BITS_UIO_H_FOR_SYS_UIO_H
 1

	)

56 
__BEGIN_DECLS


59 
ssize_t
 
	$oss_vm_adv
 (
pid_t
 
__pid
, cڡ 
iovec
 *
__lvec
,

60 
__liovt
,

61 cڡ 
iovec
 *
__rvec
,

62 
__riovt
,

63 
__ags
)

64 
__THROW
;

67 
ssize_t
 
	$oss_vm_wrev
 (
pid_t
 
__pid
, cڡ 
iovec
 *
__lvec
,

68 
__liovt
,

69 cڡ 
iovec
 *
__rvec
,

70 
__riovt
,

71 
__ags
)

72 
__THROW
;

74 
__END_DECLS


	@/usr/include/bits/wchar.h

19 #ide
_BITS_WCHAR_H


20 
	#_BITS_WCHAR_H
 1

	)

33 #ifde
__WCHAR_MAX__


34 
	#__WCHAR_MAX
 
__WCHAR_MAX__


	)

35 #i
L
'\0' - 1 > 0

36 
	#__WCHAR_MAX
 (0xffffffffu + 
L
'\0')

	)

38 
	#__WCHAR_MAX
 (0x7ffffff+ 
L
'\0')

	)

41 #ifde
__WCHAR_MIN__


42 
	#__WCHAR_MIN
 
__WCHAR_MIN__


	)

43 #i
L
'\0' - 1 > 0

44 
	#__WCHAR_MIN
 (
L
'\0' + 0)

	)

46 
	#__WCHAR_MIN
 (-
__WCHAR_MAX
 - 1)

	)

	@/usr/include/bits/wordsize.h

3 #i
defed
 
__x86_64__
 && !defed 
__ILP32__


4 
	#__WORDSIZE
 64

	)

6 
	#__WORDSIZE
 32

	)

9 #ifde
__x86_64__


10 
	#__WORDSIZE_TIME64_COMPAT32
 1

	)

12 
	#__SYSCALL_WORDSIZE
 64

	)

	@/usr/include/ctype.h

22 #idef 
_CTYPE_H


23 
	#_CTYPE_H
 1

	)

25 
	~<us.h
>

26 
	~<bs/tys.h
>

28 
	g__BEGIN_DECLS


30 #ide
_ISb


39 
	~<dn.h
>

40 #i
__BYTE_ORDER
 =
__BIG_ENDIAN


41 
	#_ISb
(
b
(1 << (b))

	)

43 
	#_ISb
(
b
((b< 8 ? ((1 << (b)<< 8: ((1 << (b)>> 8))

	)

48 
	m_ISu
 = 
_ISb
 (0),

49 
	m_ISlow
 = 
_ISb
 (1),

50 
	m_ISpha
 = 
_ISb
 (2),

51 
	m_ISdig
 = 
_ISb
 (3),

52 
	m_ISxdig
 = 
_ISb
 (4),

53 
	m_ISa
 = 
_ISb
 (5),

54 
	m_ISt
 = 
_ISb
 (6),

55 
	m_ISgph
 = 
_ISb
 (7),

56 
	m_ISbnk
 = 
_ISb
 (8),

57 
	m_ISl
 = 
_ISb
 (9),

58 
	m_ISpun
 = 
_ISb
 (10),

59 
	m_ISnum
 = 
_ISb
 (11)

79 cڡ **
	$__y_b_loc
 ()

80 
__THROW
 
	`__ibu__
 ((
__cڡ__
));

81 cڡ 
__t32_t
 **
	$__y_tow_loc
 ()

82 
__THROW
 
	`__ibu__
 ((
__cڡ__
));

83 cڡ 
__t32_t
 **
	$__y_tou_loc
 ()

84 
__THROW
 
	`__ibu__
 ((
__cڡ__
));

87 #ide
__lulus


88 
	#__isy
(
c
, 
ty
) \

89 ((*
	`__y_b_loc
 ())[((
c
)] & (
ty
)

	)

90 #i
defed
 
__USE_EXTERN_INLINES


91 
	#__isy_f
(
ty
) \

92 
__ex_le
 \

93 
is
##
	`ty
 (
__c

__THROW
 \

95  (*
	`__y_b_loc
 ())[((
__c
)] & (
_IS
##
ty
; \

96 
	}

	)
}

99 
	#__iscii
(
c
(((c& ~0x7f=0

	)

100 
	#__tscii
(
c
((c& 0x7f

	)

102 
	#__exy
(
me

	`me
 (
__THROW


	)

104 
__BEGIN_NAMESPACE_STD


110 
__exy
 (
ium
);

111 
__exy
 (
iha
);

112 
__exy
 (
isl
);

113 
__exy
 (
isdig
);

114 
__exy
 (
iow
);

115 
__exy
 (
isgph
);

116 
__exy
 (
irt
);

117 
__exy
 (
iun
);

118 
__exy
 (
isa
);

119 
__exy
 (
isu
);

120 
__exy
 (
isxdig
);

124 
	$tow
 (
__c

__THROW
;

127 
	$tou
 (
__c

__THROW
;

129 
__END_NAMESPACE_STD


133 #ifdef 
__USE_ISOC99


134 
__BEGIN_NAMESPACE_C99


136 
	`__exy
 (
isbnk
);

138 
__END_NAMESPACE_C99


141 #ifde
__USE_GNU


143 
	$isy
 (
__c
, 
__mask

__THROW
;

146 #i
defed
 
__USE_SVID
 || defed 
__USE_MISC
 || defed 
__USE_XOPEN


150 
	$iscii
 (
__c

__THROW
;

154 
	$tscii
 (
__c

__THROW
;

158 
	`__exy
 (
_tou
);

159 
	`__exy
 (
_tow
);

163 
	#__tobody
(
c
, 
f
, 
a
, 
gs
) \

164 (
__exnsi__
 \

165 ({ 
__s
; \

166 i( (
c
) > 1) \

168 i(
	`__but_cڡt_p
 (
c
)) \

170 
__c
 = (
c
); \

171 
__s
 = 
__c
 < -128 || __> 255 ? __: (
a
)[__c]; \

174 
__s
 = 
f
 
gs
; \

177 
__s
 = (
a
)[((
c
)]; \

178 
__s
; 
	}
}))

	)

180 #i!
defed
 
__NO_CTYPE


181 #ifde
__isy_f


182 
	$__isy_f
 (
num
)

183 
	$__isy_f
 (
pha
)

184 
	$__isy_f
 (
l
)

185 
	$__isy_f
 (
dig
)

186 
	$__isy_f
 (
low
)

187 
	$__isy_f
 (
gph
)

188 
	$__isy_f
 (
t
)

189 
	$__isy_f
 (
pun
)

190 
	$__isy_f
 (
a
)

191 
	$__isy_f
 (
u
)

192 
	$__isy_f
 (
xdig
)

193 #ifde
__USE_ISOC99


194 
	$__isy_f
 (
bnk
)

196 #i
defed
 
__isy


197 
	#ium
(
c

	`__isy
((c), 
_ISnum
)

	)

198 
	#iha
(
c

	`__isy
((c), 
_ISpha
)

	)

199 
	#isl
(
c

	`__isy
((c), 
_ISl
)

	)

200 
	#isdig
(
c

	`__isy
((c), 
_ISdig
)

	)

201 
	#iow
(
c

	`__isy
((c), 
_ISlow
)

	)

202 
	#isgph
(
c

	`__isy
((c), 
_ISgph
)

	)

203 
	#irt
(
c

	`__isy
((c), 
_ISt
)

	)

204 
	#iun
(
c

	`__isy
((c), 
_ISpun
)

	)

205 
	#isa
(
c

	`__isy
((c), 
_ISa
)

	)

206 
	#isu
(
c

	`__isy
((c), 
_ISu
)

	)

207 
	#isxdig
(
c

	`__isy
((c), 
_ISxdig
)

	)

208 #ifde
__USE_ISOC99


209 
	#isbnk
(
c

	`__isy
((c), 
_ISbnk
)

	)

213 #ifde
__USE_EXTERN_INLINES


214 
__ex_le
 

215 
	`__NTH
 (
	$tow
 (
__c
))

217  
__c
 >-128 && __< 256 ? (*
	`__y_tow_loc
 ())[__c] : __c;

218 
	}
}

220 
__ex_le
 

221 
__NTH
 (
	$tou
 (
__c
))

223  
__c
 >-128 && __< 256 ? (*
	`__y_tou_loc
 ())[__c] : __c;

224 
	}
}

227 #i
__GNUC__
 >2 && 
defed
 
__OPTIMIZE__
 && !defed 
__lulus


228 
	#tow
(
c

	`__tobody
 (c, 
tow
, *
	`__y_tow_loc
 (), (c))

	)

229 
	#tou
(
c

	`__tobody
 (c, 
tou
, *
	`__y_tou_loc
 (), (c))

	)

232 #i
defed
 
__USE_SVID
 || defed 
__USE_MISC
 || defed 
__USE_XOPEN


233 
	#iscii
(
c

	`__iscii
 (c)

	)

234 
	#tscii
(
c

	`__tscii
 (c)

	)

236 
	#_tow
(
c
(((*
	`__y_tow_loc
 ())[((c)])

	)

237 
	#_tou
(
c
(((*
	`__y_tou_loc
 ())[((c)])

	)

243 #ifde
__USE_XOPEN2K8


257 
	~<xlo.h
>

261 
	#__isy_l
(
c
, 
ty
, 
lo
) \

262 ((
lo
)->
__y_b
[((
c
)] & (
ty
)

	)

264 
	#__exy_l
(
me
) \

265 
	`me
 (, 
__lo_t

__THROW


	)

271 
__exy_l
 (
ium_l
);

272 
__exy_l
 (
iha_l
);

273 
__exy_l
 (
isl_l
);

274 
__exy_l
 (
isdig_l
);

275 
__exy_l
 (
iow_l
);

276 
__exy_l
 (
isgph_l
);

277 
__exy_l
 (
irt_l
);

278 
__exy_l
 (
iun_l
);

279 
__exy_l
 (
isa_l
);

280 
__exy_l
 (
isu_l
);

281 
__exy_l
 (
isxdig_l
);

283 
__exy_l
 (
isbnk_l
);

287 
	$__tow_l
 (
__c
, 
__lo_t
 
__l

__THROW
;

288 
	$tow_l
 (
__c
, 
__lo_t
 
__l

__THROW
;

291 
	$__tou_l
 (
__c
, 
__lo_t
 
__l

__THROW
;

292 
	$tou_l
 (
__c
, 
__lo_t
 
__l

__THROW
;

294 #i
__GNUC__
 >2 && 
defed
 
__OPTIMIZE__
 && !defed 
__lulus


295 
	#__tow_l
(
c
, 
lo
) \

296 
	`__tobody
 (
c
, 
__tow_l
, (
lo
)->
__y_tow
, (c,o))

	)

297 
	#__tou_l
(
c
, 
lo
) \

298 
	`__tobody
 (
c
, 
__tou_l
, (
lo
)->
__y_tou
, (c,o))

	)

299 
	#tow_l
(
c
, 
lo

	`__tow_l
 ((c), (lo))

	)

300 
	#tou_l
(
c
, 
lo

	`__tou_l
 ((c), (lo))

	)

304 #ide
__NO_CTYPE


305 
	#__ium_l
(
c
,
l

	`__isy_l
((c), 
_ISnum
, (l))

	)

306 
	#__iha_l
(
c
,
l

	`__isy_l
((c), 
_ISpha
, (l))

	)

307 
	#__isl_l
(
c
,
l

	`__isy_l
((c), 
_ISl
, (l))

	)

308 
	#__isdig_l
(
c
,
l

	`__isy_l
((c), 
_ISdig
, (l))

	)

309 
	#__iow_l
(
c
,
l

	`__isy_l
((c), 
_ISlow
, (l))

	)

310 
	#__isgph_l
(
c
,
l

	`__isy_l
((c), 
_ISgph
, (l))

	)

311 
	#__irt_l
(
c
,
l

	`__isy_l
((c), 
_ISt
, (l))

	)

312 
	#__iun_l
(
c
,
l

	`__isy_l
((c), 
_ISpun
, (l))

	)

313 
	#__isa_l
(
c
,
l

	`__isy_l
((c), 
_ISa
, (l))

	)

314 
	#__isu_l
(
c
,
l

	`__isy_l
((c), 
_ISu
, (l))

	)

315 
	#__isxdig_l
(
c
,
l

	`__isy_l
((c), 
_ISxdig
, (l))

	)

317 
	#__isbnk_l
(
c
,
l

	`__isy_l
((c), 
_ISbnk
, (l))

	)

319 #i
defed
 
__USE_SVID
 || defed 
__USE_MISC


320 
	#__iscii_l
(
c
,
l
(), 
	`__iscii
 (c))

	)

321 
	#__tscii_l
(
c
,
l
(), 
	`__tscii
 (c))

	)

324 
	#ium_l
(
c
,
l

	`__ium_l
 ((c), (l))

	)

325 
	#iha_l
(
c
,
l

	`__iha_l
 ((c), (l))

	)

326 
	#isl_l
(
c
,
l

	`__isl_l
 ((c), (l))

	)

327 
	#isdig_l
(
c
,
l

	`__isdig_l
 ((c), (l))

	)

328 
	#iow_l
(
c
,
l

	`__iow_l
 ((c), (l))

	)

329 
	#isgph_l
(
c
,
l

	`__isgph_l
 ((c), (l))

	)

330 
	#irt_l
(
c
,
l

	`__irt_l
 ((c), (l))

	)

331 
	#iun_l
(
c
,
l

	`__iun_l
 ((c), (l))

	)

332 
	#isa_l
(
c
,
l

	`__isa_l
 ((c), (l))

	)

333 
	#isu_l
(
c
,
l

	`__isu_l
 ((c), (l))

	)

334 
	#isxdig_l
(
c
,
l

	`__isxdig_l
 ((c), (l))

	)

336 
	#isbnk_l
(
c
,
l

	`__isbnk_l
 ((c), (l))

	)

338 #i
defed
 
__USE_SVID
 || defed 
__USE_MISC


339 
	#iscii_l
(
c
,
l

	`__iscii_l
 ((c), (l))

	)

340 
	#tscii_l
(
c
,
l

	`__tscii_l
 ((c), (l))

	)

347 
__END_DECLS


	@/usr/include/gnu/stubs.h

6 #i!
defed
 
__x86_64__


7 
	~<gnu/ubs-32.h
>

9 #i
defed
 
__x86_64__
 && defed 
__LP64__


10 
	~<gnu/ubs-64.h
>

12 #i
defed
 
__x86_64__
 && defed 
__ILP32__


13 
	~<gnu/ubs-x32.h
>

	@/usr/include/linux/errno.h

1 
	~<asm/o.h
>

	@/usr/include/stdc-predef.h

18 #idef 
_STDC_PREDEF_H


19 
	#_STDC_PREDEF_H
 1

	)

36 #ifde
__GCC_IEC_559


37 #i
__GCC_IEC_559
 > 0

38 
	#__STDC_IEC_559__
 1

	)

41 
	#__STDC_IEC_559__
 1

	)

44 #ifde
__GCC_IEC_559_COMPLEX


45 #i
__GCC_IEC_559_COMPLEX
 > 0

46 
	#__STDC_IEC_559_COMPLEX__
 1

	)

49 
	#__STDC_IEC_559_COMPLEX__
 1

	)

54 
	#__STDC_ISO_10646__
 201103L

	)

57 
	#__STDC_NO_THREADS__
 1

	)

	@/usr/include/sys/cdefs.h

18 #idef 
_SYS_CDEFS_H


19 
	#_SYS_CDEFS_H
 1

	)

22 #ide
_FEATURES_H


23 
	~<us.h
>

29 #i
defed
 
__GNUC__
 && !defed 
__STDC__


34 #unde
__P


35 #unde
__PMT


37 #ifde
__GNUC__


41 #i
__GNUC_PREREQ
 (4, 6&& !
defed
 
_LIBC


42 
	#__LEAF
 , 
__af__


	)

43 
	#__LEAF_ATTR
 
	`__ibu__
 ((
__af__
))

	)

45 
	#__LEAF


	)

46 
	#__LEAF_ATTR


	)

54 #i!
defed
 
__lulus
 && 
__GNUC_PREREQ
 (3, 3)

55 
	#__THROW
 
	`__ibu__
 ((
__nhrow__
 
__LEAF
))

	)

56 
	#__THROWNL
 
	`__ibu__
 ((
__nhrow__
))

	)

57 
	#__NTH
(
f

	`__ibu__
 ((
__nhrow__
 
__LEAF
)
	)
fct

59 #i
defed
 
__lulus
 && 
__GNUC_PREREQ
 (2,8)

60 
	#__THROW
 
	`throw
 ()

	)

61 
	#__THROWNL
 
	`throw
 ()

	)

62 
	#__NTH
(
f

__LEAF_ATTR
 f 
	`throw
 ()

	)

64 
	#__THROW


	)

65 
	#__THROWNL


	)

66 
	#__NTH
(
f

	)
fct

72 
	#__le


	)

74 
	#__THROW


	)

75 
	#__THROWNL


	)

76 
	#__NTH
(
f

	)
fct

82 
	#__P
(
gs

	)
args

83 
	#__PMT
(
gs

	)
args

88 
	#__CONCAT
(
x
,
y
x ## 
	)
y

89 
	#__STRING
(
x
#x

	)

92 
	#__r_t
 *

	)

93 
	#__lg_doub_t
 

	)

97 #ifdef 
__lulus


98 
	#__BEGIN_DECLS
 "C" {

	)

99 
	#__END_DECLS
 }

	)

101 
	#__BEGIN_DECLS


	)

102 
	#__END_DECLS


	)

111 #i
defed
 
__lulus
 && defed 
_GLIBCPP_USE_NAMESPACES


112 
	#__BEGIN_NAMESPACE_STD
 
mea
 
d
 {

	)

113 
	#__END_NAMESPACE_STD
 }

	)

114 
	#__USING_NAMESPACE_STD
(
me

usg
 
d
::me;

	)

115 
	#__BEGIN_NAMESPACE_C99
 
mea
 
__c99
 {

	)

116 
	#__END_NAMESPACE_C99
 }

	)

117 
	#__USING_NAMESPACE_C99
(
me

usg
 
__c99
::me;

	)

122 
	#__BEGIN_NAMESPACE_STD


	)

123 
	#__END_NAMESPACE_STD


	)

124 
	#__USING_NAMESPACE_STD
(
me
)

	)

125 
	#__BEGIN_NAMESPACE_C99


	)

126 
	#__END_NAMESPACE_C99


	)

127 
	#__USING_NAMESPACE_C99
(
me
)

	)

132 
	#__bos
(
r

	`__but_obje_size
 (r, 
__USE_FORTIFY_LEVEL
 > 1)

	)

133 
	#__bos0
(
r

	`__but_obje_size
 (r, 0)

	)

134 
	#__ftify_funi
 
__ex_ways_le
 
__ibu_tificl__


	)

136 #i
__GNUC_PREREQ
 (4,3)

137 
	#__wnde
(
me
, 
msg
) \

138 
	`me
 (
	`__ibu__
((
	`__wng__
 (
msg
)))

	)

139 
	#__wǉr
(
msg

	`__ibu__
((
	`__wng__
 (msg)))

	)

140 
	#__rde
(
me
, 
msg
) \

141 
	`me
 (
	`__ibu__
((
	`__r__
 (
msg
)))

	)

143 
	#__wnde
(
me
, 
msg

	`me
 ()

	)

144 
	#__wǉr
(
msg
)

	)

145 
	#__rde
(
me
, 
msg

	`me
 ()

	)

149 #i
__GNUC_PREREQ
 (2,97)

151 
	#__exr
 []

	)

153 #ifde
__GNUC__


154 
	#__exr
 [0]

	)

156 #i
defed
 
__STDC_VERSION__
 && __STDC_VERSION__ >= 199901L

157 
	#__exr
 []

	)

160 
	#__exr
 [1]

	)

176 #i
defed
 
__GNUC__
 && __GNUC__ >= 2

178 
	#__REDIRECT
(
me
, 
o
, 
s
m
	`__asm__
 (
	`__ASMNAME
 (#s))

	)

179 #ifde
__lulus


180 
	#__REDIRECT_NTH
(
me
, 
o
, 
s
) \

181 
me
 
o
 
__THROW
 
	`__asm__
 (
	`__ASMNAME
 (#s))

	)

182 
	#__REDIRECT_NTHNL
(
me
, 
o
, 
s
) \

183 
me
 
o
 
__THROWNL
 
	`__asm__
 (
	`__ASMNAME
 (#s))

	)

185 
	#__REDIRECT_NTH
(
me
, 
o
, 
s
) \

186 
me
 
o
 
	`__asm__
 (
	`__ASMNAME
 (#s)
__THROW


	)

187 
	#__REDIRECT_NTHNL
(
me
, 
o
, 
s
) \

188 
me
 
o
 
	`__asm__
 (
	`__ASMNAME
 (#s)
__THROWNL


	)

190 
	#__ASMNAME
(
ame

	`__ASMNAME2
 (
__USER_LABEL_PREFIX__
, cme)

	)

191 
	#__ASMNAME2
(
efix
, 
ame

	`__STRING
 (efix
	)
cname

204 #i!
defed
 
__GNUC__
 || __GNUC__ < 2

205 
	#__ibu__
(
xyz


	)

211 #i
__GNUC_PREREQ
 (2,96)

212 
	#__ibu_mloc__
 
	`__ibu__
 ((
__mloc__
))

	)

214 
	#__ibu_mloc__


	)

219 #i
__GNUC_PREREQ
 (4, 3)

220 
	#__ibu_loc_size__
(
ms
) \

221 
	`__ibu__
 ((
__loc_size__
 
ms
))

	)

223 
	#__ibu_loc_size__
(
ms


	)

229 #i
__GNUC_PREREQ
 (2,96)

230 
	#__ibu_pu__
 
	`__ibu__
 ((
__pu__
))

	)

232 
	#__ibu_pu__


	)

236 #i
__GNUC_PREREQ
 (2,5)

237 
	#__ibu_cڡ__
 
	`__ibu__
 ((
__cڡ__
))

	)

239 
	#__ibu_cڡ__


	)

245 #i
__GNUC_PREREQ
 (3,1)

246 
	#__ibu_ud__
 
	`__ibu__
 ((
__ud__
))

	)

247 
	#__ibu_nole__
 
	`__ibu__
 ((
__nole__
))

	)

249 
	#__ibu_ud__
 
	`__ibu__
 ((
__unud__
))

	)

250 
	#__ibu_nole__


	)

254 #i
__GNUC_PREREQ
 (3,2)

255 
	#__ibu_dd__
 
	`__ibu__
 ((
__dd__
))

	)

257 
	#__ibu_dd__


	)

266 #i
__GNUC_PREREQ
 (2,8)

267 
	#__ibu_fm_g__
(
x

	`__ibu__
 ((
	`__fm_g__
 (x)))

	)

269 
	#__ibu_fm_g__
(
x


	)

276 #i
__GNUC_PREREQ
 (2,97)

277 
	#__ibu_fm_rfm__
(
a
,
b
) \

278 
	`__ibu__
 ((
	`__fm__
 (
__rfm__
, 
a
, 
b
)))

	)

280 
	#__ibu_fm_rfm__
(
a
,
b


	)

285 #i
__GNUC_PREREQ
 (3,3)

286 
	#__nnu
(
ms

	`__ibu__
 ((
__nnu__
ams))

	)

288 
	#__nnu
(
ms
)

	)

293 #i
__GNUC_PREREQ
 (3,4)

294 
	#__ibu_wn_unud_su__
 \

295 
	`__ibu__
 ((
__wn_unud_su__
))

	)

296 #i
__USE_FORTIFY_LEVEL
 > 0

297 
	#__wur
 
__ibu_wn_unud_su__


	)

300 
	#__ibu_wn_unud_su__


	)

302 #ide
__wur


303 
	#__wur


	)

307 #i
__GNUC_PREREQ
 (3,2)

308 
	#__ways_le
 
__le
 
	`__ibu__
 ((
__ways_le__
))

	)

310 
	#__ways_le
 
__le


	)

315 #i
__GNUC_PREREQ
 (4,3)

316 
	#__ibu_tificl__
 
	`__ibu__
 ((
__tificl__
))

	)

318 
	#__ibu_tificl__


	)

321 #ifde
__GNUC__


326 #i
defed
 
__GNUC_STDC_INLINE__
 || defed 
__GNUC_GNU_INLINE__


327 
	#__ex_le
 
__le
 
	`__ibu__
 ((
__gnu_le__
))

	)

328 
	#__ex_ways_le
 \

329 
__ways_le
 
	`__ibu__
 ((
__gnu_le__
))

	)

331 
	#__ex_le
 
__le


	)

332 
	#__ex_ways_le
 
__ways_le


	)

335 
	#__ex_le


	)

336 
	#__ex_ways_le


	)

341 #i
__GNUC_PREREQ
 (4,3)

342 
	#__va_g_ck
(
	`__but_va_g_ck
 ()

	)

343 
	#__va_g_ck_n
(
	`__but_va_g_ck_n
 ()

	)

350 #i!
__GNUC_PREREQ
 (2,8)

351 
	#__exnsi__


	)

355 #i!
__GNUC_PREREQ
 (2,92)

356 
	#__ri


	)

362 #i
__GNUC_PREREQ
 (3,1&& !
defed
 
__GNUG__


363 
	#__ri_r
 
__ri


	)

365 #ifde
__GNUC__


366 
	#__ri_r


	)

368 #i
defed
 
__STDC_VERSION__
 && __STDC_VERSION__ >= 199901L

369 
	#__ri_r
 
ri


	)

372 
	#__ri_r


	)

377 #i
__GNUC__
 >= 3

378 
	#__glibc_uiky
(
cd

	`__but_ex
 ((cd), 0)

	)

379 
	#__glibc_liky
(
cd

	`__but_ex
 ((cd), 1)

	)

381 
	#__glibc_uiky
(
cd
(cd)

	)

382 
	#__glibc_liky
(
cd
(cd)

	)

385 
	~<bs/wdsize.h
>

387 #i
defed
 
__LONG_DOUBLE_MATH_OPTIONAL
 && defed 
__NO_LONG_DOUBLE_MATH


388 
	#__LDBL_COMPAT
 1

	)

389 #ifde
__REDIRECT


390 
	#__LDBL_REDIR1
(
me
, 
o
, 
s

	`__REDIRECT
 (me,ro,ls)

	)

391 
	#__LDBL_REDIR
(
me
, 
o
) \

392 
	`__LDBL_REDIR1
 (
me
, 
o
, 
__dbl_
##me)

	)

393 
	#__LDBL_REDIR1_NTH
(
me
, 
o
, 
s

	`__REDIRECT_NTH
 (me,ro,ls)

	)

394 
	#__LDBL_REDIR_NTH
(
me
, 
o
) \

395 
	`__LDBL_REDIR1_NTH
 (
me
, 
o
, 
__dbl_
##me)

	)

396 
	#__LDBL_REDIR1_DECL
(
me
, 
s
) \

397 
	`__tyof
 (
me
m
	`__asm
 (
	`__ASMNAME
 (#s));

	)

398 
	#__LDBL_REDIR_DECL
(
me
) \

399 
	`__tyof
 (
me
m
	`__asm
 (
	`__ASMNAME
 ("__dbl_" #me));

	)

400 
	#__REDIRECT_LDBL
(
me
, 
o
, 
s
) \

401 
	`__LDBL_REDIR1
 (
me
, 
o
, 
__dbl_
##
s
)

	)

402 
	#__REDIRECT_NTH_LDBL
(
me
, 
o
, 
s
) \

403 
	`__LDBL_REDIR1_NTH
 (
me
, 
o
, 
__dbl_
##
s
)

	)

406 #i!
defed
 
__LDBL_COMPAT
 || !defed 
__REDIRECT


407 
	#__LDBL_REDIR1
(
me
, 
o
, 
s
m
	)
proto

408 
	#__LDBL_REDIR
(
me
, 
o
m
	)
proto

409 
	#__LDBL_REDIR1_NTH
(
me
, 
o
, 
s
m
__THROW


	)

410 
	#__LDBL_REDIR_NTH
(
me
, 
o
m
__THROW


	)

411 
	#__LDBL_REDIR_DECL
(
me
)

	)

412 #ifde
__REDIRECT


413 
	#__REDIRECT_LDBL
(
me
, 
o
, 
s

	`__REDIRECT
 (me,ro,ls)

	)

414 
	#__REDIRECT_NTH_LDBL
(
me
, 
o
, 
s
) \

415 
	`__REDIRECT_NTH
 (
me
, 
o
, 
s
)

	)

	@/usr/include/asm-generic/socket.h

1 #ide
__ASM_GENERIC_SOCKET_H


2 
	#__ASM_GENERIC_SOCKET_H


	)

4 
	~<asm/sockios.h
>

7 
	#SOL_SOCKET
 1

	)

9 
	#SO_DEBUG
 1

	)

10 
	#SO_REUSEADDR
 2

	)

11 
	#SO_TYPE
 3

	)

12 
	#SO_ERROR
 4

	)

13 
	#SO_DONTROUTE
 5

	)

14 
	#SO_BROADCAST
 6

	)

15 
	#SO_SNDBUF
 7

	)

16 
	#SO_RCVBUF
 8

	)

17 
	#SO_SNDBUFFORCE
 32

	)

18 
	#SO_RCVBUFFORCE
 33

	)

19 
	#SO_KEEPALIVE
 9

	)

20 
	#SO_OOBINLINE
 10

	)

21 
	#SO_NO_CHECK
 11

	)

22 
	#SO_PRIORITY
 12

	)

23 
	#SO_LINGER
 13

	)

24 
	#SO_BSDCOMPAT
 14

	)

25 
	#SO_REUSEPORT
 15

	)

26 #ide
SO_PASSCRED


27 
	#SO_PASSCRED
 16

	)

28 
	#SO_PEERCRED
 17

	)

29 
	#SO_RCVLOWAT
 18

	)

30 
	#SO_SNDLOWAT
 19

	)

31 
	#SO_RCVTIMEO
 20

	)

32 
	#SO_SNDTIMEO
 21

	)

36 
	#SO_SECURITY_AUTHENTICATION
 22

	)

37 
	#SO_SECURITY_ENCRYPTION_TRANSPORT
 23

	)

38 
	#SO_SECURITY_ENCRYPTION_NETWORK
 24

	)

40 
	#SO_BINDTODEVICE
 25

	)

43 
	#SO_ATTACH_FILTER
 26

	)

44 
	#SO_DETACH_FILTER
 27

	)

45 
	#SO_GET_FILTER
 
SO_ATTACH_FILTER


	)

47 
	#SO_PEERNAME
 28

	)

48 
	#SO_TIMESTAMP
 29

	)

49 
	#SCM_TIMESTAMP
 
SO_TIMESTAMP


	)

51 
	#SO_ACCEPTCONN
 30

	)

53 
	#SO_PEERSEC
 31

	)

54 
	#SO_PASSSEC
 34

	)

55 
	#SO_TIMESTAMPNS
 35

	)

56 
	#SCM_TIMESTAMPNS
 
SO_TIMESTAMPNS


	)

58 
	#SO_MARK
 36

	)

60 
	#SO_TIMESTAMPING
 37

	)

61 
	#SCM_TIMESTAMPING
 
SO_TIMESTAMPING


	)

63 
	#SO_PROTOCOL
 38

	)

64 
	#SO_DOMAIN
 39

	)

66 
	#SO_RXQ_OVFL
 40

	)

68 
	#SO_WIFI_STATUS
 41

	)

69 
	#SCM_WIFI_STATUS
 
SO_WIFI_STATUS


	)

70 
	#SO_PEEK_OFF
 42

	)

73 
	#SO_NOFCS
 43

	)

75 
	#SO_LOCK_FILTER
 44

	)

77 
	#SO_SELECT_ERR_QUEUE
 45

	)

79 
	#SO_BUSY_POLL
 46

	)

81 
	#SO_MAX_PACING_RATE
 47

	)

	@/usr/include/asm/errno.h

1 
	~<asm-gic/o.h
>

	@/usr/include/bits/libc-lock.h

19 #ide
_BITS_LIBC_LOCK_H


20 
	#_BITS_LIBC_LOCK_H
 1

	)

22 
	~<had.h
>

23 
	#__ed_NULL


	)

24 
	~<ddef.h
>

27 #ifde
_LIBC


28 
	~<lowvlock.h
>

29 
	~<s.h
>

30 
	~<had-funis.h
>

31 
	~<o.h
>

32 
	~<gnu/ti-groups.h
>

36 #i
defed
 
_LIBC
 || defed 
_IO_MTSAFE_IO


37 #i(
defed
 
NOT_IN_libc
 && !defed 
IS_IN_libhad
|| !defed 
_LIBC


38 ru { 
had_mux_t
 
	mmux
; } 
	t__libc_lock_cursive_t
;

40 ru { 
	mlock
; 
	mt
; *
	mowr
; } 
	t__libc_lock_cursive_t
;

43 
__libc_lock_cursive_aque__
 
	t__libc_lock_cursive_t
;

53 
	#__libc_lock_defe_cursive
(
CLASS
,
NAME
) \

54 
CLASS
 
__libc_lock_cursive_t
 
NAME
;

	)

58 #i
defed
 
_LIBC
 && (!defed 
NOT_IN_libc
 || defed 
IS_IN_libhad
)

59 #i
LLL_LOCK_INITIALIZER
 == 0

60 
	#__libc_lock_defe_lized_cursive
(
CLASS
,
NAME
) \

61 
CLASS
 
__libc_lock_cursive_t
 
NAME
;

	)

63 
	#__libc_lock_defe_lized_cursive
(
CLASS
,
NAME
) \

64 
CLASS
 
__libc_lock_cursive_t
 
NAME
 = 
_LIBC_LOCK_RECURSIVE_INITIALIZER
;

	)

66 
	#_LIBC_LOCK_RECURSIVE_INITIALIZER
 \

67 { 
LLL_LOCK_INITIALIZER
, 0, 
NULL
 }

	)

69 
	#__libc_lock_defe_lized_cursive
(
CLASS
,
NAME
) \

70 
CLASS
 
__libc_lock_cursive_t
 
NAME
 = 
_LIBC_LOCK_RECURSIVE_INITIALIZER
;

	)

71 
	#_LIBC_LOCK_RECURSIVE_INITIALIZER
 \

72 {
PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP
}

	)

76 #i
defed
 
_LIBC
 && (!defed 
NOT_IN_libc
 || defed 
IS_IN_libhad
)

77 
	#__libc_lock__cursive
(
NAME
) \

78 ((
NAME
(
__libc_lock_cursive_t

_LIBC_LOCK_RECURSIVE_INITIALIZER
, 0)

	)

80 
	#__libc_lock__cursive
(
NAME
) \

82 i(
__had_mux_
 !
NULL
) \

84 
had_mux_t
 
__
; \

85 
	`__had_mux_
 (&
__
); \

86 
	`__had_mux_y
 (&
__
, 
PTHREAD_MUTEX_RECURSIVE_NP
); \

87 
	`__had_mux_
 (&(
NAME
).
mux
, &
__
); \

88 
	`__had_mux_deroy
 (&
__
); \

90 } 0)

	)

94 #i
defed
 
_LIBC
 && (!defed 
NOT_IN_libc
 || defed 
IS_IN_libhad
)

95 
	#__libc_lock_fi_cursive
(
NAME
((0)

	)

97 
	#__libc_lock_fi_cursive
(
NAME
) \

98 
	`__libc_maybe_
 (
__had_mux_deroy
, (&(
NAME
).
mux
), 0)

	)

102 #i
defed
 
_LIBC
 && (!defed 
NOT_IN_libc
 || defed 
IS_IN_libhad
)

103 #i
__OPTION_EGLIBC_BIG_MACROS
 != 1

107 
__libc_lock_lock_cursive_
 (
__libc_lock_cursive_t
 *);

108 
libc_hidd_o
 (
__libc_lock_lock_cursive_
);

110 #i
__OPTION_EGLIBC_BIG_MACROS


111 
	#__libc_lock_lock_cursive
(
NAME
) \

113 *
lf
 = 
THREAD_SELF
; \

114 i((
NAME
).
owr
 !
lf
) \

116 
	`l_lock
 ((
NAME
).
lock
, 
LLL_PRIVATE
); \

117 (
NAME
).
owr
 = 
lf
; \

119 ++(
NAME
).
t
; \

120 } 0)

	)

122 
	#__libc_lock_lock_cursive
(
NAME
) \

123 
	`__libc_lock_lock_cursive_
 (&(
NAME
))

	)

126 
	#__libc_lock_lock_cursive
(
NAME
) \

127 
	`__libc_maybe_
 (
__had_mux_lock
, (&(
NAME
).
mux
), 0)

	)

131 #i
defed
 
_LIBC
 && (!defed 
NOT_IN_libc
 || defed 
IS_IN_libhad
)

132 #i
__OPTION_EGLIBC_BIG_MACROS
 != 1

136 
__libc_lock_ylock_cursive_
 (
__libc_lock_cursive_t
 *);

137 
libc_hidd_o
 (
__libc_lock_ylock_cursive_
);

139 #i
__OPTION_EGLIBC_BIG_MACROS


140 
	#__libc_lock_ylock_cursive
(
NAME
) \

142 
su
 = 0; \

143 *
lf
 = 
THREAD_SELF
; \

144 i((
NAME
).
owr
 !
lf
) \

146 i(
	`l_ylock
 ((
NAME
).
lock
) == 0) \

148 (
NAME
).
owr
 = 
lf
; \

149 (
NAME
).
t
 = 1; \

152 
su
 = 
EBUSY
; \

155 ++(
NAME
).
t
; \

156 
su
; \

157 })

	)

159 
	#__libc_lock_ylock_cursive
(
NAME
) \

160 
	`__libc_lock_ylock_cursive_
 (&(
NAME
))

	)

163 
	#__libc_lock_ylock_cursive
(
NAME
) \

164 
	`__libc_maybe_
 (
__had_mux_ylock
, (&(
NAME
).
mux
), 0)

	)

168 #i
defed
 
_LIBC
 && (!defed 
NOT_IN_libc
 || defed 
IS_IN_libhad
)

169 #i
__OPTION_EGLIBC_BIG_MACROS
 != 1

173 
__libc_lock_uock_cursive_
 (
__libc_lock_cursive_t
 *);

174 
libc_hidd_o
 (
__libc_lock_uock_cursive_
);

176 #i
__OPTION_EGLIBC_BIG_MACROS


178 
	#__libc_lock_uock_cursive
(
NAME
) \

180 i(--(
NAME
).
t
 == 0) \

182 (
NAME
).
owr
 = 
NULL
; \

183 
	`l_uock
 ((
NAME
).
lock
, 
LLL_PRIVATE
); \

185 } 0)

	)

187 
	#__libc_lock_uock_cursive
(
NAME
) \

188 
	`__libc_lock_uock_cursive_
 (&(
NAME
))

	)

191 
	#__libc_lock_uock_cursive
(
NAME
) \

192 
	`__libc_maybe_
 (
__had_mux_uock
, (&(
NAME
).
mux
), 0)

	)

199 
_had_nup_push_der
 (
_had_nup_bufr
 *
bufr
,

200 (*
route
(*), *
g
);

201 
	`_had_nup_p_e
 (
_had_nup_bufr
 *
bufr
,

202 
execu
);

205 
	#__libc_nup_gi_t
(
DOIT
, 
FCT
, 
ARG
) \

206 { 
_had_nup_bufr
 
_bufr
; \

207 
_ava
; \

208 i(
DOIT
) { \

209 
_ava
 = 
	`PTFAVAIL
 (
_had_nup_push_der
); \

210 i(
_ava
) { \

211 
	`__libc_f__ways
 (
_had_nup_push_der
, (&
_bufr
, 
FCT
, \

212 
ARG
)); \

214 
_bufr
.
__route
 = (
FCT
); \

215 
_bufr
.
__g
 = (
ARG
); \

218 
_ava
 = 0; \

219 }

	)

222 
	#__libc_nup_gi_d
(
DOIT
) \

223 i(
_ava
) { \

224 
	`__libc_f__ways
 (
_had_nup_p_e
, (&
_bufr
, 
DOIT
));\

225 } i(
DOIT
) \

226 
_bufr
.
	`__route
 (_bufr.
__g
); \

227 
	}

	)
}

232 #ifde
_LIBC


233 
	~"libc-lockP.h
"

	@/usr/include/bits/timex.h

18 #idef 
_BITS_TIMEX_H


19 
	#_BITS_TIMEX_H
 1

	)

21 
	~<bs/tys.h
>

25 
	stimex


27 
	mmodes
;

28 
__sys_g_t
 
	mofft
;

29 
__sys_g_t
 
	meq
;

30 
__sys_g_t
 
	mmaxr
;

31 
__sys_g_t
 
	mer
;

32 
	mus
;

33 
__sys_g_t
 
	mcڡt
;

34 
__sys_g_t
 
	mecisi
;

35 
__sys_g_t
 
	mtޔ
;

36 
timev
 
	mtime
;

37 
__sys_g_t
 
	mtick
;

38 
__sys_g_t
 
	mseq
;

39 
__sys_g_t
 
	mjr
;

40 
	mshi
;

41 
__sys_g_t
 
	mab
;

42 
__sys_g_t
 
	mjt
;

43 
__sys_g_t
 
	mlt
;

44 
__sys_g_t
 
	mrt
;

45 
__sys_g_t
 
	mbt
;

47 
	mi
;

56 
	#ADJ_OFFSET
 0x0001

	)

57 
	#ADJ_FREQUENCY
 0x0002

	)

58 
	#ADJ_MAXERROR
 0x0004

	)

59 
	#ADJ_ESTERROR
 0x0008

	)

60 
	#ADJ_STATUS
 0x0010

	)

61 
	#ADJ_TIMECONST
 0x0020

	)

62 
	#ADJ_TAI
 0x0080

	)

63 
	#ADJ_MICRO
 0x1000

	)

64 
	#ADJ_NANO
 0x2000

	)

65 
	#ADJ_TICK
 0x4000

	)

66 
	#ADJ_OFFSET_SINGLESHOT
 0x8001

	)

67 
	#ADJ_OFFSET_SS_READ
 0xa001

	)

70 
	#MOD_OFFSET
 
ADJ_OFFSET


	)

71 
	#MOD_FREQUENCY
 
ADJ_FREQUENCY


	)

72 
	#MOD_MAXERROR
 
ADJ_MAXERROR


	)

73 
	#MOD_ESTERROR
 
ADJ_ESTERROR


	)

74 
	#MOD_STATUS
 
ADJ_STATUS


	)

75 
	#MOD_TIMECONST
 
ADJ_TIMECONST


	)

76 
	#MOD_CLKB
 
ADJ_TICK


	)

77 
	#MOD_CLKA
 
ADJ_OFFSET_SINGLESHOT


	)

78 
	#MOD_TAI
 
ADJ_TAI


	)

79 
	#MOD_MICRO
 
ADJ_MICRO


	)

80 
	#MOD_NANO
 
ADJ_NANO


	)

84 
	#STA_PLL
 0x0001

	)

85 
	#STA_PPSFREQ
 0x0002

	)

86 
	#STA_PPSTIME
 0x0004

	)

87 
	#STA_FLL
 0x0008

	)

89 
	#STA_INS
 0x0010

	)

90 
	#STA_DEL
 0x0020

	)

91 
	#STA_UNSYNC
 0x0040

	)

92 
	#STA_FREQHOLD
 0x0080

	)

94 
	#STA_PPSSIGNAL
 0x0100

	)

95 
	#STA_PPSJITTER
 0x0200

	)

96 
	#STA_PPSWANDER
 0x0400

	)

97 
	#STA_PPSERROR
 0x0800

	)

99 
	#STA_CLOCKERR
 0x1000

	)

100 
	#STA_NANO
 0x2000

	)

101 
	#STA_MODE
 0x4000

	)

102 
	#STA_CLK
 0x8000

	)

105 
	#STA_RONLY
 (
STA_PPSSIGNAL
 | 
STA_PPSJITTER
 | 
STA_PPSWANDER
 | \

106 
STA_PPSERROR
 | 
STA_CLOCKERR
 | 
STA_NANO
 | 
STA_MODE
 | 
STA_CLK
)

	)

	@/usr/include/gconv.h

22 #ide
_GCONV_H


23 
	#_GCONV_H
 1

	)

25 
	~<us.h
>

26 
	#__ed_mbe_t


	)

27 
	#__ed_wt_t


	)

28 
	~<wch.h
>

29 
	#__ed_size_t


	)

30 
	#__ed_wch_t


	)

31 
	~<ddef.h
>

34 
	#__UNKNOWN_10646_CHAR
 ((
wch_t
0xfffd)

	)

39 
	m__GCONV_OK
 = 0,

40 
	m__GCONV_NOCONV
,

41 
	m__GCONV_NODB
,

42 
	m__GCONV_NOMEM
,

44 
	m__GCONV_EMPTY_INPUT
,

45 
	m__GCONV_FULL_OUTPUT
,

46 
	m__GCONV_ILLEGAL_INPUT
,

47 
	m__GCONV_INCOMPLETE_INPUT
,

49 
	m__GCONV_ILLEGAL_DESCRIPTOR
,

50 
	m__GCONV_INTERNAL_ERROR


57 
	m__GCONV_IS_LAST
 = 0x0001,

58 
	m__GCONV_IGNORE_ERRORS
 = 0x0002,

59 
	m__GCONV_SWAP
 = 0x0004

64 
	g__gcv_
;

65 
	g__gcv__da
;

66 
	g__gcv_lded_obje
;

67 
	g__gcv_s_da
;

71 (*
	t__gcv_f
(
	t__gcv_
 *, 
	t__gcv__da
 *,

73 **, 
	tsize_t
 *, , );

76 
	$wt_t
 (*
	t__gcv_btowc_f
(
	t__gcv_
 *, );

79 (*
	t__gcv__f
(
	t__gcv_
 *);

80 (*
	t__gcv_d_f
(
	t__gcv_
 *);

84 (*
	t__gcv_s_f
(
	t__gcv_
 *,

85 
	t__gcv__da
 *, *,

89 
	tsize_t
 *);

92 (*
	t__gcv_s_cڋxt_f
) (*, const *,

97 (*
	t__gcv_s_quy_f
) (const *, const ***,

98 
	tsize_t
 *);

101 (*
	t__gcv_s__f
) (**, const *);

102 (*
	t__gcv_s_d_f
) (*);

104 
	s__gcv_s_da


107 
__gcv_s_f
 
__s_f
;

108 
__gcv_s_cڋxt_f
 
__s_cڋxt_f
;

109 
__gcv_s_d_f
 
__s_d_f
;

110 *
__da
;

111 
__gcv_s_da
 *
__xt
;

116 
	s__gcv_


118 
__gcv_lded_obje
 *
__shlib_hd
;

119 cڡ *
__modme
;

121 
__cou
;

123 *
__om_me
;

124 *
__to_me
;

126 
__gcv_f
 
__f
;

127 
__gcv_btowc_f
 
__btowc_f
;

128 
__gcv__f
 
___f
;

129 
__gcv_d_f
 
__d_f
;

133 
__m_eded_om
;

134 
__max_eded_om
;

135 
__m_eded_to
;

136 
__max_eded_to
;

139 
__eful
;

141 *
__da
;

146 
	s__gcv__da


148 *
__outbuf
;

149 *
__outbund
;

153 
__ags
;

157 
__voti_cou
;

161 
___u
;

163 
__mbe_t
 *
__
;

164 
__mbe_t
 
__e
;

168 
__gcv_s_da
 *
__s
;

173 
	s__gcv_fo


175 
size_t
 
__ns
;

176 
__gcv_
 *
__s
;

177 
__exnsi__
 
__gcv__da
 
__da
 
__exr
;

178 } *
	t__gcv_t
;

	@/usr/include/gnu/stubs-32.h

6 #ifde
_LIBC


7 #r 
Alitis
 
may
 
n
 
defe
 
the
 
mao
 
_LIBC


10 
	#__ub_chags


	)

11 
	#__ub_ach


	)

12 
	#__ub_fchags


	)

13 
	#__ub_fdach


	)

14 
	#__ub_gy


	)

15 
	#__ub_lchmod


	)

16 
	#__ub_voke


	)

17 
	#__ub_og


	)

18 
	#__ub_sigtu


	)

19 
	#__ub_sk


	)

20 
	#__ub_ty


	)

	@/usr/include/gnu/stubs-64.h

6 #ifde
_LIBC


7 #r 
Alitis
 
may
 
n
 
defe
 
the
 
mao
 
_LIBC


10 
	#__ub_bdush


	)

11 
	#__ub_chags


	)

12 
	#__ub_ach


	)

13 
	#__ub_fchags


	)

14 
	#__ub_fdach


	)

15 
	#__ub_gmsg


	)

16 
	#__ub_gy


	)

17 
	#__ub_lchmod


	)

18 
	#__ub_putmsg


	)

19 
	#__ub_voke


	)

20 
	#__ub_og


	)

21 
	#__ub_sigtu


	)

22 
	#__ub_sk


	)

23 
	#__ub_ty


	)

	@/usr/include/gnu/stubs-x32.h

6 #ifde
_LIBC


7 #r 
Alitis
 
may
 
n
 
defe
 
the
 
mao
 
_LIBC


10 
	#__ub_bdush


	)

11 
	#__ub_chags


	)

12 
	#__ub__modu


	)

13 
	#__ub_ach


	)

14 
	#__ub_fchags


	)

15 
	#__ub_fdach


	)

16 
	#__ub_g_kl_syms


	)

17 
	#__ub_gmsg


	)

18 
	#__ub_gy


	)

19 
	#__ub_lchmod


	)

20 
	#__ub_nfsrvl


	)

21 
	#__ub_putmsg


	)

22 
	#__ub_quy_modu


	)

23 
	#__ub_voke


	)

24 
	#__ub_og


	)

25 
	#__ub_sigtu


	)

26 
	#__ub_sk


	)

27 
	#__ub_ty


	)

28 
	#__ub_ulib


	)

	@/usr/include/wchar.h

23 #ide
_WCHAR_H


25 #i!
defed
 
__ed_mbe_t
 && !defed 
__ed_wt_t


26 
	#_WCHAR_H
 1

	)

27 
	~<us.h
>

30 #ifde
_WCHAR_H


32 
	#__ed___FILE


	)

33 #i
defed
 
__USE_UNIX98
 || defed 
__USE_XOPEN2K


34 
	#__ed_FILE


	)

36 
	~<dio.h
>

38 
	#__ed___va_li


	)

39 
	~<dg.h
>

41 
	~<bs/wch.h
>

44 
	#__ed_size_t


	)

45 
	#__ed_wch_t


	)

46 
	#__ed_NULL


	)

48 #i
defed
 
_WCHAR_H
 || defed 
__ed_wt_t
 || !defed 
__WINT_TYPE__


49 #unde
__ed_wt_t


50 
	#__ed_wt_t


	)

51 
	~<ddef.h
>

55 #ide
_WINT_T


60 
	#_WINT_T


	)

61 
	twt_t
;

65 #i
defed
 
__lulus
 && defed 
_GLIBCPP_USE_NAMESPACES
 \

66 && 
defed
 
__WINT_TYPE__


67 
__BEGIN_NAMESPACE_STD


68 
__WINT_TYPE__
 
	twt_t
;

69 
	g__END_NAMESPACE_STD


74 #i
defed
 
__lulus
 && 
__GNUC_PREREQ
 (4, 4)

75 
	#__CORRECT_ISO_CPP_WCHAR_H_PROTO


	)

79 #i(
defed
 
_WCHAR_H
 || defed 
__ed_mbe_t
&& !defed 
____mbe_t_defed


80 
	#____mbe_t_defed
 1

	)

84 
	m__cou
;

87 #ifde
__WINT_TYPE__


88 
__WINT_TYPE__
 
	m__wch
;

90 
wt_t
 
	m__wch
;

92 
	m__wchb
[4];

93 } 
	m__vue
;

94 } 
	t__mbe_t
;

96 #unde
__ed_mbe_t


101 #ifde
_WCHAR_H


103 #ide
__mbe_t_defed


104 
__BEGIN_NAMESPACE_C99


106 
__mbe_t
 
	tmbe_t
;

107 
	g__END_NAMESPACE_C99


108 
	#__mbe_t_defed
 1

	)

111 #ifde
__USE_GNU


112 
	$__USING_NAMESPACE_C99
(
mbe_t
)

115 #ide
WCHAR_MIN


117 
	#WCHAR_MIN
 
__WCHAR_MIN


	)

118 
	#WCHAR_MAX
 
__WCHAR_MAX


	)

121 #ide
WEOF


122 
	#WEOF
 (0xffffffffu)

	)

127 #i
defed
 
__USE_XOPEN
 && !defed 
__USE_UNIX98


128 
	~<wy.h
>

132 
__BEGIN_DECLS


134 
__BEGIN_NAMESPACE_STD


137 
tm
;

138 
__END_NAMESPACE_STD


142 
	$__USING_NAMESPACE_STD
(
tm
)

145 
__BEGIN_NAMESPACE_STD


147 
wch_t
 *
	$wcsy
 (
wch_t
 *
__ri
 
__de
,

148 cڡ 
wch_t
 *
__ri
 
__c

__THROW
;

150 
wch_t
 *
	$wcy
 (
wch_t
 *
__ri
 
__de
,

151 cڡ 
wch_t
 *
__ri
 
__c
, 
size_t
 
__n
)

152 
__THROW
;

155 
wch_t
 *
	$wcst
 (
wch_t
 *
__ri
 
__de
,

156 cڡ 
wch_t
 *
__ri
 
__c

__THROW
;

158 
wch_t
 *
	$wct
 (
wch_t
 *
__ri
 
__de
,

159 cڡ 
wch_t
 *
__ri
 
__c
, 
size_t
 
__n
)

160 
__THROW
;

163 
	$wcscmp
 (cڡ 
wch_t
 *
__s1
, cڡ wch_*
__s2
)

164 
__THROW
 
__ibu_pu__
;

166 
	$wccmp
 (cڡ 
wch_t
 *
__s1
, cڡ wch_*
__s2
, 
size_t
 
__n
)

167 
__THROW
 
__ibu_pu__
;

168 
__END_NAMESPACE_STD


170 #ifde
__USE_XOPEN2K8


172 
	$wcscmp
 (cڡ 
wch_t
 *
__s1
, cڡ wch_*
__s2

__THROW
;

175 
	$wccmp
 (cڡ 
wch_t
 *
__s1
, cڡ wch_*
__s2
,

176 
size_t
 
__n

__THROW
;

180 
	~<xlo.h
>

182 
	$wcscmp_l
 (cڡ 
wch_t
 *
__s1
, cڡ wch_*
__s2
,

183 
__lo_t
 
__loc

__THROW
;

185 
	$wccmp_l
 (cڡ 
wch_t
 *
__s1
, cڡ wch_*
__s2
,

186 
size_t
 
__n
, 
__lo_t
 
__loc

__THROW
;

189 
__BEGIN_NAMESPACE_STD


192 
	$wcscl
 (cڡ 
wch_t
 *
__s1
, cڡ wch_*
__s2

__THROW
;

196 
size_t
 
	$wcsxm
 (
wch_t
 *
__ri
 
__s1
,

197 cڡ 
wch_t
 *
__ri
 
__s2
, 
size_t
 
__n

__THROW
;

198 
__END_NAMESPACE_STD


200 #ifde
__USE_XOPEN2K8


206 
	$wcscl_l
 (cڡ 
wch_t
 *
__s1
, cڡ wch_*
__s2
,

207 
__lo_t
 
__loc

__THROW
;

212 
size_t
 
	$wcsxm_l
 (
wch_t
 *
__s1
, cڡ wch_*
__s2
,

213 
size_t
 
__n
, 
__lo_t
 
__loc

__THROW
;

216 
wch_t
 *
	$wcsdup
 (cڡ 
wch_t
 *
__s

__THROW
 
__ibu_mloc__
;

219 
__BEGIN_NAMESPACE_STD


221 #ifde
__CORRECT_ISO_CPP_WCHAR_H_PROTO


222 "C++" 
wch_t
 *
	$wcschr
 (
wch_t
 *
__wcs
, wch_
__wc
)

223 
__THROW
 
	`__asm
 ("wcschr"
__ibu_pu__
;

224 "C++" cڡ 
wch_t
 *
	$wcschr
 (cڡ 
wch_t
 *
__wcs
, wch_
__wc
)

225 
__THROW
 
	`__asm
 ("wcschr"
__ibu_pu__
;

227 
wch_t
 *
	$wcschr
 (cڡ 
wch_t
 *
__wcs
, wch_
__wc
)

228 
__THROW
 
__ibu_pu__
;

231 #ifde
__CORRECT_ISO_CPP_WCHAR_H_PROTO


232 "C++" 
wch_t
 *
	$wcchr
 (
wch_t
 *
__wcs
, wch_
__wc
)

233 
__THROW
 
	`__asm
 ("wcchr"
__ibu_pu__
;

234 "C++" cڡ 
wch_t
 *
	$wcchr
 (cڡ 
wch_t
 *
__wcs
, wch_
__wc
)

235 
__THROW
 
	`__asm
 ("wcchr"
__ibu_pu__
;

237 
wch_t
 *
	$wcchr
 (cڡ 
wch_t
 *
__wcs
, wch_
__wc
)

238 
__THROW
 
__ibu_pu__
;

240 
__END_NAMESPACE_STD


242 #ifde
__USE_GNU


245 
wch_t
 *
	$wcschul
 (cڡ 
wch_t
 *
__s
, wch_
__wc
)

246 
__THROW
 
__ibu_pu__
;

249 
__BEGIN_NAMESPACE_STD


252 
size_t
 
	$wcscn
 (cڡ 
wch_t
 *
__wcs
, cڡ wch_*
__je
)

253 
__THROW
 
__ibu_pu__
;

256 
size_t
 
	$wcsn
 (cڡ 
wch_t
 *
__wcs
, cڡ wch_*
__ac
)

257 
__THROW
 
__ibu_pu__
;

259 #ifde
__CORRECT_ISO_CPP_WCHAR_H_PROTO


260 "C++" 
wch_t
 *
	$wcbrk
 (
wch_t
 *
__wcs
, cڡ wch_*
__ac
)

261 
__THROW
 
	`__asm
 ("wcbrk"
__ibu_pu__
;

262 "C++" cڡ 
wch_t
 *
	$wcbrk
 (cڡ 
wch_t
 *
__wcs
,

263 cڡ 
wch_t
 *
__ac
)

264 
__THROW
 
	`__asm
 ("wcbrk"
__ibu_pu__
;

266 
wch_t
 *
	$wcbrk
 (cڡ 
wch_t
 *
__wcs
, cڡ wch_*
__ac
)

267 
__THROW
 
__ibu_pu__
;

270 #ifde
__CORRECT_ISO_CPP_WCHAR_H_PROTO


271 "C++" 
wch_t
 *
	$wcsr
 (
wch_t
 *
__hayack
, cڡ wch_*
__ed
)

272 
__THROW
 
	`__asm
 ("wcsr"
__ibu_pu__
;

273 "C++" cڡ 
wch_t
 *
	$wcsr
 (cڡ 
wch_t
 *
__hayack
,

274 cڡ 
wch_t
 *
__ed
)

275 
__THROW
 
	`__asm
 ("wcsr"
__ibu_pu__
;

277 
wch_t
 *
	$wcsr
 (cڡ 
wch_t
 *
__hayack
, cڡ wch_*
__ed
)

278 
__THROW
 
__ibu_pu__
;

282 
wch_t
 *
	$wcok
 (
wch_t
 *
__ri
 
__s
,

283 cڡ 
wch_t
 *
__ri
 
__dim
,

284 
wch_t
 **
__ri
 
__r

__THROW
;

287 
size_t
 
	$wc
 (cڡ 
wch_t
 *
__s

__THROW
 
__ibu_pu__
;

288 
__END_NAMESPACE_STD


290 #ifde
__USE_XOPEN


292 #ifde
__CORRECT_ISO_CPP_WCHAR_H_PROTO


293 "C++" 
wch_t
 *
	$wcswcs
 (
wch_t
 *
__hayack
, cڡ wch_*
__ed
)

294 
__THROW
 
	`__asm
 ("wcswcs"
__ibu_pu__
;

295 "C++" cڡ 
wch_t
 *
	$wcswcs
 (cڡ 
wch_t
 *
__hayack
,

296 cڡ 
wch_t
 *
__ed
)

297 
__THROW
 
	`__asm
 ("wcswcs"
__ibu_pu__
;

299 
wch_t
 *
	$wcswcs
 (cڡ 
wch_t
 *
__hayack
, cڡ wch_*
__ed
)

300 
__THROW
 
__ibu_pu__
;

304 #ifde
__USE_XOPEN2K8


306 
size_t
 
	$wcn
 (cڡ 
wch_t
 *
__s
, 
size_t
 
__maxn
)

307 
__THROW
 
__ibu_pu__
;

311 
__BEGIN_NAMESPACE_STD


313 #ifde
__CORRECT_ISO_CPP_WCHAR_H_PROTO


314 "C++" 
wch_t
 *
	$wmemchr
 (
wch_t
 *
__s
, wch_
__c
, 
size_t
 
__n
)

315 
__THROW
 
	`__asm
 ("wmemchr"
__ibu_pu__
;

316 "C++" cڡ 
wch_t
 *
	$wmemchr
 (cڡ 
wch_t
 *
__s
, wch_
__c
,

317 
size_t
 
__n
)

318 
__THROW
 
	`__asm
 ("wmemchr"
__ibu_pu__
;

320 
wch_t
 *
	$wmemchr
 (cڡ 
wch_t
 *
__s
, wch_
__c
, 
size_t
 
__n
)

321 
__THROW
 
__ibu_pu__
;

325 
	$wmemcmp
 (cڡ 
wch_t
 *
__s1
, cڡ wch_*
__s2
, 
size_t
 
__n
)

326 
__THROW
 
__ibu_pu__
;

329 
wch_t
 *
	$wmemy
 (
wch_t
 *
__ri
 
__s1
,

330 cڡ 
wch_t
 *
__ri
 
__s2
, 
size_t
 
__n

__THROW
;

334 
wch_t
 *
	$wmemmove
 (
wch_t
 *
__s1
, cڡ wch_*
__s2
, 
size_t
 
__n
)

335 
__THROW
;

338 
wch_t
 *
	$wmemt
 (
wch_t
 *
__s
, wch_
__c
, 
size_t
 
__n

__THROW
;

339 
__END_NAMESPACE_STD


341 #ifde
__USE_GNU


344 
wch_t
 *
	$wmempy
 (
wch_t
 *
__ri
 
__s1
,

345 cڡ 
wch_t
 *
__ri
 
__s2
, 
size_t
 
__n
)

346 
__THROW
;

350 
__BEGIN_NAMESPACE_STD


353 
wt_t
 
	$btowc
 (
__c

__THROW
;

357 
	$wob
 (
wt_t
 
__c

__THROW
;

361 
	$mbs
 (cڡ 
mbe_t
 *
__ps

__THROW
 
__ibu_pu__
;

365 
size_t
 
	$mbowc
 (
wch_t
 *
__ri
 
__pwc
,

366 cڡ *
__ri
 
__s
, 
size_t
 
__n
,

367 
mbe_t
 *
__ri
 
__p

__THROW
;

370 
size_t
 
	$wtomb
 (*
__ri
 
__s
, 
wch_t
 
__wc
,

371 
mbe_t
 *
__ri
 
__ps

__THROW
;

374 
size_t
 
	$__mb
 (cڡ *
__ri
 
__s
, 
size_t
 
__n
,

375 
mbe_t
 *
__ri
 
__ps

__THROW
;

376 
size_t
 
	$mb
 (cڡ *
__ri
 
__s
, 
size_t
 
__n
,

377 
mbe_t
 *
__ri
 
__ps

__THROW
;

378 
__END_NAMESPACE_STD


380 #ifde
__USE_EXTERN_INLINES


386 
wt_t
 
	$__btowc_s
 (
__c

	`__asm
 ("btowc");

387 
__ex_le
 
wt_t


388 
	`__NTH
 (
	$btowc
 (
__c
))

389 {  (
	`__but_cڡt_p
 (
__c
) && __c >= '\0' && __c <= '\x7f'

390 ? (
wt_t

__c
 : 
	`__btowc_s
 (__c)); 
	}
}

392 
	$__wob_s
 (
wt_t
 
__c

	`__asm
 ("wctob");

393 
__ex_le
 

394 
	`__NTH
 (
	$wob
 (
wt_t
 
__wc
))

395 {  (
	`__but_cڡt_p
 (
__wc
&& __w>
L
'\0' && __wc <= L'\x7f'

396 ? (
__wc
 : 
	`__wob_s
 (__wc)); 
	}
}

398 
__ex_le
 
size_t


399 
__NTH
 (
	$mb
 (cڡ *
__ri
 
__s
, 
size_t
 
__n
,

400 
mbe_t
 *
__ri
 
__ps
))

401 {  (
__ps
 !
NULL


402 ? 
	`mbowc
 (
NULL
, 
__s
, 
__n
, 
__ps
: 
	`__mb
 (__s, __n, NULL)); 
	}
}

405 
__BEGIN_NAMESPACE_STD


408 
size_t
 
	$mbtowcs
 (
wch_t
 *
__ri
 
__d
,

409 cڡ **
__ri
 
__c
, 
size_t
 
__n
,

410 
mbe_t
 *
__ri
 
__ps

__THROW
;

414 
size_t
 
	$wctombs
 (*
__ri
 
__d
,

415 cڡ 
wch_t
 **
__ri
 
__c
, 
size_t
 
__n
,

416 
mbe_t
 *
__ri
 
__ps

__THROW
;

417 
__END_NAMESPACE_STD


420 #ifdef 
__USE_XOPEN2K8


423 
size_t
 
	$mbowcs
 (
wch_t
 *
__ri
 
__d
,

424 cڡ **
__ri
 
__c
, 
size_t
 
__nmc
,

425 
size_t
 
__n
, 
mbe_t
 *
__ri
 
__ps

__THROW
;

429 
size_t
 
	$wcombs
 (*
__ri
 
__d
,

430 cڡ 
wch_t
 **
__ri
 
__c
,

431 
size_t
 
__nwc
, size_
__n
,

432 
mbe_t
 *
__ri
 
__ps

__THROW
;

437 #ifde
__USE_XOPEN


439 
	$wcwidth
 (
wch_t
 
__c

__THROW
;

443 
	$wcswidth
 (cڡ 
wch_t
 *
__s
, 
size_t
 
__n

__THROW
;

447 
__BEGIN_NAMESPACE_STD


450 
	$wcod
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

451 
wch_t
 **
__ri
 
__dr

__THROW
;

452 
__END_NAMESPACE_STD


454 #ifde
__USE_ISOC99


455 
__BEGIN_NAMESPACE_C99


457 
	$wcof
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

458 
wch_t
 **
__ri
 
__dr

__THROW
;

459 
	$wcd
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

460 
wch_t
 **
__ri
 
__dr

__THROW
;

461 
__END_NAMESPACE_C99


465 
__BEGIN_NAMESPACE_STD


468 
	$wc
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

469 
wch_t
 **
__ri
 
__dr
, 
__ba

__THROW
;

473 
	$wcoul
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

474 
wch_t
 **
__ri
 
__dr
, 
__ba
)

475 
__THROW
;

476 
__END_NAMESPACE_STD


478 #ifde
__USE_ISOC99


479 
__BEGIN_NAMESPACE_C99


482 
__exnsi__


483 
	$wcl
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

484 
wch_t
 **
__ri
 
__dr
, 
__ba
)

485 
__THROW
;

489 
__exnsi__


490 
	$wcou
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

491 
wch_t
 **
__ri
 
__dr
,

492 
__ba

__THROW
;

493 
__END_NAMESPACE_C99


496 #ifde
__USE_GNU


499 
__exnsi__


500 
	$wcoq
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

501 
wch_t
 **
__ri
 
__dr
, 
__ba
)

502 
__THROW
;

506 
__exnsi__


507 
	$wcouq
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

508 
wch_t
 **
__ri
 
__dr
,

509 
__ba

__THROW
;

512 #ifde
__USE_GNU


526 
	~<xlo.h
>

530 
	$wc_l
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

531 
wch_t
 **
__ri
 
__dr
, 
__ba
,

532 
__lo_t
 
__loc

__THROW
;

534 
	$wcoul_l
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

535 
wch_t
 **
__ri
 
__dr
,

536 
__ba
, 
__lo_t
 
__loc

__THROW
;

538 
__exnsi__


539 
	$wcl_l
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

540 
wch_t
 **
__ri
 
__dr
,

541 
__ba
, 
__lo_t
 
__loc

__THROW
;

543 
__exnsi__


544 
	$wcou_l
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

545 
wch_t
 **
__ri
 
__dr
,

546 
__ba
, 
__lo_t
 
__loc
)

547 
__THROW
;

549 
	$wcod_l
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

550 
wch_t
 **
__ri
 
__dr
, 
__lo_t
 
__loc
)

551 
__THROW
;

553 
	$wcof_l
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

554 
wch_t
 **
__ri
 
__dr
, 
__lo_t
 
__loc
)

555 
__THROW
;

557 
	$wcd_l
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

558 
wch_t
 **
__ri
 
__dr
,

559 
__lo_t
 
__loc

__THROW
;

563 #ifde
__USE_XOPEN2K8


566 
wch_t
 *
	$wy
 (
wch_t
 *
__ri
 
__de
,

567 cڡ 
wch_t
 *
__ri
 
__c

__THROW
;

571 
wch_t
 *
	$wny
 (
wch_t
 *
__ri
 
__de
,

572 cڡ 
wch_t
 *
__ri
 
__c
, 
size_t
 
__n
)

573 
__THROW
;

580 
__FILE
 *
	$ݒ_wmemam
 (
wch_t
 **
__buoc
, 
size_t
 *
__sizoc

__THROW
;

583 #i
defed
 
__USE_ISOC95
 || defed 
__USE_UNIX98


584 
__BEGIN_NAMESPACE_STD


587 
	$fwide
 (
__FILE
 *
__
, 
__mode

__THROW
;

594 
	`fwtf
 (
__FILE
 *
__ri
 
__am
,

595 cڡ 
wch_t
 *
__ri
 
__fm
, ...)

601 
	`wtf
 (cڡ 
wch_t
 *
__ri
 
__fm
, ...)

604 
	$swtf
 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__n
,

605 cڡ 
wch_t
 *
__ri
 
__fm
, ...)

606 
__THROW
 ;

612 
	`vfwtf
 (
__FILE
 *
__ri
 
__s
,

613 cڡ 
wch_t
 *
__ri
 
__fm
,

614 
__gnuc_va_li
 
__g
)

620 
	`vwtf
 (cڡ 
wch_t
 *
__ri
 
__fm
,

621 
__gnuc_va_li
 
__g
)

625 
	$vswtf
 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__n
,

626 cڡ 
wch_t
 *
__ri
 
__fm
,

627 
__gnuc_va_li
 
__g
)

628 
__THROW
 ;

635 
	`fwsnf
 (
__FILE
 *
__ri
 
__am
,

636 cڡ 
wch_t
 *
__ri
 
__fm
, ...)

642 
	`wsnf
 (cڡ 
wch_t
 *
__ri
 
__fm
, ...)

645 
	$swsnf
 (cڡ 
wch_t
 *
__ri
 
__s
,

646 cڡ 
wch_t
 *
__ri
 
__fm
, ...)

647 
__THROW
 ;

649 #i
defed
 
__USE_ISOC99
 && !defed 
__USE_GNU
 \

650 && (!
defed
 
__LDBL_COMPAT
 || !defed 
__REDIRECT
) \

651 && (
defed
 
__STRICT_ANSI__
 || defed 
__USE_XOPEN2K
)

652 #ifde
__REDIRECT


656 
	`__REDIRECT
 (
fwsnf
, (
__FILE
 *
__ri
 
__am
,

657 cڡ 
wch_t
 *
__ri
 
__fm
, ...),

658 
__isoc99_fwsnf
)

660 
	`__REDIRECT
 (
wsnf
, (cڡ 
wch_t
 *
__ri
 
__fm
, ...),

661 
__isoc99_wsnf
)

663 
	`__REDIRECT_NTH
 (
swsnf
, (cڡ 
wch_t
 *
__ri
 
__s
,

664 cڡ 
wch_t
 *
__ri
 
__fm
,

665 ...), 
__isoc99_swsnf
)

668 
	`__isoc99_fwsnf
 (
__FILE
 *
__ri
 
__am
,

669 cڡ 
wch_t
 *
__ri
 
__fm
, ...);

670 
	`__isoc99_wsnf
 (cڡ 
wch_t
 *
__ri
 
__fm
, ...);

671 
	$__isoc99_swsnf
 (cڡ 
wch_t
 *
__ri
 
__s
,

672 cڡ 
wch_t
 *
__ri
 
__fm
, ...)

673 
__THROW
;

674 
	#fwsnf
 
__isoc99_fwsnf


	)

675 
	#wsnf
 
__isoc99_wsnf


	)

676 
	#swsnf
 
__isoc99_swsnf


	)

680 
__END_NAMESPACE_STD


683 #ifde
__USE_ISOC99


684 
__BEGIN_NAMESPACE_C99


689 
	`vfwsnf
 (
__FILE
 *
__ri
 
__s
,

690 cڡ 
wch_t
 *
__ri
 
__fm
,

691 
__gnuc_va_li
 
__g
)

697 
	`vwsnf
 (cڡ 
wch_t
 *
__ri
 
__fm
,

698 
__gnuc_va_li
 
__g
)

701 
	$vswsnf
 (cڡ 
wch_t
 *
__ri
 
__s
,

702 cڡ 
wch_t
 *
__ri
 
__fm
,

703 
__gnuc_va_li
 
__g
)

704 
__THROW
 ;

706 #i!
defed
 
__USE_GNU
 \

707 && (!
defed
 
__LDBL_COMPAT
 || !defed 
__REDIRECT
) \

708 && (
defed
 
__STRICT_ANSI__
 || defed 
__USE_XOPEN2K
)

709 #ifde
__REDIRECT


710 
	`__REDIRECT
 (
vfwsnf
, (
__FILE
 *
__ri
 
__s
,

711 cڡ 
wch_t
 *
__ri
 
__fm
,

712 
__gnuc_va_li
 
__g
), 
__isoc99_vfwsnf
)

714 
	`__REDIRECT
 (
vwsnf
, (cڡ 
wch_t
 *
__ri
 
__fm
,

715 
__gnuc_va_li
 
__g
), 
__isoc99_vwsnf
)

717 
	`__REDIRECT_NTH
 (
vswsnf
, (cڡ 
wch_t
 *
__ri
 
__s
,

718 cڡ 
wch_t
 *
__ri
 
__fm
,

719 
__gnuc_va_li
 
__g
), 
__isoc99_vswsnf
)

722 
	`__isoc99_vfwsnf
 (
__FILE
 *
__ri
 
__s
,

723 cڡ 
wch_t
 *
__ri
 
__fm
,

724 
__gnuc_va_li
 
__g
);

725 
	`__isoc99_vwsnf
 (cڡ 
wch_t
 *
__ri
 
__fm
,

726 
__gnuc_va_li
 
__g
);

727 
	$__isoc99_vswsnf
 (cڡ 
wch_t
 *
__ri
 
__s
,

728 cڡ 
wch_t
 *
__ri
 
__fm
,

729 
__gnuc_va_li
 
__g

__THROW
;

730 
	#vfwsnf
 
__isoc99_vfwsnf


	)

731 
	#vwsnf
 
__isoc99_vwsnf


	)

732 
	#vswsnf
 
__isoc99_vswsnf


	)

736 
__END_NAMESPACE_C99


740 
__BEGIN_NAMESPACE_STD


745 
wt_t
 
	`fgwc
 (
__FILE
 *
__am
);

746 
wt_t
 
	`gwc
 (
__FILE
 *
__am
);

752 
wt_t
 
	`gwch
 ();

759 
wt_t
 
	`utwc
 (
wch_t
 
__wc
, 
__FILE
 *
__am
);

760 
wt_t
 
	`putwc
 (
wch_t
 
__wc
, 
__FILE
 *
__am
);

766 
wt_t
 
	`putwch
 (
wch_t
 
__wc
);

774 
wch_t
 *
	`fgws
 (wch_*
__ri
 
__ws
, 
__n
,

775 
__FILE
 *
__ri
 
__am
);

781 
	`utws
 (cڡ 
wch_t
 *
__ri
 
__ws
,

782 
__FILE
 *
__ri
 
__am
);

789 
wt_t
 
	`ungwc
 (wt_
__wc
, 
__FILE
 *
__am
);

790 
__END_NAMESPACE_STD


793 #ifde
__USE_GNU


801 
wt_t
 
	`gwc_uocked
 (
__FILE
 *
__am
);

802 
wt_t
 
	`gwch_uocked
 ();

810 
wt_t
 
	`fgwc_uocked
 (
__FILE
 *
__am
);

818 
wt_t
 
	`utwc_uocked
 (
wch_t
 
__wc
, 
__FILE
 *
__am
);

827 
wt_t
 
	`putwc_uocked
 (
wch_t
 
__wc
, 
__FILE
 *
__am
);

828 
wt_t
 
	`putwch_uocked
 (
wch_t
 
__wc
);

837 
wch_t
 *
	`fgws_uocked
 (wch_*
__ri
 
__ws
, 
__n
,

838 
__FILE
 *
__ri
 
__am
);

846 
	`utws_uocked
 (cڡ 
wch_t
 *
__ri
 
__ws
,

847 
__FILE
 *
__ri
 
__am
);

851 
__BEGIN_NAMESPACE_C99


855 
size_t
 
	$wcsime
 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__maxsize
,

856 cڡ 
wch_t
 *
__ri
 
__fm
,

857 cڡ 
tm
 *
__ri
 
__

__THROW
;

858 
__END_NAMESPACE_C99


860 #ifde
__USE_GNU


861 
	~<xlo.h
>

865 
size_t
 
	$wcsime_l
 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__maxsize
,

866 cڡ 
wch_t
 *
__ri
 
__fm
,

867 cڡ 
tm
 *
__ri
 
__
,

868 
__lo_t
 
__loc

__THROW
;

877 #i
defed
 
__USE_UNIX98
 && !defed 
__USE_GNU


878 
	#__ed_iswxxx


	)

879 
	~<wy.h
>

883 #i
__USE_FORTIFY_LEVEL
 > 0 && 
defed
 
__ftify_funi


884 
	~<bs/wch2.h
>

887 #ifde
__LDBL_COMPAT


888 
	~<bs/wch-ldbl.h
>

891 
__END_DECLS


899 #unde
__ed_mbe_t


900 #unde
__ed_wt_t


	@/usr/include/asm-generic/errno.h

1 #ide
_ASM_GENERIC_ERRNO_H


2 
	#_ASM_GENERIC_ERRNO_H


	)

4 
	~<asm-gic/o-ba.h
>

6 
	#EDEADLK
 35

	)

7 
	#ENAMETOOLONG
 36

	)

8 
	#ENOLCK
 37

	)

9 
	#ENOSYS
 38

	)

10 
	#ENOTEMPTY
 39

	)

11 
	#ELOOP
 40

	)

12 
	#EWOULDBLOCK
 
EAGAIN


	)

13 
	#ENOMSG
 42

	)

14 
	#EIDRM
 43

	)

15 
	#ECHRNG
 44

	)

16 
	#EL2NSYNC
 45

	)

17 
	#EL3HLT
 46

	)

18 
	#EL3RST
 47

	)

19 
	#ELNRNG
 48

	)

20 
	#EUNATCH
 49

	)

21 
	#ENOCSI
 50

	)

22 
	#EL2HLT
 51

	)

23 
	#EBADE
 52

	)

24 
	#EBADR
 53

	)

25 
	#EXFULL
 54

	)

26 
	#ENOANO
 55

	)

27 
	#EBADRQC
 56

	)

28 
	#EBADSLT
 57

	)

30 
	#EDEADLOCK
 
EDEADLK


	)

32 
	#EBFONT
 59

	)

33 
	#ENOSTR
 60

	)

34 
	#ENODATA
 61

	)

35 
	#ETIME
 62

	)

36 
	#ENOSR
 63

	)

37 
	#ENONET
 64

	)

38 
	#ENOPKG
 65

	)

39 
	#EREMOTE
 66

	)

40 
	#ENOLINK
 67

	)

41 
	#EADV
 68

	)

42 
	#ESRMNT
 69

	)

43 
	#ECOMM
 70

	)

44 
	#EPROTO
 71

	)

45 
	#EMULTIHOP
 72

	)

46 
	#EDOTDOT
 73

	)

47 
	#EBADMSG
 74

	)

48 
	#EOVERFLOW
 75

	)

49 
	#ENOTUNIQ
 76

	)

50 
	#EBADFD
 77

	)

51 
	#EREMCHG
 78

	)

52 
	#ELIBACC
 79

	)

53 
	#ELIBBAD
 80

	)

54 
	#ELIBSCN
 81

	)

55 
	#ELIBMAX
 82

	)

56 
	#ELIBEXEC
 83

	)

57 
	#EILSEQ
 84

	)

58 
	#ERESTART
 85

	)

59 
	#ESTRPIPE
 86

	)

60 
	#EUSERS
 87

	)

61 
	#ENOTSOCK
 88

	)

62 
	#EDESTADDRREQ
 89

	)

63 
	#EMSGSIZE
 90

	)

64 
	#EPROTOTYPE
 91

	)

65 
	#ENOPROTOOPT
 92

	)

66 
	#EPROTONOSUPPORT
 93

	)

67 
	#ESOCKTNOSUPPORT
 94

	)

68 
	#EOPNOTSUPP
 95

	)

69 
	#EPFNOSUPPORT
 96

	)

70 
	#EAFNOSUPPORT
 97

	)

71 
	#EADDRINUSE
 98

	)

72 
	#EADDRNOTAVAIL
 99

	)

73 
	#ENETDOWN
 100

	)

74 
	#ENETUNREACH
 101

	)

75 
	#ENETRESET
 102

	)

76 
	#ECONNABORTED
 103

	)

77 
	#ECONNRESET
 104

	)

78 
	#ENOBUFS
 105

	)

79 
	#EISCONN
 106

	)

80 
	#ENOTCONN
 107

	)

81 
	#ESHUTDOWN
 108

	)

82 
	#ETOOMANYREFS
 109

	)

83 
	#ETIMEDOUT
 110

	)

84 
	#ECONNREFUSED
 111

	)

85 
	#EHOSTDOWN
 112

	)

86 
	#EHOSTUNREACH
 113

	)

87 
	#EALREADY
 114

	)

88 
	#EINPROGRESS
 115

	)

89 
	#ESTALE
 116

	)

90 
	#EUCLEAN
 117

	)

91 
	#ENOTNAM
 118

	)

92 
	#ENAVAIL
 119

	)

93 
	#EISNAM
 120

	)

94 
	#EREMOTEIO
 121

	)

95 
	#EDQUOT
 122

	)

97 
	#ENOMEDIUM
 123

	)

98 
	#EMEDIUMTYPE
 124

	)

99 
	#ECANCELED
 125

	)

100 
	#ENOKEY
 126

	)

101 
	#EKEYEXPIRED
 127

	)

102 
	#EKEYREVOKED
 128

	)

103 
	#EKEYREJECTED
 129

	)

106 
	#EOWNERDEAD
 130

	)

107 
	#ENOTRECOVERABLE
 131

	)

109 
	#ERFKILL
 132

	)

111 
	#EHWPOISON
 133

	)

	@/usr/include/asm/sockios.h

1 
	~<asm-gic/sockios.h
>

	@/usr/include/bits/wchar-ldbl.h

19 #ide
_WCHAR_H


23 #i
defed
 
__USE_ISOC95
 || defed 
__USE_UNIX98


24 
__BEGIN_NAMESPACE_C99


25 
__LDBL_REDIR_DECL
 (
fwtf
);

26 
__LDBL_REDIR_DECL
 (
wtf
);

27 
__LDBL_REDIR_DECL
 (
swtf
);

28 
__LDBL_REDIR_DECL
 (
vfwtf
);

29 
__LDBL_REDIR_DECL
 (
vwtf
);

30 
__LDBL_REDIR_DECL
 (
vswtf
);

31 #i
defed
 
__USE_ISOC99
 && !defed 
__USE_GNU
 \

32 && !
defed
 
	g__REDIRECT
 \

33 && (
defed
 
	g__STRICT_ANSI__
 || defed 
	g__USE_XOPEN2K
)

34 
	$__LDBL_REDIR1_DECL
 (
fwsnf
, 
__dbl___isoc99_fwsnf
)

35 
	$__LDBL_REDIR1_DECL
 (
wsnf
, 
__dbl___isoc99_wsnf
)

36 
	$__LDBL_REDIR1_DECL
 (
swsnf
, 
__dbl___isoc99_swsnf
)

38 
	`__LDBL_REDIR_DECL
 (
fwsnf
);

39 
	`__LDBL_REDIR_DECL
 (
wsnf
);

40 
	`__LDBL_REDIR_DECL
 (
swsnf
);

42 
__END_NAMESPACE_C99


45 #ifde
__USE_ISOC99


46 
__BEGIN_NAMESPACE_C99


47 
	`__LDBL_REDIR1_DECL
 (
wcd
, 
wcod
);

48 #i!
defed
 
__USE_GNU
 && !defed 
__REDIRECT
 \

49 && (
defed
 
__STRICT_ANSI__
 || defed 
__USE_XOPEN2K
)

50 
	$__LDBL_REDIR1_DECL
 (
vfwsnf
, 
__dbl___isoc99_vfwsnf
)

51 
	$__LDBL_REDIR1_DECL
 (
vwsnf
, 
__dbl___isoc99_vwsnf
)

52 
	$__LDBL_REDIR1_DECL
 (
vswsnf
, 
__dbl___isoc99_vswsnf
)

54 
	`__LDBL_REDIR_DECL
 (
vfwsnf
);

55 
	`__LDBL_REDIR_DECL
 (
vwsnf
);

56 
	`__LDBL_REDIR_DECL
 (
vswsnf
);

58 
__END_NAMESPACE_C99


61 #ifde
__USE_GNU


62 
	`__LDBL_REDIR1_DECL
 (
wcd_l
, 
wcod_l
);

65 #i
__USE_FORTIFY_LEVEL
 > 0 && 
defed
 
__ftify_funi


66 
	$__LDBL_REDIR_DECL
 (
__swtf_chk
)

67 
	$__LDBL_REDIR_DECL
 (
__vswtf_chk
)

68 #i
__USE_FORTIFY_LEVEL
 > 1

69 
	$__LDBL_REDIR_DECL
 (
__fwtf_chk
)

70 
	$__LDBL_REDIR_DECL
 (
__wtf_chk
)

71 
	$__LDBL_REDIR_DECL
 (
__vfwtf_chk
)

72 
	$__LDBL_REDIR_DECL
 (
__vwtf_chk
)

	@/usr/include/bits/wchar2.h

19 #ide
_WCHAR_H


24 
wch_t
 *
	$__wmemy_chk
 (
wch_t
 *
__ri
 
__s1
,

25 cڡ 
wch_t
 *
__ri
 
__s2
, 
size_t
 
__n
,

26 
size_t
 
__ns1

__THROW
;

27 
wch_t
 *
	`__REDIRECT_NTH
 (
__wmemy_s
,

28 (
wch_t
 *
__ri
 
__s1
,

29 cڡ 
wch_t
 *
__ri
 
__s2
, 
size_t
 
__n
),

30 
wmemy
);

31 
wch_t
 *
	`__REDIRECT_NTH
 (
__wmemy_chk_wn
,

32 (
wch_t
 *
__ri
 
__s1
,

33 cڡ 
wch_t
 *
__ri
 
__s2
, 
size_t
 
__n
,

34 
size_t
 
__ns1
), 
__wmemy_chk
)

35 
	`__wǉr
 ("wmemcpy called withength biggerhan size of destination "

38 
__ftify_funi
 
wch_t
 *

39 
	`__NTH
 (
	$wmemy
 (
wch_t
 *
__ri
 
__s1
, cڡ wch_*__ri 
__s2
,

40 
size_t
 
__n
))

42 i(
	`__bos0
 (
__s1
!(
size_t
) -1)

44 i(!
	`__but_cڡt_p
 (
__n
))

45  
	`__wmemy_chk
 (
__s1
, 
__s2
, 
__n
,

46 
	`__bos0
 (
__s1
/  (
wch_t
));

48 i(
__n
 > 
	`__bos0
 (
__s1
/  (
wch_t
))

49  
	`__wmemy_chk_wn
 (
__s1
, 
__s2
, 
__n
,

50 
	`__bos0
 (
__s1
/  (
wch_t
));

52  
	`__wmemy_s
 (
__s1
, 
__s2
, 
__n
);

53 
	}
}

56 
wch_t
 *
	$__wmemmove_chk
 (
wch_t
 *
__s1
, cڡ wch_*
__s2
,

57 
size_t
 
__n
, size_
__ns1

__THROW
;

58 
wch_t
 *
	`__REDIRECT_NTH
 (
__wmemmove_s
, (wch_*
__s1
,

59 cڡ 
wch_t
 *
__s2
,

60 
size_t
 
__n
), 
wmemmove
);

61 
wch_t
 *
	`__REDIRECT_NTH
 (
__wmemmove_chk_wn
,

62 (
wch_t
 *
__s1
, cڡ wch_*
__s2
,

63 
size_t
 
__n
, size_
__ns1
), 
__wmemmove_chk
)

64 
	`__wǉr
 ("wmemmove called withength biggerhan size of destination "

67 
__ftify_funi
 
wch_t
 *

68 
	`__NTH
 (
	$wmemmove
 (
wch_t
 *
__s1
, cڡ wch_*
__s2
, 
size_t
 
__n
))

70 i(
	`__bos0
 (
__s1
!(
size_t
) -1)

72 i(!
	`__but_cڡt_p
 (
__n
))

73  
	`__wmemmove_chk
 (
__s1
, 
__s2
, 
__n
,

74 
	`__bos0
 (
__s1
/  (
wch_t
));

76 i(
__n
 > 
	`__bos0
 (
__s1
/  (
wch_t
))

77  
	`__wmemmove_chk_wn
 (
__s1
, 
__s2
, 
__n
,

78 
	`__bos0
 (
__s1
/  (
wch_t
));

80  
	`__wmemmove_s
 (
__s1
, 
__s2
, 
__n
);

81 
	}
}

84 #ifde
__USE_GNU


85 
wch_t
 *
	$__wmempy_chk
 (
wch_t
 *
__ri
 
__s1
,

86 cڡ 
wch_t
 *
__ri
 
__s2
, 
size_t
 
__n
,

87 
size_t
 
__ns1

__THROW
;

88 
wch_t
 *
	`__REDIRECT_NTH
 (
__wmempy_s
,

89 (
wch_t
 *
__ri
 
__s1
,

90 cڡ 
wch_t
 *
__ri
 
__s2
,

91 
size_t
 
__n
), 
wmempy
);

92 
wch_t
 *
	`__REDIRECT_NTH
 (
__wmempy_chk_wn
,

93 (
wch_t
 *
__ri
 
__s1
,

94 cڡ 
wch_t
 *
__ri
 
__s2
, 
size_t
 
__n
,

95 
size_t
 
__ns1
), 
__wmempy_chk
)

96 
	`__wǉr
 ("wmempcpy called withength biggerhan size of destination "

99 
__ftify_funi
 
wch_t
 *

100 
	`__NTH
 (
	$wmempy
 (
wch_t
 *
__ri
 
__s1
, cڡ wch_*__ri 
__s2
,

101 
size_t
 
__n
))

103 i(
	`__bos0
 (
__s1
!(
size_t
) -1)

105 i(!
	`__but_cڡt_p
 (
__n
))

106  
	`__wmempy_chk
 (
__s1
, 
__s2
, 
__n
,

107 
	`__bos0
 (
__s1
/  (
wch_t
));

109 i(
__n
 > 
	`__bos0
 (
__s1
/  (
wch_t
))

110  
	`__wmempy_chk_wn
 (
__s1
, 
__s2
, 
__n
,

111 
	`__bos0
 (
__s1
/  (
wch_t
));

113  
	`__wmempy_s
 (
__s1
, 
__s2
, 
__n
);

114 
	}
}

118 
wch_t
 *
	$__wmemt_chk
 (
wch_t
 *
__s
, wch_
__c
, 
size_t
 
__n
,

119 
size_t
 
__ns

__THROW
;

120 
wch_t
 *
	`__REDIRECT_NTH
 (
__wmemt_s
, (wch_*
__s
, wch_
__c
,

121 
size_t
 
__n
), 
wmemt
);

122 
wch_t
 *
	`__REDIRECT_NTH
 (
__wmemt_chk_wn
,

123 (
wch_t
 *
__s
, wch_
__c
, 
size_t
 
__n
,

124 
size_t
 
__ns
), 
__wmemt_chk
)

125 
	`__wǉr
 ("wmemset called withength biggerhan size of destination "

128 
__ftify_funi
 
wch_t
 *

129 
	`__NTH
 (
	$wmemt
 (
wch_t
 *
__s
, wch_
__c
, 
size_t
 
__n
))

131 i(
	`__bos0
 (
__s
!(
size_t
) -1)

133 i(!
	`__but_cڡt_p
 (
__n
))

134  
	`__wmemt_chk
 (
__s
, 
__c
, 
__n
, 
	`__bos0
 (__s/  (
wch_t
));

136 i(
__n
 > 
	`__bos0
 (
__s
/  (
wch_t
))

137  
	`__wmemt_chk_wn
 (
__s
, 
__c
, 
__n
,

138 
	`__bos0
 (
__s
/  (
wch_t
));

140  
	`__wmemt_s
 (
__s
, 
__c
, 
__n
);

141 
	}
}

144 
wch_t
 *
	$__wcsy_chk
 (
wch_t
 *
__ri
 
__de
,

145 cڡ 
wch_t
 *
__ri
 
__c
,

146 
size_t
 
__n

__THROW
;

147 
wch_t
 *
	`__REDIRECT_NTH
 (
__wcsy_s
,

148 (
wch_t
 *
__ri
 
__de
,

149 cڡ 
wch_t
 *
__ri
 
__c
), 
wcsy
);

151 
__ftify_funi
 
wch_t
 *

152 
	`__NTH
 (
	$wcsy
 (
wch_t
 *
__ri
 
__de
, cڡ wch_*__ri 
__c
))

154 i(
	`__bos
 (
__de
!(
size_t
) -1)

155  
	`__wcsy_chk
 (
__de
, 
__c
, 
	`__bos
 (__de/  (
wch_t
));

156  
	`__wcsy_s
 (
__de
, 
__c
);

157 
	}
}

160 
wch_t
 *
	$__wy_chk
 (
wch_t
 *
__ri
 
__de
,

161 cڡ 
wch_t
 *
__ri
 
__c
,

162 
size_t
 
__den

__THROW
;

163 
wch_t
 *
	`__REDIRECT_NTH
 (
__wy_s
,

164 (
wch_t
 *
__ri
 
__de
,

165 cڡ 
wch_t
 *
__ri
 
__c
), 
wy
);

167 
__ftify_funi
 
wch_t
 *

168 
	`__NTH
 (
	$wy
 (
wch_t
 *
__ri
 
__de
, cڡ wch_*__ri 
__c
))

170 i(
	`__bos
 (
__de
!(
size_t
) -1)

171  
	`__wy_chk
 (
__de
, 
__c
, 
	`__bos
 (__de/  (
wch_t
));

172  
	`__wy_s
 (
__de
, 
__c
);

173 
	}
}

176 
wch_t
 *
	$__wcy_chk
 (
wch_t
 *
__ri
 
__de
,

177 cڡ 
wch_t
 *
__ri
 
__c
, 
size_t
 
__n
,

178 
size_t
 
__den

__THROW
;

179 
wch_t
 *
	`__REDIRECT_NTH
 (
__wcy_s
,

180 (
wch_t
 *
__ri
 
__de
,

181 cڡ 
wch_t
 *
__ri
 
__c
,

182 
size_t
 
__n
), 
wcy
);

183 
wch_t
 *
	`__REDIRECT_NTH
 (
__wcy_chk_wn
,

184 (
wch_t
 *
__ri
 
__de
,

185 cڡ 
wch_t
 *
__ri
 
__c
,

186 
size_t
 
__n
, size_
__den
), 
__wcy_chk
)

187 
	`__wǉr
 ("wcsncpy called withength biggerhan size of destination "

190 
__ftify_funi
 
wch_t
 *

191 
	`__NTH
 (
	$wcy
 (
wch_t
 *
__ri
 
__de
, cڡ wch_*__ri 
__c
,

192 
size_t
 
__n
))

194 i(
	`__bos
 (
__de
!(
size_t
) -1)

196 i(!
	`__but_cڡt_p
 (
__n
))

197  
	`__wcy_chk
 (
__de
, 
__c
, 
__n
,

198 
	`__bos
 (
__de
/  (
wch_t
));

199 i(
__n
 > 
	`__bos
 (
__de
/  (
wch_t
))

200  
	`__wcy_chk_wn
 (
__de
, 
__c
, 
__n
,

201 
	`__bos
 (
__de
/  (
wch_t
));

203  
	`__wcy_s
 (
__de
, 
__c
, 
__n
);

204 
	}
}

207 
wch_t
 *
	$__wny_chk
 (
wch_t
 *
__ri
 
__de
,

208 cڡ 
wch_t
 *
__ri
 
__c
, 
size_t
 
__n
,

209 
size_t
 
__den

__THROW
;

210 
wch_t
 *
	`__REDIRECT_NTH
 (
__wny_s
,

211 (
wch_t
 *
__ri
 
__de
,

212 cڡ 
wch_t
 *
__ri
 
__c
,

213 
size_t
 
__n
), 
wny
);

214 
wch_t
 *
	`__REDIRECT_NTH
 (
__wny_chk_wn
,

215 (
wch_t
 *
__ri
 
__de
,

216 cڡ 
wch_t
 *
__ri
 
__c
,

217 
size_t
 
__n
, size_
__den
), 
__wny_chk
)

218 
	`__wǉr
 ("wcpncpy called withength biggerhan size of destination "

221 
__ftify_funi
 
wch_t
 *

222 
	`__NTH
 (
	$wny
 (
wch_t
 *
__ri
 
__de
, cڡ wch_*__ri 
__c
,

223 
size_t
 
__n
))

225 i(
	`__bos
 (
__de
!(
size_t
) -1)

227 i(!
	`__but_cڡt_p
 (
__n
))

228  
	`__wny_chk
 (
__de
, 
__c
, 
__n
,

229 
	`__bos
 (
__de
/  (
wch_t
));

230 i(
__n
 > 
	`__bos
 (
__de
/  (
wch_t
))

231  
	`__wny_chk_wn
 (
__de
, 
__c
, 
__n
,

232 
	`__bos
 (
__de
/  (
wch_t
));

234  
	`__wny_s
 (
__de
, 
__c
, 
__n
);

235 
	}
}

238 
wch_t
 *
	$__wcst_chk
 (
wch_t
 *
__ri
 
__de
,

239 cڡ 
wch_t
 *
__ri
 
__c
,

240 
size_t
 
__den

__THROW
;

241 
wch_t
 *
	`__REDIRECT_NTH
 (
__wcst_s
,

242 (
wch_t
 *
__ri
 
__de
,

243 cڡ 
wch_t
 *
__ri
 
__c
), 
wcst
);

245 
__ftify_funi
 
wch_t
 *

246 
	`__NTH
 (
	$wcst
 (
wch_t
 *
__ri
 
__de
, cڡ wch_*__ri 
__c
))

248 i(
	`__bos
 (
__de
!(
size_t
) -1)

249  
	`__wcst_chk
 (
__de
, 
__c
, 
	`__bos
 (__de/  (
wch_t
));

250  
	`__wcst_s
 (
__de
, 
__c
);

251 
	}
}

254 
wch_t
 *
	$__wct_chk
 (
wch_t
 *
__ri
 
__de
,

255 cڡ 
wch_t
 *
__ri
 
__c
,

256 
size_t
 
__n
, size_
__den

__THROW
;

257 
wch_t
 *
	`__REDIRECT_NTH
 (
__wct_s
,

258 (
wch_t
 *
__ri
 
__de
,

259 cڡ 
wch_t
 *
__ri
 
__c
,

260 
size_t
 
__n
), 
wct
);

262 
__ftify_funi
 
wch_t
 *

263 
	`__NTH
 (
	$wct
 (
wch_t
 *
__ri
 
__de
, cڡ wch_*__ri 
__c
,

264 
size_t
 
__n
))

266 i(
	`__bos
 (
__de
!(
size_t
) -1)

267  
	`__wct_chk
 (
__de
, 
__c
, 
__n
,

268 
	`__bos
 (
__de
/  (
wch_t
));

269  
	`__wct_s
 (
__de
, 
__c
, 
__n
);

270 
	}
}

273 
	$__swtf_chk
 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__n
,

274 
__ag
, 
size_t
 
__s_n
,

275 cڡ 
wch_t
 *
__ri
 
__fm
, ...)

276 
__THROW
 ;

278 
	`__REDIRECT_NTH_LDBL
 (
__swtf_s
,

279 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__n
,

280 cڡ 
wch_t
 *
__ri
 
__fmt
, ...),

281 
swtf
);

283 #ifde
__va_g_ck


284 
__ftify_funi
 

285 
	`__NTH
 (
	$swtf
 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__n
,

286 cڡ 
wch_t
 *
__ri
 
__fmt
, ...))

288 i(
	`__bos
 (
__s
!(
size_t
-1 || 
__USE_FORTIFY_LEVEL
 > 1)

289  
	`__swtf_chk
 (
__s
, 
__n
, 
__USE_FORTIFY_LEVEL
 - 1,

290 
	`__bos
 (
__s
/  (
wch_t
),

291 
__fmt
, 
	`__va_g_ck
 ());

292  
	`__swtf_s
 (
__s
, 
__n
, 
__fmt
, 
	`__va_g_ck
 ());

293 
	}
}

294 #i!
defed
 
__lulus


296 
	#swtf
(
s
, 
n
, ...) \

297 (
	`__bos
 (
s
!(
size_t
-1 || 
__USE_FORTIFY_LEVEL
 > 1 \

298 ? 
	`__swtf_chk
 (
s
, 
n
, 
__USE_FORTIFY_LEVEL
 - 1, \

299 
	`__bos
 (
s
/  (
wch_t
), 
__VA_ARGS__
) \

300 : 
	`swtf
 (
s
, 
n
, 
__VA_ARGS__
))

	)

303 
	$__vswtf_chk
 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__n
,

304 
__ag
, 
size_t
 
__s_n
,

305 cڡ 
wch_t
 *
__ri
 
__fm
,

306 
__gnuc_va_li
 
__g
)

307 
__THROW
 ;

309 
	`__REDIRECT_NTH_LDBL
 (
__vswtf_s
,

310 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__n
,

311 cڡ 
wch_t
 *
__ri
 
__fmt
,

312 
__gnuc_va_li
 
__
), 
vswtf
);

314 
__ftify_funi
 

315 
	`__NTH
 (
	$vswtf
 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__n
,

316 cڡ 
wch_t
 *
__ri
 
__fmt
, 
__gnuc_va_li
 
__
))

318 i(
	`__bos
 (
__s
!(
size_t
-1 || 
__USE_FORTIFY_LEVEL
 > 1)

319  
	`__vswtf_chk
 (
__s
, 
__n
, 
__USE_FORTIFY_LEVEL
 - 1,

320 
	`__bos
 (
__s
/  (
wch_t
), 
__fmt
, 
__
);

321  
	`__vswtf_s
 (
__s
, 
__n
, 
__fmt
, 
__
);

322 
	}
}

325 #i
__USE_FORTIFY_LEVEL
 > 1

327 
__fwtf_chk
 (
__FILE
 *
__ri
 
__am
, 
__ag
,

328 cڡ 
wch_t
 *
__ri
 
__fm
, ...);

329 
__wtf_chk
 (
__ag
, cڡ 
wch_t
 *
__ri
 
__fm
,

331 
__vfwtf_chk
 (
__FILE
 *
__ri
 
__am
, 
__ag
,

332 cڡ 
wch_t
 *
__ri
 
__fm
,

333 
__gnuc_va_li
 
__
);

334 
__vwtf_chk
 (
__ag
, cڡ 
wch_t
 *
__ri
 
__fm
,

335 
__gnuc_va_li
 
__
);

337 #ifde
__va_g_ck


338 
__ftify_funi
 

339 
	$wtf
 (cڡ 
wch_t
 *
__ri
 
__fmt
, ...)

341  
	`__wtf_chk
 (
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
, 
	`__va_g_ck
 ());

342 
	}
}

344 
__ftify_funi
 

345 
	$fwtf
 (
__FILE
 *
__ri
 
__am
, cڡ 
wch_t
 *__ri 
__fmt
, ...)

347  
	`__fwtf_chk
 (
__am
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
,

348 
	`__va_g_ck
 ());

349 
	}
}

350 #i!
defed
 
__lulus


351 
	#wtf
(...) \

352 
	`__wtf_chk
 (
__USE_FORTIFY_LEVEL
 - 1, 
__VA_ARGS__
)

	)

353 
	#fwtf
(
am
, ...) \

354 
	`__fwtf_chk
 (
am
, 
__USE_FORTIFY_LEVEL
 - 1, 
__VA_ARGS__
)

	)

357 
__ftify_funi
 

358 
	$vwtf
 (cڡ 
wch_t
 *
__ri
 
__fmt
, 
__gnuc_va_li
 
__
)

360  
	`__vwtf_chk
 (
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
, 
__
);

361 
	}
}

363 
__ftify_funi
 

364 
	$vfwtf
 (
__FILE
 *
__ri
 
__am
,

365 cڡ 
wch_t
 *
__ri
 
__fmt
, 
__gnuc_va_li
 
__
)

367  
	`__vfwtf_chk
 (
__am
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
, 
__
);

368 
	}
}

372 
wch_t
 *
	$__fgws_chk
 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__size
, 
__n
,

373 
__FILE
 *
__ri
 
__am

__wur
;

374 
wch_t
 *
	`__REDIRECT
 (
__fgws_s
,

375 (
wch_t
 *
__ri
 
__s
, 
__n
,

376 
__FILE
 *
__ri
 
__am
), 
fgws

__wur
;

377 
wch_t
 *
	`__REDIRECT
 (
__fgws_chk_wn
,

378 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__size
, 
__n
,

379 
__FILE
 *
__ri
 
__am
), 
__fgws_chk
)

380 
__wur
 
	`__wǉr
 ("fgetws called with bigger sizehanength "

383 
__ftify_funi
 
__wur
 
wch_t
 *

384 
	$fgws
 (
wch_t
 *
__ri
 
__s
, 
__n
, 
__FILE
 *__ri 
__am
)

386 i(
	`__bos
 (
__s
!(
size_t
) -1)

388 i(!
	`__but_cڡt_p
 (
__n
) || __n <= 0)

389  
	`__fgws_chk
 (
__s
, 
	`__bos
 (__s/  (
wch_t
),

390 
__n
, 
__am
);

392 i((
size_t

__n
 > 
	`__bos
 (
__s
/  (
wch_t
))

393  
	`__fgws_chk_wn
 (
__s
, 
	`__bos
 (__s/  (
wch_t
),

394 
__n
, 
__am
);

396  
	`__fgws_s
 (
__s
, 
__n
, 
__am
);

397 
	}
}

399 #ifde
__USE_GNU


400 
wch_t
 *
	$__fgws_uocked_chk
 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__size
,

401 
__n
, 
__FILE
 *
__ri
 
__am
)

402 
__wur
;

403 
wch_t
 *
	`__REDIRECT
 (
__fgws_uocked_s
,

404 (
wch_t
 *
__ri
 
__s
, 
__n
,

405 
__FILE
 *
__ri
 
__am
), 
fgws_uocked
)

406 
__wur
;

407 
wch_t
 *
	`__REDIRECT
 (
__fgws_uocked_chk_wn
,

408 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__size
, 
__n
,

409 
__FILE
 *
__ri
 
__am
),

410 
__fgws_uocked_chk
)

411 
__wur
 
	`__wǉr
 ("fgetws_unlocked called with bigger sizehanength "

414 
__ftify_funi
 
__wur
 
wch_t
 *

415 
	$fgws_uocked
 (
wch_t
 *
__ri
 
__s
, 
__n
, 
__FILE
 *__ri 
__am
)

417 i(
	`__bos
 (
__s
!(
size_t
) -1)

419 i(!
	`__but_cڡt_p
 (
__n
) || __n <= 0)

420  
	`__fgws_uocked_chk
 (
__s
, 
	`__bos
 (__s/  (
wch_t
),

421 
__n
, 
__am
);

423 i((
size_t

__n
 > 
	`__bos
 (
__s
/  (
wch_t
))

424  
	`__fgws_uocked_chk_wn
 (
__s
, 
	`__bos
 (__s/  (
wch_t
),

425 
__n
, 
__am
);

427  
	`__fgws_uocked_s
 (
__s
, 
__n
, 
__am
);

428 
	}
}

432 
size_t
 
	$__wtomb_chk
 (*
__ri
 
__s
, 
wch_t
 
__wch
,

433 
mbe_t
 *
__ri
 
__p
,

434 
size_t
 
__bu

__THROW
 
__wur
;

435 
size_t
 
	`__REDIRECT_NTH
 (
__wtomb_s
,

436 (*
__ri
 
__s
, 
wch_t
 
__wch
,

437 
mbe_t
 *
__ri
 
__ps
), 
wtomb

__wur
;

439 
__ftify_funi
 
__wur
 
size_t


440 
	`__NTH
 (
	$wtomb
 (*
__ri
 
__s
, 
wch_t
 
__wch
,

441 
mbe_t
 *
__ri
 
__ps
))

446 
	#__WCHAR_MB_LEN_MAX
 16

	)

447 #i
defed
 
MB_LEN_MAX
 && MB_LEN_MAX !
__WCHAR_MB_LEN_MAX


450 i(
	`__bos
 (
__s
!(
size_t
-1 && 
__WCHAR_MB_LEN_MAX
 > __bos (__s))

451  
	`__wtomb_chk
 (
__s
, 
__wch
, 
__ps
, 
	`__bos
 (__s));

452  
	`__wtomb_s
 (
__s
, 
__wch
, 
__ps
);

453 
	}
}

456 
size_t
 
	$__mbtowcs_chk
 (
wch_t
 *
__ri
 
__d
,

457 cڡ **
__ri
 
__c
,

458 
size_t
 
__n
, 
mbe_t
 *
__ri
 
__ps
,

459 
size_t
 
__dn

__THROW
;

460 
size_t
 
	`__REDIRECT_NTH
 (
__mbtowcs_s
,

461 (
wch_t
 *
__ri
 
__d
,

462 cڡ **
__ri
 
__c
,

463 
size_t
 
__n
, 
mbe_t
 *
__ri
 
__ps
),

464 
mbtowcs
);

465 
size_t
 
	`__REDIRECT_NTH
 (
__mbtowcs_chk_wn
,

466 (
wch_t
 *
__ri
 
__d
,

467 cڡ **
__ri
 
__c
,

468 
size_t
 
__n
, 
mbe_t
 *
__ri
 
__ps
,

469 
size_t
 
__dn
), 
__mbtowcs_chk
)

470 
	`__wǉr
 ("mbsrtowcs called with dst buffer smallerhanen "

473 
__ftify_funi
 
size_t


474 
	`__NTH
 (
	$mbtowcs
 (
wch_t
 *
__ri
 
__d
, cڡ **__ri 
__c
,

475 
size_t
 
__n
, 
mbe_t
 *
__ri
 
__ps
))

477 i(
	`__bos
 (
__d
!(
size_t
) -1)

479 i(!
	`__but_cڡt_p
 (
__n
))

480  
	`__mbtowcs_chk
 (
__d
, 
__c
, 
__n
, 
__ps
,

481 
	`__bos
 (
__d
/  (
wch_t
));

483 i(
__n
 > 
	`__bos
 (
__d
/  (
wch_t
))

484  
	`__mbtowcs_chk_wn
 (
__d
, 
__c
, 
__n
, 
__ps
,

485 
	`__bos
 (
__d
/  (
wch_t
));

487  
	`__mbtowcs_s
 (
__d
, 
__c
, 
__n
, 
__ps
);

488 
	}
}

491 
size_t
 
	$__wctombs_chk
 (*
__ri
 
__d
,

492 cڡ 
wch_t
 **
__ri
 
__c
,

493 
size_t
 
__n
, 
mbe_t
 *
__ri
 
__ps
,

494 
size_t
 
__dn

__THROW
;

495 
size_t
 
	`__REDIRECT_NTH
 (
__wctombs_s
,

496 (*
__ri
 
__d
,

497 cڡ 
wch_t
 **
__ri
 
__c
,

498 
size_t
 
__n
, 
mbe_t
 *
__ri
 
__ps
),

499 
wctombs
);

500 
size_t
 
	`__REDIRECT_NTH
 (
__wctombs_chk_wn
,

501 (*
__ri
 
__d
,

502 cڡ 
wch_t
 **
__ri
 
__c
,

503 
size_t
 
__n
, 
mbe_t
 *
__ri
 
__ps
,

504 
size_t
 
__dn
), 
__wctombs_chk
)

505 
	`__wǉr
 ("wcsrtombs called with dst buffer smallerhanen");

507 
__ftify_funi
 
size_t


508 
	`__NTH
 (
	$wctombs
 (*
__ri
 
__d
, cڡ 
wch_t
 **__ri 
__c
,

509 
size_t
 
__n
, 
mbe_t
 *
__ri
 
__ps
))

511 i(
	`__bos
 (
__d
!(
size_t
) -1)

513 i(!
	`__but_cڡt_p
 (
__n
))

514  
	`__wctombs_chk
 (
__d
, 
__c
, 
__n
, 
__ps
, 
	`__bos
 (__dst));

516 i(
__n
 > 
	`__bos
 (
__d
))

517  
	`__wctombs_chk_wn
 (
__d
, 
__c
, 
__n
, 
__ps
, 
	`__bos
 (__dst));

519  
	`__wctombs_s
 (
__d
, 
__c
, 
__n
, 
__ps
);

520 
	}
}

523 #ifde
__USE_GNU


524 
size_t
 
	$__mbowcs_chk
 (
wch_t
 *
__ri
 
__d
,

525 cڡ **
__ri
 
__c
, 
size_t
 
__nmc
,

526 
size_t
 
__n
, 
mbe_t
 *
__ri
 
__ps
,

527 
size_t
 
__dn

__THROW
;

528 
size_t
 
	`__REDIRECT_NTH
 (
__mbowcs_s
,

529 (
wch_t
 *
__ri
 
__d
,

530 cڡ **
__ri
 
__c
, 
size_t
 
__nmc
,

531 
size_t
 
__n
, 
mbe_t
 *
__ri
 
__ps
),

532 
mbowcs
);

533 
size_t
 
	`__REDIRECT_NTH
 (
__mbowcs_chk_wn
,

534 (
wch_t
 *
__ri
 
__d
,

535 cڡ **
__ri
 
__c
, 
size_t
 
__nmc
,

536 
size_t
 
__n
, 
mbe_t
 *
__ri
 
__ps
,

537 
size_t
 
__dn
), 
__mbowcs_chk
)

538 
	`__wǉr
 ("mbsnrtowcs called with dst buffer smallerhanen "

541 
__ftify_funi
 
size_t


542 
	`__NTH
 (
	$mbowcs
 (
wch_t
 *
__ri
 
__d
, cڡ **__ri 
__c
,

543 
size_t
 
__nmc
, size_
__n
, 
mbe_t
 *
__ri
 
__ps
))

545 i(
	`__bos
 (
__d
!(
size_t
) -1)

547 i(!
	`__but_cڡt_p
 (
__n
))

548  
	`__mbowcs_chk
 (
__d
, 
__c
, 
__nmc
, 
__n
, 
__ps
,

549 
	`__bos
 (
__d
/  (
wch_t
));

551 i(
__n
 > 
	`__bos
 (
__d
/  (
wch_t
))

552  
	`__mbowcs_chk_wn
 (
__d
, 
__c
, 
__nmc
, 
__n
, 
__ps
,

553 
	`__bos
 (
__d
/  (
wch_t
));

555  
	`__mbowcs_s
 (
__d
, 
__c
, 
__nmc
, 
__n
, 
__ps
);

556 
	}
}

559 
size_t
 
	$__wcombs_chk
 (*
__ri
 
__d
,

560 cڡ 
wch_t
 **
__ri
 
__c
,

561 
size_t
 
__nwc
, size_
__n
,

562 
mbe_t
 *
__ri
 
__ps
, 
size_t
 
__dn
)

563 
__THROW
;

564 
size_t
 
	`__REDIRECT_NTH
 (
__wcombs_s
,

565 (*
__ri
 
__d
,

566 cڡ 
wch_t
 **
__ri
 
__c
,

567 
size_t
 
__nwc
, size_
__n
,

568 
mbe_t
 *
__ri
 
__ps
), 
wcombs
);

569 
size_t
 
	`__REDIRECT_NTH
 (
__wcombs_chk_wn
,

570 (*
__ri
 
__d
,

571 cڡ 
wch_t
 **
__ri
 
__c
,

572 
size_t
 
__nwc
, size_
__n
,

573 
mbe_t
 *
__ri
 
__ps
,

574 
size_t
 
__dn
), 
__wcombs_chk
)

575 
	`__wǉr
 ("wcsnrtombs called with dst buffer smallerhanen");

577 
__ftify_funi
 
size_t


578 
	`__NTH
 (
	$wcombs
 (*
__ri
 
__d
, cڡ 
wch_t
 **__ri 
__c
,

579 
size_t
 
__nwc
, size_
__n
, 
mbe_t
 *
__ri
 
__ps
))

581 i(
	`__bos
 (
__d
!(
size_t
) -1)

583 i(!
	`__but_cڡt_p
 (
__n
))

584  
	`__wcombs_chk
 (
__d
, 
__c
, 
__nwc
, 
__n
, 
__ps
,

585 
	`__bos
 (
__d
));

587 i(
__n
 > 
	`__bos
 (
__d
))

588  
	`__wcombs_chk_wn
 (
__d
, 
__c
, 
__nwc
, 
__n
, 
__ps
,

589 
	`__bos
 (
__d
));

591  
	`__wcombs_s
 (
__d
, 
__c
, 
__nwc
, 
__n
, 
__ps
);

592 
	}
}

	@/usr/include/gnu/option-groups.h

10 #ide
__GNU_OPTION_GROUPS_H


11 
	#__GNU_OPTION_GROUPS_H


	)

13 
	#__OPTION_EGLIBC_ADVANCED_INET6
 1

	)

14 
	#__OPTION_EGLIBC_BACKTRACE
 1

	)

15 
	#__OPTION_EGLIBC_BIG_MACROS
 1

	)

16 
	#__OPTION_EGLIBC_BSD
 1

	)

17 
	#__OPTION_EGLIBC_CATGETS
 1

	)

18 
	#__OPTION_EGLIBC_CHARSETS
 1

	)

19 
	#__OPTION_EGLIBC_CRYPT
 1

	)

20 
	#__OPTION_EGLIBC_CRYPT_UFC
 1

	)

21 
	#__OPTION_EGLIBC_CXX_TESTS
 1

	)

22 
	#__OPTION_EGLIBC_DB_ALIASES
 1

	)

23 
	#__OPTION_EGLIBC_ENVZ
 1

	)

24 
	#__OPTION_EGLIBC_FCVT
 1

	)

25 
	#__OPTION_EGLIBC_FMTMSG
 1

	)

26 
	#__OPTION_EGLIBC_FSTAB
 1

	)

27 
	#__OPTION_EGLIBC_FTRAVERSE
 1

	)

28 
	#__OPTION_EGLIBC_GETLOGIN
 1

	)

29 
	#__OPTION_EGLIBC_IDN
 1

	)

30 
	#__OPTION_EGLIBC_INET
 1

	)

31 
	#__OPTION_EGLIBC_INET_ANL
 1

	)

32 
	#__OPTION_EGLIBC_LIBM
 1

	)

33 
	#__OPTION_EGLIBC_LOCALES
 1

	)

34 
	#__OPTION_EGLIBC_LOCALE_CODE
 1

	)

35 
	#__OPTION_EGLIBC_MEMUSAGE
 1

	)

36 
	#__OPTION_EGLIBC_NIS
 1

	)

37 
	#__OPTION_EGLIBC_NSSWITCH
 1

	)

38 
	#__OPTION_EGLIBC_RCMD
 1

	)

39 
	#__OPTION_EGLIBC_RTLD_DEBUG
 1

	)

40 
	#__OPTION_EGLIBC_SPAWN
 1

	)

41 
	#__OPTION_EGLIBC_STREAMS
 1

	)

42 
	#__OPTION_EGLIBC_SUNRPC
 1

	)

43 
	#__OPTION_EGLIBC_UTMP
 1

	)

44 
	#__OPTION_EGLIBC_UTMPX
 1

	)

45 
	#__OPTION_EGLIBC_WORDEXP
 1

	)

46 
	#__OPTION_POSIX_C_LANG_WIDE_CHAR
 1

	)

47 
	#__OPTION_POSIX_REGEXP
 1

	)

48 
	#__OPTION_POSIX_REGEXP_GLIBC
 1

	)

49 
	#__OPTION_POSIX_WIDE_CHAR_DEVICE_IO
 1

	)

	@/usr/include/pthread.h

18 #ide
_PTHREAD_H


19 
	#_PTHREAD_H
 1

	)

21 
	~<us.h
>

22 
	~<dn.h
>

23 
	~<sched.h
>

24 
	~<time.h
>

26 
	~<bs/hadtys.h
>

27 
	~<bs/tjmp.h
>

28 
	~<bs/wdsize.h
>

34 
	mPTHREAD_CREATE_JOINABLE
,

35 
	#PTHREAD_CREATE_JOINABLE
 
PTHREAD_CREATE_JOINABLE


	)

36 
	mPTHREAD_CREATE_DETACHED


37 
	#PTHREAD_CREATE_DETACHED
 
PTHREAD_CREATE_DETACHED


	)

44 
	mPTHREAD_MUTEX_TIMED_NP
,

45 
	mPTHREAD_MUTEX_RECURSIVE_NP
,

46 
	mPTHREAD_MUTEX_ERRORCHECK_NP
,

47 
	mPTHREAD_MUTEX_ADAPTIVE_NP


48 #i
defed
 
__USE_UNIX98
 || defed 
__USE_XOPEN2K8


50 
	mPTHREAD_MUTEX_NORMAL
 = 
PTHREAD_MUTEX_TIMED_NP
,

51 
	mPTHREAD_MUTEX_RECURSIVE
 = 
PTHREAD_MUTEX_RECURSIVE_NP
,

52 
	mPTHREAD_MUTEX_ERRORCHECK
 = 
PTHREAD_MUTEX_ERRORCHECK_NP
,

53 
	mPTHREAD_MUTEX_DEFAULT
 = 
PTHREAD_MUTEX_NORMAL


55 #ifde
__USE_GNU


57 , 
	mPTHREAD_MUTEX_FAST_NP
 = 
PTHREAD_MUTEX_TIMED_NP


62 #ifde
__USE_XOPEN2K


66 
	mPTHREAD_MUTEX_STALLED
,

67 
	mPTHREAD_MUTEX_STALLED_NP
 = 
PTHREAD_MUTEX_STALLED
,

68 
	mPTHREAD_MUTEX_ROBUST
,

69 
	mPTHREAD_MUTEX_ROBUST_NP
 = 
PTHREAD_MUTEX_ROBUST


74 #i
defed
 
__USE_POSIX199506
 || defed 
__USE_UNIX98


78 
	mPTHREAD_PRIO_NONE
,

79 
	mPTHREAD_PRIO_INHERIT
,

80 
	mPTHREAD_PRIO_PROTECT


86 #i
__PTHREAD_MUTEX_HAVE_ELISION
 == 1

87 
	#__PTHREAD_SPINS
 0, 0

	)

88 #i
__PTHREAD_MUTEX_HAVE_ELISION
 == 2

89 
	#__PTHREAD_SPINS
 { 0, 0 }

	)

91 
	#__PTHREAD_SPINS
 0

	)

94 #ifde
__PTHREAD_MUTEX_HAVE_PREV


95 
	#PTHREAD_MUTEX_INITIALIZER
 \

96 { { 0, 0, 0, 0, 0, 
__PTHREAD_SPINS
, { 0, 0 } } }

	)

97 #ifde
__USE_GNU


98 
	#PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP
 \

99 { { 0, 0, 0, 0, 
PTHREAD_MUTEX_RECURSIVE_NP
, 
__PTHREAD_SPINS
, { 0, 0 } } }

	)

100 
	#PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP
 \

101 { { 0, 0, 0, 0, 
PTHREAD_MUTEX_ERRORCHECK_NP
, 
__PTHREAD_SPINS
, { 0, 0 } } }

	)

102 
	#PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP
 \

103 { { 0, 0, 0, 0, 
PTHREAD_MUTEX_ADAPTIVE_NP
, 
__PTHREAD_SPINS
, { 0, 0 } } }

	)

104 
	#PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP
 \

105 { { 0, 0, 0, 0, 
PTHREAD_MUTEX_ADAPTIVE_NP
, 
__PTHREAD_SPINS
, { 0, 0 } } }

	)

109 
	#PTHREAD_MUTEX_INITIALIZER
 \

110 { { 0, 0, 0, 0, 0, { 
__PTHREAD_SPINS
 } } }

	)

111 #ifde
__USE_GNU


112 
	#PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP
 \

113 { { 0, 0, 0, 
PTHREAD_MUTEX_RECURSIVE_NP
, 0, { 
__PTHREAD_SPINS
 } } }

	)

114 
	#PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP
 \

115 { { 0, 0, 0, 
PTHREAD_MUTEX_ERRORCHECK_NP
, 0, { 
__PTHREAD_SPINS
 } } }

	)

116 
	#PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP
 \

117 { { 0, 0, 0, 
PTHREAD_MUTEX_ADAPTIVE_NP
, 0, { 
__PTHREAD_SPINS
 } } }

	)

124 #i
defed
 
__USE_UNIX98
 || defed 
__USE_XOPEN2K


127 
	mPTHREAD_RWLOCK_PREFER_READER_NP
,

128 
	mPTHREAD_RWLOCK_PREFER_WRITER_NP
,

129 
	mPTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP
,

130 
	mPTHREAD_RWLOCK_DEFAULT_NP
 = 
PTHREAD_RWLOCK_PREFER_READER_NP


136 #ide
__PTHREAD_RWLOCK_INT_FLAGS_SHARED


137 #i
__WORDSIZE
 == 64

138 
	#__PTHREAD_RWLOCK_INT_FLAGS_SHARED
 1

	)

143 
	#PTHREAD_RWLOCK_INITIALIZER
 \

144 { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }

	)

145 #ifde
__USE_GNU


146 #ifde
__PTHREAD_RWLOCK_INT_FLAGS_SHARED


147 
	#PTHREAD_RWLOCK_WRITER_NONRECURSIVE_INITIALIZER_NP
 \

149 
PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP
 } }

	)

151 #i
__BYTE_ORDER
 =
__LITTLE_ENDIAN


152 
	#PTHREAD_RWLOCK_WRITER_NONRECURSIVE_INITIALIZER_NP
 \

153 { { 0, 0, 0, 0, 0, 0, 
PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP
, \

154 0, 0, 0, 0 } }

	)

156 
	#PTHREAD_RWLOCK_WRITER_NONRECURSIVE_INITIALIZER_NP
 \

157 { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 
PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP
,\

158 0 } }

	)

168 
	mPTHREAD_INHERIT_SCHED
,

169 
	#PTHREAD_INHERIT_SCHED
 
PTHREAD_INHERIT_SCHED


	)

170 
	mPTHREAD_EXPLICIT_SCHED


171 
	#PTHREAD_EXPLICIT_SCHED
 
PTHREAD_EXPLICIT_SCHED


	)

178 
	mPTHREAD_SCOPE_SYSTEM
,

179 
	#PTHREAD_SCOPE_SYSTEM
 
PTHREAD_SCOPE_SYSTEM


	)

180 
	mPTHREAD_SCOPE_PROCESS


181 
	#PTHREAD_SCOPE_PROCESS
 
PTHREAD_SCOPE_PROCESS


	)

188 
	mPTHREAD_PROCESS_PRIVATE
,

189 
	#PTHREAD_PROCESS_PRIVATE
 
PTHREAD_PROCESS_PRIVATE


	)

190 
	mPTHREAD_PROCESS_SHARED


191 
	#PTHREAD_PROCESS_SHARED
 
PTHREAD_PROCESS_SHARED


	)

197 
	#PTHREAD_COND_INITIALIZER
 { { 0, 0, 0, 0, 0, (*0, 0, 0 } }

	)

201 
	s_had_nup_bufr


203 (*
	m__route
) (*);

204 *
	m__g
;

205 
	m__ny
;

206 
_had_nup_bufr
 *
	m__ev
;

212 
	mPTHREAD_CANCEL_ENABLE
,

213 
	#PTHREAD_CANCEL_ENABLE
 
PTHREAD_CANCEL_ENABLE


	)

214 
	mPTHREAD_CANCEL_DISABLE


215 
	#PTHREAD_CANCEL_DISABLE
 
PTHREAD_CANCEL_DISABLE


	)

219 
	mPTHREAD_CANCEL_DEFERRED
,

220 
	#PTHREAD_CANCEL_DEFERRED
 
PTHREAD_CANCEL_DEFERRED


	)

221 
	mPTHREAD_CANCEL_ASYNCHRONOUS


222 
	#PTHREAD_CANCEL_ASYNCHRONOUS
 
PTHREAD_CANCEL_ASYNCHRONOUS


	)

224 
	#PTHREAD_CANCELED
 ((*-1)

	)

228 
	#PTHREAD_ONCE_INIT
 0

	)

231 #ifde
__USE_XOPEN2K


235 
	#PTHREAD_BARRIER_SERIAL_THREAD
 -1

	)

239 
__BEGIN_DECLS


244 
had_
 (
had_t
 *
__ri
 
__wthad
,

245 cڡ 
had__t
 *
__ri
 
__
,

246 *(*
__t_route
) (*),

247 *
__ri
 
__g

__THROWNL
 
__nnu
 ((1, 3));

253 
	$had_ex
 (*
__tv

	`__ibu__
 ((
__nܑu__
));

261 
	`had_jo
 (
had_t
 
__th
, **
__thad_tu
);

263 #ifde
__USE_GNU


266 
	$had_yjo_
 (
had_t
 
__th
, **
__thad_tu

__THROW
;

274 
	`had_timedjo_
 (
had_t
 
__th
, **
__thad_tu
,

275 cڡ 
timeec
 *
__abime
);

282 
	$had_dach
 (
had_t
 
__th

__THROW
;

286 
had_t
 
	$had_lf
 (
__THROW
 
	`__ibu__
 ((
__cڡ__
));

289 
	$had_equ
 (
had_t
 
__thad1
,thad_
__thad2
)

290 
__THROW
 
	`__ibu__
 ((
__cڡ__
));

298 
	$had__
 (
had__t
 *
__

__THROW
 
	`__nnu
 ((1));

301 
	$had__deroy
 (
had__t
 *
__
)

302 
__THROW
 
	`__nnu
 ((1));

305 
	$had__gdache
 (cڡ 
had__t
 *
__
,

306 *
__dache
)

307 
__THROW
 
	`__nnu
 ((1, 2));

310 
	$had__tdache
 (
had__t
 *
__
,

311 
__dache
)

312 
__THROW
 
	`__nnu
 ((1));

316 
	$had__ggudsize
 (cڡ 
had__t
 *
__
,

317 
size_t
 *
__gudsize
)

318 
__THROW
 
	`__nnu
 ((1, 2));

321 
	$had__tgudsize
 (
had__t
 *
__
,

322 
size_t
 
__gudsize
)

323 
__THROW
 
	`__nnu
 ((1));

327 
	$had__gschedm
 (cڡ 
had__t
 *
__ri
 
__
,

328 
sched_m
 *
__ri
 
__m
)

329 
__THROW
 
	`__nnu
 ((1, 2));

332 
	$had__tschedm
 (
had__t
 *
__ri
 
__
,

333 cڡ 
sched_m
 *
__ri


334 
__m

__THROW
 
	`__nnu
 ((1, 2));

337 
	$had__gschedpicy
 (cڡ 
had__t
 *
__ri


338 
__
, *
__ri
 
__picy
)

339 
__THROW
 
	`__nnu
 ((1, 2));

342 
	$had__tschedpicy
 (
had__t
 *
__
, 
__picy
)

343 
__THROW
 
	`__nnu
 ((1));

346 
	$had__ghsched
 (cڡ 
had__t
 *
__ri


347 
__
, *
__ri
 
__h
)

348 
__THROW
 
	`__nnu
 ((1, 2));

351 
	$had__thsched
 (
had__t
 *
__
,

352 
__h
)

353 
__THROW
 
	`__nnu
 ((1));

357 
	$had__gsce
 (cڡ 
had__t
 *
__ri
 
__
,

358 *
__ri
 
__sce
)

359 
__THROW
 
	`__nnu
 ((1, 2));

362 
	$had__tsce
 (
had__t
 *
__
, 
__sce
)

363 
__THROW
 
	`__nnu
 ((1));

366 
	$had__gackaddr
 (cڡ 
had__t
 *
__ri


367 
__
, **
__ri
 
__ackaddr
)

368 
__THROW
 
	`__nnu
 ((1, 2)
__ibu_dd__
;

374 
	$had__tackaddr
 (
had__t
 *
__
,

375 *
__ackaddr
)

376 
__THROW
 
	`__nnu
 ((1)
__ibu_dd__
;

379 
	$had__gacksize
 (cڡ 
had__t
 *
__ri


380 
__
, 
size_t
 *
__ri
 
__acksize
)

381 
__THROW
 
	`__nnu
 ((1, 2));

386 
	$had__tacksize
 (
had__t
 *
__
,

387 
size_t
 
__acksize
)

388 
__THROW
 
	`__nnu
 ((1));

390 #ifde
__USE_XOPEN2K


392 
	$had__gack
 (cڡ 
had__t
 *
__ri
 
__
,

393 **
__ri
 
__ackaddr
,

394 
size_t
 *
__ri
 
__acksize
)

395 
__THROW
 
	`__nnu
 ((1, 2, 3));

400 
	$had__tack
 (
had__t
 *
__
, *
__ackaddr
,

401 
size_t
 
__acksize

__THROW
 
	`__nnu
 ((1));

404 #ifde
__USE_GNU


407 
	$had__ffy_
 (
had__t
 *
__
,

408 
size_t
 
__utsize
,

409 cڡ 
u_t_t
 *
__ut
)

410 
__THROW
 
	`__nnu
 ((1, 3));

414 
	$had__gaffy_
 (cڡ 
had__t
 *
__
,

415 
size_t
 
__utsize
,

416 
u_t_t
 *
__ut
)

417 
__THROW
 
	`__nnu
 ((1, 3));

420 
	$had_g_deu_
 (
had__t
 *
__
)

421 
__THROW
 
	`__nnu
 ((1));

425 
	$had_r_deu_
 (cڡ 
had__t
 *
__
)

426 
__THROW
 
	`__nnu
 ((1));

431 
	$had_g_
 (
had_t
 
__th
, 
had__t
 *
__
)

432 
__THROW
 
	`__nnu
 ((2));

440 
	$had_tschedm
 (
had_t
 
__rg_thad
, 
__picy
,

441 cڡ 
sched_m
 *
__m
)

442 
__THROW
 
	`__nnu
 ((3));

445 
	$had_gschedm
 (
had_t
 
__rg_thad
,

446 *
__ri
 
__picy
,

447 
sched_m
 *
__ri
 
__m
)

448 
__THROW
 
	`__nnu
 ((2, 3));

451 
	$had_tschedio
 (
had_t
 
__rg_thad
, 
__io
)

452 
__THROW
;

455 #ifde
__USE_GNU


457 
	$had_gme_
 (
had_t
 
__rg_thad
, *
__buf
,

458 
size_t
 
__bu
)

459 
__THROW
 
	`__nnu
 ((2));

462 
	$had_ame_
 (
had_t
 
__rg_thad
, cڡ *
__me
)

463 
__THROW
 
	`__nnu
 ((2));

467 #ifde
__USE_UNIX98


469 
	$had_gccucy
 (
__THROW
;

472 
	$had_tccucy
 (
__v

__THROW
;

475 #ifde
__USE_GNU


480 
	$had_yld
 (
__THROW
;

485 
	$had_ffy_
 (
had_t
 
__th
, 
size_t
 
__utsize
,

486 cڡ 
u_t_t
 *
__ut
)

487 
__THROW
 
	`__nnu
 ((3));

490 
	$had_gaffy_
 (
had_t
 
__th
, 
size_t
 
__utsize
,

491 
u_t_t
 *
__ut
)

492 
__THROW
 
	`__nnu
 ((3));

505 
	`had_
 (
had__t
 *
___cڌ
,

506 (*
___route
()
	`__nnu
 ((1, 2));

517 
	`had_tnle
 (
__e
, *
__de
);

521 
	`had_tny
 (
__ty
, *
__dty
);

524 
	`had_nl
 (
had_t
 
__th
);

529 
	`had_nl
 ();

538 
__jmp_buf
 
__nl_jmp_buf
;

539 
__mask_was_ved
;

540 } 
__nl_jmp_buf
[1];

541 *
__d
[4];

542 } 
	t__had_unwd_buf_t
 
	t__ibu__
 ((
	t__igd__
));

545 #ide
__nup_f_ibu


546 
	#__nup_f_ibu


	)

551 
	s__had_nup_ame


553 (*
__nl_route
) (*);

554 *
__nl_g
;

555 
__do_
;

556 
__nl_ty
;

559 #i
defed
 
__GNUC__
 && defed 
__EXCEPTIONS


560 #ifde
__lulus


562 as
	c__had_nup_ass


564 (*
__nl_route
) (*);

565 *
__nl_g
;

566 
__do_
;

567 
__nl_ty
;

569 
public
:

570 
	`__had_nup_ass
 ((*
__f
(*), *
__g
)

571 : 
	`__nl_route
 (
__f
), 
	`__nl_g
 (
__g
), 
	$__do_
 (1) { }

572 ~
	$__had_nup_ass
 ({ i(
__do_

	`__nl_route
 (
__nl_g
); 
	}
}

573 
	$__tdo
 (
__wv
{ 
__do_
 = __wv; 
	}
}

574 
	$__der
 ({ 
	`had_tny
 (
PTHREAD_CANCEL_DEFERRED
,

575 &
__nl_ty
); 
	}
}

576 
	$__e
 (cڡ { 
	`had_tny
 (
__nl_ty
, 0); 
	}
}

586 
	#had_nup_push
(
route
, 
g
) \

588 
__had_nup_ass
 
	`__ame
 (
route
, 
g
)

	)

592 
	#had_nup_p
(
execu
) \

593 
__ame
.
	`__tdo
 (
execu
); \

594 } 0)

	)

596 #ifde
__USE_GNU


600 
	#had_nup_push_der_
(
route
, 
g
) \

602 
__had_nup_ass
 
	`__ame
 (
route
, 
g
); \

603 
__ame
.
	`__der
 ()

	)

608 
	#had_nup_p_e_
(
execu
) \

609 
__ame
.
	`__e
 (); \

610 
__ame
.
	`__tdo
 (
execu
); \

611 } 0)

	)

618 
__ex_le
 

619 
	$__had_nup_route
 (
__had_nup_ame
 *
__ame
)

621 i(
__ame
->
__do_
)

622 
__ame
->
	`__nl_route
 (__ame->
__nl_g
);

623 
	}
}

632 
	#had_nup_push
(
route
, 
g
) \

634 
__had_nup_ame
 
__ame
 \

635 
	`__ibu__
 ((
	`__nup__
 (
__had_nup_route
))) \

636 { .
__nl_route
 = (
route
), .
__nl_g
 = (
g
), \

637 .
__do_
 = 1 };

	)

641 
	#had_nup_p
(
execu
) \

642 
__ame
.
__do_
 = (
execu
); \

643 } 0)

	)

645 #ifde
__USE_GNU


649 
	#had_nup_push_der_
(
route
, 
g
) \

651 
__had_nup_ame
 
__ame
 \

652 
	`__ibu__
 ((
	`__nup__
 (
__had_nup_route
))) \

653 { .
__nl_route
 = (
route
), .
__nl_g
 = (
g
), \

654 .
__do_
 = 1 }; \

655 (
	`had_tny
 (
PTHREAD_CANCEL_DEFERRED
, \

656 &
__ame
.
__nl_ty
)

	)

661 
	#had_nup_p_e_
(
execu
) \

662 (
	`had_tny
 (
__ame
.
__nl_ty
, 
NULL
); \

663 
__ame
.
__do_
 = (
execu
); \

664 } 0)

	)

675 
	#had_nup_push
(
route
, 
g
) \

677 
__had_unwd_buf_t
 
__nl_buf
; \

678 (*
__nl_route
(*(
route
); \

679 *
__nl_g
 = (
g
); \

680 
__n_f_
 = 
	`__sigtjmp
 ((
__jmp_buf_g
 *) (*) \

681 
__nl_buf
.
__nl_jmp_buf
, 0); \

682 i(
	`__glibc_uiky
 (
__n_f_
)) \

684 
	`__nl_route
 (
__nl_g
); \

685 
	`__had_unwd_xt
 (&
__nl_buf
); \

689 
	`__had_gi_nl
 (&
__nl_buf
); \

690 d{

	)

691 
__had_gi_nl
 (
__had_unwd_buf_t
 *
__buf
)

692 
__nup_f_ibu
;

696 
	#had_nup_p
(
execu
) \

699 
	`__had_uegi_nl
 (&
__nl_buf
); \

700 i(
execu
) \

701 
	`__nl_route
 (
__nl_g
); \

702 } 0)

	)

703 
	$__had_uegi_nl
 (
__had_unwd_buf_t
 *
__buf
)

704 
__nup_f_ibu
;

706 #ifde
__USE_GNU


710 
	#had_nup_push_der_
(
route
, 
g
) \

712 
__had_unwd_buf_t
 
__nl_buf
; \

713 (*
__nl_route
(*(
route
); \

714 *
__nl_g
 = (
g
); \

715 
__n_f_
 = 
	`__sigtjmp
 ((
__jmp_buf_g
 *) (*) \

716 
__nl_buf
.
__nl_jmp_buf
, 0); \

717 i(
	`__glibc_uiky
 (
__n_f_
)) \

719 
	`__nl_route
 (
__nl_g
); \

720 
	`__had_unwd_xt
 (&
__nl_buf
); \

724 
	`__had_gi_nl_der
 (&
__nl_buf
); \

725 d{

	)

726 
	`__had_gi_nl_der
 (
__had_unwd_buf_t
 *
__buf
)

727 
__nup_f_ibu
;

732 
	#had_nup_p_e_
(
execu
) \

735 
	`__had_uegi_nl_e
 (&
__nl_buf
); \

736 i(
execu
) \

737 
	`__nl_route
 (
__nl_g
); \

738 
	}
} 0)

	)

739 
	$__had_uegi_nl_e
 (
__had_unwd_buf_t
 *
__buf
)

740 
__nup_f_ibu
;

744 
	$__had_unwd_xt
 (
__had_unwd_buf_t
 *
__buf
)

745 
__nup_f_ibu
 
	`__ibu__
 ((
__nܑu__
))

746 #ide
SHARED


747 
	`__ibu__
 ((
__wk__
))

753 
__jmp_buf_g
;

754 
	$__sigtjmp
 (
__jmp_buf_g
 *
__v
, 
__vemask

__THROWNL
;

760 
	$had_mux_
 (
had_mux_t
 *
__mux
,

761 cڡ 
had_mux_t
 *
__mux
)

762 
__THROW
 
	`__nnu
 ((1));

765 
	$had_mux_deroy
 (
had_mux_t
 *
__mux
)

766 
__THROW
 
	`__nnu
 ((1));

769 
	$had_mux_ylock
 (
had_mux_t
 *
__mux
)

770 
__THROWNL
 
	`__nnu
 ((1));

773 
	$had_mux_lock
 (
had_mux_t
 *
__mux
)

774 
__THROWNL
 
	`__nnu
 ((1));

776 #ifde
__USE_XOPEN2K


778 
	$had_mux_timedlock
 (
had_mux_t
 *
__ri
 
__mux
,

779 cڡ 
timeec
 *
__ri


780 
__abime

__THROWNL
 
	`__nnu
 ((1, 2));

784 
	$had_mux_uock
 (
had_mux_t
 *
__mux
)

785 
__THROWNL
 
	`__nnu
 ((1));

789 
	$had_mux_giog
 (cڡ 
had_mux_t
 *

790 
__ri
 
__mux
,

791 *
__ri
 
__iog
)

792 
__THROW
 
	`__nnu
 ((1, 2));

796 
	$had_mux_riog
 (
had_mux_t
 *
__ri
 
__mux
,

797 
__iog
,

798 *
__ri
 
__d_g
)

799 
__THROW
 
	`__nnu
 ((1, 3));

802 #ifde
__USE_XOPEN2K8


804 
	$had_mux_csit
 (
had_mux_t
 *
__mux
)

805 
__THROW
 
	`__nnu
 ((1));

806 #ifde
__USE_GNU


807 
	$had_mux_csit_
 (
had_mux_t
 *
__mux
)

808 
__THROW
 
	`__nnu
 ((1));

817 
	$had_mux_
 (
had_mux_t
 *
__
)

818 
__THROW
 
	`__nnu
 ((1));

821 
	$had_mux_deroy
 (
had_mux_t
 *
__
)

822 
__THROW
 
	`__nnu
 ((1));

825 
	$had_mux_gpshed
 (cڡ 
had_mux_t
 *

826 
__ri
 
__
,

827 *
__ri
 
__pshed
)

828 
__THROW
 
	`__nnu
 ((1, 2));

831 
	$had_mux_shed
 (
had_mux_t
 *
__
,

832 
__pshed
)

833 
__THROW
 
	`__nnu
 ((1));

835 #i
defed
 
__USE_UNIX98
 || defed 
__USE_XOPEN2K8


837 
	$had_mux_gty
 (cڡ 
had_mux_t
 *
__ri


838 
__
, *
__ri
 
__kd
)

839 
__THROW
 
	`__nnu
 ((1, 2));

844 
	$had_mux_y
 (
had_mux_t
 *
__
, 
__kd
)

845 
__THROW
 
	`__nnu
 ((1));

849 
	$had_mux_goc
 (cڡ 
had_mux_t
 *

850 
__ri
 
__
,

851 *
__ri
 
__oc
)

852 
__THROW
 
	`__nnu
 ((1, 2));

856 
	$had_mux_roc
 (
had_mux_t
 *
__
,

857 
__oc
)

858 
__THROW
 
	`__nnu
 ((1));

861 
	$had_mux_giog
 (cڡ 
had_mux_t
 *

862 
__ri
 
__
,

863 *
__ri
 
__iog
)

864 
__THROW
 
	`__nnu
 ((1, 2));

867 
	$had_mux_riog
 (
had_mux_t
 *
__
,

868 
__iog
)

869 
__THROW
 
	`__nnu
 ((1));

871 #ifde
__USE_XOPEN2K


873 
	$had_mux_grobu
 (cڡ 
had_mux_t
 *
__
,

874 *
__robuss
)

875 
__THROW
 
	`__nnu
 ((1, 2));

876 #ifde
__USE_GNU


877 
	$had_mux_grobu_
 (cڡ 
had_mux_t
 *
__
,

878 *
__robuss
)

879 
__THROW
 
	`__nnu
 ((1, 2));

883 
	$had_mux_obu
 (
had_mux_t
 *
__
,

884 
__robuss
)

885 
__THROW
 
	`__nnu
 ((1));

886 #ifde
__USE_GNU


887 
	$had_mux_obu_
 (
had_mux_t
 *
__
,

888 
__robuss
)

889 
__THROW
 
	`__nnu
 ((1));

894 #i
defed
 
__USE_UNIX98
 || defed 
__USE_XOPEN2K


899 
	$had_rwlock_
 (
had_rwlock_t
 *
__ri
 
__rwlock
,

900 cڡ 
had_rwlock_t
 *
__ri


901 
__

__THROW
 
	`__nnu
 ((1));

904 
	$had_rwlock_deroy
 (
had_rwlock_t
 *
__rwlock
)

905 
__THROW
 
	`__nnu
 ((1));

908 
	$had_rwlock_rdlock
 (
had_rwlock_t
 *
__rwlock
)

909 
__THROWNL
 
	`__nnu
 ((1));

912 
	$had_rwlock_yrdlock
 (
had_rwlock_t
 *
__rwlock
)

913 
__THROWNL
 
	`__nnu
 ((1));

915 #ifde
__USE_XOPEN2K


917 
	$had_rwlock_timedrdlock
 (
had_rwlock_t
 *
__ri
 
__rwlock
,

918 cڡ 
timeec
 *
__ri


919 
__abime

__THROWNL
 
	`__nnu
 ((1, 2));

923 
	$had_rwlock_wock
 (
had_rwlock_t
 *
__rwlock
)

924 
__THROWNL
 
	`__nnu
 ((1));

927 
	$had_rwlock_ywock
 (
had_rwlock_t
 *
__rwlock
)

928 
__THROWNL
 
	`__nnu
 ((1));

930 #ifde
__USE_XOPEN2K


932 
	$had_rwlock_timedwock
 (
had_rwlock_t
 *
__ri
 
__rwlock
,

933 cڡ 
timeec
 *
__ri


934 
__abime

__THROWNL
 
	`__nnu
 ((1, 2));

938 
	$had_rwlock_uock
 (
had_rwlock_t
 *
__rwlock
)

939 
__THROWNL
 
	`__nnu
 ((1));

945 
	$had_rwlock_
 (
had_rwlock_t
 *
__
)

946 
__THROW
 
	`__nnu
 ((1));

949 
	$had_rwlock_deroy
 (
had_rwlock_t
 *
__
)

950 
__THROW
 
	`__nnu
 ((1));

953 
	$had_rwlock_gpshed
 (cڡ 
had_rwlock_t
 *

954 
__ri
 
__
,

955 *
__ri
 
__pshed
)

956 
__THROW
 
	`__nnu
 ((1, 2));

959 
	$had_rwlock_shed
 (
had_rwlock_t
 *
__
,

960 
__pshed
)

961 
__THROW
 
	`__nnu
 ((1));

964 
	$had_rwlock_gkd_
 (cڡ 
had_rwlock_t
 *

965 
__ri
 
__
,

966 *
__ri
 
__ef
)

967 
__THROW
 
	`__nnu
 ((1, 2));

970 
	$had_rwlock_tkd_
 (
had_rwlock_t
 *
__
,

971 
__ef

__THROW
 
	`__nnu
 ((1));

979 
	$had_cd_
 (
had_cd_t
 *
__ri
 
__cd
,

980 cڡ 
had_cd_t
 *
__ri
 
__cd_
)

981 
__THROW
 
	`__nnu
 ((1));

984 
	$had_cd_deroy
 (
had_cd_t
 *
__cd
)

985 
__THROW
 
	`__nnu
 ((1));

988 
	$had_cd_sigl
 (
had_cd_t
 *
__cd
)

989 
__THROWNL
 
	`__nnu
 ((1));

992 
	$had_cd_brd
 (
had_cd_t
 *
__cd
)

993 
__THROWNL
 
	`__nnu
 ((1));

1000 
	$had_cd_wa
 (
had_cd_t
 *
__ri
 
__cd
,

1001 
had_mux_t
 *
__ri
 
__mux
)

1002 
	`__nnu
 ((1, 2));

1011 
	$had_cd_timedwa
 (
had_cd_t
 *
__ri
 
__cd
,

1012 
had_mux_t
 *
__ri
 
__mux
,

1013 cڡ 
timeec
 *
__ri
 
__abime
)

1014 
	`__nnu
 ((1, 2, 3));

1019 
	$had_cd_
 (
had_cd_t
 *
__
)

1020 
__THROW
 
	`__nnu
 ((1));

1023 
	$had_cd_deroy
 (
had_cd_t
 *
__
)

1024 
__THROW
 
	`__nnu
 ((1));

1027 
	$had_cd_gpshed
 (cڡ 
had_cd_t
 *

1028 
__ri
 
__
,

1029 *
__ri
 
__pshed
)

1030 
__THROW
 
	`__nnu
 ((1, 2));

1033 
	$had_cd_shed
 (
had_cd_t
 *
__
,

1034 
__pshed

__THROW
 
	`__nnu
 ((1));

1036 #ifde
__USE_XOPEN2K


1038 
	$had_cd_gock
 (cڡ 
had_cd_t
 *

1039 
__ri
 
__
,

1040 
__ockid_t
 *
__ri
 
__ock_id
)

1041 
__THROW
 
	`__nnu
 ((1, 2));

1044 
	$had_cd_tock
 (
had_cd_t
 *
__
,

1045 
__ockid_t
 
__ock_id
)

1046 
__THROW
 
	`__nnu
 ((1));

1050 #ifde
__USE_XOPEN2K


1055 
	$had__
 (
had_lock_t
 *
__lock
, 
__pshed
)

1056 
__THROW
 
	`__nnu
 ((1));

1059 
	$had__deroy
 (
had_lock_t
 *
__lock
)

1060 
__THROW
 
	`__nnu
 ((1));

1063 
	$had__lock
 (
had_lock_t
 *
__lock
)

1064 
__THROWNL
 
	`__nnu
 ((1));

1067 
	$had__ylock
 (
had_lock_t
 *
__lock
)

1068 
__THROWNL
 
	`__nnu
 ((1));

1071 
	$had__uock
 (
had_lock_t
 *
__lock
)

1072 
__THROWNL
 
	`__nnu
 ((1));

1079 
	$had_brr_
 (
had_brr_t
 *
__ri
 
__brr
,

1080 cڡ 
had_brr_t
 *
__ri


1081 
__
, 
__cou
)

1082 
__THROW
 
	`__nnu
 ((1));

1085 
	$had_brr_deroy
 (
had_brr_t
 *
__brr
)

1086 
__THROW
 
	`__nnu
 ((1));

1089 
	$had_brr_wa
 (
had_brr_t
 *
__brr
)

1090 
__THROWNL
 
	`__nnu
 ((1));

1094 
	$had_brr_
 (
had_brr_t
 *
__
)

1095 
__THROW
 
	`__nnu
 ((1));

1098 
	$had_brr_deroy
 (
had_brr_t
 *
__
)

1099 
__THROW
 
	`__nnu
 ((1));

1102 
	$had_brr_gpshed
 (cڡ 
had_brr_t
 *

1103 
__ri
 
__
,

1104 *
__ri
 
__pshed
)

1105 
__THROW
 
	`__nnu
 ((1, 2));

1108 
	$had_brr_shed
 (
had_brr_t
 *
__
,

1109 
__pshed
)

1110 
__THROW
 
	`__nnu
 ((1));

1122 
	`had_key_
 (
had_key_t
 *
__key
,

1123 (*
__der_funi
) (*))

1124 
__THROW
 
	`__nnu
 ((1));

1127 
	$had_key_de
 (
had_key_t
 
__key

__THROW
;

1130 *
	$had_gecific
 (
had_key_t
 
__key

__THROW
;

1133 
	$had_tecific
 (
had_key_t
 
__key
,

1134 cڡ *
__por

__THROW
 ;

1137 #ifde
__USE_XOPEN2K


1139 
	$had_guockid
 (
had_t
 
__thad_id
,

1140 
__ockid_t
 *
__ock_id
)

1141 
__THROW
 
	`__nnu
 ((2));

1156 
	`had_fk
 ((*
__e
) (),

1157 (*
__
) (),

1158 (*
__chd
()
__THROW
;

1161 #ifde
__USE_EXTERN_INLINES


1163 
__ex_le
 

1164 
	`__NTH
 (
	$had_equ
 (
had_t
 
__thad1
,thad_
__thad2
))

1166  
__thad1
 =
__thad2
;

1167 
	}
}

1170 
	g__END_DECLS


	@/usr/include/wctype.h

23 #ide
_WCTYPE_H


25 
	~<us.h
>

26 
	~<bs/tys.h
>

28 #ide
__ed_iswxxx


29 
	#_WCTYPE_H
 1

	)

32 
	#__ed_wt_t


	)

33 
	~<wch.h
>

37 #ide
WEOF


38 
	#WEOF
 (0xffffffffu)

	)

41 #unde
__ed_iswxxx


46 #ide
__iswxxx_defed


47 
	#__iswxxx_defed
 1

	)

49 
__BEGIN_NAMESPACE_C99


52 
	twy_t
;

53 
	g__END_NAMESPACE_C99


55 #ide
_ISwb


60 
	~<dn.h
>

61 #i
__BYTE_ORDER
 =
__BIG_ENDIAN


62 
	#_ISwb
(
b
(1 << (b))

	)

64 
	#_ISwb
(
b
) \

65 ((
b
) < 8 ? () ((1UL << (bit)) << 24) \

66 : ((
b
) < 16 ? () ((1UL << (bit)) << 8) \

67 : ((
b
) < 24 ? () ((1UL << (bit)) >> 8) \

68 : (((1UL << (
b
)>> 24))))

	)

73 
	m__ISwu
 = 0,

74 
	m__ISwlow
 = 1,

75 
	m__ISwpha
 = 2,

76 
	m__ISwdig
 = 3,

77 
	m__ISwxdig
 = 4,

78 
	m__ISwa
 = 5,

79 
	m__ISwt
 = 6,

80 
	m__ISwgph
 = 7,

81 
	m__ISwbnk
 = 8,

82 
	m__ISwl
 = 9,

83 
	m__ISwpun
 = 10,

84 
	m__ISwnum
 = 11,

86 
	m_ISwu
 = 
_ISwb
 (
__ISwu
),

87 
	m_ISwlow
 = 
_ISwb
 (
__ISwlow
),

88 
	m_ISwpha
 = 
_ISwb
 (
__ISwpha
),

89 
	m_ISwdig
 = 
_ISwb
 (
__ISwdig
),

90 
	m_ISwxdig
 = 
_ISwb
 (
__ISwxdig
),

91 
	m_ISwa
 = 
_ISwb
 (
__ISwa
),

92 
	m_ISwt
 = 
_ISwb
 (
__ISwt
),

93 
	m_ISwgph
 = 
_ISwb
 (
__ISwgph
),

94 
	m_ISwbnk
 = 
_ISwb
 (
__ISwbnk
),

95 
	m_ISwl
 = 
_ISwb
 (
__ISwl
),

96 
	m_ISwpun
 = 
_ISwb
 (
__ISwpun
),

97 
	m_ISwnum
 = 
_ISwb
 (
__ISwnum
)

102 
__BEGIN_DECLS


104 
__BEGIN_NAMESPACE_C99


111 
	$iswnum
 (
wt_t
 
__wc

__THROW
;

117 
	$iswpha
 (
wt_t
 
__wc

__THROW
;

120 
	$iswl
 (
wt_t
 
__wc

__THROW
;

124 
	$iswdig
 (
wt_t
 
__wc

__THROW
;

128 
	$iswgph
 (
wt_t
 
__wc

__THROW
;

133 
	$iswlow
 (
wt_t
 
__wc

__THROW
;

136 
	$iswt
 (
wt_t
 
__wc

__THROW
;

141 
	$iswpun
 (
wt_t
 
__wc

__THROW
;

146 
	$iswa
 (
wt_t
 
__wc

__THROW
;

151 
	$iswu
 (
wt_t
 
__wc

__THROW
;

156 
	$iswxdig
 (
wt_t
 
__wc

__THROW
;

161 #ifde
__USE_ISOC99


162 
	$iswbnk
 (
wt_t
 
__wc

__THROW
;

171 
wy_t
 
	$wy
 (cڡ *
__ݔty

__THROW
;

175 
	$iswy
 (
wt_t
 
__wc
, 
wy_t
 
__desc

__THROW
;

176 
__END_NAMESPACE_C99


183 
__BEGIN_NAMESPACE_C99


186 cڡ 
	t__t32_t
 *
	twns_t
;

187 
__END_NAMESPACE_C99


188 #ifde
__USE_GNU


189 
	$__USING_NAMESPACE_C99
(
wns_t
)

192 
__BEGIN_NAMESPACE_C99


194 
wt_t
 
	$towlow
 (
wt_t
 
__wc

__THROW
;

197 
wt_t
 
	$towu
 (
wt_t
 
__wc

__THROW
;

198 
__END_NAMESPACE_C99


200 
__END_DECLS


207 #ifde
_WCTYPE_H


213 
__BEGIN_DECLS


215 
__BEGIN_NAMESPACE_C99


218 
wns_t
 
	$wns
 (cڡ *
__ݔty

__THROW
;

221 
wt_t
 
	$towns
 (
wt_t
 
__wc
, 
wns_t
 
__desc

__THROW
;

222 
__END_NAMESPACE_C99


224 #ifde
__USE_XOPEN2K8


226 
	~<xlo.h
>

230 
	$iswnum_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

236 
	$iswpha_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

239 
	$iswl_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

243 
	$iswdig_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

247 
	$iswgph_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

252 
	$iswlow_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

255 
	$iswt_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

260 
	$iswpun_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

265 
	$iswa_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

270 
	$iswu_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

275 
	$iswxdig_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

280 
	$iswbnk_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

284 
wy_t
 
	$wy_l
 (cڡ *
__ݔty
, 
__lo_t
 
__lo
)

285 
__THROW
;

289 
	$iswy_l
 (
wt_t
 
__wc
, 
wy_t
 
__desc
, 
__lo_t
 
__lo
)

290 
__THROW
;

298 
wt_t
 
	$towlow_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

301 
wt_t
 
	$towu_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

305 
wns_t
 
	$wns_l
 (cڡ *
__ݔty
, 
__lo_t
 
__lo
)

306 
__THROW
;

309 
wt_t
 
	$towns_l
 (
wt_t
 
__wc
, 
wns_t
 
__desc
,

310 
__lo_t
 
__lo

__THROW
;

314 
__END_DECLS


	@/usr/include/asm-generic/errno-base.h

1 #ide
_ASM_GENERIC_ERRNO_BASE_H


2 
	#_ASM_GENERIC_ERRNO_BASE_H


	)

4 
	#EPERM
 1

	)

5 
	#ENOENT
 2

	)

6 
	#ESRCH
 3

	)

7 
	#EINTR
 4

	)

8 
	#EIO
 5

	)

9 
	#ENXIO
 6

	)

10 
	#E2BIG
 7

	)

11 
	#ENOEXEC
 8

	)

12 
	#EBADF
 9

	)

13 
	#ECHILD
 10

	)

14 
	#EAGAIN
 11

	)

15 
	#ENOMEM
 12

	)

16 
	#EACCES
 13

	)

17 
	#EFAULT
 14

	)

18 
	#ENOTBLK
 15

	)

19 
	#EBUSY
 16

	)

20 
	#EEXIST
 17

	)

21 
	#EXDEV
 18

	)

22 
	#ENODEV
 19

	)

23 
	#ENOTDIR
 20

	)

24 
	#EISDIR
 21

	)

25 
	#EINVAL
 22

	)

26 
	#ENFILE
 23

	)

27 
	#EMFILE
 24

	)

28 
	#ENOTTY
 25

	)

29 
	#ETXTBSY
 26

	)

30 
	#EFBIG
 27

	)

31 
	#ENOSPC
 28

	)

32 
	#ESPIPE
 29

	)

33 
	#EROFS
 30

	)

34 
	#EMLINK
 31

	)

35 
	#EPIPE
 32

	)

36 
	#EDOM
 33

	)

37 
	#ERANGE
 34

	)

	@/usr/include/asm-generic/sockios.h

1 #ide
__ASM_GENERIC_SOCKIOS_H


2 
	#__ASM_GENERIC_SOCKIOS_H


	)

5 
	#FIOSETOWN
 0x8901

	)

6 
	#SIOCSPGRP
 0x8902

	)

7 
	#FIOGETOWN
 0x8903

	)

8 
	#SIOCGPGRP
 0x8904

	)

9 
	#SIOCATMARK
 0x8905

	)

10 
	#SIOCGSTAMP
 0x8906

	)

11 
	#SIOCGSTAMPNS
 0x8907

	)

	@/usr/include/bits/setjmp.h

19 #ide
_BITS_SETJMP_H


20 
	#_BITS_SETJMP_H
 1

	)

22 #i!
defed
 
_SETJMP_H
 && !defed 
_PTHREAD_H


26 
	~<bs/wdsize.h
>

28 #ide
_ASM


30 #i
__WORDSIZE
 == 64

31 
	t__jmp_buf
[8];

32 #i
defed
 
__x86_64__


33 
__exnsi__
 
	t__jmp_buf
[8];

35 
	t__jmp_buf
[6];

	@/usr/include/sched.h

19 #idef 
_SCHED_H


20 
	#_SCHED_H
 1

	)

22 
	~<us.h
>

25 
	~<bs/tys.h
>

27 
	#__ed_size_t


	)

28 
	~<ddef.h
>

30 
	#__ed_time_t


	)

31 
	#__ed_timeec


	)

32 
	~<time.h
>

34 #ide
__pid_t_defed


35 
__pid_t
 
	tpid_t
;

36 
	#__pid_t_defed


	)

41 
	~<bs/sched.h
>

43 
	#sched_iܙy
 
__sched_iܙy


	)

46 
__BEGIN_DECLS


49 
	$sched_am
 (
__pid_t
 
__pid
, cڡ 
sched_m
 *
__m
)

50 
__THROW
;

53 
	$sched_gm
 (
__pid_t
 
__pid
, 
sched_m
 *
__m

__THROW
;

56 
	$sched_tschedur
 (
__pid_t
 
__pid
, 
__picy
,

57 cڡ 
sched_m
 *
__m

__THROW
;

60 
	$sched_gschedur
 (
__pid_t
 
__pid

__THROW
;

63 
	$sched_yld
 (
__THROW
;

66 
	$sched_g_iܙy_max
 (
__gܙhm

__THROW
;

69 
	$sched_g_iܙy_m
 (
__gܙhm

__THROW
;

72 
	$sched__g_rv
 (
__pid_t
 
__pid
, 
timeec
 *
__t

__THROW
;

75 #ifde
__USE_GNU


77 
	#CPU_SETSIZE
 
__CPU_SETSIZE


	)

78 
	#CPU_SET
(
u
, 
u

	`__CPU_SET_S
 (u,  (
u_t_t
), cpu)

	)

79 
	#CPU_CLR
(
u
, 
u

	`__CPU_CLR_S
 (u,  (
u_t_t
), cpu)

	)

80 
	#CPU_ISSET
(
u
, 
u

	`__CPU_ISSET_S
 (u,  (
u_t_t
), \

81 
u
)

	)

82 
	#CPU_ZERO
(
u

	`__CPU_ZERO_S
 ( (
u_t_t
), cpu)

	)

83 
	#CPU_COUNT
(
u

	`__CPU_COUNT_S
 ( (
u_t_t
), cpu)

	)

85 
	#CPU_SET_S
(
u
, 
tsize
, 
u

	`__CPU_SET_S
 (u, ssize, cpu)

	)

86 
	#CPU_CLR_S
(
u
, 
tsize
, 
u

	`__CPU_CLR_S
 (u, ssize, cpu)

	)

87 
	#CPU_ISSET_S
(
u
, 
tsize
, 
u

	`__CPU_ISSET_S
 (cpu, setsize, \

88 
u
)

	)

89 
	#CPU_ZERO_S
(
tsize
, 
u

	`__CPU_ZERO_S
 (tsize, cpu)

	)

90 
	#CPU_COUNT_S
(
tsize
, 
u

	`__CPU_COUNT_S
 (tsize, cpu)

	)

92 
	#CPU_EQUAL
(
u1
, 
u2
) \

93 
	`__CPU_EQUAL_S
 ( (
u_t_t
), 
u1
, 
u2
)

	)

94 
	#CPU_EQUAL_S
(
tsize
, 
u1
, 
u2
) \

95 
	`__CPU_EQUAL_S
 (
tsize
, 
u1
, 
u2
)

	)

97 
	#CPU_AND
(
det
, 
ct1
, 
ct2
) \

98 
	`__CPU_OP_S
 ( (
u_t_t
), 
det
, 
ct1
, 
ct2
, &)

	)

99 
	#CPU_OR
(
det
, 
ct1
, 
ct2
) \

100 
	`__CPU_OP_S
 ( (
u_t_t
), 
det
, 
ct1
, 
ct2
, |)

	)

101 
	#CPU_XOR
(
det
, 
ct1
, 
ct2
) \

102 
	`__CPU_OP_S
 ( (
u_t_t
), 
det
, 
ct1
, 
ct2
, ^)

	)

103 
	#CPU_AND_S
(
tsize
, 
det
, 
ct1
, 
ct2
) \

104 
	`__CPU_OP_S
 (
tsize
, 
det
, 
ct1
, 
ct2
, &)

	)

105 
	#CPU_OR_S
(
tsize
, 
det
, 
ct1
, 
ct2
) \

106 
	`__CPU_OP_S
 (
tsize
, 
det
, 
ct1
, 
ct2
, |)

	)

107 
	#CPU_XOR_S
(
tsize
, 
det
, 
ct1
, 
ct2
) \

108 
	`__CPU_OP_S
 (
tsize
, 
det
, 
ct1
, 
ct2
, ^)

	)

110 
	#CPU_ALLOC_SIZE
(
cou

	`__CPU_ALLOC_SIZE
 (cou)

	)

111 
	#CPU_ALLOC
(
cou

	`__CPU_ALLOC
 (cou)

	)

112 
	#CPU_FREE
(
ut

	`__CPU_FREE
 (ut)

	)

116 
	$sched_ffy
 (
__pid_t
 
__pid
, 
size_t
 
__utsize
,

117 cڡ 
u_t_t
 *
__ut

__THROW
;

120 
	$sched_gaffy
 (
__pid_t
 
__pid
, 
size_t
 
__utsize
,

121 
u_t_t
 *
__ut

__THROW
;

124 
__END_DECLS


	@/usr/include/bits/sched.h

20 #ide
__ed_schedm


22 #ide
_SCHED_H


28 
	#SCHED_OTHER
 0

	)

29 
	#SCHED_FIFO
 1

	)

30 
	#SCHED_RR
 2

	)

31 #ifde
__USE_GNU


32 
	#SCHED_BATCH
 3

	)

33 
	#SCHED_IDLE
 5

	)

35 
	#SCHED_RESET_ON_FORK
 0x40000000

	)

38 #ifde
__USE_GNU


40 
	#CSIGNAL
 0x000000f

	)

41 
	#CLONE_VM
 0x00000100

	)

42 
	#CLONE_FS
 0x00000200

	)

43 
	#CLONE_FILES
 0x00000400

	)

44 
	#CLONE_SIGHAND
 0x00000800

	)

45 
	#CLONE_PTRACE
 0x00002000

	)

46 
	#CLONE_VFORK
 0x00004000

	)

48 
	#CLONE_PARENT
 0x00008000

	)

50 
	#CLONE_THREAD
 0x00010000

	)

51 
	#CLONE_NEWNS
 0x00020000

	)

52 
	#CLONE_SYSVSEM
 0x00040000

	)

53 
	#CLONE_SETTLS
 0x00080000

	)

54 
	#CLONE_PARENT_SETTID
 0x00100000

	)

56 
	#CLONE_CHILD_CLEARTID
 0x00200000

	)

58 
	#CLONE_DETACHED
 0x00400000

	)

59 
	#CLONE_UNTRACED
 0x00800000

	)

61 
	#CLONE_CHILD_SETTID
 0x01000000

	)

63 
	#CLONE_NEWUTS
 0x04000000

	)

64 
	#CLONE_NEWIPC
 0x08000000

	)

65 
	#CLONE_NEWUSER
 0x10000000

	)

66 
	#CLONE_NEWPID
 0x20000000

	)

67 
	#CLONE_NEWNET
 0x40000000

	)

68 
	#CLONE_IO
 0x80000000

	)

72 
	ssched_m


74 
	m__sched_iܙy
;

77 
	g__BEGIN_DECLS


79 #ifde
__USE_GNU


81 
e
 ((*
__
(*
__g
), *
__chd_ack
,

82 
__ags
, *
__g
, ...
__THROW
;

85 
	$unshe
 (
__ags

__THROW
;

88 
	$sched_gu
 (
__THROW
;

91 
	$s
 (
__fd
, 
__ny

__THROW
;

95 
__END_DECLS


99 #i!
defed
 
__defed_schedm
 \

100 && (
defed
 
__ed_schedm
 || defed 
_SCHED_H
)

101 
	#__defed_schedm
 1

	)

103 
	s__sched_m


105 
__sched_iܙy
;

107 #unde
__ed_schedm


111 #i
defed
 
_SCHED_H
 && !defed 
__u_t_t_defed


112 
	#__u_t_t_defed


	)

114 
	#__CPU_SETSIZE
 1024

	)

115 
	#__NCPUBITS
 (8 *  (
__u_mask
))

	)

118 
	t__u_mask
;

121 
	#__CPUELT
(
u
((u/ 
__NCPUBITS
)

	)

122 
	#__CPUMASK
(
u
((
__u_mask
1 << ((u% 
__NCPUBITS
))

	)

127 
__u_mask
 
__bs
[
__CPU_SETSIZE
 / 
__NCPUBITS
];

128 } 
	tu_t_t
;

131 #i
	`__GNUC_PREREQ
 (2, 91)

132 
	#__CPU_ZERO_S
(
tsize
, 
u
) \

133 d
	`__but_memt
 (
u
, '\0', 
tsize
); 0)

	)

135 
	#__CPU_ZERO_S
(
tsize
, 
u
) \

137 
size_t
 
__i
; \

138 
size_t
 
__imax
 = (
tsize
/  (
__u_mask
); \

139 
__u_mask
 *
__bs
 = (
u
)->__bits; \

140 
__i
 = 0; __< 
__imax
; ++__i) \

141 
__bs
[
__i
] = 0; \

142 
	}
} 0)

	)

144 
	#__CPU_SET_S
(
u
, 
tsize
, 
u
) \

145 (
__exnsi__
 \

146 ({ 
size_t
 
__u
 = (
u
); \

147 
__u
 / 8 < (
tsize
) \

148 ? (((
__u_mask
 *((
u
)->
__bs
))[
	`__CPUELT
 (
__u
)] \

149 |
	`__CPUMASK
 (
__u
)) \

150 : 0; }))

	)

151 
	#__CPU_CLR_S
(
u
, 
tsize
, 
u
) \

152 (
__exnsi__
 \

153 ({ 
size_t
 
__u
 = (
u
); \

154 
__u
 / 8 < (
tsize
) \

155 ? (((
__u_mask
 *((
u
)->
__bs
))[
	`__CPUELT
 (
__u
)] \

156 &~
	`__CPUMASK
 (
__u
)) \

157 : 0; }))

	)

158 
	#__CPU_ISSET_S
(
u
, 
tsize
, 
u
) \

159 (
__exnsi__
 \

160 ({ 
size_t
 
__u
 = (
u
); \

161 
__u
 / 8 < (
tsize
) \

162 ? ((((cڡ 
__u_mask
 *((
u
)->
__bs
))[
	`__CPUELT
 (
__u
)] \

163 & 
	`__CPUMASK
 (
__u
))) != 0 \

164 : 0; }))

	)

166 
	#__CPU_COUNT_S
(
tsize
, 
u
) \

167 
	`__sched_ucou
 (
tsize
, 
u
)

	)

169 #i
__GNUC_PREREQ
 (2, 91)

170 
	#__CPU_EQUAL_S
(
tsize
, 
u1
, 
u2
) \

171 (
	`__but_memcmp
 (
u1
, 
u2
, 
tsize
=0)

	)

173 
	#__CPU_EQUAL_S
(
tsize
, 
u1
, 
u2
) \

174 (
__exnsi__
 \

175 ({ cڡ 
__u_mask
 *
__r1
 = (
u1
)->
__bs
; \

176 cڡ 
__u_mask
 *
__r2
 = (
u2
)->
__bs
; \

177 
size_t
 
__imax
 = (
tsize
/  (
__u_mask
); \

178 
size_t
 
__i
; \

179 
__i
 = 0; __< 
__imax
; ++__i) \

180 i(
__r1
[
__i
] !
__r2
[__i]) \

182 
__i
 =
__imax
; }))

	)

185 
	#__CPU_OP_S
(
tsize
, 
det
, 
ct1
, 
ct2
, 

) \

186 (
__exnsi__
 \

187 ({ 
u_t_t
 *
__de
 = (
det
); \

188 cڡ 
__u_mask
 *
__r1
 = (
ct1
)->
__bs
; \

189 cڡ 
__u_mask
 *
__r2
 = (
ct2
)->
__bs
; \

190 
size_t
 
__imax
 = (
tsize
/  (
__u_mask
); \

191 
size_t
 
__i
; \

192 
__i
 = 0; __< 
__imax
; ++__i) \

193 ((
__u_mask
 *
__de
->
__bs
)[
__i
] = 
__r1
[__i] 

 
__r2
[__i]; \

194 
__de
; }))

	)

196 
	#__CPU_ALLOC_SIZE
(
cou
) \

197 ((((
cou
+ 
__NCPUBITS
 - 1/ __NCPUBITS*  (
__u_mask
))

	)

198 
	#__CPU_ALLOC
(
cou

	`__sched_uloc
 (cou)

	)

199 
	#__CPU_FREE
(
ut

	`__sched_u
 (ut)

	)

201 
__BEGIN_DECLS


203 
	$__sched_ucou
 (
size_t
 
__tsize
, cڡ 
u_t_t
 *
__
)

204 
__THROW
;

205 
u_t_t
 *
	$__sched_uloc
 (
size_t
 
__cou

__THROW
 
__wur
;

206 
	$__sched_u
 (
u_t_t
 *
__t

__THROW
;

208 
__END_DECLS


	@
1
.
1
/usr/include
206
8523
/home/jk/os/MINT64/00.BootLoader/BootLoader.asm
/home/jk/os/MINT64/00.BootLoader/BootLoader2.asm
/home/jk/os/MINT64/01.Kernel32/Source/EntryPoint.s
/home/jk/os/MINT64/01.Kernel32/Source/ModeSwitch.asm
/home/jk/os/MINT64/01.Kernel32/Source/ModeSwitch.h
/home/jk/os/MINT64/01.Kernel32/Source/Page.c
/home/jk/os/MINT64/01.Kernel32/Source/Page.h
/home/jk/os/MINT64/01.Kernel32/Source/Types.h
/home/jk/os/MINT64/01.Kernel32/Source/main.c
/home/jk/os/MINT64/01.Kernel32/VirtualOS.asm
/home/jk/os/MINT64/02.Kernel64/Source/AssemblyUtility.asm
/home/jk/os/MINT64/02.Kernel64/Source/AssemblyUtility.h
/home/jk/os/MINT64/02.Kernel64/Source/CacheManager.c
/home/jk/os/MINT64/02.Kernel64/Source/CacheManager.h
/home/jk/os/MINT64/02.Kernel64/Source/Console.c
/home/jk/os/MINT64/02.Kernel64/Source/Console.h
/home/jk/os/MINT64/02.Kernel64/Source/ConsoleShell.c
/home/jk/os/MINT64/02.Kernel64/Source/ConsoleShell.h
/home/jk/os/MINT64/02.Kernel64/Source/Descriptor.c
/home/jk/os/MINT64/02.Kernel64/Source/Descriptor.h
/home/jk/os/MINT64/02.Kernel64/Source/DynamicMemory.c
/home/jk/os/MINT64/02.Kernel64/Source/DynamicMemory.h
/home/jk/os/MINT64/02.Kernel64/Source/EntryPoint.s
/home/jk/os/MINT64/02.Kernel64/Source/FileSystem.c
/home/jk/os/MINT64/02.Kernel64/Source/FileSystem.h
/home/jk/os/MINT64/02.Kernel64/Source/HardDisk.c
/home/jk/os/MINT64/02.Kernel64/Source/HardDisk.h
/home/jk/os/MINT64/02.Kernel64/Source/IOAPIC.c
/home/jk/os/MINT64/02.Kernel64/Source/IOAPIC.h
/home/jk/os/MINT64/02.Kernel64/Source/ISR.asm
/home/jk/os/MINT64/02.Kernel64/Source/ISR.h
/home/jk/os/MINT64/02.Kernel64/Source/InterruptHandler.c
/home/jk/os/MINT64/02.Kernel64/Source/InterruptHandler.h
/home/jk/os/MINT64/02.Kernel64/Source/Keyboard.c
/home/jk/os/MINT64/02.Kernel64/Source/Keyboard.h
/home/jk/os/MINT64/02.Kernel64/Source/List.c
/home/jk/os/MINT64/02.Kernel64/Source/List.h
/home/jk/os/MINT64/02.Kernel64/Source/LocalAPIC.c
/home/jk/os/MINT64/02.Kernel64/Source/LocalAPIC.h
/home/jk/os/MINT64/02.Kernel64/Source/MPConfigurationTable.c
/home/jk/os/MINT64/02.Kernel64/Source/MPConfigurationTable.h
/home/jk/os/MINT64/02.Kernel64/Source/Main.c
/home/jk/os/MINT64/02.Kernel64/Source/MultiProcessor.c
/home/jk/os/MINT64/02.Kernel64/Source/MultiProcessor.h
/home/jk/os/MINT64/02.Kernel64/Source/PIC.c
/home/jk/os/MINT64/02.Kernel64/Source/PIC.h
/home/jk/os/MINT64/02.Kernel64/Source/PIT.c
/home/jk/os/MINT64/02.Kernel64/Source/PIT.h
/home/jk/os/MINT64/02.Kernel64/Source/Queue.c
/home/jk/os/MINT64/02.Kernel64/Source/Queue.h
/home/jk/os/MINT64/02.Kernel64/Source/RAMDisk.c
/home/jk/os/MINT64/02.Kernel64/Source/RAMDisk.h
/home/jk/os/MINT64/02.Kernel64/Source/RTC.c
/home/jk/os/MINT64/02.Kernel64/Source/RTC.h
/home/jk/os/MINT64/02.Kernel64/Source/SerialPort.c
/home/jk/os/MINT64/02.Kernel64/Source/SerialPort.h
/home/jk/os/MINT64/02.Kernel64/Source/Synchronization.c
/home/jk/os/MINT64/02.Kernel64/Source/Synchronization.h
/home/jk/os/MINT64/02.Kernel64/Source/Task.c
/home/jk/os/MINT64/02.Kernel64/Source/Task.h
/home/jk/os/MINT64/02.Kernel64/Source/Types.h
/home/jk/os/MINT64/02.Kernel64/Source/Utility.c
/home/jk/os/MINT64/02.Kernel64/Source/Utility.h
/home/jk/os/MINT64/02.Kernel64/Source/main.c
/home/jk/os/MINT64/04.Utility/00.ImageMaker/ImageMaker.c
/home/jk/os/MINT64/04.Utility/01.SerialTransfer/NetworkTransfer.c
/home/jk/os/MINT64/save/02.Kernel64/Source/AssemblyUtility.asm
/home/jk/os/MINT64/save/02.Kernel64/Source/AssemblyUtility.h
/home/jk/os/MINT64/save/02.Kernel64/Source/CacheManager.c
/home/jk/os/MINT64/save/02.Kernel64/Source/CacheManager.h
/home/jk/os/MINT64/save/02.Kernel64/Source/Console.c
/home/jk/os/MINT64/save/02.Kernel64/Source/Console.h
/home/jk/os/MINT64/save/02.Kernel64/Source/ConsoleShell.c
/home/jk/os/MINT64/save/02.Kernel64/Source/ConsoleShell.h
/home/jk/os/MINT64/save/02.Kernel64/Source/Descriptor.c
/home/jk/os/MINT64/save/02.Kernel64/Source/Descriptor.h
/home/jk/os/MINT64/save/02.Kernel64/Source/DynamicMemory.c
/home/jk/os/MINT64/save/02.Kernel64/Source/DynamicMemory.h
/home/jk/os/MINT64/save/02.Kernel64/Source/EntryPoint.s
/home/jk/os/MINT64/save/02.Kernel64/Source/FileSystem.c
/home/jk/os/MINT64/save/02.Kernel64/Source/FileSystem.h
/home/jk/os/MINT64/save/02.Kernel64/Source/HardDisk.c
/home/jk/os/MINT64/save/02.Kernel64/Source/HardDisk.h
/home/jk/os/MINT64/save/02.Kernel64/Source/ISR.asm
/home/jk/os/MINT64/save/02.Kernel64/Source/ISR.h
/home/jk/os/MINT64/save/02.Kernel64/Source/InterruptHandler.c
/home/jk/os/MINT64/save/02.Kernel64/Source/InterruptHandler.h
/home/jk/os/MINT64/save/02.Kernel64/Source/Keyboard.c
/home/jk/os/MINT64/save/02.Kernel64/Source/Keyboard.h
/home/jk/os/MINT64/save/02.Kernel64/Source/List.c
/home/jk/os/MINT64/save/02.Kernel64/Source/List.h
/home/jk/os/MINT64/save/02.Kernel64/Source/LocalAPIC.c
/home/jk/os/MINT64/save/02.Kernel64/Source/LocalAPIC.h
/home/jk/os/MINT64/save/02.Kernel64/Source/MPConfigurationTable.c
/home/jk/os/MINT64/save/02.Kernel64/Source/MPConfigurationTable.h
/home/jk/os/MINT64/save/02.Kernel64/Source/MultiProcessor.c
/home/jk/os/MINT64/save/02.Kernel64/Source/MultiProcessor.h
/home/jk/os/MINT64/save/02.Kernel64/Source/PIC.c
/home/jk/os/MINT64/save/02.Kernel64/Source/PIC.h
/home/jk/os/MINT64/save/02.Kernel64/Source/PIT.c
/home/jk/os/MINT64/save/02.Kernel64/Source/PIT.h
/home/jk/os/MINT64/save/02.Kernel64/Source/Queue.c
/home/jk/os/MINT64/save/02.Kernel64/Source/Queue.h
/home/jk/os/MINT64/save/02.Kernel64/Source/RAMDisk.c
/home/jk/os/MINT64/save/02.Kernel64/Source/RAMDisk.h
/home/jk/os/MINT64/save/02.Kernel64/Source/RTC.c
/home/jk/os/MINT64/save/02.Kernel64/Source/RTC.h
/home/jk/os/MINT64/save/02.Kernel64/Source/SerialPort.c
/home/jk/os/MINT64/save/02.Kernel64/Source/SerialPort.h
/home/jk/os/MINT64/save/02.Kernel64/Source/Synchronization.c
/home/jk/os/MINT64/save/02.Kernel64/Source/Synchronization.h
/home/jk/os/MINT64/save/02.Kernel64/Source/Task.c
/home/jk/os/MINT64/save/02.Kernel64/Source/Task.h
/home/jk/os/MINT64/save/02.Kernel64/Source/Types.h
/home/jk/os/MINT64/save/02.Kernel64/Source/Utility.c
/home/jk/os/MINT64/save/02.Kernel64/Source/Utility.h
/home/jk/os/MINT64/save/02.Kernel64/Source/main.c
/home/jk/os/MINT64/testdata.c
/usr/cross/lib/gcc/x86_64-pc-linux/4.8.2/include/stdarg.h
/usr/include/errno.h
/usr/include/fcntl.h
/usr/include/netinet/in.h
/usr/include/stdio.h
/usr/include/stdlib.h
/usr/include/string.h
/usr/include/sys/socket.h
/usr/include/sys/stat.h
/usr/include/sys/types.h
/usr/include/alloca.h
/usr/include/bits/byteswap.h
/usr/include/bits/errno.h
/usr/include/bits/fcntl.h
/usr/include/bits/fcntl2.h
/usr/include/bits/in.h
/usr/include/bits/pthreadtypes.h
/usr/include/bits/sigset.h
/usr/include/bits/socket.h
/usr/include/bits/socket2.h
/usr/include/bits/stat.h
/usr/include/bits/stdio-ldbl.h
/usr/include/bits/stdio.h
/usr/include/bits/stdio2.h
/usr/include/bits/stdio_lim.h
/usr/include/bits/stdlib-bsearch.h
/usr/include/bits/stdlib-float.h
/usr/include/bits/stdlib-ldbl.h
/usr/include/bits/stdlib.h
/usr/include/bits/string.h
/usr/include/bits/string2.h
/usr/include/bits/string3.h
/usr/include/bits/sys_errlist.h
/usr/include/bits/types.h
/usr/include/bits/waitflags.h
/usr/include/bits/waitstatus.h
/usr/include/endian.h
/usr/include/features.h
/usr/include/getopt.h
/usr/include/libio.h
/usr/include/stdint.h
/usr/include/sys/select.h
/usr/include/sys/sysmacros.h
/usr/include/sys/uio.h
/usr/include/time.h
/usr/include/xlocale.h
/usr/include/_G_config.h
/usr/include/asm/socket.h
/usr/include/bits/byteswap-16.h
/usr/include/bits/endian.h
/usr/include/bits/fcntl-linux.h
/usr/include/bits/libio-ldbl.h
/usr/include/bits/select.h
/usr/include/bits/select2.h
/usr/include/bits/sockaddr.h
/usr/include/bits/socket_type.h
/usr/include/bits/stdio-lock.h
/usr/include/bits/time.h
/usr/include/bits/typesizes.h
/usr/include/bits/uio.h
/usr/include/bits/wchar.h
/usr/include/bits/wordsize.h
/usr/include/ctype.h
/usr/include/gnu/stubs.h
/usr/include/linux/errno.h
/usr/include/stdc-predef.h
/usr/include/sys/cdefs.h
/usr/include/asm-generic/socket.h
/usr/include/asm/errno.h
/usr/include/bits/libc-lock.h
/usr/include/bits/timex.h
/usr/include/gconv.h
/usr/include/gnu/stubs-32.h
/usr/include/gnu/stubs-64.h
/usr/include/gnu/stubs-x32.h
/usr/include/wchar.h
/usr/include/asm-generic/errno.h
/usr/include/asm/sockios.h
/usr/include/bits/wchar-ldbl.h
/usr/include/bits/wchar2.h
/usr/include/gnu/option-groups.h
/usr/include/pthread.h
/usr/include/wctype.h
/usr/include/asm-generic/errno-base.h
/usr/include/asm-generic/sockios.h
/usr/include/bits/setjmp.h
/usr/include/sched.h
/usr/include/bits/sched.h
