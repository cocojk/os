[ORG 0x00]         					; 코드의 시작 어드레스를 0x00으로 설정
[BITS 16]          					; 이하의 코드는 16비트 코드로 설정

SECTION .text      					; text 섹션(세그먼트)을 정의

jmp 0x07C0:START					; CS 세그먼트 레지스터에 0x07C0을 복사하면서 , START 레이블로 이동 (CS 세그먼트는 데이터 이동 명령으르 설정불가능하며 점프나 인터럽트 관련 명령으로 변경 가능

START:
	mov ax, 0x07C0					; 부트 로더의 시작 어드레스(0x7C00)를 세그먼트 레지스터 값으로 변환
	mov ds, ax						; DS 세그먼트 레지스터에 설정
	mov ax, 0xB800					; 비디오 메모리의 시작 어드레스(0xB800)를 세그먼트 레지스터 값으로 변환
	mov es, ax						; ES 세그먼트 레지스터에 설정

	mov si, 0						; SI 레지스터 (문자열 원본 인덱스 레지스터)를 초기화

.SCREENCLEARLOOP:					; 화면을 지우는 루프
	mov byte [es:si],0				; 비디오 메모리의 문자가 위치하는 어드레스에 0을 복사하여 문자를 삭제
	mov byte [es:si+1],0x09			; 비디오 메모리의 속성이 위치하는 어드레스에 0x09(검은 바탕에 밝은 파랑)을 복사

	add si,2						; 문자와 속성을 설정했으므로 다음 위치로 이동

	cmp si, 80*25*2					; 화면의 전체 크기는 80문자*25라인임
									; 출력한 문자의 수를 의미하는 SI 레지스터와 비교
	jl .SCREENCLEARLOOP				; SI 레지스터가 80*25*2보다 작다면 아직 지우지 못한 영역이 있으므로 .SCREENCLEARLOOP 레이블로 이동

	mov si, 0						; SI 레지스터(문자열 원본 인덱스 레지스터)를 초기화 
	mov di ,0						; DI 레지스터(문자열 대상 인덱스 레지스터)를 초기화

.MESSAGELOOP:						; 메시지를 출력하는 루프
	mov cl,byte[si+MESSAGE1]		; MESSAGE1의 어드레스를 SI레지스터 값만큼 더한 위치의 문자를 CL 레지스터에 복사 
									; CL 레지스터는 CX(루프 또는 문자열의 카운터로 사용)되는 범용 레지스터의 하위 8비트임
									; 문자열은 1바이트면 충분하므로 CX 레지스터의 하위 1바이트만 사용
	cmp cl, 0						; 복사된 문자와 0을 비교
    je .MESSAGEEND					; 복사한 문자의 값이 0이면 문자열이 종료되었음을 의미하므로 .MESSAGEEND로 이동하여 문자 출력 종료 

	mov byte[es:di],cl				; 0이 아니라면 비디오 메모리 어드레스 0xB800:di에 문자를 출력 
	
	add si,1						; SI 레지스터에 1을 더하여 다음 문자열로 이동 
	add di,2						; DI 레지스터에 2를 더하여 비디오 메모리의 다음 문자 위치로 이동 
									; 비디오 메모리는 (문자,속성)의 쌍으로 구성되므로 문자만 출력하려면 2를 더해야 함

	jmp .MESSAGELOOP				; 메시지 출력 루프로 이동하여 다음 문자를 출력 

.MESSAGEEND:

;	jmp $							; 현재 위치에서 무한 루프 수행

MESSAGE1:	db 'MINT64 OS Boot Loader Start~!!',0 ; 출력할 메시지 정의 마지막은 0으로 설정하여 .MESSAGELOOP에서 문자열이 종료되었음을 알 수 있도록 함

; 섹터 복사 코드
TOTALSECTORCOUNT:	dw 1024			; 부트 로더를 제외한 MINT64 OS 이미지의 크기 
									; 최대 1152 섹터(0x90000byte)까지 가능 why???? 0xA0000 이후의 메모리는 graphic mode의 영역이다. 
SECTORNUMBER:	db	0x02			; OS 이미지가 시작하는 섹터 번호를 저장하는 영역 (MBR는 부트로더)
HEADNUMBER:		db	0x00			; OS 이미지가 시작하는 헤드 번호를 지정하는 영역 
TRACKNUMBER:	db	0x00			; OS 이미지가 시작하는 트랙 번호를 저장하는 영역 

	; 디스크의 내용을 메모리로 복사할 어드레스(ES:BX)를 0x10000으로 설정
	mov	si, 0x1000					; OS 이미지를 복사할 어드레스(0x10000)를 세그먼트 레지스터 값으로 변환
	mov es, si						; ES 세그먼트 레지스터에 값 설정
	mov bx, 0x0000					; BX 레지스터에 0x0000을 설정하여 복사할 어드레스를 0x1000:0000(0x10000)으로 최종 설정

	mov di, word[TOTALSECTORCOUNT]	; 복사할 OS 이미지의 섹터 수를 DI 레지스터에 설정

READDATA:							; 디스크를 읽는 코드의 시작
	; 모든 섹터를 다 읽었는지 확인
	cmp di, 0						; 복사할 OS 이미지의 섹터 수를 0과 비교
	je READEND						; 복사할 섹터 수가 0이라면 다 복사 했으므로 READEND로 이동
	sub di, 0x01					; 복사할 섹터 수를 1 감소


	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; BIOS Read Function 호출
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	
	mov ah, 0x02					; BIOS 서비스 번호 2(Read Sector)
	mov al, 0x01					; 읽을 섹터 수는 1
	mov ch, byte[TRACKNUMBER]		; 읽을 트랙 번호 설정
	mov cl, byte[SECTORNUMBER]		; 읽을 섹터 번호 설정
	mov dh, byte[HEADNUMBER]		; 읽을 헤드 번호 설정
	mov dl, 0x00					; 읽을 드라이브 번호(0=Floppy) 설정
	int 0x13						; 인터럽트 서비스 수행
	jc HANDLEDISKERROR				; 에러가 발생했다면 HANDLEDISKERROR로 이동 jc (jump on carry) CF=1일때 jump한다. 
									; 섹터 읽기가 정상적으로 완료가 되면 FLAGS의 CF비트가 0로 설정된다.

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; 복사할 어드레스와 트랙, 헤드, 섹터 어드레스 계산
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	add si, 0x0020					; 512(0x200)바이트만큼 읽었으므로, 이를 세그먼트 레지스터 값으로 변환
	mov es, si						; ES 세그머트 레지스터에 더해서 어드레스를 한 섹터만큼 증가 (base address를 변경하였네, offset이 아니라)

	; 한 섹터를 읽었으므로 섹터 번호를 증가시키고 마지막 섹터(18)까지 읽었는지 판단
	; 마지막 섹터가 아니면 섹터 읽기로 이동해서 다시 섹터 읽기 수행

times 510 - ($-$$) db 0x00      	; $ 현재 라인의 어드레스 
                                	; $$ 현재 섹션(.text)의 시작 어드레스 
                                	; $ - $$ 현재 섹션을 기준으로 하는 오프셋 ( 0x55, 0xAA를 정확한 위치에 삽입하려고 추가된 부분)
                                	; 510 - ($-$$) 현재부터 어드레스 510까지
                                	; db 0x00 db(define byte의 약자) 1바이트를 선언하고 값은 0x00
                                	; time 반복 수행
                                	; 현재 위치에서 어드레스 510까지 0x00으로 채움

db 0x55             				; 1바이트를 선언하고 값은 0x55
db 0xAA             				; 1바이트를 선언하고 값은 0xAA
                    				; 어드레스 511, 512에 0x55, 0xAA를 써서 부트 섹터로 표기함
